/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function'***REMOVED*** {
    var define = require('amdefine'***REMOVED***(module, require***REMOVED***;
}
define(function (require, exports, module***REMOVED*** {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue***REMOVED*** {
    if (aName in aArgs***REMOVED*** {
      return aArgs[aName];
  ***REMOVED*** else if (arguments.length === 3***REMOVED*** {
      return aDefaultValue;
  ***REMOVED*** else {
      throw new Error('"' + aName + '" is a required argument.'***REMOVED***;
  ***REMOVED***
***REMOVED***
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+***REMOVED***:***REMOVED***?\/\/(?:(\w+:\w+***REMOVED***@***REMOVED***?([\w.]****REMOVED***(?::(\d+***REMOVED******REMOVED***?(\S****REMOVED***$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl***REMOVED*** {
    var match = aUrl.match(urlRegexp***REMOVED***;
    if (!match***REMOVED*** {
      return null;
  ***REMOVED***
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
  ***REMOVED***;
***REMOVED***
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl***REMOVED*** {
    var url = '';
    if (aParsedUrl.scheme***REMOVED*** {
      url += aParsedUrl.scheme + ':';
  ***REMOVED***
    url += '//';
    if (aParsedUrl.auth***REMOVED*** {
      url += aParsedUrl.auth + '@';
  ***REMOVED***
    if (aParsedUrl.host***REMOVED*** {
      url += aParsedUrl.host;
  ***REMOVED***
    if (aParsedUrl.port***REMOVED*** {
      url += ":" + aParsedUrl.port
  ***REMOVED***
    if (aParsedUrl.path***REMOVED*** {
      url += aParsedUrl.path;
  ***REMOVED***
    return url;
***REMOVED***
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath***REMOVED*** {
    var path = aPath;
    var url = urlParse(aPath***REMOVED***;
    if (url***REMOVED*** {
      if (!url.path***REMOVED*** {
        return aPath;
    ***REMOVED***
      path = url.path;
  ***REMOVED***
    var isAbsolute = (path.charAt(0***REMOVED*** === '/'***REMOVED***;

    var parts = path.split(/\/+/***REMOVED***;
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--***REMOVED*** {
      part = parts[i];
      if (part === '.'***REMOVED*** {
        parts.splice(i, 1***REMOVED***;
    ***REMOVED*** else if (part === '..'***REMOVED*** {
        up++;
    ***REMOVED*** else if (up > 0***REMOVED*** {
        if (part === ''***REMOVED*** {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up***REMOVED***;
          up = 0;
      ***REMOVED*** else {
          parts.splice(i, 2***REMOVED***;
          up--;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    path = parts.join('/'***REMOVED***;

    if (path === ''***REMOVED*** {
      path = isAbsolute ? '/' : '.';
  ***REMOVED***

    if (url***REMOVED*** {
      url.path = path;
      return urlGenerate(url***REMOVED***;
  ***REMOVED***
    return path;
***REMOVED***
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath***REMOVED*** {
    var aPathUrl = urlParse(aPath***REMOVED***;
    var aRootUrl = urlParse(aRoot***REMOVED***;
    if (aRootUrl***REMOVED*** {
      aRoot = aRootUrl.path || '/';
  ***REMOVED***

    // `join(foo, '//www.example.org'***REMOVED***`
    if (aPathUrl && !aPathUrl.scheme***REMOVED*** {
      if (aRootUrl***REMOVED*** {
        aPathUrl.scheme = aRootUrl.scheme;
    ***REMOVED***
      return urlGenerate(aPathUrl***REMOVED***;
  ***REMOVED***

    if (aPathUrl || aPath.match(dataUrlRegexp***REMOVED******REMOVED*** {
      return aPath;
  ***REMOVED***

    // `join('http://', 'www.example.com'***REMOVED***`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path***REMOVED*** {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl***REMOVED***;
  ***REMOVED***

    var joined = aPath.charAt(0***REMOVED*** === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, ''***REMOVED*** + '/' + aPath***REMOVED***;

    if (aRootUrl***REMOVED*** {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl***REMOVED***;
  ***REMOVED***
    return joined;
***REMOVED***
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr***REMOVED*** {
    return '$' + aStr;
***REMOVED***
  exports.toSetString = toSetString;

  function fromSetString(aStr***REMOVED*** {
    return aStr.substr(1***REMOVED***;
***REMOVED***
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath***REMOVED*** {
    aRoot = aRoot.replace(/\/$/, ''***REMOVED***;

    var url = urlParse(aRoot***REMOVED***;
    if (aPath.charAt(0***REMOVED*** == "/" && url && url.path == "/"***REMOVED*** {
      return aPath.slice(1***REMOVED***;
  ***REMOVED***

    return aPath.indexOf(aRoot + '/'***REMOVED*** === 0
      ? aPath.substr(aRoot.length + 1***REMOVED***
      : aPath;
***REMOVED***
  exports.relative = relative;

  function strcmp(aStr1, aStr2***REMOVED*** {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2***REMOVED*** - (s1 < s2***REMOVED***;
***REMOVED***

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal***REMOVED*** {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source***REMOVED***;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = strcmp(mappingA.name, mappingB.name***REMOVED***;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    return mappingA.generatedColumn - mappingB.generatedColumn;
***REMOVED***;
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated***REMOVED*** {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = strcmp(mappingA.source, mappingB.source***REMOVED***;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp***REMOVED*** {
      return cmp;
  ***REMOVED***

    return strcmp(mappingA.name, mappingB.name***REMOVED***;
***REMOVED***;
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

}***REMOVED***;
