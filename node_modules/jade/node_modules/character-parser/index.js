exports = (module.exports = parse***REMOVED***;
exports.parse = parse;
function parse(src, state, options***REMOVED*** {
  options = options || {};
  state = state || exports.defaultState(***REMOVED***;
  var start = options.start || 0;
  var end = options.end || src.length;
  var index = start;
  while (index < end***REMOVED*** {
    if (state.roundDepth < 0 || state.curlyDepth < 0 || state.squareDepth < 0***REMOVED*** {
      throw new SyntaxError('Mismatched Bracket: ' + src[index - 1]***REMOVED***;
  ***REMOVED***
    exports.parseChar(src[index++], state***REMOVED***;
***REMOVED***
  return state;
}

exports.parseMax = parseMax;
function parseMax(src, options***REMOVED*** {
  options = options || {};
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState(***REMOVED***;
  while (state.roundDepth >= 0 && state.curlyDepth >= 0 && state.squareDepth >= 0***REMOVED*** {
    if (index >= src.length***REMOVED*** {
      throw new Error('The end of the string was reached with no closing bracket found.'***REMOVED***;
  ***REMOVED***
    exports.parseChar(src[index++], state***REMOVED***;
***REMOVED***
  var end = index - 1;
  return {
    start: start,
    end: end,
    src: src.substring(start, end***REMOVED***
***REMOVED***;
}

exports.parseUntil = parseUntil;
function parseUntil(src, delimiter, options***REMOVED*** {
  options = options || {};
  var includeLineComment = options.includeLineComment || false;
  var start = options.start || 0;
  var index = start;
  var state = exports.defaultState(***REMOVED***;
  while (state.isString(***REMOVED*** || state.regexp || state.blockComment ||
         (!includeLineComment && state.lineComment***REMOVED*** || !startsWith(src, delimiter, index***REMOVED******REMOVED*** {
    exports.parseChar(src[index++], state***REMOVED***;
***REMOVED***
  var end = index;
  return {
    start: start,
    end: end,
    src: src.substring(start, end***REMOVED***
***REMOVED***;
}


exports.parseChar = parseChar;
function parseChar(character, state***REMOVED*** {
  if (character.length !== 1***REMOVED*** throw new Error('Character must be a string of length 1'***REMOVED***;
  state = state || exports.defaultState(***REMOVED***;
  var wasComment = state.blockComment || state.lineComment;
  var lastChar = state.history ? state.history[0] : '';
  if (state.lineComment***REMOVED*** {
    if (character === '\n'***REMOVED*** {
      state.lineComment = false;
  ***REMOVED***
***REMOVED*** else if (state.blockComment***REMOVED*** {
    if (state.lastChar === '*' && character === '/'***REMOVED*** {
      state.blockComment = false;
  ***REMOVED***
***REMOVED*** else if (state.singleQuote***REMOVED*** {
    if (character === '\'' && !state.escaped***REMOVED*** {
      state.singleQuote = false;
  ***REMOVED*** else if (character === '\\' && !state.escaped***REMOVED*** {
      state.escaped = true;
  ***REMOVED*** else {
      state.escaped = false;
  ***REMOVED***
***REMOVED*** else if (state.doubleQuote***REMOVED*** {
    if (character === '"' && !state.escaped***REMOVED*** {
      state.doubleQuote = false;
  ***REMOVED*** else if (character === '\\' && !state.escaped***REMOVED*** {
      state.escaped = true;
  ***REMOVED*** else {
      state.escaped = false;
  ***REMOVED***
***REMOVED*** else if (state.regexp***REMOVED*** {
    if (character === '/' && !state.escaped***REMOVED*** {
      state.regexp = false;
  ***REMOVED*** else if (character === '\\' && !state.escaped***REMOVED*** {
      state.escaped = true;
  ***REMOVED*** else {
      state.escaped = false;
  ***REMOVED***
***REMOVED*** else if (lastChar === '/' && character === '/'***REMOVED*** {
    state.history = state.history.substr(1***REMOVED***;
    state.lineComment = true;
***REMOVED*** else if (lastChar === '/' && character === '*'***REMOVED*** {
    state.history = state.history.substr(1***REMOVED***;
    state.blockComment = true;
***REMOVED*** else if (character === '/' && isRegexp(state.history***REMOVED******REMOVED*** {
    state.regexp = true;
***REMOVED*** else if (character === '\''***REMOVED*** {
    state.singleQuote = true;
***REMOVED*** else if (character === '"'***REMOVED*** {
    state.doubleQuote = true;
***REMOVED*** else if (character === '('***REMOVED*** {
    state.roundDepth++;
***REMOVED*** else if (character === '***REMOVED***'***REMOVED*** {
    state.roundDepth--;
***REMOVED*** else if (character === '{'***REMOVED*** {
    state.curlyDepth++;
***REMOVED*** else if (character === '}'***REMOVED*** {
    state.curlyDepth--;
***REMOVED*** else if (character === '['***REMOVED*** {
    state.squareDepth++;
***REMOVED*** else if (character === ']'***REMOVED*** {
    state.squareDepth--;
***REMOVED***
  if (!state.blockComment && !state.lineComment && !wasComment***REMOVED*** state.history = character + state.history;
  return state;
}

exports.defaultState = function (***REMOVED*** { return new State(***REMOVED*** };
function State(***REMOVED*** {
  this.lineComment = false;
  this.blockComment = false;

  this.singleQuote = false;
  this.doubleQuote = false;
  this.regexp = false;
  this.escaped = false;

  this.roundDepth = 0;
  this.curlyDepth = 0;
  this.squareDepth = 0;

  this.history = ''
}
State.prototype.isString = function (***REMOVED*** {
  return this.singleQuote || this.doubleQuote;
}
State.prototype.isComment = function (***REMOVED*** {
  return this.lineComment || this.blockComment;
}
State.prototype.isNesting = function (***REMOVED*** {
  return this.isString(***REMOVED*** || this.isComment(***REMOVED*** || this.regexp || this.roundDepth > 0 || this.curlyDepth > 0 || this.squareDepth > 0
}

function startsWith(str, start, i***REMOVED*** {
  return str.substr(i || 0, start.length***REMOVED*** === start;
}

exports.isPunctuator = isPunctuator
function isPunctuator(c***REMOVED*** {
  var code = c.charCodeAt(0***REMOVED***

  switch (code***REMOVED*** {
    case 46:   // . dot
    case 40:   // ( open bracket
    case 41:   // ***REMOVED*** close bracket
    case 59:   // ; semicolon
    case 44:   // , comma
    case 123:  // { open curly brace
    case 125:  // } close curly brace
    case 91:   // [
    case 93:   // ]
    case 58:   // :
    case 63:   // ?
    case 126:  // ~
    case 37:   // %
    case 38:   // &
    case 42:   // *:
    case 43:   // +
    case 45:   // -
    case 47:   // /
    case 60:   // <
    case 62:   // >
    case 94:   // ^
    case 124:  // |
    case 33:   // !
    case 61:   // =
      return true;
    default:
      return false;
***REMOVED***
}
exports.isKeyword = isKeyword
function isKeyword(id***REMOVED*** {
  return (id === 'if'***REMOVED*** || (id === 'in'***REMOVED*** || (id === 'do'***REMOVED*** || (id === 'var'***REMOVED*** || (id === 'for'***REMOVED*** || (id === 'new'***REMOVED*** ||
         (id === 'try'***REMOVED*** || (id === 'let'***REMOVED*** || (id === 'this'***REMOVED*** || (id === 'else'***REMOVED*** || (id === 'case'***REMOVED*** ||
         (id === 'void'***REMOVED*** || (id === 'with'***REMOVED*** || (id === 'enum'***REMOVED*** || (id === 'while'***REMOVED*** || (id === 'break'***REMOVED*** || (id === 'catch'***REMOVED*** ||
         (id === 'throw'***REMOVED*** || (id === 'const'***REMOVED*** || (id === 'yield'***REMOVED*** || (id === 'class'***REMOVED*** || (id === 'super'***REMOVED*** ||
         (id === 'return'***REMOVED*** || (id === 'typeof'***REMOVED*** || (id === 'delete'***REMOVED*** || (id === 'switch'***REMOVED*** || (id === 'export'***REMOVED*** ||
         (id === 'import'***REMOVED*** || (id === 'default'***REMOVED*** || (id === 'finally'***REMOVED*** || (id === 'extends'***REMOVED*** || (id === 'function'***REMOVED*** ||
         (id === 'continue'***REMOVED*** || (id === 'debugger'***REMOVED*** || (id === 'package'***REMOVED*** || (id === 'private'***REMOVED*** || (id === 'interface'***REMOVED*** ||
         (id === 'instanceof'***REMOVED*** || (id === 'implements'***REMOVED*** || (id === 'protected'***REMOVED*** || (id === 'public'***REMOVED*** || (id === 'static'***REMOVED*** ||
         (id === 'yield'***REMOVED*** || (id === 'let'***REMOVED***;
}

function isRegexp(history***REMOVED*** {
  //could be start of regexp or divide sign

  history = history.replace(/^\s*/, ''***REMOVED***;

  //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide
  if (history[0] === '***REMOVED***'***REMOVED*** return false;
  //unless it's a function expression, it's a regexp, so we assume it's a regexp
  if (history[0] === '}'***REMOVED*** return true;
  //any punctuation means it's a regexp
  if (isPunctuator(history[0]***REMOVED******REMOVED*** return true;
  //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`***REMOVED***
  if (/^\w+\b/.test(history***REMOVED*** && isKeyword(/^\w+\b/.exec(history***REMOVED***[0].split(''***REMOVED***.reverse(***REMOVED***.join(''***REMOVED******REMOVED******REMOVED*** return true;

  return false;
}
