/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * Define a module along with a payload.
 * @param {string} moduleName Name for the payload
 * @param {ignored} deps Ignored. For compatibility with CommonJS AMD Spec
 * @param {function} payload Function with (require, exports, module***REMOVED*** params
 */
function define(moduleName, deps, payload***REMOVED*** {
  if (typeof moduleName != "string"***REMOVED*** {
    throw new TypeError('Expected string, got: ' + moduleName***REMOVED***;
***REMOVED***

  if (arguments.length == 2***REMOVED*** {
    payload = deps;
***REMOVED***

  if (moduleName in define.modules***REMOVED*** {
    throw new Error("Module already defined: " + moduleName***REMOVED***;
***REMOVED***
  define.modules[moduleName] = payload;
};

/**
 * The global store of un-instantiated modules
 */
define.modules = {};


/**
 * We invoke require(***REMOVED*** in the context of a Domain so we can have multiple
 * sets of modules running separate from each other.
 * This contrasts with JSMs which are singletons, Domains allows us to
 * optionally load a CommonJS module twice with separate data each time.
 * Perhaps you want 2 command lines with a different set of commands in each,
 * for example.
 */
function Domain(***REMOVED*** {
  this.modules = {};
  this._currentModule = null;
}

(function (***REMOVED*** {

  /**
   * Lookup module names and resolve them by calling the definition function if
   * needed.
   * There are 2 ways to call this, either with an array of dependencies and a
   * callback to call when the dependencies are found (which can happen
   * asynchronously in an in-page context***REMOVED*** or with a single string an no callback
   * where the dependency is resolved synchronously and returned.
   * The API is designed to be compatible with the CommonJS AMD spec and
   * RequireJS.
   * @param {string[]|string} deps A name, or names for the payload
   * @param {function|undefined} callback Function to call when the dependencies
   * are resolved
   * @return {undefined|object} The module required or undefined for
   * array/callback method
   */
  Domain.prototype.require = function(deps, callback***REMOVED*** {
    if (Array.isArray(deps***REMOVED******REMOVED*** {
      var params = deps.map(function(dep***REMOVED*** {
        return this.lookup(dep***REMOVED***;
    ***REMOVED***, this***REMOVED***;
      if (callback***REMOVED*** {
        callback.apply(null, params***REMOVED***;
    ***REMOVED***
      return undefined;
  ***REMOVED***
    else {
      return this.lookup(deps***REMOVED***;
  ***REMOVED***
***REMOVED***;

  function normalize(path***REMOVED*** {
    var bits = path.split('/'***REMOVED***;
    var i = 1;
    while (i < bits.length***REMOVED*** {
      if (bits[i] === '..'***REMOVED*** {
        bits.splice(i-1, 1***REMOVED***;
    ***REMOVED*** else if (bits[i] === '.'***REMOVED*** {
        bits.splice(i, 1***REMOVED***;
    ***REMOVED*** else {
        i++;
    ***REMOVED***
  ***REMOVED***
    return bits.join('/'***REMOVED***;
***REMOVED***

  function join(a, b***REMOVED*** {
    a = a.trim(***REMOVED***;
    b = b.trim(***REMOVED***;
    if (/^\//.test(b***REMOVED******REMOVED*** {
      return b;
  ***REMOVED*** else {
      return a.replace(/\/*$/, '/'***REMOVED*** + b;
  ***REMOVED***
***REMOVED***

  function dirname(path***REMOVED*** {
    var bits = path.split('/'***REMOVED***;
    bits.pop(***REMOVED***;
    return bits.join('/'***REMOVED***;
***REMOVED***

  /**
   * Lookup module names and resolve them by calling the definition function if
   * needed.
   * @param {string} moduleName A name for the payload to lookup
   * @return {object} The module specified by aModuleName or null if not found.
   */
  Domain.prototype.lookup = function(moduleName***REMOVED*** {
    if (/^\./.test(moduleName***REMOVED******REMOVED*** {
      moduleName = normalize(join(dirname(this._currentModule***REMOVED***, moduleName***REMOVED******REMOVED***;
  ***REMOVED***

    if (moduleName in this.modules***REMOVED*** {
      var module = this.modules[moduleName];
      return module;
  ***REMOVED***

    if (!(moduleName in define.modules***REMOVED******REMOVED*** {
      throw new Error("Module not defined: " + moduleName***REMOVED***;
  ***REMOVED***

    var module = define.modules[moduleName];

    if (typeof module == "function"***REMOVED*** {
      var exports = {};
      var previousModule = this._currentModule;
      this._currentModule = moduleName;
      module(this.require.bind(this***REMOVED***, exports, { id: moduleName, uri: "" }***REMOVED***;
      this._currentModule = previousModule;
      module = exports;
  ***REMOVED***

    // cache the resulting module object for next time
    this.modules[moduleName] = module;

    return module;
***REMOVED***;

}(***REMOVED******REMOVED***;

define.Domain = Domain;
define.globalDomain = new Domain(***REMOVED***;
var require = define.globalDomain.require.bind(define.globalDomain***REMOVED***;
