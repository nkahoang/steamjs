#! /usr/bin/env node
// -*- js -*-

"use strict";

var UglifyJS = require("../tools/node"***REMOVED***;
var sys = require("util"***REMOVED***;
var optimist = require("optimist"***REMOVED***;
var fs = require("fs"***REMOVED***;
var acorn;
var ARGS = optimist
    .usage("$0 input1.js [input2.js ...] [options]\n\
Use a single dash to read input from the standard input.\
\n\n\
NOTE: by default there is no mangling/compression.\n\
Without [options] it will simply parse input files and dump the AST\n\
with whitespace and comments discarded.  To achieve compression and\n\
mangling you need to use `-c` and `-m`.\
"***REMOVED***
    .describe("source-map", "Specify an output file where to generate source map."***REMOVED***
    .describe("source-map-root", "The path to the original source to be included in the source map."***REMOVED***
    .describe("source-map-url", "The path to the source map to be added in //@ sourceMappingURL.  Defaults to the value passed with --source-map."***REMOVED***
    .describe("in-source-map", "Input source map, useful if you're compressing JS that was generated from some other original code."***REMOVED***
    .describe("p", "Skip prefix for original filenames that appear in source maps. \
For example -p 3 will drop 3 directories from file names and ensure they are relative paths."***REMOVED***
    .describe("o", "Output file (default STDOUT***REMOVED***."***REMOVED***
    .describe("b", "Beautify output/specify output options."***REMOVED***
    .describe("m", "Mangle names/pass mangler options."***REMOVED***
    .describe("r", "Reserved names to exclude from mangling."***REMOVED***
    .describe("c", "Enable compressor/pass compressor options. \
Pass options like -c hoist_vars=false,if_return=false. \
Use -c with no argument to use the default compression options."***REMOVED***
    .describe("d", "Global definitions"***REMOVED***

    .describe("comments", "Preserve copyright comments in the output. \
By default this works like Google Closure, keeping JSDoc-style comments that contain \"@license\" or \"@preserve\". \
You can optionally pass one of the following arguments to this flag:\n\
- \"all\" to keep all comments\n\
- a valid JS regexp (needs to start with a slash***REMOVED*** to keep only comments that match.\n\
\
Note that currently not *all* comments can be kept when compression is on, \
because of dead code removal or cascading statements into sequences."***REMOVED***

    .describe("stats", "Display operations run time on STDERR."***REMOVED***
    .describe("acorn", "Use Acorn for parsing."***REMOVED***
    .describe("spidermonkey", "Assume input fles are SpiderMonkey AST format (as JSON***REMOVED***."***REMOVED***
    .describe("self", "Build itself (UglifyJS2***REMOVED*** as a library (implies --wrap=UglifyJS --export-all***REMOVED***"***REMOVED***
    .describe("wrap", "Embed everything in a big function, making the “exports” and “global” variables available. \
You need to pass an argument to this option to specify the name that your module will take when included in, say, a browser."***REMOVED***
    .describe("export-all", "Only used when --wrap, this tells UglifyJS to add code to automatically export all globals."***REMOVED***
    .describe("lint", "Display some scope warnings"***REMOVED***
    .describe("v", "Verbose"***REMOVED***
    .describe("V", "Print version number and exit."***REMOVED***

    .alias("p", "prefix"***REMOVED***
    .alias("o", "output"***REMOVED***
    .alias("v", "verbose"***REMOVED***
    .alias("b", "beautify"***REMOVED***
    .alias("m", "mangle"***REMOVED***
    .alias("c", "compress"***REMOVED***
    .alias("d", "define"***REMOVED***
    .alias("r", "reserved"***REMOVED***
    .alias("V", "version"***REMOVED***

    .string("source-map"***REMOVED***
    .string("source-map-root"***REMOVED***
    .string("source-map-url"***REMOVED***
    .string("b"***REMOVED***
    .string("m"***REMOVED***
    .string("c"***REMOVED***
    .string("d"***REMOVED***
    .string("comments"***REMOVED***
    .string("wrap"***REMOVED***
    .boolean("export-all"***REMOVED***
    .boolean("self"***REMOVED***
    .boolean("v"***REMOVED***
    .boolean("stats"***REMOVED***
    .boolean("acorn"***REMOVED***
    .boolean("spidermonkey"***REMOVED***
    .boolean("lint"***REMOVED***
    .boolean("V"***REMOVED***

    .wrap(80***REMOVED***

    .argv
;

normalize(ARGS***REMOVED***;

if (ARGS.version || ARGS.V***REMOVED*** {
    var json = require("../package.json"***REMOVED***;
    sys.puts(json.name + ' ' + json.version***REMOVED***;
    process.exit(0***REMOVED***;
}

if (ARGS.ast_help***REMOVED*** {
    var desc = UglifyJS.describe_ast(***REMOVED***;
    sys.puts(typeof desc == "string" ? desc : JSON.stringify(desc, null, 2***REMOVED******REMOVED***;
    process.exit(0***REMOVED***;
}

if (ARGS.h || ARGS.help***REMOVED*** {
    sys.puts(optimist.help(***REMOVED******REMOVED***;
    process.exit(0***REMOVED***;
}

if (ARGS.acorn***REMOVED*** {
    acorn = require("acorn"***REMOVED***;
}

var COMPRESS = getOptions("c", true***REMOVED***;
var MANGLE = getOptions("m", true***REMOVED***;
var BEAUTIFY = getOptions("b", true***REMOVED***;

if (COMPRESS && ARGS.d***REMOVED*** {
    COMPRESS.global_defs = getOptions("d"***REMOVED***;
}

if (MANGLE && ARGS.r***REMOVED*** {
    MANGLE.except = ARGS.r.replace(/^\s+|\s+$/g***REMOVED***.split(/\s*,+\s*/***REMOVED***;
}

var OUTPUT_OPTIONS = {
    beautify: BEAUTIFY ? true : false
};

if (BEAUTIFY***REMOVED***
    UglifyJS.merge(OUTPUT_OPTIONS, BEAUTIFY***REMOVED***;

if (ARGS.comments***REMOVED*** {
    if (/^\//.test(ARGS.comments***REMOVED******REMOVED*** {
        OUTPUT_OPTIONS.comments = new Function("return(" + ARGS.comments + "***REMOVED***"***REMOVED***(***REMOVED***;
  ***REMOVED*** else if (ARGS.comments == "all"***REMOVED*** {
        OUTPUT_OPTIONS.comments = true;
  ***REMOVED*** else {
        OUTPUT_OPTIONS.comments = function(node, comment***REMOVED*** {
            var text = comment.value;
            var type = comment.type;
            if (type == "comment2"***REMOVED*** {
                // multiline comment
                return /@preserve|@license|@cc_on/i.test(text***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}

var files = ARGS._.slice(***REMOVED***;

if (ARGS.self***REMOVED*** {
    if (files.length > 0***REMOVED*** {
        sys.error("WARN: Ignoring input files since --self was passed"***REMOVED***;
  ***REMOVED***
    files = UglifyJS.FILES;
    if (!ARGS.wrap***REMOVED*** ARGS.wrap = "UglifyJS";
    ARGS.export_all = true;
}

var ORIG_MAP = ARGS.in_source_map;

if (ORIG_MAP***REMOVED*** {
    ORIG_MAP = JSON.parse(fs.readFileSync(ORIG_MAP***REMOVED******REMOVED***;
    if (files.length == 0***REMOVED*** {
        sys.error("INFO: Using file from the input source map: " + ORIG_MAP.file***REMOVED***;
        files = [ ORIG_MAP.file ];
  ***REMOVED***
    if (ARGS.source_map_root == null***REMOVED*** {
        ARGS.source_map_root = ORIG_MAP.sourceRoot;
  ***REMOVED***
}

if (files.length == 0***REMOVED*** {
    files = [ "-" ];
}

if (files.indexOf("-"***REMOVED*** >= 0 && ARGS.source_map***REMOVED*** {
    sys.error("ERROR: Source map doesn't work with input from STDIN"***REMOVED***;
    process.exit(1***REMOVED***;
}

if (files.filter(function(el***REMOVED***{ return el == "-" }***REMOVED***.length > 1***REMOVED*** {
    sys.error("ERROR: Can read a single file from STDIN (two or more dashes specified***REMOVED***"***REMOVED***;
    process.exit(1***REMOVED***;
}

var STATS = {};
var OUTPUT_FILE = ARGS.o;
var TOPLEVEL = null;

var SOURCE_MAP = ARGS.source_map ? UglifyJS.SourceMap({
    file: OUTPUT_FILE,
    root: ARGS.source_map_root,
    orig: ORIG_MAP,
}***REMOVED*** : null;

OUTPUT_OPTIONS.source_map = SOURCE_MAP;

try {
    var output = UglifyJS.OutputStream(OUTPUT_OPTIONS***REMOVED***;
    var compressor = COMPRESS && UglifyJS.Compressor(COMPRESS***REMOVED***;
} catch(ex***REMOVED*** {
    if (ex instanceof UglifyJS.DefaultsError***REMOVED*** {
        sys.error(ex.msg***REMOVED***;
        sys.error("Supported options:"***REMOVED***;
        sys.error(sys.inspect(ex.defs***REMOVED******REMOVED***;
        process.exit(1***REMOVED***;
  ***REMOVED***
}

files.forEach(function(file***REMOVED*** {
    var code = read_whole_file(file***REMOVED***;
    if (ARGS.p != null***REMOVED*** {
        file = file.replace(/^\/+/, ""***REMOVED***.split(/\/+/***REMOVED***.slice(ARGS.p***REMOVED***.join("/"***REMOVED***;
  ***REMOVED***
    time_it("parse", function(***REMOVED***{
        if (ARGS.spidermonkey***REMOVED*** {
            var program = JSON.parse(code***REMOVED***;
            if (!TOPLEVEL***REMOVED*** TOPLEVEL = program;
            else TOPLEVEL.body = TOPLEVEL.body.concat(program.body***REMOVED***;
      ***REMOVED***
        else if (ARGS.acorn***REMOVED*** {
            TOPLEVEL = acorn.parse(code, {
                locations     : true,
                trackComments : true,
                sourceFile    : file,
                program       : TOPLEVEL
          ***REMOVED******REMOVED***;
      ***REMOVED***
        else {
            TOPLEVEL = UglifyJS.parse(code, {
                filename: file,
                toplevel: TOPLEVEL
          ***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED******REMOVED***;
}***REMOVED***;

if (ARGS.acorn || ARGS.spidermonkey***REMOVED*** time_it("convert_ast", function(***REMOVED***{
    TOPLEVEL = UglifyJS.AST_Node.from_mozilla_ast(TOPLEVEL***REMOVED***;
}***REMOVED***;

if (ARGS.wrap***REMOVED*** {
    TOPLEVEL = TOPLEVEL.wrap_commonjs(ARGS.wrap, ARGS.export_all***REMOVED***;
}

var SCOPE_IS_NEEDED = COMPRESS || MANGLE || ARGS.lint;

if (SCOPE_IS_NEEDED***REMOVED*** {
    time_it("scope", function(***REMOVED***{
        TOPLEVEL.figure_out_scope(***REMOVED***;
        if (ARGS.lint***REMOVED*** {
            TOPLEVEL.scope_warnings(***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
}

if (COMPRESS***REMOVED*** {
    time_it("squeeze", function(***REMOVED***{
        TOPLEVEL = TOPLEVEL.transform(compressor***REMOVED***;
  ***REMOVED******REMOVED***;
}

if (SCOPE_IS_NEEDED***REMOVED*** {
    time_it("scope", function(***REMOVED***{
        TOPLEVEL.figure_out_scope(***REMOVED***;
        if (MANGLE***REMOVED*** {
            TOPLEVEL.compute_char_frequency(MANGLE***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
}

if (MANGLE***REMOVED*** time_it("mangle", function(***REMOVED***{
    TOPLEVEL.mangle_names(MANGLE***REMOVED***;
}***REMOVED***;
time_it("generate", function(***REMOVED***{
    TOPLEVEL.print(output***REMOVED***;
}***REMOVED***;

output = output.get(***REMOVED***;

if (SOURCE_MAP***REMOVED*** {
    fs.writeFileSync(ARGS.source_map, SOURCE_MAP, "utf8"***REMOVED***;
    output += "\n/*\n//@ sourceMappingURL=" + (ARGS.source_map_url || ARGS.source_map***REMOVED*** + "\n*/";
}

if (OUTPUT_FILE***REMOVED*** {
    fs.writeFileSync(OUTPUT_FILE, output, "utf8"***REMOVED***;
} else {
    sys.print(output***REMOVED***;
    sys.error("\n"***REMOVED***;
}

if (ARGS.stats***REMOVED*** {
    sys.error(UglifyJS.string_template("Timing information (compressed {count} files***REMOVED***:", {
        count: files.length
  ***REMOVED******REMOVED******REMOVED***;
    for (var i in STATS***REMOVED*** if (STATS.hasOwnProperty(i***REMOVED******REMOVED*** {
        sys.error(UglifyJS.string_template("- {name}: {time}s", {
            name: i,
            time: (STATS[i] / 1000***REMOVED***.toFixed(3***REMOVED***
      ***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***
}

/* -----[ functions ]----- */

function normalize(o***REMOVED*** {
    for (var i in o***REMOVED*** if (o.hasOwnProperty(i***REMOVED*** && /-/.test(i***REMOVED******REMOVED*** {
        o[i.replace(/-/g, "_"***REMOVED***] = o[i];
        delete o[i];
  ***REMOVED***
}

function getOptions(x, constants***REMOVED*** {
    x = ARGS[x];
    if (!x***REMOVED*** return null;
    var ret = {};
    if (x !== true***REMOVED*** {
        var ast;
        try {
            ast = UglifyJS.parse(x***REMOVED***;
      ***REMOVED*** catch(ex***REMOVED*** {
            if (ex instanceof UglifyJS.JS_Parse_Error***REMOVED*** {
                sys.error("Error parsing arguments in: " + x***REMOVED***;
                process.exit(1***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        ast.walk(new UglifyJS.TreeWalker(function(node***REMOVED***{
            if (node instanceof UglifyJS.AST_Toplevel***REMOVED*** return; // descend
            if (node instanceof UglifyJS.AST_SimpleStatement***REMOVED*** return; // descend
            if (node instanceof UglifyJS.AST_Seq***REMOVED*** return; // descend
            if (node instanceof UglifyJS.AST_Assign***REMOVED*** {
                var name = node.left.print_to_string({ beautify: false }***REMOVED***.replace(/-/g, "_"***REMOVED***;
                var value = node.right;
                if (constants***REMOVED***
                    value = new Function("return (" + value.print_to_string(***REMOVED*** + "***REMOVED***"***REMOVED***(***REMOVED***;
                ret[name] = value;
                return true;    // no descend
          ***REMOVED***
            sys.error(node.TYPE***REMOVED***
            sys.error("Error parsing arguments in: " + x***REMOVED***;
            process.exit(1***REMOVED***;
      ***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***
    return ret;
}

function read_whole_file(filename***REMOVED*** {
    if (filename == "-"***REMOVED*** {
        // XXX: this sucks.  How does one read the whole STDIN
        // synchronously?
        filename = "/dev/stdin";
  ***REMOVED***
    try {
        return fs.readFileSync(filename, "utf8"***REMOVED***;
  ***REMOVED*** catch(ex***REMOVED*** {
        sys.error("ERROR: can't read file: " + filename***REMOVED***;
        process.exit(1***REMOVED***;
  ***REMOVED***
}

function time_it(name, cont***REMOVED*** {
    var t1 = new Date(***REMOVED***.getTime(***REMOVED***;
    var ret = cont(***REMOVED***;
    if (ARGS.stats***REMOVED*** {
        var spent = new Date(***REMOVED***.getTime(***REMOVED*** - t1;
        if (STATS[name]***REMOVED*** STATS[name] += spent;
        else STATS[name] = spent;
  ***REMOVED***
    return ret;
}
