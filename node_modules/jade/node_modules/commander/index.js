
/**
 * Module dependencies.
 */

var EventEmitter = require('events'***REMOVED***.EventEmitter;
var spawn = require('child_process'***REMOVED***.spawn;
var fs = require('fs'***REMOVED***;
var exists = fs.existsSync;
var ***REMOVED***;
var dirname = path.dirname;
var basename = path.basename;

/**
 * Expose the root command.
 */

exports = module.exports = new Command;

/**
 * Expose `Command`.
 */

exports.Command = Command;

/**
 * Expose `Option`.
 */

exports.Option = Option;

/**
 * Initialize a new `Option` with the given `flags` and `description`.
 *
 * @param {String} flags
 * @param {String} description
 * @api public
 */

function Option(flags, description***REMOVED*** {
  this.flags = flags;
  this.required = ~flags.indexOf('<'***REMOVED***;
  this.optional = ~flags.indexOf('['***REMOVED***;
  this.bool = !~flags.indexOf('-no-'***REMOVED***;
  flags = flags.split(/[ ,|]+/***REMOVED***;
  if (flags.length > 1 && !/^[[<]/.test(flags[1]***REMOVED******REMOVED*** this.short = flags.shift(***REMOVED***;
  this.long = flags.shift(***REMOVED***;
  this.description = description || '';
}

/**
 * Return option name.
 *
 * @return {String}
 * @api private
 */

Option.prototype.name = function(***REMOVED***{
  return this.long
    .replace('--', ''***REMOVED***
    .replace('no-', ''***REMOVED***;
};

/**
 * Check if `arg` matches the short or long flag.
 *
 * @param {String} arg
 * @return {Boolean}
 * @api private
 */

Option.prototype.is = function(arg***REMOVED***{
  return arg == this.short
    || arg == this.long;
};

/**
 * Initialize a new `Command`.
 *
 * @param {String} name
 * @api public
 */

function Command(name***REMOVED*** {
  this.commands = [];
  this.options = [];
  this._execs = [];
  this._args = [];
  this._name = name;
}

/**
 * Inherit from `EventEmitter.prototype`.
 */

Command.prototype.__proto__ = EventEmitter.prototype;

/**
 * Add command `name`.
 *
 * The `.action(***REMOVED***` callback is invoked when the
 * command `name` is specified via __ARGV__,
 * and the remaining arguments are applied to the
 * function for access.
 *
 * When the `name` is "*" an un-matched command
 * will be passed as the first arg, followed by
 * the rest of __ARGV__ remaining.
 *
 * Examples:
 *
 *      program
 *        .version('0.0.1'***REMOVED***
 *        .option('-C, --chdir <path>', 'change the working directory'***REMOVED***
 *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf'***REMOVED***
 *        .option('-T, --no-tests', 'ignore test hook'***REMOVED***
 *     
 *      program
 *        .command('setup'***REMOVED***
 *        .description('run remote setup commands'***REMOVED***
 *        .action(function(***REMOVED***{
 *          console.log('setup'***REMOVED***;
 *      ***REMOVED******REMOVED***;
 *     
 *      program
 *        .command('exec <cmd>'***REMOVED***
 *        .description('run the given remote command'***REMOVED***
 *        .action(function(cmd***REMOVED***{
 *          console.log('exec "%s"', cmd***REMOVED***;
 *      ***REMOVED******REMOVED***;
 *     
 *      program
 *        .command('*'***REMOVED***
 *        .description('deploy the given env'***REMOVED***
 *        .action(function(env***REMOVED***{
 *          console.log('deploying "%s"', env***REMOVED***;
 *      ***REMOVED******REMOVED***;
 *     
 *      program.parse(process.argv***REMOVED***;
  *
 * @param {String} name
 * @param {String} [desc]
 * @return {Command} the new command
 * @api public
 */

Command.prototype.command = function(name, desc***REMOVED***{
  var args = name.split(/ +/***REMOVED***;
  var cmd = new Command(args.shift(***REMOVED******REMOVED***;
  if (desc***REMOVED*** cmd.description(desc***REMOVED***;
  if (desc***REMOVED*** this.executables = true;
  if (desc***REMOVED*** this._execs[cmd._name] = true;
  this.commands.push(cmd***REMOVED***;
  cmd.parseExpectedArgs(args***REMOVED***;
  cmd.parent = this;
  if (desc***REMOVED*** return this;
  return cmd;
};

/**
 * Add an implicit `help [cmd]` subcommand
 * which invokes `--help` for the given command.
 *
 * @api private
 */

Command.prototype.addImplicitHelpCommand = function(***REMOVED*** {
  this.command('help [cmd]', 'display help for [cmd]'***REMOVED***;
};

/**
 * Parse expected `args`.
 *
 * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parseExpectedArgs = function(args***REMOVED***{
  if (!args.length***REMOVED*** return;
  var self = this;
  args.forEach(function(arg***REMOVED***{
    switch (arg[0]***REMOVED*** {
      case '<':
        self._args.push({ required: true, name: arg.slice(1, -1***REMOVED*** }***REMOVED***;
        break;
      case '[':
        self._args.push({ required: false, name: arg.slice(1, -1***REMOVED*** }***REMOVED***;
        break;
  ***REMOVED***
***REMOVED******REMOVED***;
  return this;
};

/**
 * Register callback `fn` for the command.
 *
 * Examples:
 *
 *      program
 *        .command('help'***REMOVED***
 *        .description('display verbose help'***REMOVED***
 *        .action(function(***REMOVED***{
 *           // output help here
 *      ***REMOVED******REMOVED***;
 *
 * @param {Function} fn
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.action = function(fn***REMOVED***{
  var self = this;
  this.parent.on(this._name, function(args, unknown***REMOVED***{    
    // Parse any so-far unknown options
    unknown = unknown || [];
    var parsed = self.parseOptions(unknown***REMOVED***;
    
    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown***REMOVED***;
    
    // If there are still any unknown options, then we simply 
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0***REMOVED*** {      
      self.unknownOption(parsed.unknown[0]***REMOVED***;
  ***REMOVED***
    
    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length***REMOVED*** args = parsed.args.concat(args***REMOVED***;
    
    self._args.forEach(function(arg, i***REMOVED***{
      if (arg.required && null == args[i]***REMOVED*** {
        self.missingArgument(arg.name***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
    
    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length***REMOVED*** {
      args[self._args.length] = self;
  ***REMOVED*** else {
      args.push(self***REMOVED***;
  ***REMOVED***
    
    fn.apply(this, args***REMOVED***;
***REMOVED******REMOVED***;
  return this;
};

/**
 * Define option with `flags`, `description` and optional
 * coercion `fn`. 
 *
 * The `flags` string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when `--help` is used.
 *
 *    "-p, --pepper"
 *    "-p|--pepper"
 *    "-p --pepper"
 *
 * Examples:
 *
 *     // simple boolean defaulting to false
 *     program.option('-p, --pepper', 'add pepper'***REMOVED***;
 *
 *     --pepper
 *     program.pepper
 *     // => Boolean
 *
 *     // simple boolean defaulting to false
 *     program.option('-C, --no-cheese', 'remove cheese'***REMOVED***;
 *
 *     program.cheese
 *     // => true
 *
 *     --no-cheese
 *     program.cheese
 *     // => true
 *
 *     // required argument
 *     program.option('-C, --chdir <path>', 'change the working directory'***REMOVED***;
 *
 *     --chdir /tmp
 *     program.chdir
 *     // => "/tmp"
 *
 *     // optional argument
 *     program.option('-c, --cheese [type]', 'add cheese [marble]'***REMOVED***;
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|Mixed} fn or default
 * @param {Mixed} defaultValue
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.option = function(flags, description, fn, defaultValue***REMOVED***{
  var self = this
    , option = new Option(flags, description***REMOVED***
    , oname = option.name(***REMOVED***
    , name = camelcase(oname***REMOVED***;

  // default as 3rd arg
  if ('function' != typeof fn***REMOVED*** defaultValue = fn, fn = null;

  // preassign default value only for --no-*, [optional], or <required>
  if (false == option.bool || option.optional || option.required***REMOVED*** {
    // when --no-* we make sure default is true
    if (false == option.bool***REMOVED*** defaultValue = true;
    // preassign only if we have a default
    if (undefined !== defaultValue***REMOVED*** self[name] = defaultValue;
***REMOVED***

  // register the option
  this.options.push(option***REMOVED***;

  // when it's passed assign the value
  // and conditionally invoke the callback
  this.on(oname, function(val***REMOVED***{
    // coercion
    if (null != val && fn***REMOVED*** val = fn(val***REMOVED***;

    // unassigned or bool
    if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]***REMOVED*** {
      // if no value, bool true, and we have a default, then use it!
      if (null == val***REMOVED*** {
        self[name] = option.bool
          ? defaultValue || true
          : false;
    ***REMOVED*** else {
        self[name] = val;
    ***REMOVED***
  ***REMOVED*** else if (null !== val***REMOVED*** {
      // reassign
      self[name] = val;
  ***REMOVED***
***REMOVED******REMOVED***;

  return this;
};

/**
 * Parse `argv`, settings options and invoking commands when defined.
 *
 * @param {Array} argv
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parse = function(argv***REMOVED***{
  // implicit help
  if (this.executables***REMOVED*** this.addImplicitHelpCommand(***REMOVED***;

  // store raw args
  this.rawArgs = argv;

  // guess name
  this._name = this._name || basename(argv[1]***REMOVED***;

  // process argv
  var parsed = this.parseOptions(this.normalize(argv.slice(2***REMOVED******REMOVED******REMOVED***;
  var args = this.args = parsed.args;
 
  var result = this.parseArgs(this.args, parsed.unknown***REMOVED***;

  // executable sub-commands
  var name = result.args[0];
  if (this._execs[name]***REMOVED*** return this.executeSubCommand(argv, args, parsed.unknown***REMOVED***;

  return result;
};

/**
 * Execute a sub-command executable.
 *
 * @param {Array} argv
 * @param {Array} args
 * @param {Array} unknown
 * @api private
 */

Command.prototype.executeSubCommand = function(argv, args, unknown***REMOVED*** {
  args = args.concat(unknown***REMOVED***;

  if (!args.length***REMOVED*** this.help(***REMOVED***;
  if ('help' == args[0] && 1 == args.length***REMOVED*** this.help(***REMOVED***;

  // <cmd> --help
  if ('help' == args[0]***REMOVED*** {
    args[0] = args[1];
    args[1] = '--help';
***REMOVED***

  // executable
  var dir = dirname(argv[1]***REMOVED***;
  var bin = basename(argv[1]***REMOVED*** + '-' + args[0];

  // check for ./<bin> first
  var local = path.join(dir, bin***REMOVED***;

  // run it
  args = args.slice(1***REMOVED***;
  var proc = spawn(local, args, { stdio: 'inherit', customFds: [0, 1, 2] }***REMOVED***;
  proc.on('error', function(err***REMOVED***{
    if (err.code == "ENOENT"***REMOVED*** {
      console.error('\n  %s(1***REMOVED*** does not exist, try --help\n', bin***REMOVED***;
  ***REMOVED*** else if (err.code == "EACCES"***REMOVED*** {
      console.error('\n  %s(1***REMOVED*** not executable. try chmod or run with root\n', bin***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;

  this.runningCommand = proc;
};

/**
 * Normalize `args`, splitting joined short flags. For example
 * the arg "-abc" is equivalent to "-a -b -c".
 * This also normalizes equal sign and splits "--abc=def" into "--abc def".
 *
 * @param {Array} args
 * @return {Array}
 * @api private
 */

Command.prototype.normalize = function(args***REMOVED***{
  var ret = []
    , arg
    , lastOpt
    , index;

  for (var i = 0, len = args.length; i < len; ++i***REMOVED*** {
    arg = args[i];
    i > 0 && (lastOpt = this.optionFor(args[i-1]***REMOVED******REMOVED***;
    
    if (lastOpt && lastOpt.required***REMOVED*** {
     	ret.push(arg***REMOVED***;
  ***REMOVED*** else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]***REMOVED*** {
      arg.slice(1***REMOVED***.split(''***REMOVED***.forEach(function(c***REMOVED***{
        ret.push('-' + c***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED*** else if (/^--/.test(arg***REMOVED*** && ~(index = arg.indexOf('='***REMOVED******REMOVED******REMOVED*** {
      ret.push(arg.slice(0, index***REMOVED***, arg.slice(index + 1***REMOVED******REMOVED***;
  ***REMOVED*** else {
      ret.push(arg***REMOVED***;
  ***REMOVED***
***REMOVED***

  return ret;
};

/**
 * Parse command `args`.
 *
 * When listener(s***REMOVED*** are available those
 * callbacks are invoked, otherwise the "*"
 * event is emitted and those actions are invoked.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api private
 */

Command.prototype.parseArgs = function(args, unknown***REMOVED***{
  var cmds = this.commands
    , len = cmds.length
    , name;

  if (args.length***REMOVED*** {
    name = args[0];
    if (this.listeners(name***REMOVED***.length***REMOVED*** {
      this.emit(args.shift(***REMOVED***, args, unknown***REMOVED***;
  ***REMOVED*** else {
      this.emit('*', args***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    outputHelpIfNecessary(this, unknown***REMOVED***;
    
    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length > 0***REMOVED*** {      
      this.unknownOption(unknown[0]***REMOVED***;
  ***REMOVED***
***REMOVED***

  return this;
};

/**
 * Return an option matching `arg` if any.
 *
 * @param {String} arg
 * @return {Option}
 * @api private
 */

Command.prototype.optionFor = function(arg***REMOVED***{
  for (var i = 0, len = this.options.length; i < len; ++i***REMOVED*** {
    if (this.options[i].is(arg***REMOVED******REMOVED*** {
      return this.options[i];
  ***REMOVED***
***REMOVED***
};

/**
 * Parse options from `argv` returning `argv`
 * void of these options.
 *
 * @param {Array} argv
 * @return {Array}
 * @api public
 */

Command.prototype.parseOptions = function(argv***REMOVED***{
  var args = []
    , len = argv.length
    , literal
    , option
    , arg;

  var unknownOptions = [];

  // parse options
  for (var i = 0; i < len; ++i***REMOVED*** {
    arg = argv[i];

    // literal args after --
    if ('--' == arg***REMOVED*** {
      literal = true;
      continue;
  ***REMOVED***

    if (literal***REMOVED*** {
      args.push(arg***REMOVED***;
      continue;
  ***REMOVED***

    // find matching Option
    option = this.optionFor(arg***REMOVED***;

    // option is defined
    if (option***REMOVED*** {
      // requires arg
      if (option.required***REMOVED*** {
        arg = argv[++i];
        if (null == arg***REMOVED*** return this.optionMissingArgument(option***REMOVED***;
        this.emit(option.name(***REMOVED***, arg***REMOVED***;
      // optional arg
    ***REMOVED*** else if (option.optional***REMOVED*** {
        arg = argv[i+1];
        if (null == arg || ('-' == arg[0] && '-' != arg***REMOVED******REMOVED*** {
          arg = null;
      ***REMOVED*** else {
          ++i;
      ***REMOVED***
        this.emit(option.name(***REMOVED***, arg***REMOVED***;
      // bool
    ***REMOVED*** else {
        this.emit(option.name(***REMOVED******REMOVED***;
    ***REMOVED***
      continue;
  ***REMOVED***
    
    // looks like an option
    if (arg.length > 1 && '-' == arg[0]***REMOVED*** {
      unknownOptions.push(arg***REMOVED***;
      
      // If the next argument looks like it might be
      // an argument for this option, we pass it on.
      // If it isn't, then it'll simply be ignored
      if (argv[i+1] && '-' != argv[i+1][0]***REMOVED*** {
        unknownOptions.push(argv[++i]***REMOVED***;
    ***REMOVED***
      continue;
  ***REMOVED***
    
    // arg
    args.push(arg***REMOVED***;
***REMOVED***
  
  return { args: args, unknown: unknownOptions };
};

/**
 * Argument `name` is missing.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.missingArgument = function(name***REMOVED***{
  console.error(***REMOVED***;
  console.error("  error: missing required argument `%s'", name***REMOVED***;
  console.error(***REMOVED***;
  process.exit(1***REMOVED***;
};

/**
 * `Option` is missing an argument, but received `flag` or nothing.
 *
 * @param {String} option
 * @param {String} flag
 * @api private
 */

Command.prototype.optionMissingArgument = function(option, flag***REMOVED***{
  console.error(***REMOVED***;
  if (flag***REMOVED*** {
    console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag***REMOVED***;
***REMOVED*** else {
    console.error("  error: option `%s' argument missing", option.flags***REMOVED***;
***REMOVED***
  console.error(***REMOVED***;
  process.exit(1***REMOVED***;
};

/**
 * Unknown option `flag`.
 *
 * @param {String} flag
 * @api private
 */

Command.prototype.unknownOption = function(flag***REMOVED***{
  console.error(***REMOVED***;
  console.error("  error: unknown option `%s'", flag***REMOVED***;
  console.error(***REMOVED***;
  process.exit(1***REMOVED***;
};


/**
 * Set the program version to `str`.
 *
 * This method auto-registers the "-V, --version" flag
 * which will print the version number when passed.
 *
 * @param {String} str
 * @param {String} flags
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.version = function(str, flags***REMOVED***{
  if (0 == arguments.length***REMOVED*** return this._version;
  this._version = str;
  flags = flags || '-V, --version';
  this.option(flags, 'output the version number'***REMOVED***;
  this.on('version', function(***REMOVED***{
    console.log(str***REMOVED***;
    process.exit(0***REMOVED***;
***REMOVED******REMOVED***;
  return this;
};

/**
 * Set the description `str`.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.description = function(str***REMOVED***{
  if (0 == arguments.length***REMOVED*** return this._description;
  this._description = str;
  return this;
};

/**
 * Set / get the command usage `str`.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.usage = function(str***REMOVED***{
  var args = this._args.map(function(arg***REMOVED***{
    return arg.required
      ? '<' + arg.name + '>'
      : '[' + arg.name + ']';
***REMOVED******REMOVED***;

  var usage = '[options'
    + (this.commands.length ? '] [command' : ''***REMOVED***
    + ']'
    + (this._args.length ? ' ' + args : ''***REMOVED***;

  if (0 == arguments.length***REMOVED*** return this._usage || usage;
  this._usage = str;

  return this;
};

/**
 * Return the largest option length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestOptionLength = function(***REMOVED***{
  return this.options.reduce(function(max, option***REMOVED***{
    return Math.max(max, option.flags.length***REMOVED***;
***REMOVED***, 0***REMOVED***;
};

/**
 * Return help for options.
 *
 * @return {String}
 * @api private
 */

Command.prototype.optionHelp = function(***REMOVED***{
  var width = this.largestOptionLength(***REMOVED***;
  
  // Prepend the help information
  return [pad('-h, --help', width***REMOVED*** + '  ' + 'output usage information']
    .concat(this.options.map(function(option***REMOVED***{
      return pad(option.flags, width***REMOVED***
        + '  ' + option.description;
    ***REMOVED******REMOVED******REMOVED***
    .join('\n'***REMOVED***;
};

/**
 * Return command help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.commandHelp = function(***REMOVED***{
  if (!this.commands.length***REMOVED*** return '';
  return [
      ''
    , '  Commands:'
    , ''
    , this.commands.map(function(cmd***REMOVED***{
      var args = cmd._args.map(function(arg***REMOVED***{
        return arg.required
          ? '<' + arg.name + '>'
          : '[' + arg.name + ']';
    ***REMOVED******REMOVED***.join(' '***REMOVED***;

      return pad(cmd._name
        + (cmd.options.length 
          ? ' [options]'
          : ''***REMOVED*** + ' ' + args, 22***REMOVED***
        + (cmd.description(***REMOVED***
          ? ' ' + cmd.description(***REMOVED***
          : ''***REMOVED***;
  ***REMOVED******REMOVED***.join('\n'***REMOVED***.replace(/^/gm, '    '***REMOVED***
    , ''
  ].join('\n'***REMOVED***;
};

/**
 * Return program help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.helpInformation = function(***REMOVED***{
  return [
      ''
    , '  Usage: ' + this._name + ' ' + this.usage(***REMOVED***
    , '' + this.commandHelp(***REMOVED***
    , '  Options:'
    , ''
    , '' + this.optionHelp(***REMOVED***.replace(/^/gm, '    '***REMOVED***
    , ''
    , ''
  ].join('\n'***REMOVED***;
};

/**
 * Output help information for this command
 *
 * @api public
 */

Command.prototype.outputHelp = function(***REMOVED***{
  process.stdout.write(this.helpInformation(***REMOVED******REMOVED***;
  this.emit('--help'***REMOVED***;
};

/**
 * Output help information and exit.
 *
 * @api public
 */

Command.prototype.help = function(***REMOVED***{
  this.outputHelp(***REMOVED***;
  process.exit(***REMOVED***;
};

/**
 * Camel-case the given `flag`
 *
 * @param {String} flag
 * @return {String}
 * @api private
 */

function camelcase(flag***REMOVED*** {
  return flag.split('-'***REMOVED***.reduce(function(str, word***REMOVED***{
    return str + word[0].toUpperCase(***REMOVED*** + word.slice(1***REMOVED***;
***REMOVED******REMOVED***;
}

/**
 * Pad `str` to `width`.
 *
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width***REMOVED*** {
  var len = Math.max(0, width - str.length***REMOVED***;
  return str + Array(len + 1***REMOVED***.join(' '***REMOVED***;
}

/**
 * Output help information if necessary
 *
 * @param {Command} command to output help for
 * @param {Array} array of options to search for -h or --help
 * @api private
 */

function outputHelpIfNecessary(cmd, options***REMOVED*** {
  options = options || [];
  for (var i = 0; i < options.length; i++***REMOVED*** {
    if (options[i] == '--help' || options[i] == '-h'***REMOVED*** {
      cmd.outputHelp(***REMOVED***;
      process.exit(0***REMOVED***;
  ***REMOVED***
***REMOVED***
}
