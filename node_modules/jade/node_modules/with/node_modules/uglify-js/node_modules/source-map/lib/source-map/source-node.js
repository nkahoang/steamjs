/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function'***REMOVED*** {
    var define = require('amdefine'***REMOVED***(module, require***REMOVED***;
}
define(function (require, exports, module***REMOVED*** {

  var SourceMapGenerator = require('./source-map-generator'***REMOVED***.SourceMapGenerator;
  var util = require('./util'***REMOVED***;

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName***REMOVED*** {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null***REMOVED*** this.add(aChunks***REMOVED***;
***REMOVED***

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer***REMOVED*** {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode(***REMOVED***;

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n'***REMOVED***;

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping***REMOVED*** {
        if (lastMapping !== null***REMOVED*** {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine***REMOVED*** {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, remainingLines.shift(***REMOVED*** + "\n"***REMOVED***;
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
        ***REMOVED*** else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn***REMOVED***;
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn***REMOVED***;
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code***REMOVED***;
            // No more remaining code, continue
            lastMapping = mapping;
            return;
        ***REMOVED***
      ***REMOVED***
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine***REMOVED*** {
          node.add(remainingLines.shift(***REMOVED*** + "\n"***REMOVED***;
          lastGeneratedLine++;
      ***REMOVED***
        if (lastGeneratedColumn < mapping.generatedColumn***REMOVED*** {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn***REMOVED******REMOVED***;
          remainingLines[0] = nextLine.substr(mapping.generatedColumn***REMOVED***;
          lastGeneratedColumn = mapping.generatedColumn;
      ***REMOVED***
        lastMapping = mapping;
    ***REMOVED***, this***REMOVED***;
      // We have processed all mappings.
      if (remainingLines.length > 0***REMOVED*** {
        if (lastMapping***REMOVED*** {
          // Associate the remaining code in the current line with "lastMapping"
          var lastLine = remainingLines.shift(***REMOVED***;
          if (remainingLines.length > 0***REMOVED*** lastLine += "\n";
          addMappingWithCode(lastMapping, lastLine***REMOVED***;
      ***REMOVED***
        // and add the remaining lines without any mapping
        node.add(remainingLines.join("\n"***REMOVED******REMOVED***;
    ***REMOVED***

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile***REMOVED*** {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile***REMOVED***;
        if (content***REMOVED*** {
          node.setSourceContent(sourceFile, content***REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;

      return node;

      function addMappingWithCode(mapping, code***REMOVED*** {
        if (mapping === null || mapping.source === undefined***REMOVED*** {
          node.add(code***REMOVED***;
      ***REMOVED*** else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk***REMOVED*** {
    if (Array.isArray(aChunk***REMOVED******REMOVED*** {
      aChunk.forEach(function (chunk***REMOVED*** {
        this.add(chunk***REMOVED***;
    ***REMOVED***, this***REMOVED***;
  ***REMOVED***
    else if (aChunk instanceof SourceNode || typeof aChunk === "string"***REMOVED*** {
      if (aChunk***REMOVED*** {
        this.children.push(aChunk***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      ***REMOVED***;
  ***REMOVED***
    return this;
***REMOVED***;

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk***REMOVED*** {
    if (Array.isArray(aChunk***REMOVED******REMOVED*** {
      for (var i = aChunk.length-1; i >= 0; i--***REMOVED*** {
        this.prepend(aChunk[i]***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    else if (aChunk instanceof SourceNode || typeof aChunk === "string"***REMOVED*** {
      this.children.unshift(aChunk***REMOVED***;
  ***REMOVED***
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      ***REMOVED***;
  ***REMOVED***
    return this;
***REMOVED***;

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn***REMOVED*** {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++***REMOVED*** {
      chunk = this.children[i];
      if (chunk instanceof SourceNode***REMOVED*** {
        chunk.walk(aFn***REMOVED***;
    ***REMOVED***
      else {
        if (chunk !== ''***REMOVED*** {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name }***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep***REMOVED*** {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0***REMOVED*** {
      newChildren = [];
      for (i = 0; i < len-1; i++***REMOVED*** {
        newChildren.push(this.children[i]***REMOVED***;
        newChildren.push(aSep***REMOVED***;
    ***REMOVED***
      newChildren.push(this.children[i]***REMOVED***;
      this.children = newChildren;
  ***REMOVED***
    return this;
***REMOVED***;

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement***REMOVED*** {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode***REMOVED*** {
      lastChild.replaceRight(aPattern, aReplacement***REMOVED***;
  ***REMOVED***
    else if (typeof lastChild === 'string'***REMOVED*** {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement***REMOVED***;
  ***REMOVED***
    else {
      this.children.push(''.replace(aPattern, aReplacement***REMOVED******REMOVED***;
  ***REMOVED***
    return this;
***REMOVED***;

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent***REMOVED*** {
      this.sourceContents[util.toSetString(aSourceFile***REMOVED***] = aSourceContent;
  ***REMOVED***;

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn***REMOVED*** {
      for (var i = 0, len = this.children.length; i < len; i++***REMOVED*** {
        if (this.children[i] instanceof SourceNode***REMOVED*** {
          this.children[i].walkSourceContents(aFn***REMOVED***;
      ***REMOVED***
    ***REMOVED***

      var sources = Object.keys(this.sourceContents***REMOVED***;
      for (var i = 0, len = sources.length; i < len; i++***REMOVED*** {
        aFn(util.fromSetString(sources[i]***REMOVED***, this.sourceContents[sources[i]]***REMOVED***;
    ***REMOVED***
  ***REMOVED***;

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString(***REMOVED*** {
    var str = "";
    this.walk(function (chunk***REMOVED*** {
      str += chunk;
  ***REMOVED******REMOVED***;
    return str;
***REMOVED***;

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs***REMOVED*** {
    var generated = {
      code: "",
      line: 1,
      column: 0
  ***REMOVED***;
    var map = new SourceMapGenerator(aArgs***REMOVED***;
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original***REMOVED*** {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null***REMOVED*** {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name***REMOVED*** {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
          ***REMOVED***,
            generated: {
              line: generated.line,
              column: generated.column
          ***REMOVED***,
            name: original.name
        ***REMOVED******REMOVED***;
      ***REMOVED***
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
    ***REMOVED*** else if (sourceMappingActive***REMOVED*** {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
        ***REMOVED***
      ***REMOVED******REMOVED***;
        lastOriginalSource = null;
        sourceMappingActive = false;
    ***REMOVED***
      chunk.split(''***REMOVED***.forEach(function (ch, idx, array***REMOVED*** {
        if (ch === '\n'***REMOVED*** {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === array.length***REMOVED*** {
            lastOriginalSource = null;
            sourceMappingActive = false;
        ***REMOVED*** else if (sourceMappingActive***REMOVED*** {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
            ***REMOVED***,
              generated: {
                line: generated.line,
                column: generated.column
            ***REMOVED***,
              name: original.name
          ***REMOVED******REMOVED***;
        ***REMOVED***
      ***REMOVED*** else {
          generated.column++;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
    this.walkSourceContents(function (sourceFile, sourceContent***REMOVED*** {
      map.setSourceContent(sourceFile, sourceContent***REMOVED***;
  ***REMOVED******REMOVED***;

    return { code: generated.code, map: map };
***REMOVED***;

  exports.SourceNode = SourceNode;

}***REMOVED***;
