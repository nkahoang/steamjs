/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c***REMOVED*** 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn***REMOVED*** {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        ***REMOVED***,
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary***REMOVED*** {
        var i, part;
        for (i = 0; ary[i]; i+= 1***REMOVED*** {
            part = ary[i];
            if (part === '.'***REMOVED*** {
                ary.splice(i, 1***REMOVED***;
                i -= 1;
          ***REMOVED*** else if (part === '..'***REMOVED*** {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..'***REMOVED******REMOVED*** {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
              ***REMOVED*** else if (i > 0***REMOVED*** {
                    ary.splice(i - 1, 2***REMOVED***;
                    i -= 2;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    function normalize(name, baseName***REMOVED*** {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0***REMOVED*** === '.'***REMOVED*** {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName***REMOVED*** {
                baseParts = baseName.split('/'***REMOVED***;
                baseParts = baseParts.slice(0, baseParts.length - 1***REMOVED***;
                baseParts = baseParts.concat(name.split('/'***REMOVED******REMOVED***;
                trimDots(baseParts***REMOVED***;
                name = baseParts.join('/'***REMOVED***;
          ***REMOVED***
      ***REMOVED***

        return name;
  ***REMOVED***

    /**
     * Create the normalize(***REMOVED*** function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName***REMOVED*** {
        return function (name***REMOVED*** {
            return normalize(name, relName***REMOVED***;
      ***REMOVED***;
  ***REMOVED***

    function makeLoad(id***REMOVED*** {
        function load(value***REMOVED*** {
            loaderCache[id] = value;
      ***REMOVED***

        load.fromText = function (id, text***REMOVED*** {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText'***REMOVED***;
      ***REMOVED***;

        return load;
  ***REMOVED***

    makeRequire = function (systemRequire, exports, module, relId***REMOVED*** {
        function amdRequire(deps, callback***REMOVED*** {
            if (typeof deps === 'string'***REMOVED*** {
                //Synchronous, single module require(''***REMOVED***
                return stringRequire(systemRequire, exports, module, deps, relId***REMOVED***;
          ***REMOVED*** else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName***REMOVED*** {
                    return stringRequire(systemRequire, exports, module, depName, relId***REMOVED***;
              ***REMOVED******REMOVED***;

                //Wait for next tick to call back the require call.
                process.nextTick(function (***REMOVED*** {
                    callback.apply(null, deps***REMOVED***;
              ***REMOVED******REMOVED***;
          ***REMOVED***
      ***REMOVED***

        amdRequire.toUrl = function (filePath***REMOVED*** {
            if (filePath.indexOf('.'***REMOVED*** === 0***REMOVED*** {
                return normalize(filePath, path.dirname(module.filename***REMOVED******REMOVED***;
          ***REMOVED*** else {
                return filePath;
          ***REMOVED***
      ***REMOVED***;

        return amdRequire;
  ***REMOVED***;

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req(***REMOVED*** {
        return module.require.apply(module, arguments***REMOVED***;
  ***REMOVED***;

    function runFactory(id, deps, factory***REMOVED*** {
        var r, e, m, result;

        if (id***REMOVED*** {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
          ***REMOVED***;
            r = makeRequire(requireFn, e, m, id***REMOVED***;
      ***REMOVED*** else {
            //Only support one define call per file
            if (alreadyCalled***REMOVED*** {
                throw new Error('amdefine with no module ID cannot be called more than once per file.'***REMOVED***;
          ***REMOVED***
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id***REMOVED***;
      ***REMOVED***

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps***REMOVED*** {
            deps = deps.map(function (depName***REMOVED*** {
                return r(depName***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***

        //Call the factory with the right dependencies.
        if (typeof factory === 'function'***REMOVED*** {
            result = factory.apply(m.exports, deps***REMOVED***;
      ***REMOVED*** else {
            result = factory;
      ***REMOVED***

        if (result !== undefined***REMOVED*** {
            m.exports = result;
            if (id***REMOVED*** {
                loaderCache[id] = m.exports;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    stringRequire = function (systemRequire, exports, module, id, relId***REMOVED*** {
        //Split the ID by a ! so that
        var index = id.indexOf('!'***REMOVED***,
            originalId = id,
            prefix, plugin;

        if (index === -1***REMOVED*** {
            id = normalize(id, relId***REMOVED***;

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require'***REMOVED*** {
                return makeRequire(systemRequire, exports, module, relId***REMOVED***;
          ***REMOVED*** else if (id === 'exports'***REMOVED*** {
                return exports;
          ***REMOVED*** else if (id === 'module'***REMOVED*** {
                return module;
          ***REMOVED*** else if (loaderCache.hasOwnProperty(id***REMOVED******REMOVED*** {
                return loaderCache[id];
          ***REMOVED*** else if (defineCache[id]***REMOVED*** {
                runFactory.apply(null, defineCache[id]***REMOVED***;
                return loaderCache[id];
          ***REMOVED*** else {
                if(systemRequire***REMOVED*** {
                    return systemRequire(originalId***REMOVED***;
              ***REMOVED*** else {
                    throw new Error('No module with ID: ' + id***REMOVED***;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED*** else {
            //There is a plugin in play.
            prefix = id.substring(0, index***REMOVED***;
            id = id.substring(index + 1, id.length***REMOVED***;

            plugin = stringRequire(systemRequire, exports, module, prefix, relId***REMOVED***;

            if (plugin.normalize***REMOVED*** {
                id = plugin.normalize(id, makeNormalize(relId***REMOVED******REMOVED***;
          ***REMOVED*** else {
                //Normalize the ID normally.
                id = normalize(id, relId***REMOVED***;
          ***REMOVED***

            if (loaderCache[id]***REMOVED*** {
                return loaderCache[id];
          ***REMOVED*** else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId***REMOVED***, makeLoad(id***REMOVED***, {}***REMOVED***;

                return loaderCache[id];
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory***REMOVED*** {
        if (Array.isArray(id***REMOVED******REMOVED*** {
            factory = deps;
            deps = id;
            id = undefined;
      ***REMOVED*** else if (typeof id !== 'string'***REMOVED*** {
            factory = id;
            id = deps = undefined;
      ***REMOVED***

        if (deps && !Array.isArray(deps***REMOVED******REMOVED*** {
            factory = deps;
            deps = undefined;
      ***REMOVED***

        if (!deps***REMOVED*** {
            deps = ['require', 'exports', 'module'];
      ***REMOVED***

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id***REMOVED*** {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
      ***REMOVED*** else {
            runFactory(id, deps, factory***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id***REMOVED*** {
        if (loaderCache[id]***REMOVED*** {
            return loaderCache[id];
      ***REMOVED***

        if (defineCache[id]***REMOVED*** {
            runFactory.apply(null, defineCache[id]***REMOVED***;
            return loaderCache[id];
      ***REMOVED***
  ***REMOVED***;

    define.amd = {};

    return define;
}

module.exports = amdefine;
