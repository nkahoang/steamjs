/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function'***REMOVED*** {
    var define = require('amdefine'***REMOVED***(module, require***REMOVED***;
}
define(function (require, exports, module***REMOVED*** {

  var base64VLQ = require('./base64-vlq'***REMOVED***;
  var util = require('./util'***REMOVED***;
  var ArraySet = require('./array-set'***REMOVED***.ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs***REMOVED*** {
    if (!aArgs***REMOVED*** {
      aArgs = {};
  ***REMOVED***
    this._file = util.getArg(aArgs, 'file', null***REMOVED***;
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null***REMOVED***;
    this._sources = new ArraySet(***REMOVED***;
    this._names = new ArraySet(***REMOVED***;
    this._mappings = [];
    this._sourcesContents = null;
***REMOVED***

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer***REMOVED*** {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
    ***REMOVED******REMOVED***;
      aSourceMapConsumer.eachMapping(function (mapping***REMOVED*** {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
        ***REMOVED***
      ***REMOVED***;

        if (mapping.source***REMOVED*** {
          newMapping.source = mapping.source;
          if (sourceRoot***REMOVED*** {
            newMapping.source = util.relative(sourceRoot, newMapping.source***REMOVED***;
        ***REMOVED***

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
        ***REMOVED***;

          if (mapping.name***REMOVED*** {
            newMapping.name = mapping.name;
        ***REMOVED***
      ***REMOVED***

        generator.addMapping(newMapping***REMOVED***;
    ***REMOVED******REMOVED***;
      aSourceMapConsumer.sources.forEach(function (sourceFile***REMOVED*** {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile***REMOVED***;
        if (content***REMOVED*** {
          generator.setSourceContent(sourceFile, content***REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
      return generator;
  ***REMOVED***;

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot***REMOVED***.
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs***REMOVED*** {
      var generated = util.getArg(aArgs, 'generated'***REMOVED***;
      var original = util.getArg(aArgs, 'original', null***REMOVED***;
      var source = util.getArg(aArgs, 'source', null***REMOVED***;
      var name = util.getArg(aArgs, 'name', null***REMOVED***;

      this._validateMapping(generated, original, source, name***REMOVED***;

      if (source && !this._sources.has(source***REMOVED******REMOVED*** {
        this._sources.add(source***REMOVED***;
    ***REMOVED***

      if (name && !this._names.has(name***REMOVED******REMOVED*** {
        this._names.add(name***REMOVED***;
    ***REMOVED***

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
    ***REMOVED******REMOVED***;
  ***REMOVED***;

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent***REMOVED*** {
      var source = aSourceFile;
      if (this._sourceRoot***REMOVED*** {
        source = util.relative(this._sourceRoot, source***REMOVED***;
    ***REMOVED***

      if (aSourceContent !== null***REMOVED*** {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents***REMOVED*** {
          this._sourcesContents = {};
      ***REMOVED***
        this._sourcesContents[util.toSetString(source***REMOVED***] = aSourceContent;
    ***REMOVED*** else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source***REMOVED***];
        if (Object.keys(this._sourcesContents***REMOVED***.length === 0***REMOVED*** {
          this._sourcesContents = null;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath***REMOVED*** {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile***REMOVED*** {
        if (!aSourceMapConsumer.file***REMOVED*** {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          ***REMOVED***;
      ***REMOVED***
        aSourceFile = aSourceMapConsumer.file;
    ***REMOVED***
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot***REMOVED*** {
        aSourceFile = util.relative(sourceRoot, aSourceFile***REMOVED***;
    ***REMOVED***
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet(***REMOVED***;
      var newNames = new ArraySet(***REMOVED***;

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping***REMOVED*** {
        if (mapping.source === aSourceFile && mapping.originalLine***REMOVED*** {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
        ***REMOVED******REMOVED***;
          if (original.source !== null***REMOVED*** {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath***REMOVED*** {
              mapping.source = util.join(aSourceMapPath, mapping.source***REMOVED***
          ***REMOVED***
            if (sourceRoot***REMOVED*** {
              mapping.source = util.relative(sourceRoot, mapping.source***REMOVED***;
          ***REMOVED***
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null***REMOVED*** {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

        var source = mapping.source;
        if (source && !newSources.has(source***REMOVED******REMOVED*** {
          newSources.add(source***REMOVED***;
      ***REMOVED***

        var name = mapping.name;
        if (name && !newNames.has(name***REMOVED******REMOVED*** {
          newNames.add(name***REMOVED***;
      ***REMOVED***

    ***REMOVED***, this***REMOVED***;
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile***REMOVED*** {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile***REMOVED***;
        if (content***REMOVED*** {
          if (sourceRoot***REMOVED*** {
            sourceFile = util.relative(sourceRoot, sourceFile***REMOVED***;
        ***REMOVED***
          this.setSourceContent(sourceFile, content***REMOVED***;
      ***REMOVED***
    ***REMOVED***, this***REMOVED***;
  ***REMOVED***;

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName***REMOVED*** {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName***REMOVED*** {
        // Case 1.
        return;
    ***REMOVED***
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource***REMOVED*** {
        // Cases 2 and 3.
        return;
    ***REMOVED***
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
      ***REMOVED******REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***;

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings(***REMOVED*** {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators***REMOVED*** will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions***REMOVED***;

      for (var i = 0, len = this._mappings.length; i < len; i++***REMOVED*** {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine***REMOVED*** {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine***REMOVED*** {
            result += ';';
            previousGeneratedLine++;
        ***REMOVED***
      ***REMOVED***
        else {
          if (i > 0***REMOVED*** {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1]***REMOVED******REMOVED*** {
              continue;
          ***REMOVED***
            result += ',';
        ***REMOVED***
      ***REMOVED***

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn***REMOVED***;
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source***REMOVED*** {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source***REMOVED***
                                     - previousSource***REMOVED***;
          previousSource = this._sources.indexOf(mapping.source***REMOVED***;

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine***REMOVED***;
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn***REMOVED***;
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name***REMOVED*** {
            result += base64VLQ.encode(this._names.indexOf(mapping.name***REMOVED***
                                       - previousName***REMOVED***;
            previousName = this._names.indexOf(mapping.name***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      return result;
  ***REMOVED***;

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot***REMOVED*** {
      return aSources.map(function (source***REMOVED*** {
        if (!this._sourcesContents***REMOVED*** {
          return null;
      ***REMOVED***
        if (aSourceRoot***REMOVED*** {
          source = util.relative(aSourceRoot, source***REMOVED***;
      ***REMOVED***
        var key = util.toSetString(source***REMOVED***;
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key***REMOVED***
          ? this._sourcesContents[key]
          : null;
    ***REMOVED***, this***REMOVED***;
  ***REMOVED***;

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON(***REMOVED*** {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(***REMOVED***,
        names: this._names.toArray(***REMOVED***,
        mappings: this._serializeMappings(***REMOVED***
    ***REMOVED***;
      if (this._sourceRoot***REMOVED*** {
        map.sourceRoot = this._sourceRoot;
    ***REMOVED***
      if (this._sourcesContents***REMOVED*** {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot***REMOVED***;
    ***REMOVED***

      return map;
  ***REMOVED***;

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString(***REMOVED*** {
      return JSON.stringify(this***REMOVED***;
  ***REMOVED***;

  exports.SourceMapGenerator = SourceMapGenerator;

}***REMOVED***;
