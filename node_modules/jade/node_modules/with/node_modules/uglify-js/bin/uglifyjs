#! /usr/bin/env node
// -*- js -*-

"use strict";

var UglifyJS = require("../tools/node"***REMOVED***;
var sys = require("util"***REMOVED***;
var optimist = require("optimist"***REMOVED***;
var fs = require("fs"***REMOVED***;
var path = require("path"***REMOVED***;
var async = require("async"***REMOVED***;
var acorn;
var ARGS = optimist
    .usage("$0 input1.js [input2.js ...] [options]\n\
Use a single dash to read input from the standard input.\
\n\n\
NOTE: by default there is no mangling/compression.\n\
Without [options] it will simply parse input files and dump the AST\n\
with whitespace and comments discarded.  To achieve compression and\n\
mangling you need to use `-c` and `-m`.\
"***REMOVED***
    .describe("source-map", "Specify an output file where to generate source map."***REMOVED***
    .describe("source-map-root", "The path to the original source to be included in the source map."***REMOVED***
    .describe("source-map-url", "The path to the source map to be added in //# sourceMappingURL.  Defaults to the value passed with --source-map."***REMOVED***
    .describe("source-map-include-sources", "Pass this flag if you want to include the content of source files in the source map as sourcesContent property."***REMOVED***
    .describe("in-source-map", "Input source map, useful if you're compressing JS that was generated from some other original code."***REMOVED***
    .describe("screw-ie8", "Pass this flag if you don't care about full compliance with Internet Explorer 6-8 quirks (by default UglifyJS will try to be IE-proof***REMOVED***."***REMOVED***
    .describe("expr", "Parse a single expression, rather than a program (for parsing JSON***REMOVED***"***REMOVED***
    .describe("p", "Skip prefix for original filenames that appear in source maps. \
For example -p 3 will drop 3 directories from file names and ensure they are relative paths. \
You can also specify -p relative, which will make UglifyJS figure out itself the relative paths between original sources, \
the source map and the output file."***REMOVED***
    .describe("o", "Output file (default STDOUT***REMOVED***."***REMOVED***
    .describe("b", "Beautify output/specify output options."***REMOVED***
    .describe("m", "Mangle names/pass mangler options."***REMOVED***
    .describe("r", "Reserved names to exclude from mangling."***REMOVED***
    .describe("c", "Enable compressor/pass compressor options. \
Pass options like -c hoist_vars=false,if_return=false. \
Use -c with no argument to use the default compression options."***REMOVED***
    .describe("d", "Global definitions"***REMOVED***
    .describe("e", "Embed everything in a big function, with a configurable parameter/argument list."***REMOVED***

    .describe("comments", "Preserve copyright comments in the output. \
By default this works like Google Closure, keeping JSDoc-style comments that contain \"@license\" or \"@preserve\". \
You can optionally pass one of the following arguments to this flag:\n\
- \"all\" to keep all comments\n\
- a valid JS regexp (needs to start with a slash***REMOVED*** to keep only comments that match.\n\
\
Note that currently not *all* comments can be kept when compression is on, \
because of dead code removal or cascading statements into sequences."***REMOVED***

    .describe("preamble", "Preamble to prepend to the output.  You can use this to insert a \
comment, for example for licensing information.  This will not be \
parsed, but the source map will adjust for its presence."***REMOVED***

    .describe("stats", "Display operations run time on STDERR."***REMOVED***
    .describe("acorn", "Use Acorn for parsing."***REMOVED***
    .describe("spidermonkey", "Assume input files are SpiderMonkey AST format (as JSON***REMOVED***."***REMOVED***
    .describe("self", "Build itself (UglifyJS2***REMOVED*** as a library (implies --wrap=UglifyJS --export-all***REMOVED***"***REMOVED***
    .describe("wrap", "Embed everything in a big function, making the “exports” and “global” variables available. \
You need to pass an argument to this option to specify the name that your module will take when included in, say, a browser."***REMOVED***
    .describe("export-all", "Only used when --wrap, this tells UglifyJS to add code to automatically export all globals."***REMOVED***
    .describe("lint", "Display some scope warnings"***REMOVED***
    .describe("v", "Verbose"***REMOVED***
    .describe("V", "Print version number and exit."***REMOVED***
    .describe("noerr", "Don't throw an error for unknown options in -c, -b or -m."***REMOVED***

    .alias("p", "prefix"***REMOVED***
    .alias("o", "output"***REMOVED***
    .alias("v", "verbose"***REMOVED***
    .alias("b", "beautify"***REMOVED***
    .alias("m", "mangle"***REMOVED***
    .alias("c", "compress"***REMOVED***
    .alias("d", "define"***REMOVED***
    .alias("r", "reserved"***REMOVED***
    .alias("V", "version"***REMOVED***
    .alias("e", "enclose"***REMOVED***

    .string("source-map"***REMOVED***
    .string("source-map-root"***REMOVED***
    .string("source-map-url"***REMOVED***
    .string("b"***REMOVED***
    .string("m"***REMOVED***
    .string("c"***REMOVED***
    .string("d"***REMOVED***
    .string("e"***REMOVED***
    .string("comments"***REMOVED***
    .string("wrap"***REMOVED***
    .string("p"***REMOVED***

    .boolean("expr"***REMOVED***
    .boolean("source-map-include-sources"***REMOVED***
    .boolean("screw-ie8"***REMOVED***
    .boolean("export-all"***REMOVED***
    .boolean("self"***REMOVED***
    .boolean("v"***REMOVED***
    .boolean("stats"***REMOVED***
    .boolean("acorn"***REMOVED***
    .boolean("spidermonkey"***REMOVED***
    .boolean("lint"***REMOVED***
    .boolean("V"***REMOVED***
    .boolean("noerr"***REMOVED***

    .wrap(80***REMOVED***

    .argv
;

normalize(ARGS***REMOVED***;

if (ARGS.noerr***REMOVED*** {
    UglifyJS.DefaultsError.croak = function(msg, defs***REMOVED*** {
        sys.error("WARN: " + msg***REMOVED***;
  ***REMOVED***;
}

if (ARGS.version || ARGS.V***REMOVED*** {
    var json = require("../package.json"***REMOVED***;
    sys.puts(json.name + ' ' + json.version***REMOVED***;
    process.exit(0***REMOVED***;
}

if (ARGS.ast_help***REMOVED*** {
    var desc = UglifyJS.describe_ast(***REMOVED***;
    sys.puts(typeof desc == "string" ? desc : JSON.stringify(desc, null, 2***REMOVED******REMOVED***;
    process.exit(0***REMOVED***;
}

if (ARGS.h || ARGS.help***REMOVED*** {
    sys.puts(optimist.help(***REMOVED******REMOVED***;
    process.exit(0***REMOVED***;
}

if (ARGS.acorn***REMOVED*** {
    acorn = require("acorn"***REMOVED***;
}

var COMPRESS = getOptions("c", true***REMOVED***;
var MANGLE = getOptions("m", true***REMOVED***;
var BEAUTIFY = getOptions("b", true***REMOVED***;

if (ARGS.d***REMOVED*** {
    if (COMPRESS***REMOVED*** COMPRESS.global_defs = getOptions("d"***REMOVED***;
}

if (ARGS.r***REMOVED*** {
    if (MANGLE***REMOVED*** MANGLE.except = ARGS.r.replace(/^\s+|\s+$/g***REMOVED***.split(/\s*,+\s*/***REMOVED***;
}

var OUTPUT_OPTIONS = {
    beautify: BEAUTIFY ? true : false,
    preamble: ARGS.preamble || null,
};

if (ARGS.screw_ie8***REMOVED*** {
    if (COMPRESS***REMOVED*** COMPRESS.screw_ie8 = true;
    if (MANGLE***REMOVED*** MANGLE.screw_ie8 = true;
    OUTPUT_OPTIONS.screw_ie8 = true;
}

if (BEAUTIFY***REMOVED***
    UglifyJS.merge(OUTPUT_OPTIONS, BEAUTIFY***REMOVED***;

if (ARGS.comments***REMOVED*** {
    if (/^\//.test(ARGS.comments***REMOVED******REMOVED*** {
        OUTPUT_OPTIONS.comments = new Function("return(" + ARGS.comments + "***REMOVED***"***REMOVED***(***REMOVED***;
  ***REMOVED*** else if (ARGS.comments == "all"***REMOVED*** {
        OUTPUT_OPTIONS.comments = true;
  ***REMOVED*** else {
        OUTPUT_OPTIONS.comments = function(node, comment***REMOVED*** {
            var text = comment.value;
            var type = comment.type;
            if (type == "comment2"***REMOVED*** {
                // multiline comment
                return /@preserve|@license|@cc_on/i.test(text***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}

var files = ARGS._.slice(***REMOVED***;

if (ARGS.self***REMOVED*** {
    if (files.length > 0***REMOVED*** {
        sys.error("WARN: Ignoring input files since --self was passed"***REMOVED***;
  ***REMOVED***
    files = UglifyJS.FILES;
    if (!ARGS.wrap***REMOVED*** ARGS.wrap = "UglifyJS";
    ARGS.export_all = true;
}

var ORIG_MAP = ARGS.in_source_map;

if (ORIG_MAP***REMOVED*** {
    ORIG_MAP = JSON.parse(fs.readFileSync(ORIG_MAP***REMOVED******REMOVED***;
    if (files.length == 0***REMOVED*** {
        sys.error("INFO: Using file from the input source map: " + ORIG_MAP.file***REMOVED***;
        files = [ ORIG_MAP.file ];
  ***REMOVED***
    if (ARGS.source_map_root == null***REMOVED*** {
        ARGS.source_map_root = ORIG_MAP.sourceRoot;
  ***REMOVED***
}

if (files.length == 0***REMOVED*** {
    files = [ "-" ];
}

if (files.indexOf("-"***REMOVED*** >= 0 && ARGS.source_map***REMOVED*** {
    sys.error("ERROR: Source map doesn't work with input from STDIN"***REMOVED***;
    process.exit(1***REMOVED***;
}

if (files.filter(function(el***REMOVED***{ return el == "-" }***REMOVED***.length > 1***REMOVED*** {
    sys.error("ERROR: Can read a single file from STDIN (two or more dashes specified***REMOVED***"***REMOVED***;
    process.exit(1***REMOVED***;
}

var STATS = {};
var OUTPUT_FILE = ARGS.o;
var TOPLEVEL = null;
var P_RELATIVE = ARGS.p && ARGS.p == "relative";
var SOURCES_CONTENT = {};

var SOURCE_MAP = ARGS.source_map ? UglifyJS.SourceMap({
    file: P_RELATIVE ? path.relative(path.dirname(ARGS.source_map***REMOVED***, OUTPUT_FILE***REMOVED*** : OUTPUT_FILE,
    root: ARGS.source_map_root,
    orig: ORIG_MAP,
}***REMOVED*** : null;

OUTPUT_OPTIONS.source_map = SOURCE_MAP;

try {
    var output = UglifyJS.OutputStream(OUTPUT_OPTIONS***REMOVED***;
    var compressor = COMPRESS && UglifyJS.Compressor(COMPRESS***REMOVED***;
} catch(ex***REMOVED*** {
    if (ex instanceof UglifyJS.DefaultsError***REMOVED*** {
        sys.error(ex.msg***REMOVED***;
        sys.error("Supported options:"***REMOVED***;
        sys.error(sys.inspect(ex.defs***REMOVED******REMOVED***;
        process.exit(1***REMOVED***;
  ***REMOVED***
}

async.eachLimit(files, 1, function (file, cb***REMOVED*** {
    read_whole_file(file, function (err, code***REMOVED*** {
        if (err***REMOVED*** {
            sys.error("ERROR: can't read file: " + file***REMOVED***;
            process.exit(1***REMOVED***;
      ***REMOVED***
        if (ARGS.p != null***REMOVED*** {
            if (P_RELATIVE***REMOVED*** {
                file = path.relative(path.dirname(ARGS.source_map***REMOVED***, file***REMOVED***;
          ***REMOVED*** else {
                var p = parseInt(ARGS.p, 10***REMOVED***;
                if (!isNaN(p***REMOVED******REMOVED*** {
                    file = file.replace(/^\/+/, ""***REMOVED***.split(/\/+/***REMOVED***.slice(ARGS.p***REMOVED***.join("/"***REMOVED***;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        SOURCES_CONTENT[file] = code;
        time_it("parse", function(***REMOVED***{
            if (ARGS.spidermonkey***REMOVED*** {
                var program = JSON.parse(code***REMOVED***;
                if (!TOPLEVEL***REMOVED*** TOPLEVEL = program;
                else TOPLEVEL.body = TOPLEVEL.body.concat(program.body***REMOVED***;
          ***REMOVED***
            else if (ARGS.acorn***REMOVED*** {
                TOPLEVEL = acorn.parse(code, {
                    locations     : true,
                    sourceFile    : file,
                    program       : TOPLEVEL
              ***REMOVED******REMOVED***;
          ***REMOVED***
            else {
                try {
                    TOPLEVEL = UglifyJS.parse(code, {
                        filename   : file,
                        toplevel   : TOPLEVEL,
                        expression : ARGS.expr,
                  ***REMOVED******REMOVED***;
              ***REMOVED*** catch(ex***REMOVED*** {
                    if (ex instanceof UglifyJS.JS_Parse_Error***REMOVED*** {
                        sys.error("Parse error at " + file + ":" + ex.line + "," + ex.col***REMOVED***;
                        sys.error(ex.message***REMOVED***;
                        sys.error(ex.stack***REMOVED***;
                        process.exit(1***REMOVED***;
                  ***REMOVED***
                    throw ex;
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED******REMOVED***;
        cb(***REMOVED***;
  ***REMOVED******REMOVED***;
}, function (***REMOVED*** {
    if (ARGS.acorn || ARGS.spidermonkey***REMOVED*** time_it("convert_ast", function(***REMOVED***{
        TOPLEVEL = UglifyJS.AST_Node.from_mozilla_ast(TOPLEVEL***REMOVED***;
  ***REMOVED******REMOVED***;

    if (ARGS.wrap***REMOVED*** {
        TOPLEVEL = TOPLEVEL.wrap_commonjs(ARGS.wrap, ARGS.export_all***REMOVED***;
  ***REMOVED***

    if (ARGS.enclose***REMOVED*** {
        var arg_parameter_list = ARGS.enclose;
        if (arg_parameter_list === true***REMOVED*** {
            arg_parameter_list = [];
      ***REMOVED***
        else if (!(arg_parameter_list instanceof Array***REMOVED******REMOVED*** {
            arg_parameter_list = [arg_parameter_list];
      ***REMOVED***
        TOPLEVEL = TOPLEVEL.wrap_enclose(arg_parameter_list***REMOVED***;
  ***REMOVED***

    var SCOPE_IS_NEEDED = COMPRESS || MANGLE || ARGS.lint;

    if (SCOPE_IS_NEEDED***REMOVED*** {
        time_it("scope", function(***REMOVED***{
            TOPLEVEL.figure_out_scope({ screw_ie8: ARGS.screw_ie8 }***REMOVED***;
            if (ARGS.lint***REMOVED*** {
                TOPLEVEL.scope_warnings(***REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***

    if (COMPRESS***REMOVED*** {
        time_it("squeeze", function(***REMOVED***{
            TOPLEVEL = TOPLEVEL.transform(compressor***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***

    if (SCOPE_IS_NEEDED***REMOVED*** {
        time_it("scope", function(***REMOVED***{
            TOPLEVEL.figure_out_scope({ screw_ie8: ARGS.screw_ie8 }***REMOVED***;
            if (MANGLE***REMOVED*** {
                TOPLEVEL.compute_char_frequency(MANGLE***REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***

    if (MANGLE***REMOVED*** time_it("mangle", function(***REMOVED***{
        TOPLEVEL.mangle_names(MANGLE***REMOVED***;
  ***REMOVED******REMOVED***;

    if (ARGS.source_map_include_sources***REMOVED*** {
        for (var file in SOURCES_CONTENT***REMOVED*** {
            if (SOURCES_CONTENT.hasOwnProperty(file***REMOVED******REMOVED*** {
                SOURCE_MAP.get(***REMOVED***.setSourceContent(file, SOURCES_CONTENT[file]***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    time_it("generate", function(***REMOVED***{
        TOPLEVEL.print(output***REMOVED***;
  ***REMOVED******REMOVED***;

    output = output.get(***REMOVED***;

    if (SOURCE_MAP***REMOVED*** {
        fs.writeFileSync(ARGS.source_map, SOURCE_MAP, "utf8"***REMOVED***;
        var source_map_url = ARGS.source_map_url || (
            P_RELATIVE
                ? path.relative(path.dirname(OUTPUT_FILE***REMOVED***, ARGS.source_map***REMOVED***
                : ARGS.source_map
        ***REMOVED***;
        output += "\n//# sourceMappingURL=" + source_map_url;
  ***REMOVED***

    if (OUTPUT_FILE***REMOVED*** {
        fs.writeFileSync(OUTPUT_FILE, output, "utf8"***REMOVED***;
  ***REMOVED*** else {
        sys.print(output***REMOVED***;
  ***REMOVED***

    if (ARGS.stats***REMOVED*** {
        sys.error(UglifyJS.string_template("Timing information (compressed {count} files***REMOVED***:", {
            count: files.length
      ***REMOVED******REMOVED******REMOVED***;
        for (var i in STATS***REMOVED*** if (STATS.hasOwnProperty(i***REMOVED******REMOVED*** {
            sys.error(UglifyJS.string_template("- {name}: {time}s", {
                name: i,
                time: (STATS[i] / 1000***REMOVED***.toFixed(3***REMOVED***
          ***REMOVED******REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED***
}***REMOVED***;

/* -----[ functions ]----- */

function normalize(o***REMOVED*** {
    for (var i in o***REMOVED*** if (o.hasOwnProperty(i***REMOVED*** && /-/.test(i***REMOVED******REMOVED*** {
        o[i.replace(/-/g, "_"***REMOVED***] = o[i];
        delete o[i];
  ***REMOVED***
}

function getOptions(x, constants***REMOVED*** {
    x = ARGS[x];
    if (!x***REMOVED*** return null;
    var ret = {};
    if (x !== true***REMOVED*** {
        var ast;
        try {
            ast = UglifyJS.parse(x, { expression: true }***REMOVED***;
      ***REMOVED*** catch(ex***REMOVED*** {
            if (ex instanceof UglifyJS.JS_Parse_Error***REMOVED*** {
                sys.error("Error parsing arguments in: " + x***REMOVED***;
                process.exit(1***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        ast.walk(new UglifyJS.TreeWalker(function(node***REMOVED***{
            if (node instanceof UglifyJS.AST_Seq***REMOVED*** return; // descend
            if (node instanceof UglifyJS.AST_Assign***REMOVED*** {
                var name = node.left.print_to_string({ beautify: false }***REMOVED***.replace(/-/g, "_"***REMOVED***;
                var value = node.right;
                if (constants***REMOVED***
                    value = new Function("return (" + value.print_to_string(***REMOVED*** + "***REMOVED***"***REMOVED***(***REMOVED***;
                ret[name] = value;
                return true;    // no descend
          ***REMOVED***
            if (node instanceof UglifyJS.AST_Symbol || node instanceof UglifyJS.AST_Binary***REMOVED*** {
                var name = node.print_to_string({ beautify: false }***REMOVED***.replace(/-/g, "_"***REMOVED***;
                ret[name] = true;
                return true;    // no descend
          ***REMOVED***
            sys.error(node.TYPE***REMOVED***
            sys.error("Error parsing arguments in: " + x***REMOVED***;
            process.exit(1***REMOVED***;
      ***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***
    return ret;
}

function read_whole_file(filename, cb***REMOVED*** {
    if (filename == "-"***REMOVED*** {
        var chunks = [];
        process.stdin.setEncoding('utf-8'***REMOVED***;
        process.stdin.on('data', function (chunk***REMOVED*** {
            chunks.push(chunk***REMOVED***;
      ***REMOVED******REMOVED***.on('end', function (***REMOVED*** {
            cb(null, chunks.join(""***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
        process.openStdin(***REMOVED***;
  ***REMOVED*** else {
        fs.readFile(filename, "utf-8", cb***REMOVED***;
  ***REMOVED***
}

function time_it(name, cont***REMOVED*** {
    var t1 = new Date(***REMOVED***.getTime(***REMOVED***;
    var ret = cont(***REMOVED***;
    if (ARGS.stats***REMOVED*** {
        var spent = new Date(***REMOVED***.getTime(***REMOVED*** - t1;
        if (STATS[name]***REMOVED*** STATS[name] += spent;
        else STATS[name] = spent;
  ***REMOVED***
    return ret;
}
