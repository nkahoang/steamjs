var Stream = require('stream'***REMOVED***;

function createStreamAPI (***REMOVED*** {
  var stream
    , processEntry
    , done
    , handleError
    , handleFatalError
    , paused = true
    , controlled = false
    , buffer = []
    , closed = false
    ;

  stream = new Stream(***REMOVED***;
  stream.writable = false;
  stream.readable = true;

  stream.pause = function (***REMOVED*** {
    controlled = true;
    paused = true;
***REMOVED***;

  stream.resume = function (***REMOVED*** {
    controlled = true;
    paused = false;
    
    // emit all buffered entries, errors and ends
    while (!paused && buffer.length***REMOVED*** {
      var msg = buffer.shift(***REMOVED***;
      this.emit(msg.type, msg.data***REMOVED***;
  ***REMOVED***
***REMOVED***;

  stream.destroy = function (***REMOVED*** {
    closed = true;
    stream.readable = false;
    stream.emit('close'***REMOVED***;
***REMOVED***;

  // called for each entry
  processEntry = function (entry***REMOVED*** {
    if (closed***REMOVED*** return;
    return paused ? buffer.push({ type: 'data', data: entry }***REMOVED*** : stream.emit('data', entry***REMOVED***;
***REMOVED***;

  // called with all found entries when directory walk finished
  done = function (err, entries***REMOVED*** {
    if (closed***REMOVED*** return;
    
    // since we already emitted each entry and all non fatal errors
    // all we need to do here is to signal that we are done
    stream.emit('end'***REMOVED***;
***REMOVED***;

  handleError = function (err***REMOVED*** {
    if (closed***REMOVED*** return;
    return paused ? buffer.push({ type: 'warn', data: err }***REMOVED*** : stream.emit('warn', err***REMOVED***;
***REMOVED***;

  handleFatalError = function (err***REMOVED*** {
    if (closed***REMOVED*** return;
    return paused ? buffer.push({ type: 'error', data: err }***REMOVED*** : stream.emit('error', err***REMOVED***;
***REMOVED***;

  // Allow stream to be returned and handlers to be attached and/or stream to be piped before emitting messages
  // Otherwise we may loose data/errors that are emitted immediately
  process.nextTick(function (***REMOVED*** { 
    if (closed***REMOVED*** return;
    
    // In case was controlled (paused/resumed***REMOVED*** manually, we don't interfer
    // see https://github.com/thlorenz/readdirp/commit/ab7ff8561d73fca82c2ce7eb4ce9f7f5caf48b55#commitcomment-1964530
    if (controlled***REMOVED*** return;
    stream.resume(***REMOVED***; 
***REMOVED******REMOVED***;

  return { 
      stream           :  stream
    , processEntry     :  processEntry
    , done             :  done
    , handleError      :  handleError
    , handleFatalError :  handleFatalError
***REMOVED***;
}

module.exports = createStreamAPI;
