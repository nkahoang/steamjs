;(function (require, exports, module, platform***REMOVED*** {

if (module***REMOVED*** module.exports = minimatch
else exports.minimatch = minimatch

if (!require***REMOVED*** {
  require = function (id***REMOVED*** {
    switch (id***REMOVED*** {
      case "sigmund": return function sigmund (obj***REMOVED*** {
        return JSON.stringify(obj***REMOVED***
    ***REMOVED***
      case "path": return { basename: function (f***REMOVED*** {
        f = f.split(/[\/\\]/***REMOVED***
        var e = f.pop(***REMOVED***
        if (!e***REMOVED*** e = f.pop(***REMOVED***
        return e
    ***REMOVED***}
      case "lru-cache": return function LRUCache (***REMOVED*** {
        // not quite an LRU, but still space-limited.
        var cache = {}
        var cnt = 0
        this.set = function (k, v***REMOVED*** {
          cnt ++
          if (cnt >= 100***REMOVED*** cache = {}
          cache[k] = v
      ***REMOVED***
        this.get = function (k***REMOVED*** { return cache[k] }
    ***REMOVED***
  ***REMOVED***
***REMOVED***
}

minimatch.Minimatch = Minimatch

var LRU = require("lru-cache"***REMOVED***
  , cache = minimatch.cache = new LRU({max: 100}***REMOVED***
  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
  , sigmund = require("sigmund"***REMOVED***

var path = require("path"***REMOVED***
  // any single thing other than /
  // don't need to escape / when using new RegExp(***REMOVED***
  , qmark = "[^/]"

  // * => any number of characters
  , star = qmark + "*?"

  // ** when dots are allowed.  Anything goes, except .. and .
  // not (^ or / followed by one or two dots followed by $ or /***REMOVED***,
  // followed by anything, any number of times.
  , twoStarDot = "(?:(?!(?:\\\/|^***REMOVED***(?:\\.{1,2}***REMOVED***($|\\\/***REMOVED******REMOVED***.***REMOVED****?"

  // not a ^ or / followed by a dot,
  // followed by anything, any number of times.
  , twoStarNoDot = "(?:(?!(?:\\\/|^***REMOVED***\\.***REMOVED***.***REMOVED****?"

  // characters that need to be escaped in RegExp.
  , reSpecials = charSet("(***REMOVED***.*{}+?[]^$\\!"***REMOVED***

// "abc" -> { a:true, b:true, c:true }
function charSet (s***REMOVED*** {
  return s.split(""***REMOVED***.reduce(function (set, c***REMOVED*** {
    set[c] = true
    return set
***REMOVED***, {}***REMOVED***
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options***REMOVED*** {
  options = options || {}
  return function (p, i, list***REMOVED*** {
    return minimatch(p, pattern, options***REMOVED***
***REMOVED***
}

function ext (a, b***REMOVED*** {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b***REMOVED***.forEach(function (k***REMOVED*** {
    t[k] = b[k]
***REMOVED******REMOVED***
  Object.keys(a***REMOVED***.forEach(function (k***REMOVED*** {
    t[k] = a[k]
***REMOVED******REMOVED***
  return t
}

minimatch.defaults = function (def***REMOVED*** {
  if (!def || !Object.keys(def***REMOVED***.length***REMOVED*** return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options***REMOVED*** {
    return orig.minimatch(p, pattern, ext(def, options***REMOVED******REMOVED***
***REMOVED***

  m.Minimatch = function Minimatch (pattern, options***REMOVED*** {
    return new orig.Minimatch(pattern, ext(def, options***REMOVED******REMOVED***
***REMOVED***

  return m
}

Minimatch.defaults = function (def***REMOVED*** {
  if (!def || !Object.keys(def***REMOVED***.length***REMOVED*** return Minimatch
  return minimatch.defaults(def***REMOVED***.Minimatch
}


function minimatch (p, pattern, options***REMOVED*** {
  if (typeof pattern !== "string"***REMOVED*** {
    throw new TypeError("glob pattern string required"***REMOVED***
***REMOVED***

  if (!options***REMOVED*** options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0***REMOVED*** === "#"***REMOVED*** {
    return false
***REMOVED***

  // "" only matches ""
  if (pattern.trim(***REMOVED*** === ""***REMOVED*** return p === ""

  return new Minimatch(pattern, options***REMOVED***.match(p***REMOVED***
}

function Minimatch (pattern, options***REMOVED*** {
  if (!(this instanceof Minimatch***REMOVED******REMOVED*** {
    return new Minimatch(pattern, options, cache***REMOVED***
***REMOVED***

  if (typeof pattern !== "string"***REMOVED*** {
    throw new TypeError("glob pattern string required"***REMOVED***
***REMOVED***

  if (!options***REMOVED*** options = {}
  pattern = pattern.trim(***REMOVED***

  // windows: need to use /, not \
  // On other platforms, \ is a valid (albeit bad***REMOVED*** filename char.
  if (platform === "win32"***REMOVED*** {
    pattern = pattern.split("\\"***REMOVED***.join("/"***REMOVED***
***REMOVED***

  // lru storage.
  // these things aren't particularly big, but walking down the string
  // and turning it into a regexp can get pretty costly.
  var cacheKey = pattern + "\n" + sigmund(options***REMOVED***
  var cached = minimatch.cache.get(cacheKey***REMOVED***
  if (cached***REMOVED*** return cached
  minimatch.cache.set(cacheKey, this***REMOVED***

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make(***REMOVED***
}

Minimatch.prototype.debug = function(***REMOVED*** {}

Minimatch.prototype.make = make
function make (***REMOVED*** {
  // don't do it more than once.
  if (this._made***REMOVED*** return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0***REMOVED*** === "#"***REMOVED*** {
    this.comment = true
    return
***REMOVED***
  if (!pattern***REMOVED*** {
    this.empty = true
    return
***REMOVED***

  // step 1: figure out negation, etc.
  this.parseNegate(***REMOVED***

  // step 2: expand braces
  var set = this.globSet = this.braceExpand(***REMOVED***

  if (options.debug***REMOVED*** this.debug = console.error

  this.debug(this.pattern, set***REMOVED***

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s***REMOVED*** {
    return s.split(slashSplit***REMOVED***
***REMOVED******REMOVED***

  this.debug(this.pattern, set***REMOVED***

  // glob --> regexps
  set = set.map(function (s, si, set***REMOVED*** {
    return s.map(this.parse, this***REMOVED***
***REMOVED***, this***REMOVED***

  this.debug(this.pattern, set***REMOVED***

  // filter out everything that didn't compile properly.
  set = set.filter(function (s***REMOVED*** {
    return -1 === s.indexOf(false***REMOVED***
***REMOVED******REMOVED***

  this.debug(this.pattern, set***REMOVED***

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate (***REMOVED*** {
  var pattern = this.pattern
    , negate = false
    , options = this.options
    , negateOffset = 0

  if (options.nonegate***REMOVED*** return

  for ( var i = 0, l = pattern.length
      ; i < l && pattern.charAt(i***REMOVED*** === "!"
      ; i ++***REMOVED*** {
    negate = !negate
    negateOffset ++
***REMOVED***

  if (negateOffset***REMOVED*** this.pattern = pattern.substr(negateOffset***REMOVED***
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options***REMOVED*** {
  return new Minimatch(pattern, options***REMOVED***.braceExpand(***REMOVED***
}

Minimatch.prototype.braceExpand = braceExpand
function braceExpand (pattern, options***REMOVED*** {
  options = options || this.options
  pattern = typeof pattern === "undefined"
    ? this.pattern : pattern

  if (typeof pattern === "undefined"***REMOVED*** {
    throw new Error("undefined pattern"***REMOVED***
***REMOVED***

  if (options.nobrace ||
      !pattern.match(/\{.*\}/***REMOVED******REMOVED*** {
    // shortcut. no need to expand.
    return [pattern]
***REMOVED***

  var escaping = false

  // examples and comments refer to this crazy pattern:
  // a{b,c{d,e},{f,g}h}x{y,z}
  // expected:
  // abxy
  // abxz
  // acdxy
  // acdxz
  // acexy
  // acexz
  // afhxy
  // afhxz
  // aghxy
  // aghxz

  // everything before the first \{ is just a prefix.
  // So, we pluck that off, and work with the rest,
  // and then prepend it to everything we find.
  if (pattern.charAt(0***REMOVED*** !== "{"***REMOVED*** {
    this.debug(pattern***REMOVED***
    var prefix = null
    for (var i = 0, l = pattern.length; i < l; i ++***REMOVED*** {
      var c = pattern.charAt(i***REMOVED***
      this.debug(i, c***REMOVED***
      if (c === "\\"***REMOVED*** {
        escaping = !escaping
    ***REMOVED*** else if (c === "{" && !escaping***REMOVED*** {
        prefix = pattern.substr(0, i***REMOVED***
        break
    ***REMOVED***
  ***REMOVED***

    // actually no sets, all { were escaped.
    if (prefix === null***REMOVED*** {
      this.debug("no sets"***REMOVED***
      return [pattern]
  ***REMOVED***

   var tail = braceExpand.call(this, pattern.substr(i***REMOVED***, options***REMOVED***
    return tail.map(function (t***REMOVED*** {
      return prefix + t
  ***REMOVED******REMOVED***
***REMOVED***

  // now we have something like:
  // {b,c{d,e},{f,g}h}x{y,z}
  // walk through the set, expanding each part, until
  // the set ends.  then, we'll expand the suffix.
  // If the set only has a single member, then'll put the {} back

  // first, handle numeric sets, since they're easier
  var numset = pattern.match(/^\{(-?[0-9]+***REMOVED***\.\.(-?[0-9]+***REMOVED***\}/***REMOVED***
  if (numset***REMOVED*** {
    this.debug("numset", numset[1], numset[2]***REMOVED***
    var suf = braceExpand.call(this, pattern.substr(numset[0].length***REMOVED***, options***REMOVED***
      , start = +numset[1]
      , end = +numset[2]
      , inc = start > end ? -1 : 1
      , set = []
    for (var i = start; i != (end + inc***REMOVED***; i += inc***REMOVED*** {
      // append all the suffixes
      for (var ii = 0, ll = suf.length; ii < ll; ii ++***REMOVED*** {
        set.push(i + suf[ii]***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return set
***REMOVED***

  // ok, walk through the set
  // We hope, somewhat optimistically, that there
  // will be a } at the end.
  // If the closing brace isn't found, then the pattern is
  // interpreted as braceExpand("\\" + pattern***REMOVED*** so that
  // the leading \{ will be interpreted literally.
  var i = 1 // skip the \{
    , depth = 1
    , set = []
    , member = ""
    , sawEnd = false
    , escaping = false

  function addMember (***REMOVED*** {
    set.push(member***REMOVED***
    member = ""
***REMOVED***

  this.debug("Entering for"***REMOVED***
  FOR: for (i = 1, l = pattern.length; i < l; i ++***REMOVED*** {
    var c = pattern.charAt(i***REMOVED***
    this.debug("", i, c***REMOVED***

    if (escaping***REMOVED*** {
      escaping = false
      member += "\\" + c
  ***REMOVED*** else {
      switch (c***REMOVED*** {
        case "\\":
          escaping = true
          continue

        case "{":
          depth ++
          member += "{"
          continue

        case "}":
          depth --
          // if this closes the actual set, then we're done
          if (depth === 0***REMOVED*** {
            addMember(***REMOVED***
            // pluck off the close-brace
            i ++
            break FOR
        ***REMOVED*** else {
            member += c
            continue
        ***REMOVED***

        case ",":
          if (depth === 1***REMOVED*** {
            addMember(***REMOVED***
        ***REMOVED*** else {
            member += c
        ***REMOVED***
          continue

        default:
          member += c
          continue
    ***REMOVED*** // switch
  ***REMOVED*** // else
***REMOVED*** // for

  // now we've either finished the set, and the suffix is
  // pattern.substr(i***REMOVED***, or we have *not* closed the set,
  // and need to escape the leading brace
  if (depth !== 0***REMOVED*** {
    this.debug("didn't close", pattern***REMOVED***
    return braceExpand.call(this, "\\" + pattern, options***REMOVED***
***REMOVED***

  // x{y,z} -> ["xy", "xz"]
  this.debug("set", set***REMOVED***
  this.debug("suffix", pattern.substr(i***REMOVED******REMOVED***
  var suf = braceExpand.call(this, pattern.substr(i***REMOVED***, options***REMOVED***
  // ["b", "c{d,e}","{f,g}h"] ->
  //   [["b"], ["cd", "ce"], ["fh", "gh"]]
  var addBraces = set.length === 1
  this.debug("set pre-expanded", set***REMOVED***
  set = set.map(function (p***REMOVED*** {
    return braceExpand.call(this, p, options***REMOVED***
***REMOVED***, this***REMOVED***
  this.debug("set expanded", set***REMOVED***


  // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
  //   ["b", "cd", "ce", "fh", "gh"]
  set = set.reduce(function (l, r***REMOVED*** {
    return l.concat(r***REMOVED***
***REMOVED******REMOVED***

  if (addBraces***REMOVED*** {
    set = set.map(function (s***REMOVED*** {
      return "{" + s + "}"
  ***REMOVED******REMOVED***
***REMOVED***

  // now attach the suffixes.
  var ret = []
  for (var i = 0, l = set.length; i < l; i ++***REMOVED*** {
    for (var ii = 0, ll = suf.length; ii < ll; ii ++***REMOVED*** {
      ret.push(set[i] + suf[ii]***REMOVED***
  ***REMOVED***
***REMOVED***
  return ret
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub***REMOVED*** {
  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === "**"***REMOVED*** return GLOBSTAR
  if (pattern === ""***REMOVED*** return ""

  var re = ""
    , hasMagic = !!options.nocase
    , escaping = false
    // ? => one single character
    , patternListStack = []
    , plType
    , stateChar
    , inClass = false
    , reClassStart = -1
    , classStart = -1
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    , patternStart = pattern.charAt(0***REMOVED*** === "." ? "" // anything
      // not (start or / followed by . or .. followed by / or end***REMOVED***
      : options.dot ? "(?!(?:^|\\\/***REMOVED***\\.{1,2}(?:$|\\\/***REMOVED******REMOVED***"
      : "(?!\\.***REMOVED***"
    , self = this

  function clearStateChar (***REMOVED*** {
    if (stateChar***REMOVED*** {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar***REMOVED*** {
        case "*":
          re += star
          hasMagic = true
          break
        case "?":
          re += qmark
          hasMagic = true
          break
        default:
          re += "\\"+stateChar
          break
    ***REMOVED***
      self.debug('clearStateChar %j %j', stateChar, re***REMOVED***
      stateChar = false
  ***REMOVED***
***REMOVED***

  for ( var i = 0, len = pattern.length, c
      ; (i < len***REMOVED*** && (c = pattern.charAt(i***REMOVED******REMOVED***
      ; i ++ ***REMOVED*** {

    this.debug("%s\t%s %s %j", pattern, i, re, c***REMOVED***

    // skip over any that are escaped.
    if (escaping && reSpecials[c]***REMOVED*** {
      re += "\\" + c
      escaping = false
      continue
  ***REMOVED***

    SWITCH: switch (c***REMOVED*** {
      case "/":
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case "\\":
        clearStateChar(***REMOVED***
        escaping = true
        continue

      // the various stateChar values
      // for the "extglob" stuff.
      case "?":
      case "*":
      case "+":
      case "@":
      case "!":
        this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c***REMOVED***

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass***REMOVED*** {
          this.debug('  in class'***REMOVED***
          if (c === "!" && i === classStart + 1***REMOVED*** c = "^"
          re += c
          continue
      ***REMOVED***

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar***REMOVED***
        clearStateChar(***REMOVED***
        stateChar = c
        // if extglob is disabled, then +(asdf|foo***REMOVED*** isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext***REMOVED*** clearStateChar(***REMOVED***
        continue

      case "(":
        if (inClass***REMOVED*** {
          re += "("
          continue
      ***REMOVED***

        if (!stateChar***REMOVED*** {
          re += "\\("
          continue
      ***REMOVED***

        plType = stateChar
        patternListStack.push({ type: plType
                              , start: i - 1
                              , reStart: re.length }***REMOVED***
        // negation is (?:(?!js***REMOVED***[^/]****REMOVED***
        re += stateChar === "!" ? "(?:(?!" : "(?:"
        this.debug('plType %j %j', stateChar, re***REMOVED***
        stateChar = false
        continue

      case "***REMOVED***":
        if (inClass || !patternListStack.length***REMOVED*** {
          re += "\\***REMOVED***"
          continue
      ***REMOVED***

        clearStateChar(***REMOVED***
        hasMagic = true
        re += "***REMOVED***"
        plType = patternListStack.pop(***REMOVED***.type
        // negation is (?:(?!js***REMOVED***[^/]****REMOVED***
        // The others are (?:<pattern>***REMOVED***<type>
        switch (plType***REMOVED*** {
          case "!":
            re += "[^/]*?***REMOVED***"
            break
          case "?":
          case "+":
          case "*": re += plType
          case "@": break // the default anyway
      ***REMOVED***
        continue

      case "|":
        if (inClass || !patternListStack.length || escaping***REMOVED*** {
          re += "\\|"
          escaping = false
          continue
      ***REMOVED***

        clearStateChar(***REMOVED***
        re += "|"
        continue

      // these are mostly the same in regexp and glob
      case "[":
        // swallow any state-tracking char before the [
        clearStateChar(***REMOVED***

        if (inClass***REMOVED*** {
          re += "\\" + c
          continue
      ***REMOVED***

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
        continue

      case "]":
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass***REMOVED*** {
          re += "\\" + c
          escaping = false
          continue
      ***REMOVED***

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
        continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar(***REMOVED***

        if (escaping***REMOVED*** {
          // no need
          escaping = false
      ***REMOVED*** else if (reSpecials[c]
                   && !(c === "^" && inClass***REMOVED******REMOVED*** {
          re += "\\"
      ***REMOVED***

        re += c

  ***REMOVED*** // switch
***REMOVED*** // for


  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass***REMOVED*** {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    var cs = pattern.substr(classStart + 1***REMOVED***
      , sp = this.parse(cs, SUBPARSE***REMOVED***
    re = re.substr(0, reClassStart***REMOVED*** + "\\[" + sp[0]
    hasMagic = hasMagic || sp[1]
***REMOVED***

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  var pl
  while (pl = patternListStack.pop(***REMOVED******REMOVED*** {
    var tail = re.slice(pl.reStart + 3***REMOVED***
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}***REMOVED*******REMOVED***(\\?***REMOVED***\|/g, function (_, $1, $2***REMOVED*** {
      if (!$2***REMOVED*** {
        // the | isn't already escaped, so escape it.
        $2 = "\\"
    ***REMOVED***

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + "|"
  ***REMOVED******REMOVED***

    this.debug("tail=%j\n   %s", tail, tail***REMOVED***
    var t = pl.type === "*" ? star
          : pl.type === "?" ? qmark
          : "\\" + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart***REMOVED***
       + t + "\\("
       + tail
***REMOVED***

  // handle trailing things that only matter at the very end.
  clearStateChar(***REMOVED***
  if (escaping***REMOVED*** {
    // trailing \\
    re += "\\\\"
***REMOVED***

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0***REMOVED******REMOVED*** {
    case ".":
    case "[":
    case "(": addPatternStart = true
***REMOVED***

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== "" && hasMagic***REMOVED*** re = "(?=.***REMOVED***" + re

  if (addPatternStart***REMOVED*** re = patternStart + re

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE***REMOVED*** {
    return [ re, hasMagic ]
***REMOVED***

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic***REMOVED*** {
    return globUnescape(pattern***REMOVED***
***REMOVED***

  var flags = options.nocase ? "i" : ""
    , regExp = new RegExp("^" + re + "$", flags***REMOVED***

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options***REMOVED*** {
  return new Minimatch(pattern, options || {}***REMOVED***.makeRe(***REMOVED***
}

Minimatch.prototype.makeRe = makeRe
function makeRe (***REMOVED*** {
  if (this.regexp || this.regexp === false***REMOVED*** return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match(***REMOVED***.  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length***REMOVED*** return this.regexp = false
  var options = this.options

  var twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    , flags = options.nocase ? "i" : ""

  var re = set.map(function (pattern***REMOVED*** {
    return pattern.map(function (p***REMOVED*** {
      return (p === GLOBSTAR***REMOVED*** ? twoStar
           : (typeof p === "string"***REMOVED*** ? regExpEscape(p***REMOVED***
           : p._src
  ***REMOVED******REMOVED***.join("\\\/"***REMOVED***
***REMOVED******REMOVED***.join("|"***REMOVED***

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = "^(?:" + re + "***REMOVED***$"

  // can match anything, as long as it's not this.
  if (this.negate***REMOVED*** re = "^(?!" + re + "***REMOVED***.*$"

  try {
    return this.regexp = new RegExp(re, flags***REMOVED***
***REMOVED*** catch (ex***REMOVED*** {
    return this.regexp = false
***REMOVED***
}

minimatch.match = function (list, pattern, options***REMOVED*** {
  var mm = new Minimatch(pattern, options***REMOVED***
  list = list.filter(function (f***REMOVED*** {
    return mm.match(f***REMOVED***
***REMOVED******REMOVED***
  if (options.nonull && !list.length***REMOVED*** {
    list.push(pattern***REMOVED***
***REMOVED***
  return list
}

Minimatch.prototype.match = match
function match (f, partial***REMOVED*** {
  this.debug("match", f, this.pattern***REMOVED***
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment***REMOVED*** return false
  if (this.empty***REMOVED*** return f === ""

  if (f === "/" && partial***REMOVED*** return true

  var options = this.options

  // windows: need to use /, not \
  // On other platforms, \ is a valid (albeit bad***REMOVED*** filename char.
  if (platform === "win32"***REMOVED*** {
    f = f.split("\\"***REMOVED***.join("/"***REMOVED***
***REMOVED***

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit***REMOVED***
  this.debug(this.pattern, "split", f***REMOVED***

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, "set", set***REMOVED***

  var splitFile = path.basename(f.join("/"***REMOVED******REMOVED***.split("/"***REMOVED***

  for (var i = 0, l = set.length; i < l; i ++***REMOVED*** {
    var pattern = set[i], file = f
    if (options.matchBase && pattern.length === 1***REMOVED*** {
      file = splitFile
  ***REMOVED***
    var hit = this.matchOne(file, pattern, partial***REMOVED***
    if (hit***REMOVED*** {
      if (options.flipNegate***REMOVED*** return true
      return !this.negate
  ***REMOVED***
***REMOVED***

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate***REMOVED*** return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial***REMOVED*** {
  var options = this.options

  this.debug("matchOne",
              { "this": this
              , file: file
              , pattern: pattern }***REMOVED***

  this.debug("matchOne", file.length, pattern.length***REMOVED***

  for ( var fi = 0
          , pi = 0
          , fl = file.length
          , pl = pattern.length
      ; (fi < fl***REMOVED*** && (pi < pl***REMOVED***
      ; fi ++, pi ++ ***REMOVED*** {

    this.debug("matchOne loop"***REMOVED***
    var p = pattern[pi]
      , f = file[fi]

    this.debug(pattern, p, f***REMOVED***

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false***REMOVED*** return false

    if (p === GLOBSTAR***REMOVED*** {
      this.debug('GLOBSTAR', [pattern, p, f]***REMOVED***

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c***REMOVED***
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c***REMOVED*** -> no
      //       - matchOne(y/z/c, c***REMOVED*** -> no
      //       - matchOne(z/c, c***REMOVED*** -> no
      //       - matchOne(c, c***REMOVED*** yes, hit
      var fr = fi
        , pr = pi + 1
      if (pr === pl***REMOVED*** {
        this.debug('** at the end'***REMOVED***
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for ( ; fi < fl; fi ++***REMOVED*** {
          if (file[fi] === "." || file[fi] === ".." ||
              (!options.dot && file[fi].charAt(0***REMOVED*** === "."***REMOVED******REMOVED*** return false
      ***REMOVED***
        return true
    ***REMOVED***

      // ok, let's see if we can swallow whatever we can.
      WHILE: while (fr < fl***REMOVED*** {
        var swallowee = file[fr]

        this.debug('\nglobstar while',
                    file, fr, pattern, pr, swallowee***REMOVED***

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr***REMOVED***, pattern.slice(pr***REMOVED***, partial***REMOVED******REMOVED*** {
          this.debug('globstar found match!', fr, fl, swallowee***REMOVED***
          // found a match.
          return true
      ***REMOVED*** else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === "." || swallowee === ".." ||
              (!options.dot && swallowee.charAt(0***REMOVED*** === "."***REMOVED******REMOVED*** {
            this.debug("dot detected!", file, fr, pattern, pr***REMOVED***
            break WHILE
        ***REMOVED***

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue'***REMOVED***
          fr ++
      ***REMOVED***
    ***REMOVED***
      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then 
      if (partial***REMOVED*** {
        // ran out of file
        this.debug("\n>>> no match, partial?", file, fr, pattern, pr***REMOVED***
        if (fr === fl***REMOVED*** return true
    ***REMOVED***
      return false
  ***REMOVED***

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === "string"***REMOVED*** {
      if (options.nocase***REMOVED*** {
        hit = f.toLowerCase(***REMOVED*** === p.toLowerCase(***REMOVED***
    ***REMOVED*** else {
        hit = f === p
    ***REMOVED***
      this.debug("string match", p, f, hit***REMOVED***
  ***REMOVED*** else {
      hit = f.match(p***REMOVED***
      this.debug("pattern match", p, f, hit***REMOVED***
  ***REMOVED***

    if (!hit***REMOVED*** return false
***REMOVED***

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl***REMOVED*** {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
***REMOVED*** else if (fi === fl***REMOVED*** {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
***REMOVED*** else if (pi === pl***REMOVED*** {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1***REMOVED*** && (file[fi] === ""***REMOVED***
    return emptyFileEnd
***REMOVED***

  // should be unreachable.
  throw new Error("wtf?"***REMOVED***
}


// replace stuff like \* with *
function globUnescape (s***REMOVED*** {
  return s.replace(/\\(.***REMOVED***/g, "$1"***REMOVED***
}


function regExpEscape (s***REMOVED*** {
  return s.replace(/[-[\]{}(***REMOVED****+?.,\\^$|#\s]/g, "\\$&"***REMOVED***
}

}***REMOVED***( typeof require === "function" ? require : null,
    this,
    typeof module === "object" ? module : null,
    typeof process === "object" ? process.platform : "win32"
  ***REMOVED***
