/*jshint asi:true */

var test      =  require('tap'***REMOVED***.test
  , path      =  require('path'***REMOVED***
  , fs        =  require('fs'***REMOVED***
  , util      =  require('util'***REMOVED***
  , Stream    =  require('stream'***REMOVED***
  , through   =  require('through'***REMOVED***
  , streamapi =  require('../stream-api'***REMOVED***
  , readdirp  =  require('..'***REMOVED***
  , root       =  path.join(__dirname, 'bed'***REMOVED***
  , totalDirs  =  6
  , totalFiles =  12
  , ext1Files  =  4
  , ext2Files  =  3
  , ext3Files  =  2
  ;
  
// see test/readdirp.js for test bed layout

function opts (extend***REMOVED*** {
  var o = { root: root };

  if (extend***REMOVED*** {
    for (var prop in extend***REMOVED*** {
      o[prop] = extend[prop];
  ***REMOVED***
***REMOVED***
  return o;
}

function capture (***REMOVED*** {
  var result = { entries: [], errors: [], ended: false }
    , dst = new Stream(***REMOVED***;

  dst.writable = true;
  dst.readable = true;

  dst.write = function (entry***REMOVED*** {
    result.entries.push(entry***REMOVED***;
***REMOVED***

  dst.end = function (***REMOVED*** {
    result.ended = true;
    dst.emit('data', result***REMOVED***;
    dst.emit('end'***REMOVED***;
***REMOVED***

  return dst;
}

test('\nintegrated', function (t***REMOVED*** {
  t.test('\n# reading root without filter', function (t***REMOVED*** {
    t.plan(2***REMOVED***;
    readdirp(opts(***REMOVED******REMOVED***
      .on('error', function (err***REMOVED*** {
        t.fail('should not throw error', err***REMOVED***;
    ***REMOVED******REMOVED***
      .pipe(capture(***REMOVED******REMOVED***
      .pipe(through(
        function (result***REMOVED*** { 
          t.equals(result.entries.length, totalFiles, 'emits all files'***REMOVED***;
          t.ok(result.ended, 'ends stream'***REMOVED***;
          t.end(***REMOVED***;
      ***REMOVED***
      ***REMOVED******REMOVED***;
***REMOVED******REMOVED***

  t.test('\n# normal: ["*.ext1", "*.ext3"]', function (t***REMOVED*** {
    t.plan(2***REMOVED***;

    readdirp(opts( { fileFilter: [ '*.ext1', '*.ext3' ] } ***REMOVED******REMOVED***
      .on('error', function (err***REMOVED*** {
        t.fail('should not throw error', err***REMOVED***;
    ***REMOVED******REMOVED***
      .pipe(capture(***REMOVED******REMOVED***
      .pipe(through(
        function (result***REMOVED*** { 
          t.equals(result.entries.length, ext1Files + ext3Files, 'all ext1 and ext3 files'***REMOVED***;
          t.ok(result.ended, 'ends stream'***REMOVED***;
          t.end(***REMOVED***;
      ***REMOVED***
      ***REMOVED******REMOVED***
***REMOVED******REMOVED***

  t.test('\n# negated: ["!*.ext1", "!*.ext3"]', function (t***REMOVED*** {
    t.plan(2***REMOVED***;

    readdirp(opts( { fileFilter: [ '!*.ext1', '!*.ext3' ] } ***REMOVED******REMOVED***
      .on('error', function (err***REMOVED*** {
        t.fail('should not throw error', err***REMOVED***;
    ***REMOVED******REMOVED***
      .pipe(capture(***REMOVED******REMOVED***
      .pipe(through(
        function (result***REMOVED*** { 
          t.equals(result.entries.length, totalFiles - ext1Files - ext3Files, 'all but ext1 and ext3 files'***REMOVED***;
          t.ok(result.ended, 'ends stream'***REMOVED***;
          t.end(***REMOVED***;
      ***REMOVED***
      ***REMOVED******REMOVED***
***REMOVED******REMOVED***

  t.test('\n# no options given', function (t***REMOVED*** {
    t.plan(1***REMOVED***;
    readdirp(***REMOVED***
      .on('error', function (err***REMOVED*** {
        t.similar(err.toString(***REMOVED*** , /Need to pass at least one argument/ , 'emits meaningful error'***REMOVED***;
        t.end(***REMOVED***;
    ***REMOVED******REMOVED***
***REMOVED******REMOVED***

  t.test('\n# mixed: ["*.ext1", "!*.ext3"]', function (t***REMOVED*** {
    t.plan(1***REMOVED***;

    readdirp(opts( { fileFilter: [ '*.ext1', '!*.ext3' ] } ***REMOVED******REMOVED***
      .on('error', function (err***REMOVED*** {
        t.similar(err.toString(***REMOVED*** , /Cannot mix negated with non negated glob filters/ , 'emits meaningful error'***REMOVED***;
        t.end(***REMOVED***;
    ***REMOVED******REMOVED***
***REMOVED******REMOVED***
}***REMOVED***


test('\napi separately', function (t***REMOVED*** {

  t.test('\n# handleError', function (t***REMOVED*** {
    t.plan(1***REMOVED***;

    var api = streamapi(***REMOVED***
      , warning = new Error('some file caused problems'***REMOVED***;

    api.stream
      .on('warn', function (err***REMOVED*** {
        t.equals(err, warning, 'warns with the handled error'***REMOVED***;
    ***REMOVED******REMOVED***
    api.handleError(warning***REMOVED***;
***REMOVED******REMOVED***

  t.test('\n# when stream is paused and then resumed', function (t***REMOVED*** {
    t.plan(6***REMOVED***;
    var api = streamapi(***REMOVED***
      , resumed = false
      , fatalError = new Error('fatal!'***REMOVED***
      , nonfatalError = new Error('nonfatal!'***REMOVED***
      , processedData = 'some data'
      ;

    api.stream
      .on('warn', function (err***REMOVED*** {
        t.equals(err, nonfatalError, 'emits the buffered warning'***REMOVED***;
        t.ok(resumed, 'emits warning only after it was resumed'***REMOVED***;
    ***REMOVED******REMOVED***
      .on('error', function (err***REMOVED*** {
        t.equals(err, fatalError, 'emits the buffered fatal error'***REMOVED***;
        t.ok(resumed, 'emits errors only after it was resumed'***REMOVED***;
    ***REMOVED******REMOVED***
      .on('data', function (data***REMOVED*** {
        t.equals(data, processedData, 'emits the buffered data'***REMOVED***;
        t.ok(resumed, 'emits data only after it was resumed'***REMOVED***;
    ***REMOVED******REMOVED***
      .pause(***REMOVED***
    
    api.processEntry(processedData***REMOVED***;
    api.handleError(nonfatalError***REMOVED***;
    api.handleFatalError(fatalError***REMOVED***;
  
    process.nextTick(function (***REMOVED*** {
      resumed = true;
      api.stream.resume(***REMOVED***;
  ***REMOVED******REMOVED***
***REMOVED******REMOVED***

  t.test('\n# when a stream is destroyed, it emits "closed", but no longer emits "data", "warn" and "error"', function (t***REMOVED*** {
    t.plan(6***REMOVED***
    var api = streamapi(***REMOVED***
      , destroyed = false
      , fatalError = new Error('fatal!'***REMOVED***
      , nonfatalError = new Error('nonfatal!'***REMOVED***
      , processedData = 'some data'

    var stream = api.stream
      .on('warn', function (err***REMOVED*** {
        t.notOk(destroyed, 'emits warning until destroyed'***REMOVED***;
    ***REMOVED******REMOVED***
      .on('error', function (err***REMOVED*** {
        t.notOk(destroyed, 'emits errors until destroyed'***REMOVED***;
    ***REMOVED******REMOVED***
      .on('data', function (data***REMOVED*** {
        t.notOk(destroyed, 'emits data until destroyed'***REMOVED***;
    ***REMOVED******REMOVED***
      .on('close', function (***REMOVED*** {
        t.ok(destroyed, 'emits close when stream is destroyed'***REMOVED***;
    ***REMOVED******REMOVED***
    

    api.processEntry(processedData***REMOVED***;
    api.handleError(nonfatalError***REMOVED***;
    api.handleFatalError(fatalError***REMOVED***;

    process.nextTick(function (***REMOVED*** {
      destroyed = true
      stream.destroy(***REMOVED***

      t.notOk(stream.readable, 'stream is no longer readable after it is destroyed'***REMOVED***

      api.processEntry(processedData***REMOVED***;
      api.handleError(nonfatalError***REMOVED***;
      api.handleFatalError(fatalError***REMOVED***;

      process.nextTick(function (***REMOVED*** {
        t.pass('emits no more data, warn or error events after it was destroyed'***REMOVED***  
    ***REMOVED******REMOVED***
  ***REMOVED******REMOVED***
***REMOVED******REMOVED***
}***REMOVED***
