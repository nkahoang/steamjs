'use strict';

var fs        =  require('fs'***REMOVED***
  , path      =  require('path'***REMOVED***
  , minimatch =  require('minimatch'***REMOVED***
  , toString  =  Object.prototype.toString
  ;

// Standard helpers
function isFunction (obj***REMOVED*** {
  return toString.call(obj***REMOVED*** == '[object Function]';
}

function isString (obj***REMOVED*** {
  return toString.call(obj***REMOVED*** == '[object String]';
}

function isRegExp (obj***REMOVED*** {
  return toString.call(obj***REMOVED*** == '[object RegExp]';
}

function isUndefined (obj***REMOVED*** {
  return obj === void 0;
}

/** 
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param { Object }   opts     Options to specify root (start directory***REMOVED***, filters and recursion depth
 * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo***REMOVED*** { ... },
 *                                when callback2 is not given, it behaves like explained in callback2
 * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
 *                                function (err, fileInfos***REMOVED*** { ... }
 */
function readdir(opts, callback1, callback2***REMOVED*** {
  var stream
    , handleError
    , handleFatalError
    , pending = 0
    , errors = []
    , readdirResult = {
        directories: []
      , files: []
  ***REMOVED***
    , fileProcessed
    , allProcessed
    , realRoot
    , aborted = false
    ;

  // If no callbacks were given we will use a streaming interface
  if (isUndefined(callback1***REMOVED******REMOVED*** {
    var api          =  require('./stream-api'***REMOVED***(***REMOVED***;
    stream           =  api.stream;
    callback1        =  api.processEntry;
    callback2        =  api.done;
    handleError      =  api.handleError;
    handleFatalError =  api.handleFatalError;

    stream.on('close', function (***REMOVED*** { aborted = true; }***REMOVED***;
***REMOVED*** else {
    handleError      =  function (err***REMOVED*** { errors.push(err***REMOVED***; };
    handleFatalError =  function (err***REMOVED*** {
      handleError(err***REMOVED***;
      allProcessed(errors, null***REMOVED***;
  ***REMOVED***;
***REMOVED***

  if (isUndefined(opts***REMOVED******REMOVED***{
    handleFatalError(new Error (
      'Need to pass at least one argument: opts! \n' +
      'https://github.com/thlorenz/readdirp#options'
      ***REMOVED***
    ***REMOVED***;
    return stream;
***REMOVED***

  opts.root            =  opts.root            || '.';
  opts.fileFilter      =  opts.fileFilter      || function(***REMOVED*** { return true; };
  opts.directoryFilter =  opts.directoryFilter || function(***REMOVED*** { return true; };
  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;

  if (isUndefined(callback2***REMOVED******REMOVED*** {
    fileProcessed = function(***REMOVED*** { };
    allProcessed = callback1;
***REMOVED*** else {
    fileProcessed = callback1;
    allProcessed = callback2;
***REMOVED***

  function normalizeFilter (filter***REMOVED*** {

    if (isUndefined(filter***REMOVED******REMOVED*** return undefined;

    function isNegated (filters***REMOVED*** {

      function negated(f***REMOVED*** { 
        return f.indexOf('!'***REMOVED*** === 0; 
    ***REMOVED***

      var some = filters.some(negated***REMOVED***;
      if (!some***REMOVED*** {
        return false;
    ***REMOVED*** else {
        if (filters.every(negated***REMOVED******REMOVED*** {
          return true;
      ***REMOVED*** else {
          // if we detect illegal filters, bail out immediately
          throw new Error(
            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
            'https://github.com/thlorenz/readdirp#filters'
          ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    // Turn all filters into a function
    if (isFunction(filter***REMOVED******REMOVED*** {

      return filter;

  ***REMOVED*** else if (isString(filter***REMOVED******REMOVED*** {

      return function (entryInfo***REMOVED*** {
        return minimatch(entryInfo.name, filter.trim(***REMOVED******REMOVED***;
    ***REMOVED***;

  ***REMOVED*** else if (filter && Array.isArray(filter***REMOVED******REMOVED*** {

      if (filter***REMOVED*** filter = filter.map(function (f***REMOVED*** {
        return f.trim(***REMOVED***;
    ***REMOVED******REMOVED***;

      return isNegated(filter***REMOVED*** ?
        // use AND to concat multiple negated filters
        function (entryInfo***REMOVED*** {
          return filter.every(function (f***REMOVED*** {
            return minimatch(entryInfo.name, f***REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED***
        :
        // use OR to concat multiple inclusive filters
        function (entryInfo***REMOVED*** {
          return filter.some(function (f***REMOVED*** {
            return minimatch(entryInfo.name, f***REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED***
***REMOVED***

  function processDir(currentDir, entries, callProcessed***REMOVED*** {
    if (aborted***REMOVED*** return;
    var total = entries.length
      , processed = 0
      , entryInfos = []
      ;

    fs.realpath(currentDir, function(err, realCurrentDir***REMOVED*** {
      if (aborted***REMOVED*** return;
      if (err***REMOVED*** {
        handleError(err***REMOVED***;
        callProcessed(entryInfos***REMOVED***;
        return;
    ***REMOVED***

      var relDir = path.relative(realRoot, realCurrentDir***REMOVED***;

      if (entries.length === 0***REMOVED*** {
        callProcessed([]***REMOVED***;
    ***REMOVED*** else {
        entries.forEach(function (entry***REMOVED*** { 

          var fullPath = path.join(realCurrentDir, entry***REMOVED***,
            relPath  = path.join(relDir, entry***REMOVED***;

          fs.stat(fullPath, function (err, stat***REMOVED*** {
            if (err***REMOVED*** {
              handleError(err***REMOVED***;
          ***REMOVED*** else {
              entryInfos.push({
                  name          :  entry
                , path          :  relPath   // relative to root
                , fullPath      :  fullPath

                , parentDir     :  relDir    // relative to root
                , fullParentDir :  realCurrentDir

                , stat          :  stat
            ***REMOVED******REMOVED***;
          ***REMOVED***
            processed++;
            if (processed === total***REMOVED*** callProcessed(entryInfos***REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***

  function readdirRec(currentDir, depth, callCurrentDirProcessed***REMOVED*** {
    if (aborted***REMOVED*** return;

    fs.readdir(currentDir, function (err, entries***REMOVED*** {
      if (err***REMOVED*** {
        handleError(err***REMOVED***;
        callCurrentDirProcessed(***REMOVED***;
        return;
    ***REMOVED***

      processDir(currentDir, entries, function(entryInfos***REMOVED*** {

        var subdirs = entryInfos
          .filter(function (ei***REMOVED*** { return ei.stat.isDirectory(***REMOVED*** && opts.directoryFilter(ei***REMOVED***; }***REMOVED***;

        subdirs.forEach(function (di***REMOVED*** { 
          readdirResult.directories.push(di***REMOVED***; 
      ***REMOVED******REMOVED***;

        entryInfos
          .filter(function(ei***REMOVED*** { return ei.stat.isFile(***REMOVED*** && opts.fileFilter(ei***REMOVED***; }***REMOVED***
          .forEach(function (fi***REMOVED*** { 
            fileProcessed(fi***REMOVED***;
            readdirResult.files.push(fi***REMOVED***; 
        ***REMOVED******REMOVED***;

        var pendingSubdirs = subdirs.length;

        // Be done if no more subfolders exist or we reached the maximum desired depth
        if(pendingSubdirs === 0 || depth === opts.depth***REMOVED*** {
          callCurrentDirProcessed(***REMOVED***;
      ***REMOVED*** else {
          // recurse into subdirs, keeping track of which ones are done 
          // and call back once all are processed
          subdirs.forEach(function (subdir***REMOVED*** {
            readdirRec(subdir.fullPath, depth + 1, function (***REMOVED*** {
              pendingSubdirs = pendingSubdirs - 1;
              if(pendingSubdirs === 0***REMOVED*** { 
                callCurrentDirProcessed(***REMOVED***;
            ***REMOVED***
          ***REMOVED******REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  // Validate and normalize filters
  try {
    opts.fileFilter = normalizeFilter(opts.fileFilter***REMOVED***;
    opts.directoryFilter = normalizeFilter(opts.directoryFilter***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    // if we detect illegal filters, bail out immediately
    handleFatalError(err***REMOVED***;
    return stream;
***REMOVED***

  // If filters were valid get on with the show
  fs.realpath(opts.root, function(err, res***REMOVED*** {
    if (err***REMOVED*** {
      handleFatalError(err***REMOVED***;
      return stream;
  ***REMOVED***

    realRoot = res;
    readdirRec(opts.root, 0, function (***REMOVED*** { 
      // All errors are collected into the errors array
      if (errors.length > 0***REMOVED*** {
        allProcessed(errors, readdirResult***REMOVED***; 
    ***REMOVED*** else {
        allProcessed(null, readdirResult***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED******REMOVED***;

  return stream;
}

module.exports = readdir;
