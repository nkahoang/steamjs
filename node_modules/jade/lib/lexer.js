'use strict';

var utils = require('./utils'***REMOVED***;
var characterParser = require('character-parser'***REMOVED***;


/**
 * Initialize `Lexer` with the given `str`.
 *
 * @param {String} str
 * @param {String} filename
 * @api private
 */

var Lexer = module.exports = function Lexer(str, filename***REMOVED*** {
  this.input = str.replace(/\r\n|\r/g, '\n'***REMOVED***;
  this.filename = filename;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
};


function assertExpression(exp***REMOVED*** {
  //this verifies that a JavaScript expression is valid
  Function('', 'return (' + exp + '***REMOVED***'***REMOVED***;
}
function assertNestingCorrect(exp***REMOVED*** {
  //this verifies that code is properly nested, but allows
  //invalid JavaScript such as the contents of `attributes`
  var res = characterParser(exp***REMOVED***
  if (res.isNesting(***REMOVED******REMOVED*** {
    throw new Error('Nesting must match on expression `' + exp + '`'***REMOVED***
***REMOVED***
}

/**
 * Lexer prototype.
 */

Lexer.prototype = {

  /**
   * Construct a token with the given `type` and `val`.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */

  tok: function(type, val***REMOVED***{
    return {
        type: type
      , line: this.lineno
      , val: val
  ***REMOVED***
***REMOVED***,

  /**
   * Consume the given `len` of input.
   *
   * @param {Number} len
   * @api private
   */

  consume: function(len***REMOVED***{
    this.input = this.input.substr(len***REMOVED***;
***REMOVED***,

  /**
   * Scan for `type` with the given `regexp`.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */

  scan: function(regexp, type***REMOVED***{
    var captures;
    if (captures = regexp.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      return this.tok(type, captures[1]***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Defer the given `tok`.
   *
   * @param {Object} tok
   * @api private
   */

  defer: function(tok***REMOVED***{
    this.deferredTokens.push(tok***REMOVED***;
***REMOVED***,

  /**
   * Lookahead `n` tokens.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n***REMOVED***{
    var fetch = n - this.stash.length;
    while (fetch-- > 0***REMOVED*** this.stash.push(this.next(***REMOVED******REMOVED***;
    return this.stash[--n];
***REMOVED***,

  /**
   * Return the indexOf `(` or `{` or `[` / `***REMOVED***` or `}` or `]` delimiters.
   *
   * @return {Number}
   * @api private
   */

  bracketExpression: function(skip***REMOVED***{
    skip = skip || 0;
    var start = this.input[skip];
    if (start != '(' && start != '{' && start != '['***REMOVED*** throw new Error('unrecognized start character'***REMOVED***;
    var end = ({'(': '***REMOVED***', '{': '}', '[': ']'}***REMOVED***[start];
    var range = characterParser.parseMax(this.input, {start: skip + 1}***REMOVED***;
    if (this.input[range.end] !== end***REMOVED*** throw new Error('start character ' + start + ' does not match end character ' + this.input[range.end]***REMOVED***;
    return range;
***REMOVED***,

  /**
   * Stashed token.
   */

  stashed: function(***REMOVED*** {
    return this.stash.length
      && this.stash.shift(***REMOVED***;
***REMOVED***,

  /**
   * Deferred token.
   */

  deferred: function(***REMOVED*** {
    return this.deferredTokens.length
      && this.deferredTokens.shift(***REMOVED***;
***REMOVED***,

  /**
   * end-of-source.
   */

  eos: function(***REMOVED*** {
    if (this.input.length***REMOVED*** return;
    if (this.indentStack.length***REMOVED*** {
      this.indentStack.shift(***REMOVED***;
      return this.tok('outdent'***REMOVED***;
  ***REMOVED*** else {
      return this.tok('eos'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Blank line.
   */

  blank: function(***REMOVED*** {
    var captures;
    if (captures = /^\n *\n/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length - 1***REMOVED***;
      ++this.lineno;
      if (this.pipeless***REMOVED*** return this.tok('text', ''***REMOVED***;
      return this.next(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Comment.
   */

  comment: function(***REMOVED*** {
    var captures;
    if (captures = /^\/\/(-***REMOVED***?([^\n]****REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var tok = this.tok('comment', captures[2]***REMOVED***;
      tok.buffer = '-' != captures[1];
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Interpolated tag.
   */

  interpolation: function(***REMOVED*** {
    if (/^#\{/.test(this.input***REMOVED******REMOVED*** {
      var match;
      try {
        match = this.bracketExpression(1***REMOVED***;
    ***REMOVED*** catch (ex***REMOVED*** {
        return;//not an interpolation expression, just an unmatched open interpolation
    ***REMOVED***

      this.consume(match.end + 1***REMOVED***;
      return this.tok('interpolation', match.src***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Tag.
   */

  tag: function(***REMOVED*** {
    var captures;
    if (captures = /^(\w[-:\w]****REMOVED***(\/?***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var tok, name = captures[1];
      if (':' == name[name.length - 1]***REMOVED*** {
        name = name.slice(0, -1***REMOVED***;
        tok = this.tok('tag', name***REMOVED***;
        this.defer(this.tok(':'***REMOVED******REMOVED***;
        while (' ' == this.input[0]***REMOVED*** this.input = this.input.substr(1***REMOVED***;
    ***REMOVED*** else {
        tok = this.tok('tag', name***REMOVED***;
    ***REMOVED***
      tok.selfClosing = !!captures[2];
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Filter.
   */

  filter: function(***REMOVED*** {
    return this.scan(/^:([\w\-]+***REMOVED***/, 'filter'***REMOVED***;
***REMOVED***,

  /**
   * Doctype.
   */

  doctype: function(***REMOVED*** {
    if (this.scan(/^!!! *([^\n]+***REMOVED***?/, 'doctype'***REMOVED******REMOVED*** {
      throw new Error('`!!!` is deprecated, you must now use `doctype`'***REMOVED***;
  ***REMOVED***
    var node = this.scan(/^(?:doctype***REMOVED*** *([^\n]+***REMOVED***?/, 'doctype'***REMOVED***;
    if (node && node.val && node.val.trim(***REMOVED*** === '5'***REMOVED*** {
      throw new Error('`doctype 5` is deprecated, you must now use `doctype html`'***REMOVED***;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * Id.
   */

  id: function(***REMOVED*** {
    return this.scan(/^#([\w-]+***REMOVED***/, 'id'***REMOVED***;
***REMOVED***,

  /**
   * Class.
   */

  className: function(***REMOVED*** {
    return this.scan(/^\.([\w-]+***REMOVED***/, 'class'***REMOVED***;
***REMOVED***,

  /**
   * Text.
   */

  text: function(***REMOVED*** {
    return this.scan(/^(?:\| ?| ***REMOVED***([^\n]+***REMOVED***/, 'text'***REMOVED*** || this.scan(/^(<[^\n]****REMOVED***/, 'text'***REMOVED***;
***REMOVED***,

  textFail: function (***REMOVED*** {
    var tok;
    if (tok = this.scan(/^([^\.\n][^\n]+***REMOVED***/, 'text'***REMOVED******REMOVED*** {
      console.warn('Warning: missing space before text for line ' + this.lineno +
          ' of jade file "' + this.filename + '"'***REMOVED***;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Dot.
   */

  dot: function(***REMOVED*** {
    return this.scan(/^\./, 'dot'***REMOVED***;
***REMOVED***,

  /**
   * Extends.
   */

  "extends": function(***REMOVED*** {
    return this.scan(/^extends? +([^\n]+***REMOVED***/, 'extends'***REMOVED***;
***REMOVED***,

  /**
   * Block prepend.
   */

  prepend: function(***REMOVED*** {
    var captures;
    if (captures = /^prepend +([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var mode = 'prepend'
        , name = captures[1]
        , tok = this.tok('block', name***REMOVED***;
      tok.mode = mode;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Block append.
   */

  append: function(***REMOVED*** {
    var captures;
    if (captures = /^append +([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var mode = 'append'
        , name = captures[1]
        , tok = this.tok('block', name***REMOVED***;
      tok.mode = mode;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Block.
   */

  block: function(***REMOVED*** {
    var captures;
    if (captures = /^block\b *(?:(prepend|append***REMOVED*** +***REMOVED***?([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var mode = captures[1] || 'replace'
        , name = captures[2]
        , tok = this.tok('block', name***REMOVED***;

      tok.mode = mode;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Mixin Block.
   */

  mixinBlock: function(***REMOVED*** {
    var captures;
    if (captures = /^block\s*(\n|$***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length - 1***REMOVED***;
      return this.tok('mixin-block'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Yield.
   */

  yield: function(***REMOVED*** {
    return this.scan(/^yield */, 'yield'***REMOVED***;
***REMOVED***,

  /**
   * Include.
   */

  include: function(***REMOVED*** {
    return this.scan(/^include +([^\n]+***REMOVED***/, 'include'***REMOVED***;
***REMOVED***,

  /**
   * Include with filter
   */

  includeFiltered: function(***REMOVED*** {
    var captures;
    if (captures = /^include:([\w\-]+***REMOVED*** +([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var filter = captures[1];
      var path = captures[2];
      var tok = this.tok('include', path***REMOVED***;
      tok.filter = filter;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Case.
   */

  "case": function(***REMOVED*** {
    return this.scan(/^case +([^\n]+***REMOVED***/, 'case'***REMOVED***;
***REMOVED***,

  /**
   * When.
   */

  when: function(***REMOVED*** {
    return this.scan(/^when +([^:\n]+***REMOVED***/, 'when'***REMOVED***;
***REMOVED***,

  /**
   * Default.
   */

  "default": function(***REMOVED*** {
    return this.scan(/^default */, 'default'***REMOVED***;
***REMOVED***,

  /**
   * Call mixin.
   */

  call: function(***REMOVED***{

    var tok, captures;
    if (captures = /^\+(([-\w]+***REMOVED***|(#\{***REMOVED******REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      // try to consume simple or interpolated call
      if (captures[2]***REMOVED*** {
        // simple call
        this.consume(captures[0].length***REMOVED***;
        tok = this.tok('call', captures[2]***REMOVED***;
    ***REMOVED*** else {
        // interpolated call
        var match;
        try {
          match = this.bracketExpression(2***REMOVED***;
      ***REMOVED*** catch (ex***REMOVED*** {
          return;//not an interpolation expression, just an unmatched open interpolation
      ***REMOVED***
        this.consume(match.end + 1***REMOVED***;
        assertExpression(match.src***REMOVED***;
        tok = this.tok('call', '#{'+match.src+'}'***REMOVED***;
    ***REMOVED***

      // Check for args (not attributes***REMOVED***
      if (captures = /^ *\(/.exec(this.input***REMOVED******REMOVED*** {
        try {
          var range = this.bracketExpression(captures[0].length - 1***REMOVED***;
          if (!/^ *[-\w]+ *=/.test(range.src***REMOVED******REMOVED*** { // not attributes
            this.consume(range.end + 1***REMOVED***;
            tok.args = range.src;
        ***REMOVED***
      ***REMOVED*** catch (ex***REMOVED*** {
          //not a bracket expcetion, just unmatched open parens
      ***REMOVED***
    ***REMOVED***

      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Mixin.
   */

  mixin: function(***REMOVED***{
    var captures;
    if (captures = /^mixin +([-\w]+***REMOVED***(?: *\((.****REMOVED***\***REMOVED******REMOVED***? */.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var tok = this.tok('mixin', captures[1]***REMOVED***;
      tok.args = captures[2];
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Conditional.
   */

  conditional: function(***REMOVED*** {
    var captures;
    if (captures = /^(if|unless|else if|else***REMOVED***\b([^\n]****REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var type = captures[1]
      var js = captures[2];
      var isIf = false;
      var isElse = false;

      switch (type***REMOVED*** {
        case 'if':
          assertExpression(js***REMOVED***
          js = 'if (' + js + '***REMOVED***';
          isIf = true;
          break;
        case 'unless':
          assertExpression(js***REMOVED***
          js = 'if (!(' + js + '***REMOVED******REMOVED***';
          isIf = true;
          break;
        case 'else if':
          assertExpression(js***REMOVED***
          js = 'else if (' + js + '***REMOVED***';
          isIf = true;
          isElse = true;
          break;
        case 'else':
          if (js && js.trim(***REMOVED******REMOVED*** {
            throw new Error('`else` cannot have a condition, perhaps you meant `else if`'***REMOVED***;
        ***REMOVED***
          js = 'else';
          isElse = true;
          break;
    ***REMOVED***
      var tok = this.tok('code', js***REMOVED***;
      tok.isElse = isElse;
      tok.isIf = isIf;
      tok.requiresBlock = true;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * While.
   */

  "while": function(***REMOVED*** {
    var captures;
    if (captures = /^while +([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      assertExpression(captures[1]***REMOVED***
      var tok = this.tok('code', 'while (' + captures[1] + '***REMOVED***'***REMOVED***;
      tok.requiresBlock = true;
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Each.
   */

  each: function(***REMOVED*** {
    var captures;
    if (captures = /^(?:- ****REMOVED***?(?:each|for***REMOVED*** +([a-zA-Z_$][\w$]****REMOVED***(?: *, *([a-zA-Z_$][\w$]****REMOVED******REMOVED***? * in *([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var tok = this.tok('each', captures[1]***REMOVED***;
      tok.key = captures[2] || '$index';
      assertExpression(captures[3]***REMOVED***
      tok.code = captures[3];
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Code.
   */

  code: function(***REMOVED*** {
    var captures;
    if (captures = /^(!?=|-***REMOVED***[ \t]*([^\n]+***REMOVED***/.exec(this.input***REMOVED******REMOVED*** {
      this.consume(captures[0].length***REMOVED***;
      var flags = captures[1];
      captures[1] = captures[2];
      var tok = this.tok('code', captures[1]***REMOVED***;
      tok.escape = flags.charAt(0***REMOVED*** === '=';
      tok.buffer = flags.charAt(0***REMOVED*** === '=' || flags.charAt(1***REMOVED*** === '=';
      if (tok.buffer***REMOVED*** assertExpression(captures[1]***REMOVED***
      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Attributes.
   */

  attrs: function(***REMOVED*** {
    if ('(' == this.input.charAt(0***REMOVED******REMOVED*** {
      var index = this.bracketExpression(***REMOVED***.end
        , str = this.input.substr(1, index-1***REMOVED***
        , tok = this.tok('attrs'***REMOVED***;

      assertNestingCorrect(str***REMOVED***;

      var quote = '';
      var interpolate = function (attr***REMOVED*** {
        return attr.replace(/(\\***REMOVED***?#\{(.+***REMOVED***/g, function(_, escape, expr***REMOVED***{
          if (escape***REMOVED*** return _;
          try {
            var range = characterParser.parseMax(expr***REMOVED***;
            if (expr[range.end] !== '}'***REMOVED*** return _.substr(0, 2***REMOVED*** + interpolate(_.substr(2***REMOVED******REMOVED***;
            assertExpression(range.src***REMOVED***
            return quote + " + (" + range.src + "***REMOVED*** + " + quote + interpolate(expr.substr(range.end + 1***REMOVED******REMOVED***;
        ***REMOVED*** catch (ex***REMOVED*** {
            return _.substr(0, 2***REMOVED*** + interpolate(_.substr(2***REMOVED******REMOVED***;
        ***REMOVED***
      ***REMOVED******REMOVED***;
    ***REMOVED***

      this.consume(index + 1***REMOVED***;
      tok.attrs = [];

      var escapedAttr = true
      var key = '';
      var val = '';
      var interpolatable = '';
      var state = characterParser.defaultState(***REMOVED***;
      var loc = 'key';
      var isEndOfAttribute = function (i***REMOVED*** {
        if (key.trim(***REMOVED*** === ''***REMOVED*** return false;
        if (i === str.length***REMOVED*** return true;
        if (loc === 'key'***REMOVED*** {
          if (str[i] === ' ' || str[i] === '\n'***REMOVED*** {
            for (var x = i; x < str.length; x++***REMOVED*** {
              if (str[x] != ' ' && str[x] != '\n'***REMOVED*** {
                if (str[x] === '=' || str[x] === '!' || str[x] === ','***REMOVED*** return false;
                else return true;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
          return str[i] === ','
      ***REMOVED*** else if (loc === 'value' && !state.isNesting(***REMOVED******REMOVED*** {
          try {
            Function('', 'return (' + val + '***REMOVED***;'***REMOVED***;
            if (str[i] === ' ' || str[i] === '\n'***REMOVED*** {
              for (var x = i; x < str.length; x++***REMOVED*** {
                if (str[x] != ' ' && str[x] != '\n'***REMOVED*** {
                  if (characterParser.isPunctuator(str[x]***REMOVED*** && str[x] != '"' && str[x] != "'"***REMOVED*** return false;
                  else return true;
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
            return str[i] === ',';
        ***REMOVED*** catch (ex***REMOVED*** {
            return false;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      this.lineno += str.split("\n"***REMOVED***.length - 1;

      for (var i = 0; i <= str.length; i++***REMOVED*** {
        if (isEndOfAttribute(i***REMOVED******REMOVED*** {
          val = val.trim(***REMOVED***;
          if (val***REMOVED*** assertExpression(val***REMOVED***
          key = key.trim(***REMOVED***;
          key = key.replace(/^['"]|['"]$/g, ''***REMOVED***;
          tok.attrs.push({
            name: key,
            val: '' == val ? true : val,
            escaped: escapedAttr
        ***REMOVED******REMOVED***;
          key = val = '';
          loc = 'key';
          escapedAttr = false;
      ***REMOVED*** else {
          switch (loc***REMOVED*** {
            case 'key-char':
              if (str[i] === quote***REMOVED*** {
                loc = 'key';
                if (i + 1 < str.length && [' ', ',', '!', '=', '\n'].indexOf(str[i + 1]***REMOVED*** === -1***REMOVED***
                  throw new Error('Unexpected character ' + str[i + 1] + ' expected ` `, `\\n`, `,`, `!` or `=`'***REMOVED***;
            ***REMOVED*** else {
                key += str[i];
            ***REMOVED***
              break;
            case 'key':
              if (key === '' && (str[i] === '"' || str[i] === "'"***REMOVED******REMOVED*** {
                loc = 'key-char';
                quote = str[i];
            ***REMOVED*** else if (str[i] === '!' || str[i] === '='***REMOVED*** {
                escapedAttr = str[i] !== '!';
                if (str[i] === '!'***REMOVED*** i++;
                if (str[i] !== '='***REMOVED*** throw new Error('Unexpected character ' + str[i] + ' expected `=`'***REMOVED***;
                loc = 'value';
                state = characterParser.defaultState(***REMOVED***;
            ***REMOVED*** else {
                key += str[i]
            ***REMOVED***
              break;
            case 'value':
              state = characterParser.parseChar(str[i], state***REMOVED***;
              if (state.isString(***REMOVED******REMOVED*** {
                loc = 'string';
                quote = str[i];
                interpolatable = str[i];
            ***REMOVED*** else {
                val += str[i];
            ***REMOVED***
              break;
            case 'string':
              state = characterParser.parseChar(str[i], state***REMOVED***;
              interpolatable += str[i];
              if (!state.isString(***REMOVED******REMOVED*** {
                loc = 'value';
                val += interpolate(interpolatable***REMOVED***;
            ***REMOVED***
              break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      if ('/' == this.input.charAt(0***REMOVED******REMOVED*** {
        this.consume(1***REMOVED***;
        tok.selfClosing = true;
    ***REMOVED***

      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * &attributes block
   */
  attributesBlock: function (***REMOVED*** {
    var captures;
    if (/^&attributes\b/.test(this.input***REMOVED******REMOVED*** {
      this.consume(11***REMOVED***;
      var args = this.bracketExpression(***REMOVED***;
      this.consume(args.end + 1***REMOVED***;
      return this.tok('&attributes', args.src***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Indent | Outdent | Newline.
   */

  indent: function(***REMOVED*** {
    var captures, re;

    // established regexp
    if (this.indentRe***REMOVED*** {
      captures = this.indentRe.exec(this.input***REMOVED***;
    // determine regexp
  ***REMOVED*** else {
      // tabs
      re = /^\n(\t****REMOVED*** */;
      captures = re.exec(this.input***REMOVED***;

      // spaces
      if (captures && !captures[1].length***REMOVED*** {
        re = /^\n( ****REMOVED***/;
        captures = re.exec(this.input***REMOVED***;
    ***REMOVED***

      // established
      if (captures && captures[1].length***REMOVED*** this.indentRe = re;
  ***REMOVED***

    if (captures***REMOVED*** {
      var tok
        , indents = captures[1].length;

      ++this.lineno;
      this.consume(indents + 1***REMOVED***;

      if (' ' == this.input[0] || '\t' == this.input[0]***REMOVED*** {
        throw new Error('Invalid indentation, you can use tabs or spaces but not both'***REMOVED***;
    ***REMOVED***

      // blank line
      if ('\n' == this.input[0]***REMOVED*** return this.tok('newline'***REMOVED***;

      // outdent
      if (this.indentStack.length && indents < this.indentStack[0]***REMOVED*** {
        while (this.indentStack.length && this.indentStack[0] > indents***REMOVED*** {
          this.stash.push(this.tok('outdent'***REMOVED******REMOVED***;
          this.indentStack.shift(***REMOVED***;
      ***REMOVED***
        tok = this.stash.pop(***REMOVED***;
      // indent
    ***REMOVED*** else if (indents && indents != this.indentStack[0]***REMOVED*** {
        this.indentStack.unshift(indents***REMOVED***;
        tok = this.tok('indent', indents***REMOVED***;
      // newline
    ***REMOVED*** else {
        tok = this.tok('newline'***REMOVED***;
    ***REMOVED***

      return tok;
  ***REMOVED***
***REMOVED***,

  /**
   * Pipe-less text consumed only when
   * pipeless is true;
   */

  pipelessText: function(***REMOVED*** {
    if (this.pipeless***REMOVED*** {
      if ('\n' == this.input[0]***REMOVED*** return;
      var i = this.input.indexOf('\n'***REMOVED***;
      if (-1 == i***REMOVED*** i = this.input.length;
      var str = this.input.substr(0, i***REMOVED***;
      this.consume(str.length***REMOVED***;
      return this.tok('text', str***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * ':'
   */

  colon: function(***REMOVED*** {
    return this.scan(/^: */, ':'***REMOVED***;
***REMOVED***,

  fail: function (***REMOVED*** {
    if (/^ ($|\n***REMOVED***/.test(this.input***REMOVED******REMOVED*** {
      this.consume(1***REMOVED***;
      return this.next(***REMOVED***;
  ***REMOVED***
    throw new Error('unexpected text ' + this.input.substr(0, 5***REMOVED******REMOVED***;
***REMOVED***,

  /**
   * Return the next token object, or those
   * previously stashed by lookahead.
   *
   * @return {Object}
   * @api private
   */

  advance: function(***REMOVED***{
    return this.stashed(***REMOVED***
      || this.next(***REMOVED***;
***REMOVED***,

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  next: function(***REMOVED*** {
    return this.deferred(***REMOVED***
      || this.blank(***REMOVED***
      || this.eos(***REMOVED***
      || this.pipelessText(***REMOVED***
      || this.yield(***REMOVED***
      || this.doctype(***REMOVED***
      || this.interpolation(***REMOVED***
      || this["case"](***REMOVED***
      || this.when(***REMOVED***
      || this["default"](***REMOVED***
      || this["extends"](***REMOVED***
      || this.append(***REMOVED***
      || this.prepend(***REMOVED***
      || this.block(***REMOVED***
      || this.mixinBlock(***REMOVED***
      || this.include(***REMOVED***
      || this.includeFiltered(***REMOVED***
      || this.mixin(***REMOVED***
      || this.call(***REMOVED***
      || this.conditional(***REMOVED***
      || this.each(***REMOVED***
      || this["while"](***REMOVED***
      || this.tag(***REMOVED***
      || this.filter(***REMOVED***
      || this.code(***REMOVED***
      || this.id(***REMOVED***
      || this.className(***REMOVED***
      || this.attrs(***REMOVED***
      || this.attributesBlock(***REMOVED***
      || this.indent(***REMOVED***
      || this.text(***REMOVED***
      || this.comment(***REMOVED***
      || this.colon(***REMOVED***
      || this.dot(***REMOVED***
      || this.textFail(***REMOVED***
      || this.fail(***REMOVED***;
***REMOVED***
};
