'use strict';

var Lexer = require('./lexer'***REMOVED***;
var nodes = require('./nodes'***REMOVED***;
var utils = require('./utils'***REMOVED***;
var filters = require('./filters'***REMOVED***;
var ***REMOVED***;
var constantinople = require('constantinople'***REMOVED***;
var parseJSExpression = require('character-parser'***REMOVED***.parseMax;
var extname = path.extname;

/**
 * Initialize `Parser` with the given input `str` and `filename`.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */

var Parser = exports = module.exports = function Parser(str, filename, options***REMOVED***{
  //Strip any UTF-8 BOM off of the start of `str`, if it exists.
  this.input = str.replace(/^\uFEFF/, ''***REMOVED***;
  this.lexer = new Lexer(this.input, filename***REMOVED***;
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
  this.inMixin = false;
};

/**
 * Parser prototype.
 */

Parser.prototype = {

  /**
   * Save original constructor
   */

  constructor: Parser,

  /**
   * Push `parser` onto the context stack,
   * or pop and return a `Parser`.
   */

  context: function(parser***REMOVED***{
    if (parser***REMOVED*** {
      this.contexts.push(parser***REMOVED***;
  ***REMOVED*** else {
      return this.contexts.pop(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  advance: function(***REMOVED***{
    return this.lexer.advance(***REMOVED***;
***REMOVED***,

  /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */

  peek: function(***REMOVED*** {
    return this.lookahead(1***REMOVED***;
***REMOVED***,

  /**
   * Return lexer lineno.
   *
   * @return {Number}
   * @api private
   */

  line: function(***REMOVED*** {
    return this.lexer.lineno;
***REMOVED***,

  /**
   * `n` token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */

  lookahead: function(n***REMOVED***{
    return this.lexer.lookahead(n***REMOVED***;
***REMOVED***,

  /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */

  parse: function(***REMOVED***{
    var block = new nodes.Block, parser;
    block.line = 0;
    block.filename = this.filename;

    while ('eos' != this.peek(***REMOVED***.type***REMOVED*** {
      if ('newline' == this.peek(***REMOVED***.type***REMOVED*** {
        this.advance(***REMOVED***;
    ***REMOVED*** else {
        var next = this.peek(***REMOVED***;
        var expr = this.parseExpr(***REMOVED***;
        expr.filename = expr.filename || this.filename;
        expr.line = next.line;
        block.push(expr***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    if (parser = this.extending***REMOVED*** {
      this.context(parser***REMOVED***;
      var ast = parser.parse(***REMOVED***;
      this.context(***REMOVED***;

      // hoist mixins
      for (var name in this.mixins***REMOVED***
        ast.unshift(this.mixins[name]***REMOVED***;
      return ast;
  ***REMOVED***

    return block;
***REMOVED***,

  /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */

  expect: function(type***REMOVED***{
    if (this.peek(***REMOVED***.type === type***REMOVED*** {
      return this.advance(***REMOVED***;
  ***REMOVED*** else {
      throw new Error('expected "' + type + '", but got "' + this.peek(***REMOVED***.type + '"'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Accept the given `type`.
   *
   * @param {String} type
   * @api private
   */

  accept: function(type***REMOVED***{
    if (this.peek(***REMOVED***.type === type***REMOVED*** {
      return this.advance(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */

  parseExpr: function(***REMOVED***{
    switch (this.peek(***REMOVED***.type***REMOVED*** {
      case 'tag':
        return this.parseTag(***REMOVED***;
      case 'mixin':
        return this.parseMixin(***REMOVED***;
      case 'block':
        return this.parseBlock(***REMOVED***;
      case 'mixin-block':
        return this.parseMixinBlock(***REMOVED***;
      case 'case':
        return this.parseCase(***REMOVED***;
      case 'extends':
        return this.parseExtends(***REMOVED***;
      case 'include':
        return this.parseInclude(***REMOVED***;
      case 'doctype':
        return this.parseDoctype(***REMOVED***;
      case 'filter':
        return this.parseFilter(***REMOVED***;
      case 'comment':
        return this.parseComment(***REMOVED***;
      case 'text':
        return this.parseText(***REMOVED***;
      case 'each':
        return this.parseEach(***REMOVED***;
      case 'code':
        return this.parseCode(***REMOVED***;
      case 'call':
        return this.parseCall(***REMOVED***;
      case 'interpolation':
        return this.parseInterpolation(***REMOVED***;
      case 'yield':
        this.advance(***REMOVED***;
        var block = new nodes.Block;
        block.yield = true;
        return block;
      case 'id':
      case 'class':
        var tok = this.advance(***REMOVED***;
        this.lexer.defer(this.lexer.tok('tag', 'div'***REMOVED******REMOVED***;
        this.lexer.defer(tok***REMOVED***;
        return this.parseExpr(***REMOVED***;
      default:
        throw new Error('unexpected token "' + this.peek(***REMOVED***.type + '"'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Text
   */

  parseText: function(***REMOVED***{
    var tok = this.expect('text'***REMOVED***;
    var tokens = this.parseTextWithInlineTags(tok.val***REMOVED***;
    if (tokens.length === 1***REMOVED*** return tokens[0];
    var node = new nodes.Block;
    for (var i = 0; i < tokens.length; i++***REMOVED*** {
      node.push(tokens[i]***REMOVED***;
  ***REMOVED***;
    return node;
***REMOVED***,

  /**
   *   ':' expr
   * | block
   */

  parseBlockExpansion: function(***REMOVED***{
    if (':' == this.peek(***REMOVED***.type***REMOVED*** {
      this.advance(***REMOVED***;
      return new nodes.Block(this.parseExpr(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.block(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * case
   */

  parseCase: function(***REMOVED***{
    var val = this.expect('case'***REMOVED***.val;
    var node = new nodes.Case(val***REMOVED***;
    node.line = this.line(***REMOVED***;

    var block = new nodes.Block;
    block.line = this.line(***REMOVED***;
    block.filename = this.filename;
    this.expect('indent'***REMOVED***;
    while ('outdent' != this.peek(***REMOVED***.type***REMOVED*** {
      switch (this.peek(***REMOVED***.type***REMOVED*** {
        case 'newline':
          this.advance(***REMOVED***;
          break;
        case 'when':
          block.push(this.parseWhen(***REMOVED******REMOVED***;
          break;
        case 'default':
          block.push(this.parseDefault(***REMOVED******REMOVED***;
          break;
        default:
          throw new Error('Unexpected token "' + this.peek(***REMOVED***.type
                          + '", expected "when", "default" or "newline"'***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    this.expect('outdent'***REMOVED***;

    node.block = block;

    return node;
***REMOVED***,

  /**
   * when
   */

  parseWhen: function(***REMOVED***{
    var val = this.expect('when'***REMOVED***.val;
    if (this.peek(***REMOVED***.type !== 'newline'***REMOVED***
      return new nodes.Case.When(val, this.parseBlockExpansion(***REMOVED******REMOVED***;
    else
      return new nodes.Case.When(val***REMOVED***;
***REMOVED***,

  /**
   * default
   */

  parseDefault: function(***REMOVED***{
    this.expect('default'***REMOVED***;
    return new nodes.Case.When('default', this.parseBlockExpansion(***REMOVED******REMOVED***;
***REMOVED***,

  /**
   * code
   */

  parseCode: function(afterIf***REMOVED***{
    var tok = this.expect('code'***REMOVED***;
    var node = new nodes.Code(tok.val, tok.buffer, tok.escape***REMOVED***;
    var block;
    node.line = this.line(***REMOVED***;

    // throw an error if an else does not have an if
    if (tok.isElse && !tok.hasIf***REMOVED*** {
      throw new Error('Unexpected else without if'***REMOVED***;
  ***REMOVED***

    // handle block
    block = 'indent' == this.peek(***REMOVED***.type;
    if (block***REMOVED*** {
      node.block = this.block(***REMOVED***;
  ***REMOVED***

    // handle missing block
    if (tok.requiresBlock && !block***REMOVED*** {
      node.block = new nodes.Block(***REMOVED***;
  ***REMOVED***

    // mark presense of if for future elses
    if (tok.isIf && this.peek(***REMOVED***.isElse***REMOVED*** {
      this.peek(***REMOVED***.hasIf = true;
  ***REMOVED*** else if (tok.isIf && this.peek(***REMOVED***.type === 'newline' && this.lookahead(2***REMOVED***.isElse***REMOVED*** {
      this.lookahead(2***REMOVED***.hasIf = true;
  ***REMOVED***

    return node;
***REMOVED***,

  /**
   * comment
   */

  parseComment: function(***REMOVED***{
    var tok = this.expect('comment'***REMOVED***;
    var node;

    if ('indent' == this.peek(***REMOVED***.type***REMOVED*** {
      this.lexer.pipeless = true;
      node = new nodes.BlockComment(tok.val, this.parseTextBlock(***REMOVED***, tok.buffer***REMOVED***;
      this.lexer.pipeless = false;
  ***REMOVED*** else {
      node = new nodes.Comment(tok.val, tok.buffer***REMOVED***;
  ***REMOVED***

    node.line = this.line(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * doctype
   */

  parseDoctype: function(***REMOVED***{
    var tok = this.expect('doctype'***REMOVED***;
    var node = new nodes.Doctype(tok.val***REMOVED***;
    node.line = this.line(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * filter attrs? text-block
   */

  parseFilter: function(***REMOVED***{
    var tok = this.expect('filter'***REMOVED***;
    var attrs = this.accept('attrs'***REMOVED***;
    var block;

    if ('indent' == this.peek(***REMOVED***.type***REMOVED*** {
      this.lexer.pipeless = true;
      block = this.parseTextBlock(***REMOVED***;
      this.lexer.pipeless = false;
  ***REMOVED*** else {
      block = new nodes.Block;
  ***REMOVED***

    var options = {};
    if (attrs***REMOVED*** {
      attrs.attrs.forEach(function (attribute***REMOVED*** {
        options[attribute.name] = constantinople.toConstant(attribute.val***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED***

    var node = new nodes.Filter(tok.val, block, options***REMOVED***;
    node.line = this.line(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * each block
   */

  parseEach: function(***REMOVED***{
    var tok = this.expect('each'***REMOVED***;
    var node = new nodes.Each(tok.code, tok.val, tok.key***REMOVED***;
    node.line = this.line(***REMOVED***;
    node.block = this.block(***REMOVED***;
    if (this.peek(***REMOVED***.type == 'code' && this.peek(***REMOVED***.val == 'else'***REMOVED*** {
      this.advance(***REMOVED***;
      node.alternative = this.block(***REMOVED***;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * Resolves a path relative to the template for use in
   * includes and extends
   *
   * @param {String}  path
   * @param {String}  purpose  Used in error messages.
   * @return {String}
   * @api private
   */

  resolvePath: function (path, purpose***REMOVED*** {
    var p = require('path'***REMOVED***;
    var dirname = p.dirname;
    var basename = p.basename;
    var join = p.join;

    if (path[0] !== '/' && !this.filename***REMOVED***
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths'***REMOVED***;

    if (path[0] === '/' && !this.options.basedir***REMOVED***
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths'***REMOVED***;

    path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename***REMOVED***, path***REMOVED***;

    if (basename(path***REMOVED***.indexOf('.'***REMOVED*** === -1***REMOVED*** path += '.jade';

    return path;
***REMOVED***,

  /**
   * 'extends' name
   */

  parseExtends: function(***REMOVED***{
    var fs = require('fs'***REMOVED***;

    var path = this.resolvePath(this.expect('extends'***REMOVED***.val.trim(***REMOVED***, 'extends'***REMOVED***;
    if ('.jade' != path.substr(-5***REMOVED******REMOVED*** path += '.jade';

    var str = fs.readFileSync(path, 'utf8'***REMOVED***;
    var parser = new this.constructor(str, path, this.options***REMOVED***;

    parser.blocks = this.blocks;
    parser.contexts = this.contexts;
    this.extending = parser;

    // TODO: null node
    return new nodes.Literal(''***REMOVED***;
***REMOVED***,

  /**
   * 'block' name block
   */

  parseBlock: function(***REMOVED***{
    var block = this.expect('block'***REMOVED***;
    var mode = block.mode;
    var name = block.val.trim(***REMOVED***;

    block = 'indent' == this.peek(***REMOVED***.type
      ? this.block(***REMOVED***
      : new nodes.Block(new nodes.Literal(''***REMOVED******REMOVED***;

    var prev = this.blocks[name] || {prepended: [], appended: []}
    if (prev.mode === 'replace'***REMOVED*** return this.blocks[name] = prev;

    var allNodes = prev.prepended.concat(block.nodes***REMOVED***.concat(prev.appended***REMOVED***;

    switch (mode***REMOVED*** {
      case 'append':
        prev.appended = prev.parser === this ?
                        prev.appended.concat(block.nodes***REMOVED*** :
                        block.nodes.concat(prev.appended***REMOVED***;
        break;
      case 'prepend':
        prev.prepended = prev.parser === this ?
                         block.nodes.concat(prev.prepended***REMOVED*** :
                         prev.prepended.concat(block.nodes***REMOVED***;
        break;
  ***REMOVED***
    block.nodes = allNodes;
    block.appended = prev.appended;
    block.prepended = prev.prepended;
    block.mode = mode;
    block.parser = this;

    return this.blocks[name] = block;
***REMOVED***,

  parseMixinBlock: function (***REMOVED*** {
    var block = this.expect('mixin-block'***REMOVED***;
    if (!this.inMixin***REMOVED*** {
      throw new Error('Anonymous blocks are not allowed unless they are part of a mixin.'***REMOVED***;
  ***REMOVED***
    return new nodes.MixinBlock(***REMOVED***;
***REMOVED***,

  /**
   * include block?
   */

  parseInclude: function(***REMOVED***{
    var fs = require('fs'***REMOVED***;
    var tok = this.expect('include'***REMOVED***;

    var path = this.resolvePath(tok.val.trim(***REMOVED***, 'include'***REMOVED***;

    // has-filter
    if (tok.filter***REMOVED*** {
      var str = fs.readFileSync(path, 'utf8'***REMOVED***.replace(/\r/g, ''***REMOVED***;
      str = filters(tok.filter, str, { filename: path }***REMOVED***;
      return new nodes.Literal(str***REMOVED***;
  ***REMOVED***

    // non-jade
    if ('.jade' != path.substr(-5***REMOVED******REMOVED*** {
      var str = fs.readFileSync(path, 'utf8'***REMOVED***.replace(/\r/g, ''***REMOVED***;
      return new nodes.Literal(str***REMOVED***;
  ***REMOVED***

    var str = fs.readFileSync(path, 'utf8'***REMOVED***;
    var parser = new this.constructor(str, path, this.options***REMOVED***;
    parser.blocks = utils.merge({}, this.blocks***REMOVED***;

    parser.mixins = this.mixins;

    this.context(parser***REMOVED***;
    var ast = parser.parse(***REMOVED***;
    this.context(***REMOVED***;
    ast.filename = path;

    if ('indent' == this.peek(***REMOVED***.type***REMOVED*** {
      ast.includeBlock(***REMOVED***.push(this.block(***REMOVED******REMOVED***;
  ***REMOVED***

    return ast;
***REMOVED***,

  /**
   * call ident block
   */

  parseCall: function(***REMOVED***{
    var tok = this.expect('call'***REMOVED***;
    var name = tok.val;
    var args = tok.args;
    var mixin = new nodes.Mixin(name, args, new nodes.Block, true***REMOVED***;

    this.tag(mixin***REMOVED***;
    if (mixin.code***REMOVED*** {
      mixin.block.push(mixin.code***REMOVED***;
      mixin.code = null;
  ***REMOVED***
    if (mixin.block.isEmpty(***REMOVED******REMOVED*** mixin.block = null;
    return mixin;
***REMOVED***,

  /**
   * mixin block
   */

  parseMixin: function(***REMOVED***{
    var tok = this.expect('mixin'***REMOVED***;
    var name = tok.val;
    var args = tok.args;
    var mixin;

    // definition
    if ('indent' == this.peek(***REMOVED***.type***REMOVED*** {
      this.inMixin = true;
      mixin = new nodes.Mixin(name, args, this.block(***REMOVED***, false***REMOVED***;
      this.mixins[name] = mixin;
      this.inMixin = false;
      return mixin;
    // call
  ***REMOVED*** else {
      return new nodes.Mixin(name, args, null, true***REMOVED***;
  ***REMOVED***
***REMOVED***,

  parseTextWithInlineTags: function (str***REMOVED*** {
    var line = this.line(***REMOVED***;

    var match = /(\\***REMOVED***?#\[((?:.|\n***REMOVED*******REMOVED***$/.exec(str***REMOVED***;
    if (match***REMOVED*** {
      if (match[1]***REMOVED*** { // escape
        var text = new nodes.Text(str.substr(0, match.index***REMOVED*** + '#['***REMOVED***;
        text.line = line;
        var rest = this.parseTextWithInlineTags(match[2]***REMOVED***;
        if (rest[0].type === 'Text'***REMOVED*** {
          text.val += rest[0].val;
          rest.shift(***REMOVED***;
      ***REMOVED***
        return [text].concat(rest***REMOVED***;
    ***REMOVED*** else {
        var text = new nodes.Text(str.substr(0, match.index***REMOVED******REMOVED***;
        text.line = line;
        var buffer = [text];
        var rest = match[2];
        var range = parseJSExpression(rest***REMOVED***;
        var inner = new Parser(range.src, this.filename, this.options***REMOVED***;
        buffer.push(inner.parse(***REMOVED******REMOVED***;
        return buffer.concat(this.parseTextWithInlineTags(rest.substr(range.end + 1***REMOVED******REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      var text = new nodes.Text(str***REMOVED***;
      text.line = line;
      return [text];
  ***REMOVED***
***REMOVED***,

  /**
   * indent (text | newline***REMOVED**** outdent
   */

  parseTextBlock: function(***REMOVED***{
    var block = new nodes.Block;
    block.line = this.line(***REMOVED***;
    var spaces = this.expect('indent'***REMOVED***.val;
    if (null == this._spaces***REMOVED*** this._spaces = spaces;
    var indent = Array(spaces - this._spaces + 1***REMOVED***.join(' '***REMOVED***;
    while ('outdent' != this.peek(***REMOVED***.type***REMOVED*** {
      switch (this.peek(***REMOVED***.type***REMOVED*** {
        case 'newline':
          this.advance(***REMOVED***;
          break;
        case 'indent':
          this.parseTextBlock(true***REMOVED***.nodes.forEach(function(node***REMOVED***{
            block.push(node***REMOVED***;
        ***REMOVED******REMOVED***;
          break;
        default:
          var texts = this.parseTextWithInlineTags(indent + this.advance(***REMOVED***.val***REMOVED***;
          texts.forEach(function (text***REMOVED*** {
            block.push(text***REMOVED***;
        ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***

    if (spaces == this._spaces***REMOVED*** this._spaces = null;
    this.expect('outdent'***REMOVED***;

    return block;
***REMOVED***,

  /**
   * indent expr* outdent
   */

  block: function(***REMOVED***{
    var block = new nodes.Block;
    block.line = this.line(***REMOVED***;
    block.filename = this.filename;
    this.expect('indent'***REMOVED***;
    while ('outdent' != this.peek(***REMOVED***.type***REMOVED*** {
      if ('newline' == this.peek(***REMOVED***.type***REMOVED*** {
        this.advance(***REMOVED***;
    ***REMOVED*** else {
        var expr = this.parseExpr(***REMOVED***;
        expr.filename = this.filename;
        block.push(expr***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    this.expect('outdent'***REMOVED***;
    return block;
***REMOVED***,

  /**
   * interpolation (attrs | class | id***REMOVED**** (text | code | ':'***REMOVED***? newline* block?
   */

  parseInterpolation: function(***REMOVED***{
    var tok = this.advance(***REMOVED***;
    var tag = new nodes.Tag(tok.val***REMOVED***;
    tag.buffer = true;
    return this.tag(tag***REMOVED***;
***REMOVED***,

  /**
   * tag (attrs | class | id***REMOVED**** (text | code | ':'***REMOVED***? newline* block?
   */

  parseTag: function(***REMOVED***{
    var tok = this.advance(***REMOVED***;
    var tag = new nodes.Tag(tok.val***REMOVED***;

    tag.selfClosing = tok.selfClosing;

    return this.tag(tag***REMOVED***;
***REMOVED***,

  /**
   * Parse tag.
   */

  tag: function(tag***REMOVED***{
    tag.line = this.line(***REMOVED***;

    var seenAttrs = false;
    // (attrs | class | id***REMOVED****
    out:
      while (true***REMOVED*** {
        switch (this.peek(***REMOVED***.type***REMOVED*** {
          case 'id':
          case 'class':
            var tok = this.advance(***REMOVED***;
            tag.setAttribute(tok.type, "'" + tok.val + "'"***REMOVED***;
            continue;
          case 'attrs':
            if (seenAttrs***REMOVED*** {
              console.warn(this.filename + ', line ' + this.peek(***REMOVED***.line + ':\nYou should not have jade tags with multiple attributes.'***REMOVED***;
          ***REMOVED***
            seenAttrs = true;
            var tok = this.advance(***REMOVED***;
            var attrs = tok.attrs;

            if (tok.selfClosing***REMOVED*** tag.selfClosing = true;

            for (var i = 0; i < attrs.length; i++***REMOVED*** {
              tag.setAttribute(attrs[i].name, attrs[i].val, attrs[i].escaped***REMOVED***;
          ***REMOVED***
            continue;
          case '&attributes':
            var tok = this.advance(***REMOVED***;
            tag.addAttributes(tok.val***REMOVED***;
            break;
          default:
            break out;
      ***REMOVED***
    ***REMOVED***

    // check immediate '.'
    if ('dot' == this.peek(***REMOVED***.type***REMOVED*** {
      tag.textOnly = true;
      this.advance(***REMOVED***;
  ***REMOVED***

    // (text | code | ':'***REMOVED***?
    switch (this.peek(***REMOVED***.type***REMOVED*** {
      case 'text':
        tag.block.push(this.parseText(***REMOVED******REMOVED***;
        break;
      case 'code':
        tag.code = this.parseCode(***REMOVED***;
        break;
      case ':':
        this.advance(***REMOVED***;
        tag.block = new nodes.Block;
        tag.block.push(this.parseExpr(***REMOVED******REMOVED***;
        break;
      case 'newline':
      case 'indent':
      case 'outdent':
      case 'eos':
        break;
      default:
        throw new Error('Unexpected token `' + this.peek(***REMOVED***.type + '` expected `text`, `code`, `:`, `newline` or `eos`'***REMOVED***
  ***REMOVED***

    // newline*
    while ('newline' == this.peek(***REMOVED***.type***REMOVED*** this.advance(***REMOVED***;

    // block?
    if ('indent' == this.peek(***REMOVED***.type***REMOVED*** {
      if (tag.textOnly***REMOVED*** {
        this.lexer.pipeless = true;
        tag.block = this.parseTextBlock(***REMOVED***;
        this.lexer.pipeless = false;
    ***REMOVED*** else {
        var block = this.block(***REMOVED***;
        for (var i = 0, len = block.nodes.length; i < len; ++i***REMOVED*** {
          tag.block.push(block.nodes[i]***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return tag;
***REMOVED***
};
