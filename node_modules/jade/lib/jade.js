'use strict';

/*!
 * Jade
 * Copyright(c***REMOVED*** 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Parser = require('./parser'***REMOVED***
  , Lexer = require('./lexer'***REMOVED***
  , Compiler = require('./compiler'***REMOVED***
  , runtime = require('./runtime'***REMOVED***
  , addWith = require('with'***REMOVED***
  , fs = require('fs'***REMOVED***;

/**
 * Expose self closing tags.
 */

exports.selfClosing = require('./self-closing'***REMOVED***;

/**
 * Default supported doctypes.
 */

exports.doctypes = require('./doctypes'***REMOVED***;

/**
 * Text filters.
 */

exports.filters = require('./filters'***REMOVED***;

/**
 * Utilities.
 */

exports.utils = require('./utils'***REMOVED***;

/**
 * Expose `Compiler`.
 */

exports.Compiler = Compiler;

/**
 * Expose `Parser`.
 */

exports.Parser = Parser;

/**
 * Expose `Lexer`.
 */

exports.Lexer = Lexer;

/**
 * Nodes.
 */

exports.nodes = require('./nodes'***REMOVED***;

/**
 * Jade runtime helpers.
 */

exports.runtime = runtime;

/**
 * Template function cache.
 */

exports.cache = {};

/**
 * Parse the given `str` of jade and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api private
 */

function parse(str, options***REMOVED***{
  // Parse
  var parser = new (options.parser || Parser***REMOVED***(str, options.filename, options***REMOVED***;
  var tokens;
  try {
    // Parse
    tokens = parser.parse(***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    parser = parser.context(***REMOVED***;
    runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input***REMOVED***;
***REMOVED***

  // Compile
  var compiler = new (options.compiler || Compiler***REMOVED***(tokens, options***REMOVED***;
  var js;
  try {
    js = compiler.compile(***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    if (err.line && (err.filename || !options.filename***REMOVED******REMOVED*** {
      runtime.rethrow(err, err.filename, err.line, parser.input***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Debug compiler
  if (options.debug***REMOVED*** {
    console.error('\nCompiled Function:\n\n\u001b[90m%s\u001b[0m', js.replace(/^/gm, '  '***REMOVED******REMOVED***;
***REMOVED***

  var globals = [];

  globals.push('jade'***REMOVED***;
  globals.push('jade_mixins'***REMOVED***;
  globals.push('jade_interp'***REMOVED***;
  globals.push('jade_debug'***REMOVED***;
  globals.push('buf'***REMOVED***;

  return ''
    + 'var buf = [];\n'
    + 'var jade_mixins = {};\n'
    + 'var jade_interp;\n'
    + (options.self
      ? 'var self = locals || {};\n' + js
      : addWith('locals || {}', '\n' + js, globals***REMOVED******REMOVED*** + ';'
    + 'return buf.join(""***REMOVED***;';
}

/**
 * Compile a `Function` representation of the given jade `str`.
 *
 * Options:
 *
 *   - `compileDebug` when `false` debugging code is stripped from the compiled
       template, when it is explicitly `true`, the source code is included in
       the compiled template for better accuracy.
 *   - `filename` used to improve errors when `compileDebug` is not `false` and to resolve imports/extends
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options***REMOVED***{
  var options = options || {}
    , filename = options.filename
      ? JSON.stringify(options.filename***REMOVED***
      : 'undefined'
    , fn;

  str = String(str***REMOVED***;

  if (options.compileDebug !== false***REMOVED*** {
    fn = [
        'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
      , 'try {'
      , parse(str, options***REMOVED***
      , '} catch (err***REMOVED*** {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno' + (options.compileDebug === true ? ',' + JSON.stringify(str***REMOVED*** : ''***REMOVED*** + '***REMOVED***;'
      , '}'
    ].join('\n'***REMOVED***;
***REMOVED*** else {
    fn = parse(str, options***REMOVED***;
***REMOVED***
  fn = new Function('locals, jade', fn***REMOVED***
  var res = function(locals***REMOVED***{ return fn(locals, Object.create(runtime***REMOVED******REMOVED*** };
  if (options.client***REMOVED*** {
    res.toString = function (***REMOVED*** {
      var err = new Error('The `client` option is deprecated, use `jade.compileClient`'***REMOVED***;
      console.error(err.stack || err.message***REMOVED***;
      return exports.compileClient(str, options***REMOVED***;
  ***REMOVED***;
***REMOVED***
  return res;
};

/**
 * Compile a JavaScript source representation of the given jade `str`.
 *
 * Options:
 *
 *   - `compileDebug` When it is `true`, the source code is included in
       the compiled template for better error messages.
 *   - `filename` used to improve errors when `compileDebug` is not `true` and to resolve imports/extends
 *
 * @param {String} str
 * @param {Options} options
 * @return {String}
 * @api public
 */

exports.compileClient = function(str, options***REMOVED***{
  var options = options || {}
    , filename = options.filename
      ? JSON.stringify(options.filename***REMOVED***
      : 'undefined'
    , fn;

  str = String(str***REMOVED***;

  if (options.compileDebug***REMOVED*** {
    options.compileDebug = true;
    fn = [
        'var jade_debug = [{ lineno: 1, filename: ' + filename + ' }];'
      , 'try {'
      , parse(str, options***REMOVED***
      , '} catch (err***REMOVED*** {'
      , '  jade.rethrow(err, jade_debug[0].filename, jade_debug[0].lineno, ' + JSON.stringify(str***REMOVED*** + '***REMOVED***;'
      , '}'
    ].join('\n'***REMOVED***;
***REMOVED*** else {
    options.compileDebug = false;
    fn = parse(str, options***REMOVED***;
***REMOVED***

  return 'function template(locals***REMOVED*** {\n' + fn + '\n}';
};



/**
 * Render the given `str` of jade.
 *
 * Options:
 *
 *   - `cache` enable template caching
 *   - `filename` filename required for `include` / `extends` and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */

exports.render = function(str, options, fn***REMOVED***{
  // support callback API
  if ('function' == typeof options***REMOVED*** {
    fn = options, options = undefined;
***REMOVED***
  if (typeof fn === 'function'***REMOVED*** {
    var res
    try {
      res = exports.render(str, options***REMOVED***;
  ***REMOVED*** catch (ex***REMOVED*** {
      return fn(ex***REMOVED***;
  ***REMOVED***
    return fn(null, res***REMOVED***;
***REMOVED***

  options = options || {};

  // cache requires .filename
  if (options.cache && !options.filename***REMOVED*** {
    throw new Error('the "filename" option is required for caching'***REMOVED***;
***REMOVED***

  var path = options.filename;
  var tmpl = options.cache
    ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options***REMOVED******REMOVED***
    : exports.compile(str, options***REMOVED***;
  return tmpl(options***REMOVED***;
};

/**
 * Render a Jade file at the given `path`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function|undefined} fn
 * @returns {String}
 * @api public
 */

exports.renderFile = function(path, options, fn***REMOVED***{
  // support callback API
  if ('function' == typeof options***REMOVED*** {
    fn = options, options = undefined;
***REMOVED***
  if (typeof fn === 'function'***REMOVED*** {
    var res
    try {
      res = exports.renderFile(path, options***REMOVED***;
  ***REMOVED*** catch (ex***REMOVED*** {
      return fn(ex***REMOVED***;
  ***REMOVED***
    return fn(null, res***REMOVED***;
***REMOVED***

  options = options || {};

  var key = path + ':string';

  options.filename = path;
  var str = options.cache
    ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'***REMOVED******REMOVED***
    : fs.readFileSync(path, 'utf8'***REMOVED***;
  return exports.render(str, options***REMOVED***;
};


/**
 * Compile a Jade file at the given `path` for use on the client.
 *
 * @param {String} path
 * @param {Object} options
 * @returns {String}
 * @api public
 */

exports.compileFileClient = function(path, options***REMOVED***{
  options = options || {};

  var key = path + ':string';

  options.filename = path;
  var str = options.cache
    ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'***REMOVED******REMOVED***
    : fs.readFileSync(path, 'utf8'***REMOVED***;

  return exports.compileClient(str, options***REMOVED***;
};

/**
 * Express support.
 */

exports.__express = exports.renderFile;
