'use strict';

var nodes = require('./nodes'***REMOVED***;
var filters = require('./filters'***REMOVED***;
var doctypes = require('./doctypes'***REMOVED***;
var runtime = require('./runtime'***REMOVED***;
var utils = require('./utils'***REMOVED***;
var selfClosing = require('./self-closing'***REMOVED***;
var parseJSExpression = require('character-parser'***REMOVED***.parseMax;
var constantinople = require('constantinople'***REMOVED***;

function isConstant(src***REMOVED*** {
  return constantinople(src, {jade: runtime, 'jade_interp': undefined}***REMOVED***;
}
function toConstant(src***REMOVED*** {
  return constantinople.toConstant(src, {jade: runtime, 'jade_interp': undefined}***REMOVED***;
}
function errorAtNode(node, error***REMOVED*** {
  error.line = node.line;
  error.filename = node.filename;
  return error;
}

/**
 * Initialize `Compiler` with the given `node`.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */

var Compiler = module.exports = function Compiler(node, options***REMOVED*** {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  this.terse = false;
  this.mixins = {};
  this.dynamicMixins = false;
  if (options.doctype***REMOVED*** this.setDoctype(options.doctype***REMOVED***;
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {

  /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */

  compile: function(***REMOVED***{
    this.buf = [];
    if (this.pp***REMOVED*** this.buf.push("var jade_indent = [];"***REMOVED***;
    this.lastBufferedIdx = -1;
    this.visit(this.node***REMOVED***;
    if (!this.dynamicMixins***REMOVED*** {
      // if there are no dynamic mixins we can remove any un-used mixins
      var mixinNames = Object.keys(this.mixins***REMOVED***;
      for (var i = 0; i < mixinNames.length; i++***REMOVED*** {
        var mixin = this.mixins[mixinNames[i]];
        if (!mixin.used***REMOVED*** {
          for (var x = 0; x < mixin.instances.length; x++***REMOVED*** {
            for (var y = mixin.instances[x].start; y < mixin.instances[x].end; y++***REMOVED*** {
              this.buf[y] = '';
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return this.buf.join('\n'***REMOVED***;
***REMOVED***,

  /**
   * Sets the default doctype `name`. Sets terse mode to `true` when
   * html 5 is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */

  setDoctype: function(name***REMOVED***{
    this.doctype = doctypes[name.toLowerCase(***REMOVED***] || '<!DOCTYPE ' + name + '>';
    this.terse = this.doctype.toLowerCase(***REMOVED*** == '<!doctype html>';
    this.xml = 0 == this.doctype.indexOf('<?xml'***REMOVED***;
***REMOVED***,

  /**
   * Buffer the given `str` exactly as is or with interpolation
   *
   * @param {String} str
   * @param {Boolean} interpolate
   * @api public
   */

  buffer: function (str, interpolate***REMOVED*** {
    var self = this;
    if (interpolate***REMOVED*** {
      var match = /(\\***REMOVED***?([#!]***REMOVED***{((?:.|\n***REMOVED*******REMOVED***$/.exec(str***REMOVED***;
      if (match***REMOVED*** {
        this.buffer(str.substr(0, match.index***REMOVED***, false***REMOVED***;
        if (match[1]***REMOVED*** { // escape
          this.buffer(match[2] + '{', false***REMOVED***;
          this.buffer(match[3], true***REMOVED***;
          return;
      ***REMOVED*** else {
          var rest = match[3];
          var range = parseJSExpression(rest***REMOVED***;
          var code = ('!' == match[2] ? '' : 'jade.escape'***REMOVED*** + "((jade_interp = " + range.src + "***REMOVED*** == null ? '' : jade_interp***REMOVED***";
          this.bufferExpression(code***REMOVED***;
          this.buffer(rest.substr(range.end + 1***REMOVED***, true***REMOVED***;
          return;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    str = JSON.stringify(str***REMOVED***;
    str = str.substr(1, str.length - 2***REMOVED***;

    if (this.lastBufferedIdx == this.buf.length***REMOVED*** {
      if (this.lastBufferedType === 'code'***REMOVED*** this.lastBuffered += ' + "';
      this.lastBufferedType = 'text';
      this.lastBuffered += str;
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '"***REMOVED***;'
  ***REMOVED*** else {
      this.buf.push('buf.push("' + str + '"***REMOVED***;'***REMOVED***;
      this.lastBufferedType = 'text';
      this.bufferStartChar = '"';
      this.lastBuffered = str;
      this.lastBufferedIdx = this.buf.length;
  ***REMOVED***
***REMOVED***,

  /**
   * Buffer the given `src` so it is evaluated at run time
   *
   * @param {String} src
   * @api public
   */

  bufferExpression: function (src***REMOVED*** {
    if (isConstant(src***REMOVED******REMOVED*** {
      return this.buffer(toConstant(src***REMOVED*** + '', false***REMOVED***
  ***REMOVED***
    if (this.lastBufferedIdx == this.buf.length***REMOVED*** {
      if (this.lastBufferedType === 'text'***REMOVED*** this.lastBuffered += '"';
      this.lastBufferedType = 'code';
      this.lastBuffered += ' + (' + src + '***REMOVED***';
      this.buf[this.lastBufferedIdx - 1] = 'buf.push(' + this.bufferStartChar + this.lastBuffered + '***REMOVED***;'
  ***REMOVED*** else {
      this.buf.push('buf.push(' + src + '***REMOVED***;'***REMOVED***;
      this.lastBufferedType = 'code';
      this.bufferStartChar = '';
      this.lastBuffered = '(' + src + '***REMOVED***';
      this.lastBufferedIdx = this.buf.length;
  ***REMOVED***
***REMOVED***,

  /**
   * Buffer an indent based on the current `indent`
   * property and an additional `offset`.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */

  prettyIndent: function(offset, newline***REMOVED***{
    offset = offset || 0;
    newline = newline ? '\n' : '';
    this.buffer(newline + Array(this.indents + offset***REMOVED***.join('  '***REMOVED******REMOVED***;
    if (this.parentIndents***REMOVED***
      this.buf.push("buf.push.apply(buf, jade_indent***REMOVED***;"***REMOVED***;
***REMOVED***,

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visit: function(node***REMOVED***{
    var debug = this.debug;

    if (debug***REMOVED*** {
      this.buf.push('jade_debug.unshift({ lineno: ' + node.line
        + ', filename: ' + (node.filename
          ? JSON.stringify(node.filename***REMOVED***
          : 'jade_debug[0].filename'***REMOVED***
        + ' }***REMOVED***;'***REMOVED***;
  ***REMOVED***

    // Massive hack to fix our context
    // stack for - else[ if] etc
    if (false === node.debug && this.debug***REMOVED*** {
      this.buf.pop(***REMOVED***;
      this.buf.pop(***REMOVED***;
  ***REMOVED***

    this.visitNode(node***REMOVED***;

    if (debug***REMOVED*** this.buf.push('jade_debug.shift(***REMOVED***;'***REMOVED***;
***REMOVED***,

  /**
   * Visit `node`.
   *
   * @param {Node} node
   * @api public
   */

  visitNode: function(node***REMOVED***{
    return this['visit' + node.type](node***REMOVED***;
***REMOVED***,

  /**
   * Visit case `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitCase: function(node***REMOVED***{
    var _ = this.withinCase;
    this.withinCase = true;
    this.buf.push('switch (' + node.expr + '***REMOVED***{'***REMOVED***;
    this.visit(node.block***REMOVED***;
    this.buf.push('}'***REMOVED***;
    this.withinCase = _;
***REMOVED***,

  /**
   * Visit when `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitWhen: function(node***REMOVED***{
    if ('default' == node.expr***REMOVED*** {
      this.buf.push('default:'***REMOVED***;
  ***REMOVED*** else {
      this.buf.push('case ' + node.expr + ':'***REMOVED***;
  ***REMOVED***
    if (node.block***REMOVED*** {
      this.visit(node.block***REMOVED***;
      this.buf.push('  break;'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Visit literal `node`.
   *
   * @param {Literal} node
   * @api public
   */

  visitLiteral: function(node***REMOVED***{
    this.buffer(node.str***REMOVED***;
***REMOVED***,

  /**
   * Visit all nodes in `block`.
   *
   * @param {Block} block
   * @api public
   */

  visitBlock: function(block***REMOVED***{
    var len = block.nodes.length
      , escape = this.escape
      , pp = this.pp

    // Pretty print multi-line text
    if (pp && len > 1 && !escape && block.nodes[0].isText && block.nodes[1].isText***REMOVED***
      this.prettyIndent(1, true***REMOVED***;

    for (var i = 0; i < len; ++i***REMOVED*** {
      // Pretty print text
      if (pp && i > 0 && !escape && block.nodes[i].isText && block.nodes[i-1].isText***REMOVED***
        this.prettyIndent(1, false***REMOVED***;

      this.visit(block.nodes[i]***REMOVED***;
      // Multiple text nodes are separated by newlines
      if (block.nodes[i+1] && block.nodes[i].isText && block.nodes[i+1].isText***REMOVED***
        this.buffer('\n'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Visit a mixin's `block` keyword.
   *
   * @param {MixinBlock} block
   * @api public
   */

  visitMixinBlock: function(block***REMOVED***{
    if (this.pp***REMOVED*** this.buf.push("jade_indent.push('" + Array(this.indents + 1***REMOVED***.join('  '***REMOVED*** + "'***REMOVED***;"***REMOVED***;
    this.buf.push('block && block(***REMOVED***;'***REMOVED***;
    if (this.pp***REMOVED*** this.buf.push("jade_indent.pop(***REMOVED***;"***REMOVED***;
***REMOVED***,

  /**
   * Visit `doctype`. Sets terse mode to `true` when html 5
   * is used, causing self-closing tags to end with ">" vs "/>",
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */

  visitDoctype: function(doctype***REMOVED***{
    if (doctype && (doctype.val || !this.doctype***REMOVED******REMOVED*** {
      this.setDoctype(doctype.val || 'default'***REMOVED***;
  ***REMOVED***

    if (this.doctype***REMOVED*** this.buffer(this.doctype***REMOVED***;
    this.hasCompiledDoctype = true;
***REMOVED***,

  /**
   * Visit `mixin`, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */

  visitMixin: function(mixin***REMOVED***{
    var name = 'jade_mixins[';
    var args = mixin.args || '';
    var block = mixin.block;
    var attrs = mixin.attrs;
    var attrsBlocks = mixin.attributeBlocks;
    var pp = this.pp;
    var dynamic = mixin.name[0]==='#';
    var key = mixin.name;
    if (dynamic***REMOVED*** this.dynamicMixins = true;
    name += (dynamic ? mixin.name.substr(2,mixin.name.length-3***REMOVED***:'"'+mixin.name+'"'***REMOVED***+']';

    this.mixins[key] = this.mixins[key] || {used: false, instances: []};
    if (mixin.call***REMOVED*** {
      this.mixins[key].used = true;
      if (pp***REMOVED*** this.buf.push("jade_indent.push('" + Array(this.indents + 1***REMOVED***.join('  '***REMOVED*** + "'***REMOVED***;"***REMOVED***
      if (block || attrs.length || attrsBlocks.length***REMOVED*** {

        this.buf.push(name + '.call({'***REMOVED***;

        if (block***REMOVED*** {
          this.buf.push('block: function(***REMOVED***{'***REMOVED***;

          // Render block with no indents, dynamically added when rendered
          this.parentIndents++;
          var _indents = this.indents;
          this.indents = 0;
          this.visit(mixin.block***REMOVED***;
          this.indents = _indents;
          this.parentIndents--;

          if (attrs.length || attrsBlocks.length***REMOVED*** {
            this.buf.push('},'***REMOVED***;
        ***REMOVED*** else {
            this.buf.push('}'***REMOVED***;
        ***REMOVED***
      ***REMOVED***

        if (attrsBlocks.length***REMOVED*** {
          if (attrs.length***REMOVED*** {
            var val = this.attrs(attrs***REMOVED***;
            attrsBlocks.unshift(val***REMOVED***;
        ***REMOVED***
          this.buf.push('attributes: jade.merge([' + attrsBlocks.join(','***REMOVED*** + ']***REMOVED***'***REMOVED***;
      ***REMOVED*** else if (attrs.length***REMOVED*** {
          var val = this.attrs(attrs***REMOVED***;
          this.buf.push('attributes: ' + val***REMOVED***;
      ***REMOVED***

        if (args***REMOVED*** {
          this.buf.push('}, ' + args + '***REMOVED***;'***REMOVED***;
      ***REMOVED*** else {
          this.buf.push('}***REMOVED***;'***REMOVED***;
      ***REMOVED***

    ***REMOVED*** else {
        this.buf.push(name + '(' + args + '***REMOVED***;'***REMOVED***;
    ***REMOVED***
      if (pp***REMOVED*** this.buf.push("jade_indent.pop(***REMOVED***;"***REMOVED***
  ***REMOVED*** else {
      var mixin_start = this.buf.length;
      this.buf.push(name + ' = function(' + args + '***REMOVED***{'***REMOVED***;
      this.buf.push('var block = (this && this.block***REMOVED***, attributes = (this && this.attributes***REMOVED*** || {};'***REMOVED***;
      this.parentIndents++;
      this.visit(block***REMOVED***;
      this.parentIndents--;
      this.buf.push('};'***REMOVED***;
      var mixin_end = this.buf.length;
      this.mixins[key].instances.push({start: mixin_start, end: mixin_end}***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Visit `tag` buffering tag markup, generating
   * attributes, visiting the `tag`'s code and block.
   *
   * @param {Tag} tag
   * @api public
   */

  visitTag: function(tag***REMOVED***{
    this.indents++;
    var name = tag.name
      , pp = this.pp
      , self = this;

    function bufferName(***REMOVED*** {
      if (tag.buffer***REMOVED*** self.bufferExpression(name***REMOVED***;
      else self.buffer(name***REMOVED***;
  ***REMOVED***

    if ('pre' == tag.name***REMOVED*** this.escape = true;

    if (!this.hasCompiledTag***REMOVED*** {
      if (!this.hasCompiledDoctype && 'html' == name***REMOVED*** {
        this.visitDoctype(***REMOVED***;
    ***REMOVED***
      this.hasCompiledTag = true;
  ***REMOVED***

    // pretty print
    if (pp && !tag.isInline(***REMOVED******REMOVED***
      this.prettyIndent(0, true***REMOVED***;

    if (tag.selfClosing || (!this.xml && selfClosing.indexOf(tag.name***REMOVED*** !== -1***REMOVED******REMOVED*** {
      this.buffer('<'***REMOVED***;
      bufferName(***REMOVED***;
      this.visitAttributes(tag.attrs, tag.attributeBlocks***REMOVED***;
      this.terse
        ? this.buffer('>'***REMOVED***
        : this.buffer('/>'***REMOVED***;
      // if it is non-empty throw an error
      if (tag.block &&
          !(tag.block.type === 'Block' && tag.block.nodes.length === 0***REMOVED*** &&
          tag.block.nodes.some(function (tag***REMOVED*** {
            return tag.type !== 'Text' || !/^\s*$/.test(tag.val***REMOVED***
        ***REMOVED******REMOVED******REMOVED*** {
        throw errorAtNode(tag, new Error(name + ' is self closing and should not have content.'***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      // Optimize attributes buffering
      this.buffer('<'***REMOVED***;
      bufferName(***REMOVED***;
      this.visitAttributes(tag.attrs, tag.attributeBlocks***REMOVED***;
      this.buffer('>'***REMOVED***;
      if (tag.code***REMOVED*** this.visitCode(tag.code***REMOVED***;
      this.visit(tag.block***REMOVED***;

      // pretty print
      if (pp && !tag.isInline(***REMOVED*** && 'pre' != tag.name && !tag.canInline(***REMOVED******REMOVED***
        this.prettyIndent(0, true***REMOVED***;

      this.buffer('</'***REMOVED***;
      bufferName(***REMOVED***;
      this.buffer('>'***REMOVED***;
  ***REMOVED***

    if ('pre' == tag.name***REMOVED*** this.escape = false;

    this.indents--;
***REMOVED***,

  /**
   * Visit `filter`, throwing when the filter does not exist.
   *
   * @param {Filter} filter
   * @api public
   */

  visitFilter: function(filter***REMOVED***{
    var text = filter.block.nodes.map(
      function(node***REMOVED***{ return node.val; }
    ***REMOVED***.join('\n'***REMOVED***;
    filter.attrs.filename = this.options.filename;
    try {
      this.buffer(filters(filter.name, text, filter.attrs***REMOVED***, true***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
      throw errorAtNode(filter, err***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Visit `text` node.
   *
   * @param {Text} text
   * @api public
   */

  visitText: function(text***REMOVED***{
    this.buffer(text.val, true***REMOVED***;
***REMOVED***,

  /**
   * Visit a `comment`, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */

  visitComment: function(comment***REMOVED***{
    if (!comment.buffer***REMOVED*** return;
    if (this.pp***REMOVED*** this.prettyIndent(1, true***REMOVED***;
    this.buffer('<!--' + comment.val + '-->'***REMOVED***;
***REMOVED***,

  /**
   * Visit a `BlockComment`.
   *
   * @param {Comment} comment
   * @api public
   */

  visitBlockComment: function(comment***REMOVED***{
    if (!comment.buffer***REMOVED*** return;
    if (this.pp***REMOVED*** this.prettyIndent(1, true***REMOVED***;
    this.buffer('<!--' + comment.val***REMOVED***;
    this.visit(comment.block***REMOVED***;
    if (this.pp***REMOVED*** this.prettyIndent(1, true***REMOVED***;
    this.buffer('-->'***REMOVED***;
***REMOVED***,

  /**
   * Visit `code`, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */

  visitCode: function(code***REMOVED***{
    // Wrap code blocks with {}.
    // we only wrap unbuffered code blocks ATM
    // since they are usually flow control

    // Buffer code
    if (code.buffer***REMOVED*** {
      var val = code.val.trimLeft(***REMOVED***;
      val = 'null == (jade_interp = '+val+'***REMOVED*** ? "" : jade_interp';
      if (code.escape***REMOVED*** val = 'jade.escape(' + val + '***REMOVED***';
      this.bufferExpression(val***REMOVED***;
  ***REMOVED*** else {
      this.buf.push(code.val***REMOVED***;
  ***REMOVED***

    // Block support
    if (code.block***REMOVED*** {
      if (!code.buffer***REMOVED*** this.buf.push('{'***REMOVED***;
      this.visit(code.block***REMOVED***;
      if (!code.buffer***REMOVED*** this.buf.push('}'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Visit `each` block.
   *
   * @param {Each} each
   * @api public
   */

  visitEach: function(each***REMOVED***{
    this.buf.push(''
      + '// iterate ' + each.obj + '\n'
      + ';(function(***REMOVED***{\n'
      + '  var $$obj = ' + each.obj + ';\n'
      + '  if (\'number\' == typeof $$obj.length***REMOVED*** {\n'***REMOVED***;

    if (each.alternative***REMOVED*** {
      this.buf.push('  if ($$obj.length***REMOVED*** {'***REMOVED***;
  ***REMOVED***

    this.buf.push(''
      + '    for (var ' + each.key + ' = 0, $$l = $$obj.length; ' + each.key + ' < $$l; ' + each.key + '++***REMOVED*** {\n'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n'***REMOVED***;

    this.visit(each.block***REMOVED***;

    this.buf.push('  ***REMOVED***\n'***REMOVED***;

    if (each.alternative***REMOVED*** {
      this.buf.push('***REMOVED*** else {'***REMOVED***;
      this.visit(each.alternative***REMOVED***;
      this.buf.push('***REMOVED***'***REMOVED***;
  ***REMOVED***

    this.buf.push(''
      + '***REMOVED*** else {\n'
      + '    var $$l = 0;\n'
      + '    for (var ' + each.key + ' in $$obj***REMOVED*** {\n'
      + '      $$l++;'
      + '      var ' + each.val + ' = $$obj[' + each.key + '];\n'***REMOVED***;

    this.visit(each.block***REMOVED***;

    this.buf.push('  ***REMOVED***\n'***REMOVED***;
    if (each.alternative***REMOVED*** {
      this.buf.push('    if ($$l === 0***REMOVED*** {'***REMOVED***;
      this.visit(each.alternative***REMOVED***;
      this.buf.push('  ***REMOVED***'***REMOVED***;
  ***REMOVED***
    this.buf.push('***REMOVED***\n}***REMOVED***.call(this***REMOVED***;\n'***REMOVED***;
***REMOVED***,

  /**
   * Visit `attrs`.
   *
   * @param {Array} attrs
   * @api public
   */

  visitAttributes: function(attrs, attributeBlocks***REMOVED***{
    if (attributeBlocks.length***REMOVED*** {
      if (attrs.length***REMOVED*** {
        var val = this.attrs(attrs***REMOVED***;
        attributeBlocks.unshift(val***REMOVED***;
    ***REMOVED***
      this.bufferExpression('jade.attrs(jade.merge([' + attributeBlocks.join(','***REMOVED*** + ']***REMOVED***, ' + JSON.stringify(this.terse***REMOVED*** + '***REMOVED***'***REMOVED***;
  ***REMOVED*** else if (attrs.length***REMOVED*** {
      this.attrs(attrs, true***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Compile attributes.
   */

  attrs: function(attrs, buffer***REMOVED***{
    var buf = [];
    var classes = [];
    var classEscaping = [];

    attrs.forEach(function(attr***REMOVED***{
      var key = attr.name;
      var escaped = attr.escaped;

      if (key === 'class'***REMOVED*** {
        classes.push(attr.val***REMOVED***;
        classEscaping.push(attr.escaped***REMOVED***;
    ***REMOVED*** else if (isConstant(attr.val***REMOVED******REMOVED*** {
        if (buffer***REMOVED*** {
          this.buffer(runtime.attr(key, toConstant(attr.val***REMOVED***, escaped, this.terse***REMOVED******REMOVED***;
      ***REMOVED*** else {
          var val = toConstant(attr.val***REMOVED***;
          if (escaped && !(key.indexOf('data'***REMOVED*** === 0 && typeof val !== 'string'***REMOVED******REMOVED*** {
            val = runtime.escape(val***REMOVED***;
        ***REMOVED***
          buf.push(JSON.stringify(key***REMOVED*** + ': ' + JSON.stringify(val***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED*** else {
        if (buffer***REMOVED*** {
          this.bufferExpression('jade.attr("' + key + '", ' + attr.val + ', ' + JSON.stringify(escaped***REMOVED*** + ', ' + JSON.stringify(this.terse***REMOVED*** + '***REMOVED***'***REMOVED***;
      ***REMOVED*** else {
          var val = attr.val;
          if (escaped && !(key.indexOf('data'***REMOVED*** === 0***REMOVED******REMOVED*** {
            val = 'jade.escape(' + val + '***REMOVED***';
        ***REMOVED*** else if (escaped***REMOVED*** {
            val = '(typeof (jade_interp = ' + val + '***REMOVED*** == "string" ? jade.escape(jade_interp***REMOVED*** : jade_interp***REMOVED***';
        ***REMOVED***
          buf.push(JSON.stringify(key***REMOVED*** + ': ' + val***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***.bind(this***REMOVED******REMOVED***;
    if (buffer***REMOVED*** {
      if (classes.every(isConstant***REMOVED******REMOVED*** {
        this.buffer(runtime.cls(classes.map(toConstant***REMOVED***, classEscaping***REMOVED******REMOVED***;
    ***REMOVED*** else {
        this.bufferExpression('jade.cls([' + classes.join(','***REMOVED*** + '], ' + JSON.stringify(classEscaping***REMOVED*** + '***REMOVED***'***REMOVED***;
    ***REMOVED***
  ***REMOVED*** else if (classes.length***REMOVED*** {
      if (classes.every(isConstant***REMOVED******REMOVED*** {
        classes = JSON.stringify(runtime.joinClasses(classes.map(toConstant***REMOVED***.map(runtime.joinClasses***REMOVED***.map(function (cls, i***REMOVED*** {
          return classEscaping[i] ? runtime.escape(cls***REMOVED*** : cls;
      ***REMOVED******REMOVED******REMOVED******REMOVED***;
    ***REMOVED*** else {
        classes = '(jade_interp = ' + JSON.stringify(classEscaping***REMOVED*** + ',' +
          ' jade.joinClasses([' + classes.join(','***REMOVED*** + '].map(jade.joinClasses***REMOVED***.map(function (cls, i***REMOVED*** {' +
          '   return jade_interp[i] ? jade.escape(cls***REMOVED*** : cls' +
          ' }***REMOVED******REMOVED***' +
          '***REMOVED***';
    ***REMOVED***
      if (classes.length***REMOVED***
        buf.push('"class": ' + classes***REMOVED***;
  ***REMOVED***
    return '{' + buf.join(','***REMOVED*** + '}';
***REMOVED***
};
