/*global Buffer require exports console setTimeout */

var net = require("net"***REMOVED***,
    util = require("./lib/util"***REMOVED***,
    Queue = require("./lib/queue"***REMOVED***,
    to_array = require("./lib/to_array"***REMOVED***,
    events = require("events"***REMOVED***,
    crypto = require("crypto"***REMOVED***,
    parsers = [], commands,
    connection_id = 0,
    default_port = 6379,
    default_host = "127.0.0.1";

// can set this to true to enable for all connections
exports.debug_mode = false;

var arraySlice = Array.prototype.slice
function trace(***REMOVED*** {
    if (!exports.debug_mode***REMOVED*** return;
    console.log.apply(null, arraySlice.call(arguments***REMOVED******REMOVED***
}

// hiredis might not be installed
try {
    require("./lib/parser/hiredis"***REMOVED***;
    parsers.push(require("./lib/parser/hiredis"***REMOVED******REMOVED***;
} catch (err***REMOVED*** {
    if (exports.debug_mode***REMOVED*** {
        console.warn("hiredis parser not installed."***REMOVED***;
  ***REMOVED***
}

parsers.push(require("./lib/parser/javascript"***REMOVED******REMOVED***;

function RedisClient(stream, options***REMOVED*** {
    this.stream = stream;
    this.options = options = options || {};

    this.connection_id = ++connection_id;
    this.connected = false;
    this.ready = false;
    this.connections = 0;
    if (this.options.socket_nodelay === undefined***REMOVED*** {
        this.options.socket_nodelay = true;
  ***REMOVED***
    this.should_buffer = false;
    this.command_queue_high_water = this.options.command_queue_high_water || 1000;
    this.command_queue_low_water = this.options.command_queue_low_water || 0;
    this.max_attempts = null;
    if (options.max_attempts && !isNaN(options.max_attempts***REMOVED*** && options.max_attempts > 0***REMOVED*** {
        this.max_attempts = +options.max_attempts;
  ***REMOVED***
    this.command_queue = new Queue(***REMOVED***; // holds sent commands to de-pipeline them
    this.offline_queue = new Queue(***REMOVED***; // holds commands issued but not able to be sent
    this.commands_sent = 0;
    this.connect_timeout = false;
    if (options.connect_timeout && !isNaN(options.connect_timeout***REMOVED*** && options.connect_timeout > 0***REMOVED*** {
        this.connect_timeout = +options.connect_timeout;
  ***REMOVED***
    this.enable_offline_queue = true;
    if (typeof this.options.enable_offline_queue === "boolean"***REMOVED*** {
        this.enable_offline_queue = this.options.enable_offline_queue;
  ***REMOVED***
    this.retry_max_delay = null;
    if (options.retry_max_delay !== undefined && !isNaN(options.retry_max_delay***REMOVED*** && options.retry_max_delay > 0***REMOVED*** {
        this.retry_max_delay = options.retry_max_delay;
  ***REMOVED***

    this.initialize_retry_vars(***REMOVED***;
    this.pub_sub_mode = false;
    this.subscription_set = {};
    this.monitoring = false;
    this.closing = false;
    this.server_info = {};
    this.auth_pass = null;
    if (options.auth_pass !== undefined***REMOVED*** {
        this.auth_pass = options.auth_pass;
  ***REMOVED***
    this.parser_module = null;
    this.selected_db = null;	// save the selected db here, used when reconnecting

    this.old_state = null;

    var self = this;

    this.stream.on("connect", function (***REMOVED*** {
        self.on_connect(***REMOVED***;
  ***REMOVED******REMOVED***;

    this.stream.on("data", function (buffer_from_socket***REMOVED*** {
        self.on_data(buffer_from_socket***REMOVED***;
  ***REMOVED******REMOVED***;

    this.stream.on("error", function (msg***REMOVED*** {
        self.on_error(msg.message***REMOVED***;
  ***REMOVED******REMOVED***;

    this.stream.on("close", function (***REMOVED*** {
        self.connection_gone("close"***REMOVED***;
  ***REMOVED******REMOVED***;

    this.stream.on("end", function (***REMOVED*** {
        self.connection_gone("end"***REMOVED***;
  ***REMOVED******REMOVED***;

    this.stream.on("drain", function (***REMOVED*** {
        self.should_buffer = false;
        self.emit("drain"***REMOVED***;
  ***REMOVED******REMOVED***;

    events.EventEmitter.call(this***REMOVED***;
}
util.inherits(RedisClient, events.EventEmitter***REMOVED***;
exports.RedisClient = RedisClient;

RedisClient.prototype.initialize_retry_vars = function (***REMOVED*** {
    this.retry_timer = null;
    this.retry_totaltime = 0;
    this.retry_delay = 150;
    this.retry_backoff = 1.7;
    this.attempts = 1;
};

RedisClient.prototype.unref = function (***REMOVED*** {
    trace("User requesting to unref the connection"***REMOVED***;
    if (this.connected***REMOVED*** {
        trace("unref'ing the socket connection"***REMOVED***;
        this.stream.unref(***REMOVED***;
  ***REMOVED***
    else {
        trace("Not connected yet, will unref later"***REMOVED***;
        this.once("connect", function (***REMOVED*** {
            this.unref(***REMOVED***;
      ***REMOVED******REMOVED***
  ***REMOVED***
};

// flush offline_queue and command_queue, erroring any items with a callback first
RedisClient.prototype.flush_and_error = function (message***REMOVED*** {
    var command_obj, error;

    error = new Error(message***REMOVED***;

    while (this.offline_queue.length > 0***REMOVED*** {
        command_obj = this.offline_queue.shift(***REMOVED***;
        if (typeof command_obj.callback === "function"***REMOVED*** {
            try {
                command_obj.callback(error***REMOVED***;
          ***REMOVED*** catch (callback_err***REMOVED*** {
                this.emit("error", callback_err***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    this.offline_queue = new Queue(***REMOVED***;

    while (this.command_queue.length > 0***REMOVED*** {
        command_obj = this.command_queue.shift(***REMOVED***;
        if (typeof command_obj.callback === "function"***REMOVED*** {
            try {
                command_obj.callback(error***REMOVED***;
          ***REMOVED*** catch (callback_err***REMOVED*** {
                this.emit("error", callback_err***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    this.command_queue = new Queue(***REMOVED***;
};

RedisClient.prototype.on_error = function (msg***REMOVED*** {
    var message = "Redis connection to " + this.host + ":" + this.port + " failed - " + msg;

    if (this.closing***REMOVED*** {
        return;
  ***REMOVED***

    if (exports.debug_mode***REMOVED*** {
        console.warn(message***REMOVED***;
  ***REMOVED***

    this.flush_and_error(message***REMOVED***;

    this.connected = false;
    this.ready = false;

    this.emit("error", new Error(message***REMOVED******REMOVED***;
    // "error" events get turned into exceptions if they aren't listened for.  If the user handled this error
    // then we should try to reconnect.
    this.connection_gone("error"***REMOVED***;
};

RedisClient.prototype.do_auth = function (***REMOVED*** {
    var self = this;

    if (exports.debug_mode***REMOVED*** {
        console.log("Sending auth to " + self.host + ":" + self.port + " id " + self.connection_id***REMOVED***;
  ***REMOVED***
    self.send_anyway = true;
    self.send_command("auth", [this.auth_pass], function (err, res***REMOVED*** {
        if (err***REMOVED*** {
            if (err.toString(***REMOVED***.match("LOADING"***REMOVED******REMOVED*** {
                // if redis is still loading the db, it will not authenticate and everything else will fail
                console.log("Redis still loading, trying to authenticate later"***REMOVED***;
                setTimeout(function (***REMOVED*** {
                    self.do_auth(***REMOVED***;
              ***REMOVED***, 2000***REMOVED***; // TODO - magic number alert
                return;
          ***REMOVED*** else if (err.toString(***REMOVED***.match("no password is set"***REMOVED******REMOVED*** {
                console.log("Warning: Redis server does not require a password, but a password was supplied."***REMOVED***
                err = null;
                res = "OK";
          ***REMOVED*** else {
                return self.emit("error", new Error("Auth error: " + err.message***REMOVED******REMOVED***;
          ***REMOVED***
      ***REMOVED***
        if (res.toString(***REMOVED*** !== "OK"***REMOVED*** {
            return self.emit("error", new Error("Auth failed: " + res.toString(***REMOVED******REMOVED******REMOVED***;
      ***REMOVED***
        if (exports.debug_mode***REMOVED*** {
            console.log("Auth succeeded " + self.host + ":" + self.port + " id " + self.connection_id***REMOVED***;
      ***REMOVED***
        if (self.auth_callback***REMOVED*** {
            self.auth_callback(err, res***REMOVED***;
            self.auth_callback = null;
      ***REMOVED***

        // now we are really connected
        self.emit("connect"***REMOVED***;
        self.initialize_retry_vars(***REMOVED***;

        if (self.options.no_ready_check***REMOVED*** {
            self.on_ready(***REMOVED***;
      ***REMOVED*** else {
            self.ready_check(***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
    self.send_anyway = false;
};

RedisClient.prototype.on_connect = function (***REMOVED*** {
    if (exports.debug_mode***REMOVED*** {
        console.log("Stream connected " + this.host + ":" + this.port + " id " + this.connection_id***REMOVED***;
  ***REMOVED***

    this.connected = true;
    this.ready = false;
    this.connections += 1;
    this.command_queue = new Queue(***REMOVED***;
    this.emitted_end = false;
    if (this.options.socket_nodelay***REMOVED*** {
        this.stream.setNoDelay(***REMOVED***;
  ***REMOVED***
    this.stream.setTimeout(0***REMOVED***;

    this.init_parser(***REMOVED***;

    if (this.auth_pass***REMOVED*** {
        this.do_auth(***REMOVED***;
  ***REMOVED*** else {
        this.emit("connect"***REMOVED***;
        this.initialize_retry_vars(***REMOVED***;

        if (this.options.no_ready_check***REMOVED*** {
            this.on_ready(***REMOVED***;
      ***REMOVED*** else {
            this.ready_check(***REMOVED***;
      ***REMOVED***
  ***REMOVED***
};

RedisClient.prototype.init_parser = function (***REMOVED*** {
    var self = this;

    if (this.options.parser***REMOVED*** {
        if (! parsers.some(function (parser***REMOVED*** {
            if (parser.name === self.options.parser***REMOVED*** {
                self.parser_module = parser;
                if (exports.debug_mode***REMOVED*** {
                    console.log("Using parser module: " + self.parser_module.name***REMOVED***;
              ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED******REMOVED******REMOVED*** {
            throw new Error("Couldn't find named parser " + self.options.parser + " on this system"***REMOVED***;
      ***REMOVED***
  ***REMOVED*** else {
        if (exports.debug_mode***REMOVED*** {
            console.log("Using default parser module: " + parsers[0].name***REMOVED***;
      ***REMOVED***
        this.parser_module = parsers[0];
  ***REMOVED***

    this.parser_module.debug_mode = exports.debug_mode;

    // return_buffers sends back Buffers from parser to callback. detect_buffers sends back Buffers from parser, but
    // converts to Strings if the input arguments are not Buffers.
    this.reply_parser = new this.parser_module.Parser({
        return_buffers: self.options.return_buffers || self.options.detect_buffers || false
  ***REMOVED******REMOVED***;

    // "reply error" is an error sent back by Redis
    this.reply_parser.on("reply error", function (reply***REMOVED*** {
        if (reply instanceof Error***REMOVED*** {
            self.return_error(reply***REMOVED***;
      ***REMOVED*** else {
            self.return_error(new Error(reply***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
    this.reply_parser.on("reply", function (reply***REMOVED*** {
        self.return_reply(reply***REMOVED***;
  ***REMOVED******REMOVED***;
    // "error" is bad.  Somehow the parser got confused.  It'll try to reset and continue.
    this.reply_parser.on("error", function (err***REMOVED*** {
        self.emit("error", new Error("Redis reply parser error: " + err.stack***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

RedisClient.prototype.on_ready = function (***REMOVED*** {
    var self = this;

    this.ready = true;

    if (this.old_state !== null***REMOVED*** {
        this.monitoring = this.old_state.monitoring;
        this.pub_sub_mode = this.old_state.pub_sub_mode;
        this.selected_db = this.old_state.selected_db;
        this.old_state = null;
  ***REMOVED***

    // magically restore any modal commands from a previous connection
    if (this.selected_db !== null***REMOVED*** {
        // this trick works if and only if the following send_command
        // never goes into the offline queue
        var pub_sub_mode = this.pub_sub_mode;
        this.pub_sub_mode = false;
        this.send_command('select', [this.selected_db]***REMOVED***;
        this.pub_sub_mode = pub_sub_mode;
  ***REMOVED***
    if (this.pub_sub_mode === true***REMOVED*** {
        // only emit "ready" when all subscriptions were made again
        var callback_count = 0;
        var callback = function (***REMOVED*** {
            callback_count--;
            if (callback_count === 0***REMOVED*** {
                self.emit("ready"***REMOVED***;
          ***REMOVED***
      ***REMOVED***;
        Object.keys(this.subscription_set***REMOVED***.forEach(function (key***REMOVED*** {
            var parts = key.split(" "***REMOVED***;
            if (exports.debug_mode***REMOVED*** {
                console.warn("sending pub/sub on_ready " + parts[0] + ", " + parts[1]***REMOVED***;
          ***REMOVED***
            callback_count++;
            self.send_command(parts[0] + "scribe", [parts[1]], callback***REMOVED***;
      ***REMOVED******REMOVED***;
        return;
  ***REMOVED*** else if (this.monitoring***REMOVED*** {
        this.send_command("monitor"***REMOVED***;
  ***REMOVED*** else {
        this.send_offline_queue(***REMOVED***;
  ***REMOVED***
    this.emit("ready"***REMOVED***;
};

RedisClient.prototype.on_info_cmd = function (err, res***REMOVED*** {
    var self = this, obj = {}, lines, retry_time;

    if (err***REMOVED*** {
        return self.emit("error", new Error("Ready check failed: " + err.message***REMOVED******REMOVED***;
  ***REMOVED***

    lines = res.toString(***REMOVED***.split("\r\n"***REMOVED***;

    lines.forEach(function (line***REMOVED*** {
        var parts = line.split(':'***REMOVED***;
        if (parts[1]***REMOVED*** {
            obj[parts[0]] = parts[1];
      ***REMOVED***
  ***REMOVED******REMOVED***;

    obj.versions = [];
    if( obj.redis_version ***REMOVED***{
        obj.redis_version.split('.'***REMOVED***.forEach(function (num***REMOVED*** {
            obj.versions.push(+num***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***

    // expose info key/vals to users
    this.server_info = obj;

    if (!obj.loading || (obj.loading && obj.loading === "0"***REMOVED******REMOVED*** {
        if (exports.debug_mode***REMOVED*** {
            console.log("Redis server ready."***REMOVED***;
      ***REMOVED***
        this.on_ready(***REMOVED***;
  ***REMOVED*** else {
        retry_time = obj.loading_eta_seconds * 1000;
        if (retry_time > 1000***REMOVED*** {
            retry_time = 1000;
      ***REMOVED***
        if (exports.debug_mode***REMOVED*** {
            console.log("Redis server still loading, trying again in " + retry_time***REMOVED***;
      ***REMOVED***
        setTimeout(function (***REMOVED*** {
            self.ready_check(***REMOVED***;
      ***REMOVED***, retry_time***REMOVED***;
  ***REMOVED***
};

RedisClient.prototype.ready_check = function (***REMOVED*** {
    var self = this;

    if (exports.debug_mode***REMOVED*** {
        console.log("checking server ready state..."***REMOVED***;
  ***REMOVED***

    this.send_anyway = true;  // secret flag to send_command to send something even if not "ready"
    this.info(function (err, res***REMOVED*** {
        self.on_info_cmd(err, res***REMOVED***;
  ***REMOVED******REMOVED***;
    this.send_anyway = false;
};

RedisClient.prototype.send_offline_queue = function (***REMOVED*** {
    var command_obj, buffered_writes = 0;

    while (this.offline_queue.length > 0***REMOVED*** {
        command_obj = this.offline_queue.shift(***REMOVED***;
        if (exports.debug_mode***REMOVED*** {
            console.log("Sending offline command: " + command_obj.command***REMOVED***;
      ***REMOVED***
        buffered_writes += !this.send_command(command_obj.command, command_obj.args, command_obj.callback***REMOVED***;
  ***REMOVED***
    this.offline_queue = new Queue(***REMOVED***;
    // Even though items were shifted off, Queue backing store still uses memory until next add, so just get a new Queue

    if (!buffered_writes***REMOVED*** {
        this.should_buffer = false;
        this.emit("drain"***REMOVED***;
  ***REMOVED***
};

RedisClient.prototype.connection_gone = function (why***REMOVED*** {
    var self = this;

    // If a retry is already in progress, just let that happen
    if (this.retry_timer***REMOVED*** {
        return;
  ***REMOVED***

    if (exports.debug_mode***REMOVED*** {
        console.warn("Redis connection is gone from " + why + " event."***REMOVED***;
  ***REMOVED***
    this.connected = false;
    this.ready = false;

    if (this.old_state === null***REMOVED*** {
        var state = {
            monitoring: this.monitoring,
            pub_sub_mode: this.pub_sub_mode,
            selected_db: this.selected_db
      ***REMOVED***;
        this.old_state = state;
        this.monitoring = false;
        this.pub_sub_mode = false;
        this.selected_db = null;
  ***REMOVED***

    // since we are collapsing end and close, users don't expect to be called twice
    if (! this.emitted_end***REMOVED*** {
        this.emit("end"***REMOVED***;
        this.emitted_end = true;
  ***REMOVED***

    this.flush_and_error("Redis connection gone from " + why + " event."***REMOVED***;

    // If this is a requested shutdown, then don't retry
    if (this.closing***REMOVED*** {
        this.retry_timer = null;
        if (exports.debug_mode***REMOVED*** {
            console.warn("connection ended from quit command, not retrying."***REMOVED***;
      ***REMOVED***
        return;
  ***REMOVED***

    var nextDelay = Math.floor(this.retry_delay * this.retry_backoff***REMOVED***;
    if (this.retry_max_delay !== null && nextDelay > this.retry_max_delay***REMOVED*** {
        this.retry_delay = this.retry_max_delay;
  ***REMOVED*** else {
        this.retry_delay = nextDelay;
  ***REMOVED***

    if (exports.debug_mode***REMOVED*** {
        console.log("Retry connection in " + this.retry_delay + " ms"***REMOVED***;
  ***REMOVED***

    if (this.max_attempts && this.attempts >= this.max_attempts***REMOVED*** {
        this.retry_timer = null;
        // TODO - some people need a "Redis is Broken mode" for future commands that errors immediately, and others
        // want the program to exit.  Right now, we just log, which doesn't really help in either case.
        console.error("node_redis: Couldn't get Redis connection after " + this.max_attempts + " attempts."***REMOVED***;
        return;
  ***REMOVED***

    this.attempts += 1;
    this.emit("reconnecting", {
        delay: self.retry_delay,
        attempt: self.attempts
  ***REMOVED******REMOVED***;
    this.retry_timer = setTimeout(function (***REMOVED*** {
        if (exports.debug_mode***REMOVED*** {
            console.log("Retrying connection..."***REMOVED***;
      ***REMOVED***

        self.retry_totaltime += self.retry_delay;

        if (self.connect_timeout && self.retry_totaltime >= self.connect_timeout***REMOVED*** {
            self.retry_timer = null;
            // TODO - engage Redis is Broken mode for future commands, or whatever
            console.error("node_redis: Couldn't get Redis connection after " + self.retry_totaltime + "ms."***REMOVED***;
            return;
      ***REMOVED***

        self.stream.connect(self.port, self.host***REMOVED***;
        self.retry_timer = null;
  ***REMOVED***, this.retry_delay***REMOVED***;
};

RedisClient.prototype.on_data = function (data***REMOVED*** {
    if (exports.debug_mode***REMOVED*** {
        console.log("net read " + this.host + ":" + this.port + " id " + this.connection_id + ": " + data.toString(***REMOVED******REMOVED***;
  ***REMOVED***

    try {
        this.reply_parser.execute(data***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
        // This is an unexpected parser problem, an exception that came from the parser code itself.
        // Parser should emit "error" events if it notices things are out of whack.
        // Callbacks that throw exceptions will land in return_reply(***REMOVED***, below.
        // TODO - it might be nice to have a different "error" event for different types of errors
        this.emit("error", err***REMOVED***;
  ***REMOVED***
};

RedisClient.prototype.return_error = function (err***REMOVED*** {
    var command_obj = this.command_queue.shift(***REMOVED***, queue_len = this.command_queue.getLength(***REMOVED***;

    if (this.pub_sub_mode === false && queue_len === 0***REMOVED*** {
        this.command_queue = new Queue(***REMOVED***;
        this.emit("idle"***REMOVED***;
  ***REMOVED***
    if (this.should_buffer && queue_len <= this.command_queue_low_water***REMOVED*** {
        this.emit("drain"***REMOVED***;
        this.should_buffer = false;
  ***REMOVED***

    if (command_obj && typeof command_obj.callback === "function"***REMOVED*** {
        try {
            command_obj.callback(err***REMOVED***;
      ***REMOVED*** catch (callback_err***REMOVED*** {
            this.emit("error", callback_err***REMOVED***;
      ***REMOVED***
  ***REMOVED*** else {
        console.log("node_redis: no callback to send error: " + err.message***REMOVED***;
        this.emit("error", err***REMOVED***;
  ***REMOVED***
};

// if a callback throws an exception, re-throw it on a new stack so the parser can keep going.
// if a domain is active, emit the error on the domain, which will serve the same function.
// put this try/catch in its own function because V8 doesn't optimize this well yet.
function try_callback(client, callback, reply***REMOVED*** {
    try {
        callback(null, reply***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
        if (process.domain***REMOVED*** {
            process.domain.emit('error', err***REMOVED***;
            process.domain.exit(***REMOVED***;
      ***REMOVED*** else {
            client.emit("error", err***REMOVED***;
      ***REMOVED***
  ***REMOVED***
}

// hgetall converts its replies to an Object.  If the reply is empty, null is returned.
function reply_to_object(reply***REMOVED*** {
    var obj = {}, j, jl, key, val;

    if (reply.length === 0***REMOVED*** {
        return null;
  ***REMOVED***

    for (j = 0, jl = reply.length; j < jl; j += 2***REMOVED*** {
        key = reply[j].toString(***REMOVED***;
        val = reply[j + 1];
        obj[key] = val;
  ***REMOVED***

    return obj;
}

function reply_to_strings(reply***REMOVED*** {
    var i;

    if (Buffer.isBuffer(reply***REMOVED******REMOVED*** {
        return reply.toString(***REMOVED***;
  ***REMOVED***

    if (Array.isArray(reply***REMOVED******REMOVED*** {
        for (i = 0; i < reply.length; i++***REMOVED*** {
            if (reply[i] !== null && reply[i] !== undefined***REMOVED*** {
                reply[i] = reply[i].toString(***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        return reply;
  ***REMOVED***

    return reply;
}

RedisClient.prototype.return_reply = function (reply***REMOVED*** {
    var command_obj, len, type, timestamp, argindex, args, queue_len;

    // If the "reply" here is actually a message received asynchronously due to a
    // pubsub subscription, don't pop the command queue as we'll only be consuming
    // the head command prematurely.
    if (Array.isArray(reply***REMOVED*** && reply.length > 0 && reply[0]***REMOVED*** {
        type = reply[0].toString(***REMOVED***;
  ***REMOVED***

    if (this.pub_sub_mode && (type == 'message' || type == 'pmessage'***REMOVED******REMOVED*** {
        trace("received pubsub message"***REMOVED***;
  ***REMOVED***
    else {
        command_obj = this.command_queue.shift(***REMOVED***;
  ***REMOVED***

    queue_len = this.command_queue.getLength(***REMOVED***;

    if (this.pub_sub_mode === false && queue_len === 0***REMOVED*** {
        this.command_queue = new Queue(***REMOVED***;  // explicitly reclaim storage from old Queue
        this.emit("idle"***REMOVED***;
  ***REMOVED***
    if (this.should_buffer && queue_len <= this.command_queue_low_water***REMOVED*** {
        this.emit("drain"***REMOVED***;
        this.should_buffer = false;
  ***REMOVED***

    if (command_obj && !command_obj.sub_command***REMOVED*** {
        if (typeof command_obj.callback === "function"***REMOVED*** {
            if (this.options.detect_buffers && command_obj.buffer_args === false***REMOVED*** {
                // If detect_buffers option was specified, then the reply from the parser will be Buffers.
                // If this command did not use Buffer arguments, then convert the reply to Strings here.
                reply = reply_to_strings(reply***REMOVED***;
          ***REMOVED***

            // TODO - confusing and error-prone that hgetall is special cased in two places
            if (reply && 'hgetall' === command_obj.command.toLowerCase(***REMOVED******REMOVED*** {
                reply = reply_to_object(reply***REMOVED***;
          ***REMOVED***

            try_callback(this, command_obj.callback, reply***REMOVED***;
      ***REMOVED*** else if (exports.debug_mode***REMOVED*** {
            console.log("no callback for reply: " + (reply && reply.toString && reply.toString(***REMOVED******REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED*** else if (this.pub_sub_mode || (command_obj && command_obj.sub_command***REMOVED******REMOVED*** {
        if (Array.isArray(reply***REMOVED******REMOVED*** {
            type = reply[0].toString(***REMOVED***;

            if (type === "message"***REMOVED*** {
                this.emit("message", reply[1].toString(***REMOVED***, reply[2]***REMOVED***; // channel, message
          ***REMOVED*** else if (type === "pmessage"***REMOVED*** {
                this.emit("pmessage", reply[1].toString(***REMOVED***, reply[2].toString(***REMOVED***, reply[3]***REMOVED***; // pattern, channel, message
          ***REMOVED*** else if (type === "subscribe" || type === "unsubscribe" || type === "psubscribe" || type === "punsubscribe"***REMOVED*** {
                if (reply[2] === 0***REMOVED*** {
                    this.pub_sub_mode = false;
                    if (this.debug_mode***REMOVED*** {
                        console.log("All subscriptions removed, exiting pub/sub mode"***REMOVED***;
                  ***REMOVED***
              ***REMOVED*** else {
                    this.pub_sub_mode = true;
              ***REMOVED***
                // subscribe commands take an optional callback and also emit an event, but only the first response is included in the callback
                // TODO - document this or fix it so it works in a more obvious way
                // reply[1] can be null
                var reply1String = (reply[1] === null***REMOVED*** ? null : reply[1].toString(***REMOVED***;
                if (command_obj && typeof command_obj.callback === "function"***REMOVED*** {
                    try_callback(this, command_obj.callback, reply1String***REMOVED***;
              ***REMOVED***
                this.emit(type, reply1String, reply[2]***REMOVED***; // channel, count
          ***REMOVED*** else {
                throw new Error("subscriptions are active but got unknown reply type " + type***REMOVED***;
          ***REMOVED***
      ***REMOVED*** else if (! this.closing***REMOVED*** {
            throw new Error("subscriptions are active but got an invalid reply: " + reply***REMOVED***;
      ***REMOVED***
  ***REMOVED*** else if (this.monitoring***REMOVED*** {
        len = reply.indexOf(" "***REMOVED***;
        timestamp = reply.slice(0, len***REMOVED***;
        argindex = reply.indexOf('"'***REMOVED***;
        args = reply.slice(argindex + 1, -1***REMOVED***.split('" "'***REMOVED***.map(function (elem***REMOVED*** {
            return elem.replace(/\\"/g, '"'***REMOVED***;
      ***REMOVED******REMOVED***;
        this.emit("monitor", timestamp, args***REMOVED***;
  ***REMOVED*** else {
        throw new Error("node_redis command queue state error. If you can reproduce this, please report it."***REMOVED***;
  ***REMOVED***
};

// This Command constructor is ever so slightly faster than using an object literal, but more importantly, using
// a named constructor helps it show up meaningfully in the V8 CPU profiler and in heap snapshots.
function Command(command, args, sub_command, buffer_args, callback***REMOVED*** {
    this.command = command;
    this.args = args;
    this.sub_command = sub_command;
    this.buffer_args = buffer_args;
    this.callback = callback;
}

RedisClient.prototype.send_command = function (command, args, callback***REMOVED*** {
    var arg, command_obj, i, il, elem_count, buffer_args, stream = this.stream, command_str = "", buffered_writes = 0, last_arg_type, lcaseCommand;

    if (typeof command !== "string"***REMOVED*** {
        throw new Error("First argument to send_command must be the command name string, not " + typeof command***REMOVED***;
  ***REMOVED***

    if (Array.isArray(args***REMOVED******REMOVED*** {
        if (typeof callback === "function"***REMOVED*** {
            // probably the fastest way:
            //     client.command([arg1, arg2], cb***REMOVED***;  (straight passthrough***REMOVED***
            //         send_command(command, [arg1, arg2], cb***REMOVED***;
      ***REMOVED*** else if (! callback***REMOVED*** {
            // most people find this variable argument length form more convenient, but it uses arguments, which is slower
            //     client.command(arg1, arg2, cb***REMOVED***;   (wraps up arguments into an array***REMOVED***
            //       send_command(command, [arg1, arg2, cb]***REMOVED***;
            //     client.command(arg1, arg2***REMOVED***;   (callback is optional***REMOVED***
            //       send_command(command, [arg1, arg2]***REMOVED***;
            //     client.command(arg1, arg2, undefined***REMOVED***;   (callback is undefined***REMOVED***
            //       send_command(command, [arg1, arg2, undefined]***REMOVED***;
            last_arg_type = typeof args[args.length - 1];
            if (last_arg_type === "function" || last_arg_type === "undefined"***REMOVED*** {
                callback = args.pop(***REMOVED***;
          ***REMOVED***
      ***REMOVED*** else {
            throw new Error("send_command: last argument must be a callback or undefined"***REMOVED***;
      ***REMOVED***
  ***REMOVED*** else {
        throw new Error("send_command: second argument must be an array"***REMOVED***;
  ***REMOVED***

    if (callback && process.domain***REMOVED*** callback = process.domain.bind(callback***REMOVED***;

    // if the last argument is an array and command is sadd or srem, expand it out:
    //     client.sadd(arg1, [arg2, arg3, arg4], cb***REMOVED***;
    //  converts to:
    //     client.sadd(arg1, arg2, arg3, arg4, cb***REMOVED***;
    lcaseCommand = command.toLowerCase(***REMOVED***;
    if ((lcaseCommand === 'sadd' || lcaseCommand === 'srem'***REMOVED*** && args.length > 0 && Array.isArray(args[args.length - 1]***REMOVED******REMOVED*** {
        args = args.slice(0, -1***REMOVED***.concat(args[args.length - 1]***REMOVED***;
  ***REMOVED***

    // if the value is undefined or null and command is set or setx, need not to send message to redis
    if (command === 'set' || command === 'setex'***REMOVED*** {
        if(args[args.length - 1] === undefined || args[args.length - 1] === null***REMOVED*** {
            var err = new Error('send_command: ' + command + ' value must not be undefined or null'***REMOVED***;
            return callback && callback(err***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    buffer_args = false;
    for (i = 0, il = args.length, arg; i < il; i += 1***REMOVED*** {
        if (Buffer.isBuffer(args[i]***REMOVED******REMOVED*** {
            buffer_args = true;
      ***REMOVED***
  ***REMOVED***

    command_obj = new Command(command, args, false, buffer_args, callback***REMOVED***;

    if ((!this.ready && !this.send_anyway***REMOVED*** || !stream.writable***REMOVED*** {
        if (exports.debug_mode***REMOVED*** {
            if (!stream.writable***REMOVED*** {
                console.log("send command: stream is not writeable."***REMOVED***;
          ***REMOVED***
      ***REMOVED***

        if (this.enable_offline_queue***REMOVED*** {
            if (exports.debug_mode***REMOVED*** {
                console.log("Queueing " + command + " for next server connection."***REMOVED***;
          ***REMOVED***
            this.offline_queue.push(command_obj***REMOVED***;
            this.should_buffer = true;
      ***REMOVED*** else {
            var not_writeable_error = new Error('send_command: stream not writeable. enable_offline_queue is false'***REMOVED***;
            if (command_obj.callback***REMOVED*** {
                command_obj.callback(not_writeable_error***REMOVED***;
          ***REMOVED*** else {
                throw not_writeable_error;
          ***REMOVED***
      ***REMOVED***

        return false;
  ***REMOVED***

    if (command === "subscribe" || command === "psubscribe" || command === "unsubscribe" || command === "punsubscribe"***REMOVED*** {
        this.pub_sub_command(command_obj***REMOVED***;
  ***REMOVED*** else if (command === "monitor"***REMOVED*** {
        this.monitoring = true;
  ***REMOVED*** else if (command === "quit"***REMOVED*** {
        this.closing = true;
  ***REMOVED*** else if (this.pub_sub_mode === true***REMOVED*** {
        throw new Error("Connection in subscriber mode, only subscriber commands may be used"***REMOVED***;
  ***REMOVED***
    this.command_queue.push(command_obj***REMOVED***;
    this.commands_sent += 1;

    elem_count = args.length + 1;

    // Always use "Multi bulk commands", but if passed any Buffer args, then do multiple writes, one for each arg.
    // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.

    command_str = "*" + elem_count + "\r\n$" + command.length + "\r\n" + command + "\r\n";

    if (! buffer_args***REMOVED*** { // Build up a string and send entire command in one write
        for (i = 0, il = args.length, arg; i < il; i += 1***REMOVED*** {
            arg = args[i];
            if (typeof arg !== "string"***REMOVED*** {
                arg = String(arg***REMOVED***;
          ***REMOVED***
            command_str += "$" + Buffer.byteLength(arg***REMOVED*** + "\r\n" + arg + "\r\n";
      ***REMOVED***
        if (exports.debug_mode***REMOVED*** {
            console.log("send " + this.host + ":" + this.port + " id " + this.connection_id + ": " + command_str***REMOVED***;
      ***REMOVED***
        buffered_writes += !stream.write(command_str***REMOVED***;
  ***REMOVED*** else {
        if (exports.debug_mode***REMOVED*** {
            console.log("send command (" + command_str + "***REMOVED*** has Buffer arguments"***REMOVED***;
      ***REMOVED***
        buffered_writes += !stream.write(command_str***REMOVED***;

        for (i = 0, il = args.length, arg; i < il; i += 1***REMOVED*** {
            arg = args[i];
            if (!(Buffer.isBuffer(arg***REMOVED*** || arg instanceof String***REMOVED******REMOVED*** {
                arg = String(arg***REMOVED***;
          ***REMOVED***

            if (Buffer.isBuffer(arg***REMOVED******REMOVED*** {
                if (arg.length === 0***REMOVED*** {
                    if (exports.debug_mode***REMOVED*** {
                        console.log("send_command: using empty string for 0 length buffer"***REMOVED***;
                  ***REMOVED***
                    buffered_writes += !stream.write("$0\r\n\r\n"***REMOVED***;
              ***REMOVED*** else {
                    buffered_writes += !stream.write("$" + arg.length + "\r\n"***REMOVED***;
                    buffered_writes += !stream.write(arg***REMOVED***;
                    buffered_writes += !stream.write("\r\n"***REMOVED***;
                    if (exports.debug_mode***REMOVED*** {
                        console.log("send_command: buffer send " + arg.length + " bytes"***REMOVED***;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED*** else {
                if (exports.debug_mode***REMOVED*** {
                    console.log("send_command: string send " + Buffer.byteLength(arg***REMOVED*** + " bytes: " + arg***REMOVED***;
              ***REMOVED***
                buffered_writes += !stream.write("$" + Buffer.byteLength(arg***REMOVED*** + "\r\n" + arg + "\r\n"***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    if (exports.debug_mode***REMOVED*** {
        console.log("send_command buffered_writes: " + buffered_writes, " should_buffer: " + this.should_buffer***REMOVED***;
  ***REMOVED***
    if (buffered_writes || this.command_queue.getLength(***REMOVED*** >= this.command_queue_high_water***REMOVED*** {
        this.should_buffer = true;
  ***REMOVED***
    return !this.should_buffer;
};

RedisClient.prototype.pub_sub_command = function (command_obj***REMOVED*** {
    var i, key, command, args;

    if (this.pub_sub_mode === false && exports.debug_mode***REMOVED*** {
        console.log("Entering pub/sub mode from " + command_obj.command***REMOVED***;
  ***REMOVED***
    this.pub_sub_mode = true;
    command_obj.sub_command = true;

    command = command_obj.command;
    args = command_obj.args;
    if (command === "subscribe" || command === "psubscribe"***REMOVED*** {
        if (command === "subscribe"***REMOVED*** {
            key = "sub";
      ***REMOVED*** else {
            key = "psub";
      ***REMOVED***
        for (i = 0; i < args.length; i++***REMOVED*** {
            this.subscription_set[key + " " + args[i]] = true;
      ***REMOVED***
  ***REMOVED*** else {
        if (command === "unsubscribe"***REMOVED*** {
            key = "sub";
      ***REMOVED*** else {
            key = "psub";
      ***REMOVED***
        for (i = 0; i < args.length; i++***REMOVED*** {
            delete this.subscription_set[key + " " + args[i]];
      ***REMOVED***
  ***REMOVED***
};

RedisClient.prototype.end = function (***REMOVED*** {
    this.stream._events = {};
    this.connected = false;
    this.ready = false;
    this.closing = true;
    return this.stream.destroySoon(***REMOVED***;
};

function Multi(client, args***REMOVED*** {
    this._client = client;
    this.queue = [["MULTI"]];
    if (Array.isArray(args***REMOVED******REMOVED*** {
        this.queue = this.queue.concat(args***REMOVED***;
  ***REMOVED***
}

exports.Multi = Multi;

// take 2 arrays and return the union of their elements
function set_union(seta, setb***REMOVED*** {
    var obj = {};

    seta.forEach(function (val***REMOVED*** {
        obj[val] = true;
  ***REMOVED******REMOVED***;
    setb.forEach(function (val***REMOVED*** {
        obj[val] = true;
  ***REMOVED******REMOVED***;
    return Object.keys(obj***REMOVED***;
}

// This static list of commands is updated from time to time.  ./lib/commands.js can be updated with generate_commands.js
commands = set_union(["get", "set", "setnx", "setex", "append", "strlen", "del", "exists", "setbit", "getbit", "setrange", "getrange", "substr",
    "incr", "decr", "mget", "rpush", "lpush", "rpushx", "lpushx", "linsert", "rpop", "lpop", "brpop", "brpoplpush", "blpop", "llen", "lindex",
    "lset", "lrange", "ltrim", "lrem", "rpoplpush", "sadd", "srem", "smove", "sismember", "scard", "spop", "srandmember", "sinter", "sinterstore",
    "sunion", "sunionstore", "sdiff", "sdiffstore", "smembers", "zadd", "zincrby", "zrem", "zremrangebyscore", "zremrangebyrank", "zunionstore",
    "zinterstore", "zrange", "zrangebyscore", "zrevrangebyscore", "zcount", "zrevrange", "zcard", "zscore", "zrank", "zrevrank", "hset", "hsetnx",
    "hget", "hmset", "hmget", "hincrby", "hdel", "hlen", "hkeys", "hvals", "hgetall", "hexists", "incrby", "decrby", "getset", "mset", "msetnx",
    "randomkey", "select", "move", "rename", "renamenx", "expire", "expireat", "keys", "dbsize", "auth", "ping", "echo", "save", "bgsave",
    "bgrewriteaof", "shutdown", "lastsave", "type", "multi", "exec", "discard", "sync", "flushdb", "flushall", "sort", "info", "monitor", "ttl",
    "persist", "slaveof", "debug", "config", "subscribe", "unsubscribe", "psubscribe", "punsubscribe", "publish", "watch", "unwatch", "cluster",
    "restore", "migrate", "dump", "object", "client", "eval", "evalsha"], require("./lib/commands"***REMOVED******REMOVED***;

commands.forEach(function (fullCommand***REMOVED*** {
    var command = fullCommand.split(' '***REMOVED***[0];

    RedisClient.prototype[command] = function (args, callback***REMOVED*** {
        if (Array.isArray(args***REMOVED*** && typeof callback === "function"***REMOVED*** {
            return this.send_command(command, args, callback***REMOVED***;
      ***REMOVED*** else {
            return this.send_command(command, to_array(arguments***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED***;
    RedisClient.prototype[command.toUpperCase(***REMOVED***] = RedisClient.prototype[command];

    Multi.prototype[command] = function (***REMOVED*** {
        this.queue.push([command].concat(to_array(arguments***REMOVED******REMOVED******REMOVED***;
        return this;
  ***REMOVED***;
    Multi.prototype[command.toUpperCase(***REMOVED***] = Multi.prototype[command];
}***REMOVED***;

// store db in this.select_db to restore it on reconnect
RedisClient.prototype.select = function (db, callback***REMOVED*** {
    var self = this;

    this.send_command('select', [db], function (err, res***REMOVED*** {
        if (err === null***REMOVED*** {
            self.selected_db = db;
      ***REMOVED***
        if (typeof(callback***REMOVED*** === 'function'***REMOVED*** {
            callback(err, res***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};
RedisClient.prototype.SELECT = RedisClient.prototype.select;

// Stash auth for connect and reconnect.  Send immediately if already connected.
RedisClient.prototype.auth = function (***REMOVED*** {
    var args = to_array(arguments***REMOVED***;
    this.auth_pass = args[0];
    this.auth_callback = args[1];
    if (exports.debug_mode***REMOVED*** {
        console.log("Saving auth as " + this.auth_pass***REMOVED***;
  ***REMOVED***

    if (this.connected***REMOVED*** {
        this.send_command("auth", args***REMOVED***;
  ***REMOVED***
};
RedisClient.prototype.AUTH = RedisClient.prototype.auth;

RedisClient.prototype.hmget = function (arg1, arg2, arg3***REMOVED*** {
    if (Array.isArray(arg2***REMOVED*** && typeof arg3 === "function"***REMOVED*** {
        return this.send_command("hmget", [arg1].concat(arg2***REMOVED***, arg3***REMOVED***;
  ***REMOVED*** else if (Array.isArray(arg1***REMOVED*** && typeof arg2 === "function"***REMOVED*** {
        return this.send_command("hmget", arg1, arg2***REMOVED***;
  ***REMOVED*** else {
        return this.send_command("hmget", to_array(arguments***REMOVED******REMOVED***;
  ***REMOVED***
};
RedisClient.prototype.HMGET = RedisClient.prototype.hmget;

RedisClient.prototype.hmset = function (args, callback***REMOVED*** {
    var tmp_args, tmp_keys, i, il, key;

    if (Array.isArray(args***REMOVED*** && typeof callback === "function"***REMOVED*** {
        return this.send_command("hmset", args, callback***REMOVED***;
  ***REMOVED***

    args = to_array(arguments***REMOVED***;
    if (typeof args[args.length - 1] === "function"***REMOVED*** {
        callback = args[args.length - 1];
        args.length -= 1;
  ***REMOVED*** else {
        callback = null;
  ***REMOVED***

    if (args.length === 2 && (typeof args[0] === "string" || typeof args[0] === "number"***REMOVED*** && typeof args[1] === "object"***REMOVED*** {
        // User does: client.hmset(key, {key1: val1, key2: val2}***REMOVED***
        // assuming key is a string, i.e. email address

        // if key is a number, i.e. timestamp, convert to string
        if (typeof args[0] === "number"***REMOVED*** {
            args[0] = args[0].toString(***REMOVED***;
      ***REMOVED***

        tmp_args = [ args[0] ];
        tmp_keys = Object.keys(args[1]***REMOVED***;
        for (i = 0, il = tmp_keys.length; i < il ; i++***REMOVED*** {
            key = tmp_keys[i];
            tmp_args.push(key***REMOVED***;
            tmp_args.push(args[1][key]***REMOVED***;
      ***REMOVED***
        args = tmp_args;
  ***REMOVED***

    return this.send_command("hmset", args, callback***REMOVED***;
};
RedisClient.prototype.HMSET = RedisClient.prototype.hmset;

Multi.prototype.hmset = function (***REMOVED*** {
    var args = to_array(arguments***REMOVED***, tmp_args;
    if (args.length >= 2 && typeof args[0] === "string" && typeof args[1] === "object"***REMOVED*** {
        tmp_args = [ "hmset", args[0] ];
        Object.keys(args[1]***REMOVED***.map(function (key***REMOVED*** {
            tmp_args.push(key***REMOVED***;
            tmp_args.push(args[1][key]***REMOVED***;
      ***REMOVED******REMOVED***;
        if (args[2]***REMOVED*** {
            tmp_args.push(args[2]***REMOVED***;
      ***REMOVED***
        args = tmp_args;
  ***REMOVED*** else {
        args.unshift("hmset"***REMOVED***;
  ***REMOVED***

    this.queue.push(args***REMOVED***;
    return this;
};
Multi.prototype.HMSET = Multi.prototype.hmset;

Multi.prototype.exec = function (callback***REMOVED*** {
    var self = this;
    var errors = [];
    // drain queue, callback will catch "QUEUED" or error
    // TODO - get rid of all of these anonymous functions which are elegant but slow
    this.queue.forEach(function (args, index***REMOVED*** {
        var command = args[0], obj;
        if (typeof args[args.length - 1] === "function"***REMOVED*** {
            args = args.slice(1, -1***REMOVED***;
      ***REMOVED*** else {
            args = args.slice(1***REMOVED***;
      ***REMOVED***
        if (args.length === 1 && Array.isArray(args[0]***REMOVED******REMOVED*** {
            args = args[0];
      ***REMOVED***
        if (command.toLowerCase(***REMOVED*** === 'hmset' && typeof args[1] === 'object'***REMOVED*** {
            obj = args.pop(***REMOVED***;
            Object.keys(obj***REMOVED***.forEach(function (key***REMOVED*** {
                args.push(key***REMOVED***;
                args.push(obj[key]***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
        this._client.send_command(command, args, function (err, reply***REMOVED*** {
            if (err***REMOVED*** {
                var cur = self.queue[index];
                if (typeof cur[cur.length - 1] === "function"***REMOVED*** {
                    cur[cur.length - 1](err***REMOVED***;
              ***REMOVED*** else {
                    errors.push(new Error(err***REMOVED******REMOVED***;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***, this***REMOVED***;

    // TODO - make this callback part of Multi.prototype instead of creating it each time
    return this._client.send_command("EXEC", [], function (err, replies***REMOVED*** {
        if (err***REMOVED*** {
            if (callback***REMOVED*** {
                errors.push(new Error(err***REMOVED******REMOVED***;
                callback(errors***REMOVED***;
                return;
          ***REMOVED*** else {
                throw new Error(err***REMOVED***;
          ***REMOVED***
      ***REMOVED***

        var i, il, reply, args;

        if (replies***REMOVED*** {
            for (i = 1, il = self.queue.length; i < il; i += 1***REMOVED*** {
                reply = replies[i - 1];
                args = self.queue[i];

                // TODO - confusing and error-prone that hgetall is special cased in two places
                if (reply && args[0].toLowerCase(***REMOVED*** === "hgetall"***REMOVED*** {
                    replies[i - 1] = reply = reply_to_object(reply***REMOVED***;
              ***REMOVED***

                if (typeof args[args.length - 1] === "function"***REMOVED*** {
                    args[args.length - 1](null, reply***REMOVED***;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***

        if (callback***REMOVED*** {
            callback(null, replies***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};
Multi.prototype.EXEC = Multi.prototype.exec;

RedisClient.prototype.multi = function (args***REMOVED*** {
    return new Multi(this, args***REMOVED***;
};
RedisClient.prototype.MULTI = function (args***REMOVED*** {
    return new Multi(this, args***REMOVED***;
};


// stash original eval method
var eval_orig = RedisClient.prototype.eval;
// hook eval with an attempt to evalsha for cached scripts
RedisClient.prototype.eval = RedisClient.prototype.EVAL = function (***REMOVED*** {
    var self = this,
        args = to_array(arguments***REMOVED***,
        callback;

    if (typeof args[args.length - 1] === "function"***REMOVED*** {
        callback = args.pop(***REMOVED***;
  ***REMOVED***

    if (Array.isArray(args[0]***REMOVED******REMOVED*** {
        args = args[0];
  ***REMOVED***

    // replace script source with sha value
    var source = args[0];
    args[0] = crypto.createHash("sha1"***REMOVED***.update(source***REMOVED***.digest("hex"***REMOVED***;

    self.evalsha(args, function (err, reply***REMOVED*** {
        if (err && /NOSCRIPT/.test(err.message***REMOVED******REMOVED*** {
            args[0] = source;
            eval_orig.call(self, args, callback***REMOVED***;

      ***REMOVED*** else if (callback***REMOVED*** {
            callback(err, reply***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};


exports.createClient = function (port_arg, host_arg, options***REMOVED*** {
    var port = port_arg || default_port,
        host = host_arg || default_host,
        redis_client, net_client;

    net_client = net.createConnection(port, host***REMOVED***;

    redis_client = new RedisClient(net_client, options***REMOVED***;

    redis_client.port = port;
    redis_client.host = host;

    return redis_client;
};

exports.print = function (err, reply***REMOVED*** {
    if (err***REMOVED*** {
        console.log("Error: " + err***REMOVED***;
  ***REMOVED*** else {
        console.log("Reply: " + reply***REMOVED***;
  ***REMOVED***
};
