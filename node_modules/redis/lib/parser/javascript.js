var events = require("events"***REMOVED***,
    util   = require("../util"***REMOVED***;

function Packet(type, size***REMOVED*** {
    this.type = type;
    this.size = +size;
}

exports.name = "javascript";
exports.debug_mode = false;

function ReplyParser(options***REMOVED*** {
    this.name = exports.name;
    this.options = options || { };

    this._buffer            = null;
    this._offset            = 0;
    this._encoding          = "utf-8";
    this._debug_mode        = options.debug_mode;
    this._reply_type        = null;
}

util.inherits(ReplyParser, events.EventEmitter***REMOVED***;

exports.Parser = ReplyParser;

function IncompleteReadBuffer(message***REMOVED*** {
    this.name = "IncompleteReadBuffer";
    this.message = message;
}
util.inherits(IncompleteReadBuffer, Error***REMOVED***;

// Buffer.toString(***REMOVED*** is quite slow for small strings
function small_toString(buf, start, end***REMOVED*** {
    var tmp = "", i;

    for (i = start; i < end; i++***REMOVED*** {
        tmp += String.fromCharCode(buf[i]***REMOVED***;
  ***REMOVED***

    return tmp;
}

ReplyParser.prototype._parseResult = function (type***REMOVED*** {
    var start, end, offset, packetHeader;

    if (type === 43 || type === 45***REMOVED*** { // + or -
        // up to the delimiter
        end = this._packetEndOffset(***REMOVED*** - 1;
        start = this._offset;

        // include the delimiter
        this._offset = end + 2;

        if (end > this._buffer.length***REMOVED*** {
            this._offset = start;
            throw new IncompleteReadBuffer("Wait for more data."***REMOVED***;
      ***REMOVED***

        if (this.options.return_buffers***REMOVED*** {
            return this._buffer.slice(start, end***REMOVED***;
      ***REMOVED*** else {
            if (end - start < 65536***REMOVED*** { // completely arbitrary
                return small_toString(this._buffer, start, end***REMOVED***;
          ***REMOVED*** else {
                return this._buffer.toString(this._encoding, start, end***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED*** else if (type === 58***REMOVED*** { // :
        // up to the delimiter
        end = this._packetEndOffset(***REMOVED*** - 1;
        start = this._offset;

        // include the delimiter
        this._offset = end + 2;

        if (end > this._buffer.length***REMOVED*** {
            this._offset = start;
            throw new IncompleteReadBuffer("Wait for more data."***REMOVED***;
      ***REMOVED***

        if (this.options.return_buffers***REMOVED*** {
            return this._buffer.slice(start, end***REMOVED***;
      ***REMOVED***

        // return the coerced numeric value
        return +small_toString(this._buffer, start, end***REMOVED***;
  ***REMOVED*** else if (type === 36***REMOVED*** { // $
        // set a rewind point, as the packet could be larger than the
        // buffer in memory
        offset = this._offset - 1;

        packetHeader = new Packet(type, this.parseHeader(***REMOVED******REMOVED***;

        // packets with a size of -1 are considered null
        if (packetHeader.size === -1***REMOVED*** {
            return undefined;
      ***REMOVED***

        end = this._offset + packetHeader.size;
        start = this._offset;

        // set the offset to after the delimiter
        this._offset = end + 2;

        if (end > this._buffer.length***REMOVED*** {
            this._offset = offset;
            throw new IncompleteReadBuffer("Wait for more data."***REMOVED***;
      ***REMOVED***

        if (this.options.return_buffers***REMOVED*** {
            return this._buffer.slice(start, end***REMOVED***;
      ***REMOVED*** else {
            return this._buffer.toString(this._encoding, start, end***REMOVED***;
      ***REMOVED***
  ***REMOVED*** else if (type === 42***REMOVED*** { // *
        offset = this._offset;
        packetHeader = new Packet(type, this.parseHeader(***REMOVED******REMOVED***;

        if (packetHeader.size < 0***REMOVED*** {
            return null;
      ***REMOVED***

        if (packetHeader.size > this._bytesRemaining(***REMOVED******REMOVED*** {
            this._offset = offset - 1;
            throw new IncompleteReadBuffer("Wait for more data."***REMOVED***;
      ***REMOVED***

        var reply = [ ];
        var ntype, i, res;

        offset = this._offset - 1;

        for (i = 0; i < packetHeader.size; i++***REMOVED*** {
            ntype = this._buffer[this._offset++];

            if (this._offset > this._buffer.length***REMOVED*** {
                throw new IncompleteReadBuffer("Wait for more data."***REMOVED***;
          ***REMOVED***
            res = this._parseResult(ntype***REMOVED***;
            if (res === undefined***REMOVED*** {
                res = null;
          ***REMOVED***
            reply.push(res***REMOVED***;
      ***REMOVED***

        return reply;
  ***REMOVED***
};

ReplyParser.prototype.execute = function (buffer***REMOVED*** {
    this.append(buffer***REMOVED***;

    var type, ret, offset;

    while (true***REMOVED*** {
        offset = this._offset;
        try {
            // at least 4 bytes: :1\r\n
            if (this._bytesRemaining(***REMOVED*** < 4***REMOVED*** {
                break;
          ***REMOVED***

            type = this._buffer[this._offset++];

            if (type === 43***REMOVED*** { // +
                ret = this._parseResult(type***REMOVED***;

                if (ret === null***REMOVED*** {
                    break;
              ***REMOVED***

                this.send_reply(ret***REMOVED***;
          ***REMOVED*** else  if (type === 45***REMOVED*** { // -
                ret = this._parseResult(type***REMOVED***;

                if (ret === null***REMOVED*** {
                    break;
              ***REMOVED***

                this.send_error(ret***REMOVED***;
          ***REMOVED*** else if (type === 58***REMOVED*** { // :
                ret = this._parseResult(type***REMOVED***;

                if (ret === null***REMOVED*** {
                    break;
              ***REMOVED***

                this.send_reply(ret***REMOVED***;
          ***REMOVED*** else if (type === 36***REMOVED*** { // $
                ret = this._parseResult(type***REMOVED***;

                if (ret === null***REMOVED*** {
                    break;
              ***REMOVED***

                // check the state for what is the result of
                // a -1, set it back up for a null reply
                if (ret === undefined***REMOVED*** {
                    ret = null;
              ***REMOVED***

                this.send_reply(ret***REMOVED***;
          ***REMOVED*** else if (type === 42***REMOVED*** { // *
                // set a rewind point. if a failure occurs,
                // wait for the next execute(***REMOVED***/append(***REMOVED*** and try again
                offset = this._offset - 1;

                ret = this._parseResult(type***REMOVED***;

                this.send_reply(ret***REMOVED***;
          ***REMOVED***
      ***REMOVED*** catch (err***REMOVED*** {
            // catch the error (not enough data***REMOVED***, rewind, and wait
            // for the next packet to appear
            if (! (err instanceof IncompleteReadBuffer***REMOVED******REMOVED*** {
              throw err;
          ***REMOVED***
            this._offset = offset;
            break;
      ***REMOVED***
  ***REMOVED***
};

ReplyParser.prototype.append = function (newBuffer***REMOVED*** {
    if (!newBuffer***REMOVED*** {
        return;
  ***REMOVED***

    // first run
    if (this._buffer === null***REMOVED*** {
        this._buffer = newBuffer;

        return;
  ***REMOVED***

    // out of data
    if (this._offset >= this._buffer.length***REMOVED*** {
        this._buffer = newBuffer;
        this._offset = 0;

        return;
  ***REMOVED***

    // very large packet
    // check for concat, if we have it, use it
    if (Buffer.concat !== undefined***REMOVED*** {
        this._buffer = Buffer.concat([this._buffer.slice(this._offset***REMOVED***, newBuffer]***REMOVED***;
  ***REMOVED*** else {
        var remaining = this._bytesRemaining(***REMOVED***,
            newLength = remaining + newBuffer.length,
            tmpBuffer = new Buffer(newLength***REMOVED***;

        this._buffer.copy(tmpBuffer, 0, this._offset***REMOVED***;
        newBuffer.copy(tmpBuffer, remaining, 0***REMOVED***;

        this._buffer = tmpBuffer;
  ***REMOVED***

    this._offset = 0;
};

ReplyParser.prototype.parseHeader = function (***REMOVED*** {
    var end   = this._packetEndOffset(***REMOVED***,
        value = small_toString(this._buffer, this._offset, end - 1***REMOVED***;

    this._offset = end + 1;

    return value;
};

ReplyParser.prototype._packetEndOffset = function (***REMOVED*** {
    var offset = this._offset;

    while (this._buffer[offset] !== 0x0d && this._buffer[offset + 1] !== 0x0a***REMOVED*** {
        offset++;

        if (offset >= this._buffer.length***REMOVED*** {
            throw new IncompleteReadBuffer("didn't see LF after NL reading multi bulk count (" + offset + " => " + this._buffer.length + ", " + this._offset + "***REMOVED***"***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    offset++;
    return offset;
};

ReplyParser.prototype._bytesRemaining = function (***REMOVED*** {
    return (this._buffer.length - this._offset***REMOVED*** < 0 ? 0 : (this._buffer.length - this._offset***REMOVED***;
};

ReplyParser.prototype.parser_error = function (message***REMOVED*** {
    this.emit("error", message***REMOVED***;
};

ReplyParser.prototype.send_error = function (reply***REMOVED*** {
    this.emit("reply error", reply***REMOVED***;
};

ReplyParser.prototype.send_reply = function (reply***REMOVED*** {
    this.emit("reply", reply***REMOVED***;
};
