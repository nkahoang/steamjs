/*global require console setTimeout process Buffer */
var PORT = 6379;
var HOST = '127.0.0.1';

var redis = require("./index"***REMOVED***,
    client = redis.createClient(PORT, HOST***REMOVED***,
    client2 = redis.createClient(PORT, HOST***REMOVED***,
    client3 = redis.createClient(PORT, HOST***REMOVED***,
    bclient = redis.createClient(PORT, HOST, { return_buffers: true }***REMOVED***,
    assert = require("assert"***REMOVED***,
    crypto = require("crypto"***REMOVED***,
    util = require("./lib/util"***REMOVED***,
    fork = require("child_process"***REMOVED***.fork,
    test_db_num = 15, // this DB will be flushed and used for testing
    tests = {},
    connected = false,
    ended = false,
    next, cur_start, run_next_test, all_tests, all_start, test_count;


// Set this to truthy to see the wire protocol and other debugging info
redis.debug_mode = process.argv[2];

function server_version_at_least(connection, desired_version***REMOVED*** {
    // Return true if the server version >= desired_version
    var version = connection.server_info.versions;
    for (var i = 0; i < 3; i++***REMOVED*** {
        if (version[i] > desired_version[i]***REMOVED*** return true;
        if (version[i] < desired_version[i]***REMOVED*** return false;
  ***REMOVED***
    return true;
}

function buffers_to_strings(arr***REMOVED*** {
    return arr.map(function (val***REMOVED*** {
        return val.toString(***REMOVED***;
  ***REMOVED******REMOVED***;
}

function require_number(expected, label***REMOVED*** {
    return function (err, results***REMOVED*** {
        assert.strictEqual(null, err, label + " expected " + expected + ", got error: " + err***REMOVED***;
        assert.strictEqual(expected, results, label + " " + expected + " !== " + results***REMOVED***;
        assert.strictEqual(typeof results, "number", label***REMOVED***;
        return true;
  ***REMOVED***;
}

function require_number_any(label***REMOVED*** {
    return function (err, results***REMOVED*** {
        assert.strictEqual(null, err, label + " expected any number, got error: " + err***REMOVED***;
        assert.strictEqual(typeof results, "number", label + " " + results + " is not a number"***REMOVED***;
        return true;
  ***REMOVED***;
}

function require_number_pos(label***REMOVED*** {
    return function (err, results***REMOVED*** {
        assert.strictEqual(null, err, label + " expected positive number, got error: " + err***REMOVED***;
        assert.strictEqual(true, (results > 0***REMOVED***, label + " " + results + " is not a positive number"***REMOVED***;
        return true;
  ***REMOVED***;
}

function require_string(str, label***REMOVED*** {
    return function (err, results***REMOVED*** {
        assert.strictEqual(null, err, label + " expected string '" + str + "', got error: " + err***REMOVED***;
        assert.equal(str, results, label + " " + str + " does not match " + results***REMOVED***;
        return true;
  ***REMOVED***;
}

function require_null(label***REMOVED*** {
    return function (err, results***REMOVED*** {
        assert.strictEqual(null, err, label + " expected null, got error: " + err***REMOVED***;
        assert.strictEqual(null, results, label + ": " + results + " is not null"***REMOVED***;
        return true;
  ***REMOVED***;
}

function require_error(label***REMOVED*** {
    return function (err, results***REMOVED*** {
        assert.notEqual(err, null, label + " err is null, but an error is expected here."***REMOVED***;
        return true;
  ***REMOVED***;
}

function is_empty_array(obj***REMOVED*** {
    return Array.isArray(obj***REMOVED*** && obj.length === 0;
}

function last(name, fn***REMOVED*** {
    return function (err, results***REMOVED*** {
        fn(err, results***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***;
}

// Wraps the given callback in a timeout. If the returned function
// is not called within the timeout period, we fail the named test.
function with_timeout(name, cb, millis***REMOVED*** {
    var timeoutId = setTimeout(function(***REMOVED*** {
        assert.fail("Callback timed out!", name***REMOVED***;
  ***REMOVED***, millis***REMOVED***;
    return function(***REMOVED*** {
        clearTimeout(timeoutId***REMOVED***;
        cb.apply(this, arguments***REMOVED***;
  ***REMOVED***;
}

next = function next(name***REMOVED*** {
    console.log(" \x1b[33m" + (Date.now(***REMOVED*** - cur_start***REMOVED*** + "\x1b[0m ms"***REMOVED***;
    run_next_test(***REMOVED***;
};

// Tests are run in the order they are defined, so FLUSHDB should always be first.

tests.FLUSHDB = function (***REMOVED*** {
    var name = "FLUSHDB";
    client.select(test_db_num, require_string("OK", name***REMOVED******REMOVED***;
    client2.select(test_db_num, require_string("OK", name***REMOVED******REMOVED***;
    client3.select(test_db_num, require_string("OK", name***REMOVED******REMOVED***;
    client.mset("flush keys 1", "flush val 1", "flush keys 2", "flush val 2", require_string("OK", name***REMOVED******REMOVED***;
    client.FLUSHDB(require_string("OK", name***REMOVED******REMOVED***;
    client.dbsize(last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.INCR = function (***REMOVED*** {
    var name = "INCR";

    if (bclient.reply_parser.name == "hiredis"***REMOVED*** {
        console.log("Skipping INCR buffer test with hiredis"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    // Test incr with the maximum JavaScript number value. Since we are
    // returning buffers we should get back one more as a Buffer.
    bclient.set("seq", "9007199254740992", function (err, result***REMOVED*** {
        assert.strictEqual(result.toString(***REMOVED***, "OK"***REMOVED***;
        bclient.incr("seq", function (err, result***REMOVED*** {
            assert.strictEqual("9007199254740993", result.toString(***REMOVED******REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTI_1 = function (***REMOVED*** {
    var name = "MULTI_1", multi1, multi2;

    // Provoke an error at queue time
    multi1 = client.multi(***REMOVED***;
    multi1.mset("multifoo", "10", "multibar", "20", require_string("OK", name***REMOVED******REMOVED***;
    multi1.set("foo2", require_error(name***REMOVED******REMOVED***;
    multi1.incr("multifoo", require_number(11, name***REMOVED******REMOVED***;
    multi1.incr("multibar", require_number(21, name***REMOVED******REMOVED***;
    multi1.exec(function (***REMOVED*** {
        require_error(name***REMOVED***;

        // Redis 2.6.5+ will abort transactions with errors
        // see: http://redis.io/topics/transactions
        var multibar_expected = 22;
        var multifoo_expected = 12;
        if (server_version_at_least(client, [2, 6, 5]***REMOVED******REMOVED*** {
            multibar_expected = 1;
            multifoo_expected = 1;
      ***REMOVED***

        // Confirm that the previous command, while containing an error, still worked.
        multi2 = client.multi(***REMOVED***;
        multi2.incr("multibar", require_number(multibar_expected, name***REMOVED******REMOVED***;
        multi2.incr("multifoo", require_number(multifoo_expected, name***REMOVED******REMOVED***;
        multi2.exec(function (err, replies***REMOVED*** {
            assert.strictEqual(multibar_expected, replies[0]***REMOVED***;
            assert.strictEqual(multifoo_expected, replies[1]***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTI_2 = function (***REMOVED*** {
    var name = "MULTI_2";

    // test nested multi-bulk replies
    client.multi([
        ["mget", "multifoo", "multibar", function (err, res***REMOVED*** {
            assert.strictEqual(2, res.length, name***REMOVED***;
            assert.strictEqual("12", res[0].toString(***REMOVED***, name***REMOVED***;
            assert.strictEqual("22", res[1].toString(***REMOVED***, name***REMOVED***;
      ***REMOVED***],
        ["set", "foo2", require_error(name***REMOVED***],
        ["incr", "multifoo", require_number(13, name***REMOVED***],
        ["incr", "multibar", require_number(23, name***REMOVED***]

    ]***REMOVED***.exec(function (err, replies***REMOVED*** {

        if (server_version_at_least(client, [2, 6, 5]***REMOVED******REMOVED*** {
            assert.notEqual(err, null, name***REMOVED***;
            assert.equal(replies, undefined, name***REMOVED***;
      ***REMOVED*** else {
            assert.strictEqual(2, replies[0].length, name***REMOVED***;
            assert.strictEqual("12", replies[0][0].toString(***REMOVED***, name***REMOVED***;
            assert.strictEqual("22", replies[0][1].toString(***REMOVED***, name***REMOVED***;

            assert.strictEqual("13", replies[1].toString(***REMOVED******REMOVED***;
            assert.strictEqual("23", replies[2].toString(***REMOVED******REMOVED***;
      ***REMOVED***
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTI_3 = function (***REMOVED*** {
    var name = "MULTI_3";

    client.sadd("some set", "mem 1"***REMOVED***;
    client.sadd("some set", "mem 2"***REMOVED***;
    client.sadd("some set", "mem 3"***REMOVED***;
    client.sadd("some set", "mem 4"***REMOVED***;

    // make sure empty mb reply works
    client.del("some missing set"***REMOVED***;
    client.smembers("some missing set", function (err, reply***REMOVED*** {
        // make sure empty mb reply works
        assert.strictEqual(true, is_empty_array(reply***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;

    // test nested multi-bulk replies with empty mb elements.
    client.multi([
        ["smembers", "some set"],
        ["del", "some set"],
        ["smembers", "some set"]
    ]***REMOVED***
    .scard("some set"***REMOVED***
    .exec(function (err, replies***REMOVED*** {
        assert.strictEqual(true, is_empty_array(replies[2]***REMOVED***, name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTI_4 = function (***REMOVED*** {
    var name = "MULTI_4";

    client.multi(***REMOVED***
        .mset('some', '10', 'keys', '20'***REMOVED***
        .incr('some'***REMOVED***
        .incr('keys'***REMOVED***
        .mget('some', 'keys'***REMOVED***
        .exec(function (err, replies***REMOVED*** {
            assert.strictEqual(null, err***REMOVED***;
            assert.equal('OK', replies[0]***REMOVED***;
            assert.equal(11, replies[1]***REMOVED***;
            assert.equal(21, replies[2]***REMOVED***;
            assert.equal(11, replies[3][0].toString(***REMOVED******REMOVED***;
            assert.equal(21, replies[3][1].toString(***REMOVED******REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
};

tests.MULTI_5 = function (***REMOVED*** {
    var name = "MULTI_5";

    // test nested multi-bulk replies with nulls.
    client.multi([
        ["mget", ["multifoo", "some", "random value", "keys"]],
        ["incr", "multifoo"]
    ]***REMOVED***
    .exec(function (err, replies***REMOVED*** {
        assert.strictEqual(replies.length, 2, name***REMOVED***;
        assert.strictEqual(replies[0].length, 4, name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTI_6 = function (***REMOVED*** {
    var name = "MULTI_6";

    client.multi(***REMOVED***
        .hmset("multihash", "a", "foo", "b", 1***REMOVED***
        .hmset("multihash", {
            extra: "fancy",
            things: "here"
      ***REMOVED******REMOVED***
        .hgetall("multihash"***REMOVED***
        .exec(function (err, replies***REMOVED*** {
            assert.strictEqual(null, err***REMOVED***;
            assert.equal("OK", replies[0]***REMOVED***;
            assert.equal(Object.keys(replies[2]***REMOVED***.length, 4***REMOVED***;
            assert.equal("foo", replies[2].a***REMOVED***;
            assert.equal("1", replies[2].b***REMOVED***;
            assert.equal("fancy", replies[2].extra***REMOVED***;
            assert.equal("here", replies[2].things***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
};

tests.MULTI_7 = function (***REMOVED*** {
    var name = "MULTI_7";

    if (bclient.reply_parser.name != "javascript"***REMOVED*** {
        console.log("Skipping wire-protocol test for 3rd-party parser"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    var p = require("./lib/parser/javascript"***REMOVED***;
    var parser = new p.Parser(false***REMOVED***;
    var reply_count = 0;
    function check_reply(reply***REMOVED*** {
        assert.deepEqual(reply, [['a']], "Expecting multi-bulk reply of [['a']]"***REMOVED***;
        reply_count++;
        assert.notEqual(reply_count, 4, "Should only parse 3 replies"***REMOVED***;
  ***REMOVED***
    parser.on("reply", check_reply***REMOVED***;

    parser.execute(new Buffer('*1\r\n*1\r\n$1\r\na\r\n'***REMOVED******REMOVED***;

    parser.execute(new Buffer('*1\r\n*1\r'***REMOVED******REMOVED***;
    parser.execute(new Buffer('\n$1\r\na\r\n'***REMOVED******REMOVED***;

    parser.execute(new Buffer('*1\r\n*1\r\n'***REMOVED******REMOVED***;
    parser.execute(new Buffer('$1\r\na\r\n'***REMOVED******REMOVED***;

    next(name***REMOVED***;
};


tests.MULTI_EXCEPTION_1 = function(***REMOVED*** {
    var name = "MULTI_EXCEPTION_1";

    if (!server_version_at_least(client, [2, 6, 5]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " for old Redis server version < 2.6.5"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    client.multi(***REMOVED***.set("foo"***REMOVED***.exec(function (err, reply***REMOVED*** {
        assert(Array.isArray(err***REMOVED***, "err should be an array"***REMOVED***;
        assert.equal(2, err.length, "err should have 2 items"***REMOVED***;
        assert(err[0].message.match(/ERR/***REMOVED***, "First error message should contain ERR"***REMOVED***;
        assert(err[1].message.match(/EXECABORT/***REMOVED***, "First error message should contain EXECABORT"***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTI_8 = function (***REMOVED*** {
    var name = "MULTI_8", multi1, multi2;

    // Provoke an error at queue time
    multi1 = client.multi(***REMOVED***;
    multi1.mset("multifoo_8", "10", "multibar_8", "20", require_string("OK", name***REMOVED******REMOVED***;
    multi1.set("foo2", require_error(name***REMOVED******REMOVED***;
    multi1.set("foo3", require_error(name***REMOVED******REMOVED***;
    multi1.incr("multifoo_8", require_number(11, name***REMOVED******REMOVED***;
    multi1.incr("multibar_8", require_number(21, name***REMOVED******REMOVED***;
    multi1.exec(function (***REMOVED*** {
        require_error(name***REMOVED***;

        // Redis 2.6.5+ will abort transactions with errors
        // see: http://redis.io/topics/transactions
        var multibar_expected = 22;
        var multifoo_expected = 12;
        if (server_version_at_least(client, [2, 6, 5]***REMOVED******REMOVED*** {
            multibar_expected = 1;
            multifoo_expected = 1;
      ***REMOVED***

        // Confirm that the previous command, while containing an error, still worked.
        multi2 = client.multi(***REMOVED***;
        multi2.incr("multibar_8", require_number(multibar_expected, name***REMOVED******REMOVED***;
        multi2.incr("multifoo_8", require_number(multifoo_expected, name***REMOVED******REMOVED***;
        multi2.exec(function (err, replies***REMOVED*** {
            assert.strictEqual(multibar_expected, replies[0]***REMOVED***;
            assert.strictEqual(multifoo_expected, replies[1]***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.FWD_ERRORS_1 = function (***REMOVED*** {
    var name = "FWD_ERRORS_1";

    var toThrow = new Error("Forced exception"***REMOVED***;
    var recordedError = null;

    var originalHandlers = client3.listeners("error"***REMOVED***;
    client3.removeAllListeners("error"***REMOVED***;
    client3.once("error", function (err***REMOVED*** {
        recordedError = err;
  ***REMOVED******REMOVED***;

    client3.on("message", function (channel, data***REMOVED*** {
        console.log("incoming"***REMOVED***;
        if (channel == name***REMOVED*** {
            assert.equal(data, "Some message"***REMOVED***;
            throw toThrow;
      ***REMOVED***
  ***REMOVED******REMOVED***;
    client3.subscribe(name***REMOVED***;

    client.publish(name, "Some message"***REMOVED***;
    setTimeout(function (***REMOVED*** {
        client3.listeners("error"***REMOVED***.push(originalHandlers***REMOVED***;
        assert.equal(recordedError, toThrow, "Should have caught our forced exception"***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***, 150***REMOVED***;
};

tests.FWD_ERRORS_2 = function (***REMOVED*** {
    var name = "FWD_ERRORS_2";

    var toThrow = new Error("Forced exception"***REMOVED***;
    var recordedError = null;

    var originalHandler = client.listeners("error"***REMOVED***.pop(***REMOVED***;
    client.removeAllListeners("error"***REMOVED***;
    client.once("error", function (err***REMOVED*** {
        recordedError = err;
  ***REMOVED******REMOVED***;

    client.get("no_such_key", function (err, reply***REMOVED*** {
        throw toThrow;
  ***REMOVED******REMOVED***;

    setTimeout(function (***REMOVED*** {
        client.listeners("error"***REMOVED***.push(originalHandler***REMOVED***;
        assert.equal(recordedError, toThrow, "Should have caught our forced exception"***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***, 150***REMOVED***;
};

tests.FWD_ERRORS_3 = function (***REMOVED*** {
    var name = "FWD_ERRORS_3";

    var recordedError = null;

    var originalHandler = client.listeners("error"***REMOVED***.pop(***REMOVED***;
    client.removeAllListeners("error"***REMOVED***;
    client.once("error", function (err***REMOVED*** {
        recordedError = err;
  ***REMOVED******REMOVED***;

    client.send_command("no_such_command", []***REMOVED***;

    setTimeout(function (***REMOVED*** {
        client.listeners("error"***REMOVED***.push(originalHandler***REMOVED***;
        assert.ok(recordedError instanceof Error***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***, 150***REMOVED***;
};

tests.FWD_ERRORS_4 = function (***REMOVED*** {
    var name = "FWD_ERRORS_4";

    var toThrow = new Error("Forced exception"***REMOVED***;
    var recordedError = null;

    var originalHandler = client.listeners("error"***REMOVED***.pop(***REMOVED***;
    client.removeAllListeners("error"***REMOVED***;
    client.once("error", function (err***REMOVED*** {
        recordedError = err;
  ***REMOVED******REMOVED***;

    client.send_command("no_such_command", [], function (***REMOVED*** {
        throw toThrow;
  ***REMOVED******REMOVED***;

    setTimeout(function (***REMOVED*** {
        client.listeners("error"***REMOVED***.push(originalHandler***REMOVED***;
        assert.equal(recordedError, toThrow, "Should have caught our forced exception"***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***, 150***REMOVED***;
};

tests.EVAL_1 = function (***REMOVED*** {
    var name = "EVAL_1";

    if (!server_version_at_least(client, [2, 5, 0]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " for old Redis server version < 2.5.x"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    // test {EVAL - Lua integer -> Redis protocol type conversion}
    client.eval("return 100.5", 0, require_number(100, name***REMOVED******REMOVED***;
    // test {EVAL - Lua string -> Redis protocol type conversion}
    client.eval("return 'hello world'", 0, require_string("hello world", name***REMOVED******REMOVED***;
    // test {EVAL - Lua true boolean -> Redis protocol type conversion}
    client.eval("return true", 0, require_number(1, name***REMOVED******REMOVED***;
    // test {EVAL - Lua false boolean -> Redis protocol type conversion}
    client.eval("return false", 0, require_null(name***REMOVED******REMOVED***;
    // test {EVAL - Lua status code reply -> Redis protocol type conversion}
    client.eval("return {ok='fine'}", 0, require_string("fine", name***REMOVED******REMOVED***;
    // test {EVAL - Lua error reply -> Redis protocol type conversion}
    client.eval("return {err='this is an error'}", 0, require_error(name***REMOVED******REMOVED***;
    // test {EVAL - Lua table -> Redis protocol type conversion}
    client.eval("return {1,2,3,'ciao',{1,2}}", 0, function (err, res***REMOVED*** {
        assert.strictEqual(5, res.length, name***REMOVED***;
        assert.strictEqual(1, res[0], name***REMOVED***;
        assert.strictEqual(2, res[1], name***REMOVED***;
        assert.strictEqual(3, res[2], name***REMOVED***;
        assert.strictEqual("ciao", res[3], name***REMOVED***;
        assert.strictEqual(2, res[4].length, name***REMOVED***;
        assert.strictEqual(1, res[4][0], name***REMOVED***;
        assert.strictEqual(2, res[4][1], name***REMOVED***;
  ***REMOVED******REMOVED***;
    // test {EVAL - Are the KEYS and ARGS arrays populated correctly?}
    client.eval("return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}", 2, "a", "b", "c", "d", function (err, res***REMOVED*** {
        assert.strictEqual(4, res.length, name***REMOVED***;
        assert.strictEqual("a", res[0], name***REMOVED***;
        assert.strictEqual("b", res[1], name***REMOVED***;
        assert.strictEqual("c", res[2], name***REMOVED***;
        assert.strictEqual("d", res[3], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // test {EVAL - parameters in array format gives same result}
    client.eval(["return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}", 2, "a", "b", "c", "d"], function (err, res***REMOVED*** {
        assert.strictEqual(4, res.length, name***REMOVED***;
        assert.strictEqual("a", res[0], name***REMOVED***;
        assert.strictEqual("b", res[1], name***REMOVED***;
        assert.strictEqual("c", res[2], name***REMOVED***;
        assert.strictEqual("d", res[3], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // prepare sha sum for evalsha cache test
    var source = "return redis.call('get', 'sha test'***REMOVED***",
        sha = crypto.createHash('sha1'***REMOVED***.update(source***REMOVED***.digest('hex'***REMOVED***;

    client.set("sha test", "eval get sha test", function (err, res***REMOVED*** {
        if (err***REMOVED*** throw err;
        // test {EVAL - is Lua able to call Redis API?}
        client.eval(source, 0, function (err, res***REMOVED*** {
            require_string("eval get sha test", name***REMOVED***(err, res***REMOVED***;
            // test {EVALSHA - Can we call a SHA1 if already defined?}
            client.evalsha(sha, 0, require_string("eval get sha test", name***REMOVED******REMOVED***;
            // test {EVALSHA - Do we get an error on non defined SHA1?}
            client.evalsha("ffffffffffffffffffffffffffffffffffffffff", 0, require_error(name***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;

    // test {EVAL - Redis integer -> Lua type conversion}
    client.set("incr key", 0, function (err, reply***REMOVED*** {
        if (err***REMOVED*** throw err;
        client.eval("local foo = redis.call('incr','incr key'***REMOVED***\n" + "return {type(foo***REMOVED***,foo}", 0, function (err, res***REMOVED*** {
            if (err***REMOVED*** throw err;
            assert.strictEqual(2, res.length, name***REMOVED***;
            assert.strictEqual("number", res[0], name***REMOVED***;
            assert.strictEqual(1, res[1], name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;

    client.set("bulk reply key", "bulk reply value", function (err, res***REMOVED*** {
        // test {EVAL - Redis bulk -> Lua type conversion}
        client.eval("local foo = redis.call('get','bulk reply key'***REMOVED***; return {type(foo***REMOVED***,foo}", 0, function (err, res***REMOVED*** {
            if (err***REMOVED*** throw err;
            assert.strictEqual(2, res.length, name***REMOVED***;
            assert.strictEqual("string", res[0], name***REMOVED***;
            assert.strictEqual("bulk reply value", res[1], name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;

    // test {EVAL - Redis multi bulk -> Lua type conversion}
    client.multi(***REMOVED***
        .del("mylist"***REMOVED***
        .rpush("mylist", "a"***REMOVED***
        .rpush("mylist", "b"***REMOVED***
        .rpush("mylist", "c"***REMOVED***
        .exec(function (err, replies***REMOVED*** {
            if (err***REMOVED*** throw err;
            client.eval("local foo = redis.call('lrange','mylist',0,-1***REMOVED***; return {type(foo***REMOVED***,foo[1],foo[2],foo[3],# foo}", 0, function (err, res***REMOVED*** {
                assert.strictEqual(5, res.length, name***REMOVED***;
                assert.strictEqual("table", res[0], name***REMOVED***;
                assert.strictEqual("a", res[1], name***REMOVED***;
                assert.strictEqual("b", res[2], name***REMOVED***;
                assert.strictEqual("c", res[3], name***REMOVED***;
                assert.strictEqual(3, res[4], name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
    // test {EVAL - Redis status reply -> Lua type conversion}
    client.eval("local foo = redis.call('set','mykey','myval'***REMOVED***; return {type(foo***REMOVED***,foo['ok']}", 0, function (err, res***REMOVED*** {
        if (err***REMOVED*** throw err;
        assert.strictEqual(2, res.length, name***REMOVED***;
        assert.strictEqual("table", res[0], name***REMOVED***;
        assert.strictEqual("OK", res[1], name***REMOVED***;
  ***REMOVED******REMOVED***;
    // test {EVAL - Redis error reply -> Lua type conversion}
    client.set("error reply key", "error reply value", function (err, res***REMOVED*** {
        if (err***REMOVED*** throw err;
        client.eval("local foo = redis.pcall('incr','error reply key'***REMOVED***; return {type(foo***REMOVED***,foo['err']}", 0, function (err, res***REMOVED*** {
            if (err***REMOVED*** throw err;
            assert.strictEqual(2, res.length, name***REMOVED***;
            assert.strictEqual("table", res[0], name***REMOVED***;
            assert.strictEqual("ERR value is not an integer or out of range", res[1], name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
    // test {EVAL - Redis nil bulk reply -> Lua type conversion}
    client.del("nil reply key", function (err, res***REMOVED*** {
        if (err***REMOVED*** throw err;
        client.eval("local foo = redis.call('get','nil reply key'***REMOVED***; return {type(foo***REMOVED***,foo == false}", 0, function (err, res***REMOVED*** {
            if (err***REMOVED*** throw err;
            assert.strictEqual(2, res.length, name***REMOVED***;
            assert.strictEqual("boolean", res[0], name***REMOVED***;
            assert.strictEqual(1, res[1], name***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SCRIPT_LOAD = function(***REMOVED*** {
    var name = "SCRIPT_LOAD",
        command = "return 1",
        commandSha = crypto.createHash('sha1'***REMOVED***.update(command***REMOVED***.digest('hex'***REMOVED***;

    if (!server_version_at_least(client, [2, 6, 0]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " for old Redis server version < 2.6.x"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    bclient.script("load", command, function(err, result***REMOVED*** {
        assert.strictEqual(result.toString(***REMOVED***, commandSha***REMOVED***;
        client.multi(***REMOVED***.script("load", command***REMOVED***.exec(function(err, result***REMOVED*** {
            assert.strictEqual(result[0].toString(***REMOVED***, commandSha***REMOVED***;
            client.multi([['script', 'load', command]]***REMOVED***.exec(function(err, result***REMOVED*** {
                assert.strictEqual(result[0].toString(***REMOVED***, commandSha***REMOVED***;
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.CLIENT_LIST = function(***REMOVED*** {
    var name = "CLIENT_LIST";

    if (!server_version_at_least(client, [2, 4, 0]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " for old Redis server version < 2.4.x"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    function checkResult(result***REMOVED*** {
        var lines = result.toString(***REMOVED***.split('\n'***REMOVED***.slice(0, -1***REMOVED***;
        assert.strictEqual(lines.length, 4***REMOVED***;
        assert(lines.every(function(line***REMOVED*** {
            return line.match(/^addr=/***REMOVED***;
      ***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***

    bclient.client("list", function(err, result***REMOVED*** {
        console.log(result.toString(***REMOVED******REMOVED***;
        checkResult(result***REMOVED***;
        client.multi(***REMOVED***.client("list"***REMOVED***.exec(function(err, result***REMOVED*** {
            console.log(result.toString(***REMOVED******REMOVED***;
            checkResult(result***REMOVED***;
            client.multi([['client', 'list']]***REMOVED***.exec(function(err, result***REMOVED*** {
                console.log(result.toString(***REMOVED******REMOVED***;
                checkResult(result***REMOVED***;
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.WATCH_MULTI = function (***REMOVED*** {
    var name = 'WATCH_MULTI', multi;
    if (!server_version_at_least(client, [2, 2, 0]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " for old Redis server version < 2.2.x"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    client.watch(name***REMOVED***;
    client.incr(name***REMOVED***;
    multi = client.multi(***REMOVED***;
    multi.incr(name***REMOVED***;
    multi.exec(last(name, require_null(name***REMOVED******REMOVED******REMOVED***;
};

tests.WATCH_TRANSACTION = function (***REMOVED*** {
    var name = "WATCH_TRANSACTION";

    if (!server_version_at_least(client, [2, 1, 0]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " because server version isn't new enough."***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    // Test WATCH command aborting transactions, look for parser offset errors.

    client.set("unwatched", 200***REMOVED***;

    client.set(name, 0***REMOVED***;
    client.watch(name***REMOVED***;
    client.incr(name***REMOVED***;
    var multi = client.multi(***REMOVED***
        .incr(name***REMOVED***
        .exec(function (err, replies***REMOVED*** {
            // Failure expected because of pre-multi incr
            assert.strictEqual(replies, null, "Aborted transaction multi-bulk reply should be null."***REMOVED***;

            client.get("unwatched", function (err, reply***REMOVED*** {
                assert.equal(err, null, name***REMOVED***;
                assert.equal(reply, 200, "Expected 200, got " + reply***REMOVED***;
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;

    client.set("unrelated", 100, function (err, reply***REMOVED*** {
        assert.equal(err, null, name***REMOVED***;
        assert.equal(reply, "OK", "Expected 'OK', got " + reply***REMOVED***;
  ***REMOVED******REMOVED***;
};


tests.detect_buffers = function (***REMOVED*** {
    var name = "detect_buffers", detect_client = redis.createClient(null, null, {detect_buffers: true}***REMOVED***;

    detect_client.on("ready", function (***REMOVED*** {
        // single Buffer or String
        detect_client.set("string key 1", "string value"***REMOVED***;
        detect_client.get("string key 1", require_string("string value", name***REMOVED******REMOVED***;
        detect_client.get(new Buffer("string key 1"***REMOVED***, function (err, reply***REMOVED*** {
            assert.strictEqual(null, err, name***REMOVED***;
            assert.strictEqual(true, Buffer.isBuffer(reply***REMOVED***, name***REMOVED***;
            assert.strictEqual("<Buffer 73 74 72 69 6e 67 20 76 61 6c 75 65>", reply.inspect(***REMOVED***, name***REMOVED***;
      ***REMOVED******REMOVED***;

        detect_client.hmset("hash key 2", "key 1", "val 1", "key 2", "val 2"***REMOVED***;
        // array of Buffers or Strings
        detect_client.hmget("hash key 2", "key 1", "key 2", function (err, reply***REMOVED*** {
            assert.strictEqual(null, err, name***REMOVED***;
            assert.strictEqual(true, Array.isArray(reply***REMOVED***, name***REMOVED***;
            assert.strictEqual(2, reply.length, name***REMOVED***;
            assert.strictEqual("val 1", reply[0], name***REMOVED***;
            assert.strictEqual("val 2", reply[1], name***REMOVED***;
      ***REMOVED******REMOVED***;
        detect_client.hmget(new Buffer("hash key 2"***REMOVED***, "key 1", "key 2", function (err, reply***REMOVED*** {
            assert.strictEqual(null, err, name***REMOVED***;
            assert.strictEqual(true, Array.isArray(reply***REMOVED******REMOVED***;
            assert.strictEqual(2, reply.length, name***REMOVED***;
            assert.strictEqual(true, Buffer.isBuffer(reply[0]***REMOVED******REMOVED***;
            assert.strictEqual(true, Buffer.isBuffer(reply[1]***REMOVED******REMOVED***;
            assert.strictEqual("<Buffer 76 61 6c 20 31>", reply[0].inspect(***REMOVED***, name***REMOVED***;
            assert.strictEqual("<Buffer 76 61 6c 20 32>", reply[1].inspect(***REMOVED***, name***REMOVED***;
      ***REMOVED******REMOVED***;

        // array of strings with undefined values (repro #344***REMOVED***
        detect_client.hmget("hash key 2", "key 3", "key 4", function(err, reply***REMOVED*** {
            assert.strictEqual(null, err, name***REMOVED***;
            assert.strictEqual(true, Array.isArray(reply***REMOVED***, name***REMOVED***;
            assert.strictEqual(2, reply.length, name***REMOVED***;
            assert.equal(null, reply[0], name***REMOVED***;
            assert.equal(null, reply[1], name***REMOVED***;
      ***REMOVED******REMOVED***;

        // Object of Buffers or Strings
        detect_client.hgetall("hash key 2", function (err, reply***REMOVED*** {
            assert.strictEqual(null, err, name***REMOVED***;
            assert.strictEqual("object", typeof reply, name***REMOVED***;
            assert.strictEqual(2, Object.keys(reply***REMOVED***.length, name***REMOVED***;
            assert.strictEqual("val 1", reply["key 1"], name***REMOVED***;
            assert.strictEqual("val 2", reply["key 2"], name***REMOVED***;
      ***REMOVED******REMOVED***;
        detect_client.hgetall(new Buffer("hash key 2"***REMOVED***, function (err, reply***REMOVED*** {
            assert.strictEqual(null, err, name***REMOVED***;
            assert.strictEqual("object", typeof reply, name***REMOVED***;
            assert.strictEqual(2, Object.keys(reply***REMOVED***.length, name***REMOVED***;
            assert.strictEqual(true, Buffer.isBuffer(reply["key 1"]***REMOVED******REMOVED***;
            assert.strictEqual(true, Buffer.isBuffer(reply["key 2"]***REMOVED******REMOVED***;
            assert.strictEqual("<Buffer 76 61 6c 20 31>", reply["key 1"].inspect(***REMOVED***, name***REMOVED***;
            assert.strictEqual("<Buffer 76 61 6c 20 32>", reply["key 2"].inspect(***REMOVED***, name***REMOVED***;
      ***REMOVED******REMOVED***;

        detect_client.quit(function (err, res***REMOVED*** {
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.socket_nodelay = function (***REMOVED*** {
    var name = "socket_nodelay", c1, c2, c3, ready_count = 0, quit_count = 0;

    c1 = redis.createClient(null, null, {socket_nodelay: true}***REMOVED***;
    c2 = redis.createClient(null, null, {socket_nodelay: false}***REMOVED***;
    c3 = redis.createClient(null, null***REMOVED***;

    function quit_check(***REMOVED*** {
        quit_count++;

        if (quit_count === 3***REMOVED*** {
            next(name***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    function run(***REMOVED*** {
        assert.strictEqual(true, c1.options.socket_nodelay, name***REMOVED***;
        assert.strictEqual(false, c2.options.socket_nodelay, name***REMOVED***;
        assert.strictEqual(true, c3.options.socket_nodelay, name***REMOVED***;

        c1.set(["set key 1", "set val"], require_string("OK", name***REMOVED******REMOVED***;
        c1.set(["set key 2", "set val"], require_string("OK", name***REMOVED******REMOVED***;
        c1.get(["set key 1"], require_string("set val", name***REMOVED******REMOVED***;
        c1.get(["set key 2"], require_string("set val", name***REMOVED******REMOVED***;

        c2.set(["set key 3", "set val"], require_string("OK", name***REMOVED******REMOVED***;
        c2.set(["set key 4", "set val"], require_string("OK", name***REMOVED******REMOVED***;
        c2.get(["set key 3"], require_string("set val", name***REMOVED******REMOVED***;
        c2.get(["set key 4"], require_string("set val", name***REMOVED******REMOVED***;

        c3.set(["set key 5", "set val"], require_string("OK", name***REMOVED******REMOVED***;
        c3.set(["set key 6", "set val"], require_string("OK", name***REMOVED******REMOVED***;
        c3.get(["set key 5"], require_string("set val", name***REMOVED******REMOVED***;
        c3.get(["set key 6"], require_string("set val", name***REMOVED******REMOVED***;

        c1.quit(quit_check***REMOVED***;
        c2.quit(quit_check***REMOVED***;
        c3.quit(quit_check***REMOVED***;
  ***REMOVED***

    function ready_check(***REMOVED*** {
        ready_count++;
        if (ready_count === 3***REMOVED*** {
            run(***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    c1.on("ready", ready_check***REMOVED***;
    c2.on("ready", ready_check***REMOVED***;
    c3.on("ready", ready_check***REMOVED***;
};

tests.reconnect = function (***REMOVED*** {
    var name = "reconnect";

    client.set("recon 1", "one"***REMOVED***;
    client.set("recon 2", "two", function (err, res***REMOVED*** {
        // Do not do this in normal programs. This is to simulate the server closing on us.
        // For orderly shutdown in normal programs, do client.quit(***REMOVED***
        client.stream.destroy(***REMOVED***;
  ***REMOVED******REMOVED***;

    client.on("reconnecting", function on_recon(params***REMOVED*** {
        client.on("connect", function on_connect(***REMOVED*** {
            client.select(test_db_num, require_string("OK", name***REMOVED******REMOVED***;
            client.get("recon 1", require_string("one", name***REMOVED******REMOVED***;
            client.get("recon 1", require_string("one", name***REMOVED******REMOVED***;
            client.get("recon 2", require_string("two", name***REMOVED******REMOVED***;
            client.get("recon 2", require_string("two", name***REMOVED******REMOVED***;
            client.removeListener("connect", on_connect***REMOVED***;
            client.removeListener("reconnecting", on_recon***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.reconnect_select_db_after_pubsub = function(***REMOVED*** {
    var name = "reconnect_select_db_after_pubsub";

    client.select(test_db_num***REMOVED***;
    client.set(name, "one"***REMOVED***;
    client.subscribe('ChannelV', function (err, res***REMOVED*** {
        client.stream.destroy(***REMOVED***;
  ***REMOVED******REMOVED***;

    client.on("reconnecting", function on_recon(params***REMOVED*** {
        client.on("ready", function on_connect(***REMOVED*** {
            client.unsubscribe('ChannelV', function (err, res***REMOVED*** {
                client.get(name, require_string("one", name***REMOVED******REMOVED***;
                client.removeListener("connect", on_connect***REMOVED***;
                client.removeListener("reconnecting", on_recon***REMOVED***;
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.idle = function (***REMOVED*** {
  var name = "idle";

  client.on("idle", function on_idle(***REMOVED*** {
    client.removeListener("idle", on_idle***REMOVED***;
    next(name***REMOVED***;
***REMOVED******REMOVED***;

  client.set("idle", "test"***REMOVED***;
};

tests.HSET = function (***REMOVED*** {
    var key = "test hash",
        field1 = new Buffer("0123456789"***REMOVED***,
        value1 = new Buffer("abcdefghij"***REMOVED***,
        field2 = new Buffer(0***REMOVED***,
        value2 = new Buffer(0***REMOVED***,
        name = "HSET";

    client.HSET(key, field1, value1, require_number(1, name***REMOVED******REMOVED***;
    client.HGET(key, field1, require_string(value1.toString(***REMOVED***, name***REMOVED******REMOVED***;

    // Empty value
    client.HSET(key, field1, value2, require_number(0, name***REMOVED******REMOVED***;
    client.HGET([key, field1], require_string("", name***REMOVED******REMOVED***;

    // Empty key, empty value
    client.HSET([key, field2, value1], require_number(1, name***REMOVED******REMOVED***;
    client.HSET(key, field2, value2, last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.HLEN = function (***REMOVED*** {
    var key = "test hash",
        field1 = new Buffer("0123456789"***REMOVED***,
        value1 = new Buffer("abcdefghij"***REMOVED***,
        field2 = new Buffer(0***REMOVED***,
        value2 = new Buffer(0***REMOVED***,
        name = "HSET",
        timeout = 1000;

    client.HSET(key, field1, value1, function (err, results***REMOVED*** {
        client.HLEN(key, function (err, len***REMOVED*** {
            assert.ok(2 === +len***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.HMSET_BUFFER_AND_ARRAY = function (***REMOVED*** {
    // Saving a buffer and an array to the same key should not error
    var key = "test hash",
        field1 = "buffer",
        value1 = new Buffer("abcdefghij"***REMOVED***,
        field2 = "array",
        value2 = ["array contents"],
        name = "HSET";

    client.HMSET(key, field1, value1, field2, value2, last(name, require_string("OK", name***REMOVED******REMOVED******REMOVED***;
};

// TODO - add test for HMSET with optional callbacks

tests.HMGET = function (***REMOVED*** {
    var key1 = "test hash 1", key2 = "test hash 2", key3 = 123456789, name = "HMGET";

    // redis-like hmset syntax
    client.HMSET(key1, "0123456789", "abcdefghij", "some manner of key", "a type of value", require_string("OK", name***REMOVED******REMOVED***;

    // fancy hmset syntax
    client.HMSET(key2, {
        "0123456789": "abcdefghij",
        "some manner of key": "a type of value"
  ***REMOVED***, require_string("OK", name***REMOVED******REMOVED***;

    // test for numeric key
    client.HMSET(key3, {
        "0123456789": "abcdefghij",
        "some manner of key": "a type of value"
  ***REMOVED***, require_string("OK", name***REMOVED******REMOVED***;    

    client.HMGET(key1, "0123456789", "some manner of key", function (err, reply***REMOVED*** {
        assert.strictEqual("abcdefghij", reply[0].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("a type of value", reply[1].toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.HMGET(key2, "0123456789", "some manner of key", function (err, reply***REMOVED*** {
        assert.strictEqual("abcdefghij", reply[0].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("a type of value", reply[1].toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.HMGET(key3, "0123456789", "some manner of key", function (err, reply***REMOVED*** {
        assert.strictEqual("abcdefghij", reply[0].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("a type of value", reply[1].toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.HMGET(key1, ["0123456789"], function (err, reply***REMOVED*** {
        assert.strictEqual("abcdefghij", reply[0], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.HMGET(key1, ["0123456789", "some manner of key"], function (err, reply***REMOVED*** {
        assert.strictEqual("abcdefghij", reply[0], name***REMOVED***;
        assert.strictEqual("a type of value", reply[1], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.HMGET(key1, "missing thing", "another missing thing", function (err, reply***REMOVED*** {
        assert.strictEqual(null, reply[0], name***REMOVED***;
        assert.strictEqual(null, reply[1], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.HINCRBY = function (***REMOVED*** {
    var name = "HINCRBY";
    client.hset("hash incr", "value", 10, require_number(1, name***REMOVED******REMOVED***;
    client.HINCRBY("hash incr", "value", 1, require_number(11, name***REMOVED******REMOVED***;
    client.HINCRBY("hash incr", "value 2", 1, last(name, require_number(1, name***REMOVED******REMOVED******REMOVED***;
};

tests.SUBSCRIBE = function (***REMOVED*** {
    var client1 = client, msg_count = 0, name = "SUBSCRIBE";

    client1.on("subscribe", function (channel, count***REMOVED*** {
        if (channel === "chan1"***REMOVED*** {
            client2.publish("chan1", "message 1", require_number(1, name***REMOVED******REMOVED***;
            client2.publish("chan2", "message 2", require_number(1, name***REMOVED******REMOVED***;
            client2.publish("chan1", "message 3", require_number(1, name***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;

    client1.on("unsubscribe", function (channel, count***REMOVED*** {
        if (count === 0***REMOVED*** {
            // make sure this connection can go into and out of pub/sub mode
            client1.incr("did a thing", last(name, require_number(2, name***REMOVED******REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;

    client1.on("message", function (channel, message***REMOVED*** {
        msg_count += 1;
        assert.strictEqual("message " + msg_count, message.toString(***REMOVED******REMOVED***;
        if (msg_count === 3***REMOVED*** {
            client1.unsubscribe("chan1", "chan2"***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;

    client1.set("did a thing", 1, require_string("OK", name***REMOVED******REMOVED***;
    client1.subscribe("chan1", "chan2", function (err, results***REMOVED*** {
        assert.strictEqual(null, err, "result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual("chan1", results.toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.UNSUB_EMPTY = function (***REMOVED*** {
  // test situation where unsubscribe reply[1] is null
  var name = "UNSUB_EMPTY";
  client3.unsubscribe(***REMOVED***; // unsubscribe from all so can test null
  client3.unsubscribe(***REMOVED***; // reply[1] will be null
  next(name***REMOVED***;
};

tests.PUNSUB_EMPTY = function (***REMOVED*** {
  // test situation where punsubscribe reply[1] is null
  var name = "PUNSUB_EMPTY";
  client3.punsubscribe(***REMOVED***; // punsubscribe from all so can test null
  client3.punsubscribe(***REMOVED***; // reply[1] will be null
  next(name***REMOVED***;
};

tests.UNSUB_EMPTY_CB = function (***REMOVED*** {
  var name = "UNSUB_EMPTY_CB";
  // test hangs on older versions of redis, so skip
  if (!server_version_at_least(client, [2, 6, 11]***REMOVED******REMOVED*** return next(name***REMOVED***;

  // test situation where unsubscribe reply[1] is null
  client3.unsubscribe(***REMOVED***; // unsubscribe from all so can test null
  client3.unsubscribe(function (err, results***REMOVED*** {
      // reply[1] will be null
      assert.strictEqual(null, err, "unexpected error: " + err***REMOVED***;
      next(name***REMOVED***;
***REMOVED******REMOVED***;
};

tests.PUNSUB_EMPTY_CB = function (***REMOVED*** {
  var name = "PUNSUB_EMPTY_CB";
  // test hangs on older versions of redis, so skip
  if (!server_version_at_least(client, [2, 6, 11]***REMOVED******REMOVED*** return next(name***REMOVED***;

  // test situation where punsubscribe reply[1] is null
  client3.punsubscribe(***REMOVED***; // punsubscribe from all so can test null
  client3.punsubscribe(function (err, results***REMOVED*** {
      // reply[1] will be null
      assert.strictEqual(null, err, "unexpected error: " + err***REMOVED***;
      next(name***REMOVED***;
***REMOVED******REMOVED***;
};

tests.SUB_UNSUB_SUB = function (***REMOVED*** {
    var name = "SUB_UNSUB_SUB";
    // test hangs on older versions of redis, so skip
    if (!server_version_at_least(client, [2, 6, 11]***REMOVED******REMOVED*** return next(name***REMOVED***;

    client3.subscribe('chan3'***REMOVED***;
    client3.unsubscribe('chan3'***REMOVED***;
    client3.subscribe('chan3', function (err, results***REMOVED*** {
        assert.strictEqual(null, err, "unexpected error: " + err***REMOVED***;
        client2.publish('chan3', 'foo'***REMOVED***;
  ***REMOVED******REMOVED***;
    client3.on('message', function (channel, message***REMOVED*** {
        assert.strictEqual(channel, 'chan3'***REMOVED***;
        assert.strictEqual(message, 'foo'***REMOVED***;
        client3.removeAllListeners(***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SUB_UNSUB_MSG_SUB = function (***REMOVED*** {
    var name = "SUB_UNSUB_MSG_SUB";
    // test hangs on older versions of redis, so skip
    if (!server_version_at_least(client, [2, 6, 11]***REMOVED******REMOVED*** return next(name***REMOVED***;

    client3.subscribe('chan8'***REMOVED***;
    client3.subscribe('chan9'***REMOVED***;
    client3.unsubscribe('chan9'***REMOVED***;
    client2.publish('chan8', 'something'***REMOVED***;
    client3.subscribe('chan9', with_timeout(name, function (err, results***REMOVED*** {
        next(name***REMOVED***;
  ***REMOVED***, 2000***REMOVED******REMOVED***;
};

tests.PSUB_UNSUB_PMSG_SUB = function (***REMOVED*** {
    var name = "PSUB_UNSUB_PMSG_SUB";
    // test hangs on older versions of redis, so skip
    if (!server_version_at_least(client, [2, 6, 11]***REMOVED******REMOVED*** return next(name***REMOVED***;

    client3.psubscribe('abc*'***REMOVED***;
    client3.subscribe('xyz'***REMOVED***;
    client3.unsubscribe('xyz'***REMOVED***;
    client2.publish('abcd', 'something'***REMOVED***;
    client3.subscribe('xyz', with_timeout(name, function (err, results***REMOVED*** {
        next(name***REMOVED***;
  ***REMOVED***, 2000***REMOVED******REMOVED***;
};

tests.SUBSCRIBE_QUIT = function (***REMOVED*** {
    var name = "SUBSCRIBE_QUIT";
    client3.on("end", function (***REMOVED*** {
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
    client3.on("subscribe", function (channel, count***REMOVED*** {
        client3.quit(***REMOVED***;
  ***REMOVED******REMOVED***;
    client3.subscribe("chan3"***REMOVED***;
};

tests.SUBSCRIBE_CLOSE_RESUBSCRIBE = function (***REMOVED*** {
    var name = "SUBSCRIBE_CLOSE_RESUBSCRIBE";
    var c1 = redis.createClient(***REMOVED***;
    var c2 = redis.createClient(***REMOVED***;
    var count = 0;

    /* Create two clients. c1 subscribes to two channels, c2 will publish to them.
       c2 publishes the first message.
       c1 gets the message and drops its connection. It must resubscribe itself.
       When it resubscribes, c2 publishes the second message, on the same channel
       c1 gets the message and drops its connection. It must resubscribe itself, again.
       When it resubscribes, c2 publishes the third message, on the second channel
       c1 gets the message and drops its connection. When it reconnects, the test ends.
    */

    c1.on("message", function(channel, message***REMOVED*** {
        if (channel === "chan1"***REMOVED*** {
            assert.strictEqual(message, "hi on channel 1"***REMOVED***;
            c1.stream.end(***REMOVED***;

      ***REMOVED*** else if (channel === "chan2"***REMOVED*** {
            assert.strictEqual(message, "hi on channel 2"***REMOVED***;
            c1.stream.end(***REMOVED***;

      ***REMOVED*** else {
            c1.quit(***REMOVED***;
            c2.quit(***REMOVED***;
            assert.fail("test failed"***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;

    c1.subscribe("chan1", "chan2"***REMOVED***;

    c2.once("ready", function(***REMOVED*** {
        console.log("c2 is ready"***REMOVED***;
        c1.on("ready", function(err, results***REMOVED*** {
            console.log("c1 is ready", count***REMOVED***;

            count++;
            if (count == 1***REMOVED*** {
                c2.publish("chan1", "hi on channel 1"***REMOVED***;
                return;

          ***REMOVED*** else if (count == 2***REMOVED*** {
                c2.publish("chan2", "hi on channel 2"***REMOVED***;

          ***REMOVED*** else {
                c1.quit(function(***REMOVED*** {
                    c2.quit(function(***REMOVED*** {
                        next(name***REMOVED***;
                  ***REMOVED******REMOVED***;
              ***REMOVED******REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;

        c2.publish("chan1", "hi on channel 1"***REMOVED***;

  ***REMOVED******REMOVED***;
};

tests.EXISTS = function (***REMOVED*** {
    var name = "EXISTS";
    client.del("foo", "foo2", require_number_any(name***REMOVED******REMOVED***;
    client.set("foo", "bar", require_string("OK", name***REMOVED******REMOVED***;
    client.EXISTS("foo", require_number(1, name***REMOVED******REMOVED***;
    client.EXISTS("foo2", last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.DEL = function (***REMOVED*** {
    var name = "DEL";
    client.DEL("delkey", require_number_any(name***REMOVED******REMOVED***;
    client.set("delkey", "delvalue", require_string("OK", name***REMOVED******REMOVED***;
    client.DEL("delkey", require_number(1, name***REMOVED******REMOVED***;
    client.exists("delkey", require_number(0, name***REMOVED******REMOVED***;
    client.DEL("delkey", require_number(0, name***REMOVED******REMOVED***;
    client.mset("delkey", "delvalue", "delkey2", "delvalue2", require_string("OK", name***REMOVED******REMOVED***;
    client.DEL("delkey", "delkey2", last(name, require_number(2, name***REMOVED******REMOVED******REMOVED***;
};

tests.TYPE = function (***REMOVED*** {
    var name = "TYPE";
    client.set(["string key", "should be a string"], require_string("OK", name***REMOVED******REMOVED***;
    client.rpush(["list key", "should be a list"], require_number_pos(name***REMOVED******REMOVED***;
    client.sadd(["set key", "should be a set"], require_number_any(name***REMOVED******REMOVED***;
    client.zadd(["zset key", "10.0", "should be a zset"], require_number_any(name***REMOVED******REMOVED***;
    client.hset(["hash key", "hashtest", "should be a hash"], require_number_any(0, name***REMOVED******REMOVED***;

    client.TYPE(["string key"], require_string("string", name***REMOVED******REMOVED***;
    client.TYPE(["list key"], require_string("list", name***REMOVED******REMOVED***;
    client.TYPE(["set key"], require_string("set", name***REMOVED******REMOVED***;
    client.TYPE(["zset key"], require_string("zset", name***REMOVED******REMOVED***;
    client.TYPE("not here yet", require_string("none", name***REMOVED******REMOVED***;
    client.TYPE(["hash key"], last(name, require_string("hash", name***REMOVED******REMOVED******REMOVED***;
};

tests.KEYS = function (***REMOVED*** {
    var name = "KEYS";
    client.mset(["test keys 1", "test val 1", "test keys 2", "test val 2"], require_string("OK", name***REMOVED******REMOVED***;
    client.KEYS(["test keys*"], function (err, results***REMOVED*** {
        assert.strictEqual(null, err, "result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(2, results.length, name***REMOVED***;
        assert.ok(~results.indexOf("test keys 1"***REMOVED******REMOVED***;
        assert.ok(~results.indexOf("test keys 2"***REMOVED******REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.MULTIBULK = function(***REMOVED*** {
    var name = "MULTIBULK",
        keys_values = [];

    for (var i = 0; i < 200; i++***REMOVED*** {
        var key_value = [
            "multibulk:" + crypto.randomBytes(256***REMOVED***.toString("hex"***REMOVED***, // use long strings as keys to ensure generation of large packet
            "test val " + i
        ];
        keys_values.push(key_value***REMOVED***;
  ***REMOVED***

    client.mset(keys_values.reduce(function(a, b***REMOVED*** {
        return a.concat(b***REMOVED***;
  ***REMOVED******REMOVED***, require_string("OK", name***REMOVED******REMOVED***;

    client.KEYS("multibulk:*", function(err, results***REMOVED*** {
        assert.strictEqual(null, err, "result sent back unexpected error: " + err***REMOVED***;
        assert.deepEqual(keys_values.map(function(val***REMOVED*** {
            return val[0];
      ***REMOVED******REMOVED***.sort(***REMOVED***, results.sort(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;

    next(name***REMOVED***;
};

tests.MULTIBULK_ZERO_LENGTH = function (***REMOVED*** {
    var name = "MULTIBULK_ZERO_LENGTH";
    client.KEYS(['users:*'], function (err, results***REMOVED*** {
        assert.strictEqual(null, err, 'error on empty multibulk reply'***REMOVED***;
        assert.strictEqual(true, is_empty_array(results***REMOVED***, "not an empty array"***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.RANDOMKEY = function (***REMOVED*** {
    var name = "RANDOMKEY";
    client.mset(["test keys 1", "test val 1", "test keys 2", "test val 2"], require_string("OK", name***REMOVED******REMOVED***;
    client.RANDOMKEY([], function (err, results***REMOVED*** {
        assert.strictEqual(null, err, name + " result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(true, /\w+/.test(results***REMOVED***, name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.RENAME = function (***REMOVED*** {
    var name = "RENAME";
    client.set(['foo', 'bar'], require_string("OK", name***REMOVED******REMOVED***;
    client.RENAME(["foo", "new foo"], require_string("OK", name***REMOVED******REMOVED***;
    client.exists(["foo"], require_number(0, name***REMOVED******REMOVED***;
    client.exists(["new foo"], last(name, require_number(1, name***REMOVED******REMOVED******REMOVED***;
};

tests.RENAMENX = function (***REMOVED*** {
    var name = "RENAMENX";
    client.set(['foo', 'bar'], require_string("OK", name***REMOVED******REMOVED***;
    client.set(['foo2', 'bar2'], require_string("OK", name***REMOVED******REMOVED***;
    client.RENAMENX(["foo", "foo2"], require_number(0, name***REMOVED******REMOVED***;
    client.exists(["foo"], require_number(1, name***REMOVED******REMOVED***;
    client.exists(["foo2"], require_number(1, name***REMOVED******REMOVED***;
    client.del(["foo2"], require_number(1, name***REMOVED******REMOVED***;
    client.RENAMENX(["foo", "foo2"], require_number(1, name***REMOVED******REMOVED***;
    client.exists(["foo"], require_number(0, name***REMOVED******REMOVED***;
    client.exists(["foo2"], last(name, require_number(1, name***REMOVED******REMOVED******REMOVED***;
};

tests.DBSIZE = function (***REMOVED*** {
    var name = "DBSIZE";
    client.set(['foo', 'bar'], require_string("OK", name***REMOVED******REMOVED***;
    client.DBSIZE([], last(name, require_number_pos("DBSIZE"***REMOVED******REMOVED******REMOVED***;
};

tests.GET_1 = function (***REMOVED*** {
    var name = "GET_1";
    client.set(["get key", "get val"], require_string("OK", name***REMOVED******REMOVED***;
    client.GET(["get key"], last(name, require_string("get val", name***REMOVED******REMOVED******REMOVED***;
};

tests.GET_2 = function(***REMOVED*** {
    var name = "GET_2";

    // tests handling of non-existent keys
    client.GET('this_key_shouldnt_exist', last(name, require_null(name***REMOVED******REMOVED******REMOVED***;
};

tests.SET = function (***REMOVED*** {
    var name = "SET";
    client.SET(["set key", "set val"], require_string("OK", name***REMOVED******REMOVED***;
    client.get(["set key"], last(name, require_string("set val", name***REMOVED******REMOVED******REMOVED***;
    client.SET(["set key", undefined], require_error(name***REMOVED******REMOVED***;
};

tests.GETSET = function (***REMOVED*** {
    var name = "GETSET";
    client.set(["getset key", "getset val"], require_string("OK", name***REMOVED******REMOVED***;
    client.GETSET(["getset key", "new getset val"], require_string("getset val", name***REMOVED******REMOVED***;
    client.get(["getset key"], last(name, require_string("new getset val", name***REMOVED******REMOVED******REMOVED***;
};

tests.MGET = function (***REMOVED*** {
    var name = "MGET";
    client.mset(["mget keys 1", "mget val 1", "mget keys 2", "mget val 2", "mget keys 3", "mget val 3"], require_string("OK", name***REMOVED******REMOVED***;
    client.MGET("mget keys 1", "mget keys 2", "mget keys 3", function (err, results***REMOVED*** {
        assert.strictEqual(null, err, "result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(3, results.length, name***REMOVED***;
        assert.strictEqual("mget val 1", results[0].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("mget val 2", results[1].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("mget val 3", results[2].toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;
    client.MGET(["mget keys 1", "mget keys 2", "mget keys 3"], function (err, results***REMOVED*** {
        assert.strictEqual(null, err, "result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(3, results.length, name***REMOVED***;
        assert.strictEqual("mget val 1", results[0].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("mget val 2", results[1].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("mget val 3", results[2].toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;
    client.MGET(["mget keys 1", "some random shit", "mget keys 2", "mget keys 3"], function (err, results***REMOVED*** {
        assert.strictEqual(null, err, "result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(4, results.length, name***REMOVED***;
        assert.strictEqual("mget val 1", results[0].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual(null, results[1], name***REMOVED***;
        assert.strictEqual("mget val 2", results[2].toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("mget val 3", results[3].toString(***REMOVED***, name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SETNX = function (***REMOVED*** {
    var name = "SETNX";
    client.set(["setnx key", "setnx value"], require_string("OK", name***REMOVED******REMOVED***;
    client.SETNX(["setnx key", "new setnx value"], require_number(0, name***REMOVED******REMOVED***;
    client.del(["setnx key"], require_number(1, name***REMOVED******REMOVED***;
    client.exists(["setnx key"], require_number(0, name***REMOVED******REMOVED***;
    client.SETNX(["setnx key", "new setnx value"], require_number(1, name***REMOVED******REMOVED***;
    client.exists(["setnx key"], last(name, require_number(1, name***REMOVED******REMOVED******REMOVED***;
};

tests.SETEX = function (***REMOVED*** {
    var name = "SETEX";
    client.SETEX(["setex key", "100", "setex val"], require_string("OK", name***REMOVED******REMOVED***;
    client.exists(["setex key"], require_number(1, name***REMOVED******REMOVED***;
    client.ttl(["setex key"], last(name, require_number_pos(name***REMOVED******REMOVED******REMOVED***;
    client.SETEX(["setex key", "100", undefined], require_error(name***REMOVED******REMOVED***;
};

tests.MSETNX = function (***REMOVED*** {
    var name = "MSETNX";
    client.mset(["mset1", "val1", "mset2", "val2", "mset3", "val3"], require_string("OK", name***REMOVED******REMOVED***;
    client.MSETNX(["mset3", "val3", "mset4", "val4"], require_number(0, name***REMOVED******REMOVED***;
    client.del(["mset3"], require_number(1, name***REMOVED******REMOVED***;
    client.MSETNX(["mset3", "val3", "mset4", "val4"], require_number(1, name***REMOVED******REMOVED***;
    client.exists(["mset3"], require_number(1, name***REMOVED******REMOVED***;
    client.exists(["mset4"], last(name, require_number(1, name***REMOVED******REMOVED******REMOVED***;
};

tests.HGETALL = function (***REMOVED*** {
    var name = "HGETALL";
    client.hmset(["hosts", "mjr", "1", "another", "23", "home", "1234"], require_string("OK", name***REMOVED******REMOVED***;
    client.HGETALL(["hosts"], function (err, obj***REMOVED*** {
        assert.strictEqual(null, err, name + " result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(3, Object.keys(obj***REMOVED***.length, name***REMOVED***;
        assert.strictEqual("1", obj.mjr.toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("23", obj.another.toString(***REMOVED***, name***REMOVED***;
        assert.strictEqual("1234", obj.home.toString(***REMOVED***, name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.HGETALL_MESSAGE = function (***REMOVED*** {
    var name = "HGETALL_MESSAGE";
    client.hmset("msg_test", {message: "hello"}, require_string("OK", name***REMOVED******REMOVED***;
    client.hgetall("msg_test", function (err, obj***REMOVED*** {
        assert.strictEqual(null, err, name + " result sent back unexpected error: " + err***REMOVED***;
        assert.strictEqual(1, Object.keys(obj***REMOVED***.length, name***REMOVED***;
        assert.strictEqual(obj.message, "hello"***REMOVED***
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.HGETALL_NULL = function (***REMOVED*** {
    var name = "HGETALL_NULL";

    client.hgetall("missing", function (err, obj***REMOVED*** {
        assert.strictEqual(null, err***REMOVED***;
        assert.strictEqual(null, obj***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.UTF8 = function (***REMOVED*** {
    var name = "UTF8",
        utf8_sample = "_";

    client.set(["utf8test", utf8_sample], require_string("OK", name***REMOVED******REMOVED***;
    client.get(["utf8test"], function (err, obj***REMOVED*** {
        assert.strictEqual(null, err***REMOVED***;
        assert.strictEqual(utf8_sample, obj***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

// Set tests were adapted from Brian Hammond's redis-node-client.js, which has a comprehensive test suite

tests.SADD = function (***REMOVED*** {
    var name = "SADD";

    client.del('set0'***REMOVED***;
    client.SADD('set0', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('set0', 'member0', last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.SADD2 = function (***REMOVED*** {
    var name = "SADD2";

    client.del("set0"***REMOVED***;
    client.sadd("set0", ["member0", "member1", "member2"], require_number(3, name***REMOVED******REMOVED***;
    client.smembers("set0", function (err, res***REMOVED*** {
        assert.strictEqual(res.length, 3***REMOVED***;
        assert.ok(~res.indexOf("member0"***REMOVED******REMOVED***;
        assert.ok(~res.indexOf("member1"***REMOVED******REMOVED***;
        assert.ok(~res.indexOf("member2"***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
    client.SADD("set1", ["member0", "member1", "member2"], require_number(3, name***REMOVED******REMOVED***;
    client.smembers("set1", function (err, res***REMOVED*** {
        assert.strictEqual(res.length, 3***REMOVED***;
        assert.ok(~res.indexOf("member0"***REMOVED******REMOVED***;
        assert.ok(~res.indexOf("member1"***REMOVED******REMOVED***;
        assert.ok(~res.indexOf("member2"***REMOVED******REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SISMEMBER = function (***REMOVED*** {
    var name = "SISMEMBER";

    client.del('set0'***REMOVED***;
    client.sadd('set0', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.sismember('set0', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.sismember('set0', 'member1', last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.SCARD = function (***REMOVED*** {
    var name = "SCARD";

    client.del('set0'***REMOVED***;
    client.sadd('set0', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.scard('set0', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('set0', 'member1', require_number(1, name***REMOVED******REMOVED***;
    client.scard('set0', last(name, require_number(2, name***REMOVED******REMOVED******REMOVED***;
};

tests.SREM = function (***REMOVED*** {
    var name = "SREM";

    client.del('set0'***REMOVED***;
    client.sadd('set0', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.srem('set0', 'foobar', require_number(0, name***REMOVED******REMOVED***;
    client.srem('set0', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.scard('set0', last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};


tests.SREM2 = function (***REMOVED*** {
    var name = "SREM2";
    client.del("set0"***REMOVED***;
    client.sadd("set0", ["member0", "member1", "member2"], require_number(3, name***REMOVED******REMOVED***;
    client.SREM("set0", ["member1", "member2"], require_number(2, name***REMOVED******REMOVED***;
    client.smembers("set0", function (err, res***REMOVED*** {
        assert.strictEqual(res.length, 1***REMOVED***;
        assert.ok(~res.indexOf("member0"***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
    client.sadd("set0", ["member3", "member4", "member5"], require_number(3, name***REMOVED******REMOVED***;
    client.srem("set0", ["member0", "member6"], require_number(1, name***REMOVED******REMOVED***;
    client.smembers("set0", function (err, res***REMOVED*** {
        assert.strictEqual(res.length, 3***REMOVED***;
        assert.ok(~res.indexOf("member3"***REMOVED******REMOVED***;
        assert.ok(~res.indexOf("member4"***REMOVED******REMOVED***;
        assert.ok(~res.indexOf("member5"***REMOVED******REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SPOP = function (***REMOVED*** {
    var name = "SPOP";

    client.del('zzz'***REMOVED***;
    client.sadd('zzz', 'member0', require_number(1, name***REMOVED******REMOVED***;
    client.scard('zzz', require_number(1, name***REMOVED******REMOVED***;

    client.spop('zzz', function (err, value***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err***REMOVED***;
      ***REMOVED***
        assert.equal(value, 'member0', name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.scard('zzz', last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.SDIFF = function (***REMOVED*** {
    var name = "SDIFF";

    client.del('foo'***REMOVED***;
    client.sadd('foo', 'x', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('foo', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('foo', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('foo', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('bar', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('baz', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('baz', 'd', require_number(1, name***REMOVED******REMOVED***;

    client.sdiff('foo', 'bar', 'baz', function (err, values***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        values.sort(***REMOVED***;
        assert.equal(values.length, 2, name***REMOVED***;
        assert.equal(values[0], 'b', name***REMOVED***;
        assert.equal(values[1], 'x', name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SDIFFSTORE = function (***REMOVED*** {
    var name = "SDIFFSTORE";

    client.del('foo'***REMOVED***;
    client.del('bar'***REMOVED***;
    client.del('baz'***REMOVED***;
    client.del('quux'***REMOVED***;

    client.sadd('foo', 'x', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('foo', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('foo', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('foo', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('bar', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('baz', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('baz', 'd', require_number(1, name***REMOVED******REMOVED***;

    // NB: SDIFFSTORE returns the number of elements in the dstkey

    client.sdiffstore('quux', 'foo', 'bar', 'baz', require_number(2, name***REMOVED******REMOVED***;

    client.smembers('quux', function (err, values***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        var members = buffers_to_strings(values***REMOVED***.sort(***REMOVED***;

        assert.deepEqual(members, [ 'b', 'x' ], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SMEMBERS = function (***REMOVED*** {
    var name = "SMEMBERS";

    client.del('foo'***REMOVED***;
    client.sadd('foo', 'x', require_number(1, name***REMOVED******REMOVED***;

    client.smembers('foo', function (err, members***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(members***REMOVED***, [ 'x' ], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.sadd('foo', 'y', require_number(1, name***REMOVED******REMOVED***;

    client.smembers('foo', function (err, values***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(values.length, 2, name***REMOVED***;
        var members = buffers_to_strings(values***REMOVED***.sort(***REMOVED***;

        assert.deepEqual(members, [ 'x', 'y' ], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SMOVE = function (***REMOVED*** {
    var name = "SMOVE";

    client.del('foo'***REMOVED***;
    client.del('bar'***REMOVED***;

    client.sadd('foo', 'x', require_number(1, name***REMOVED******REMOVED***;
    client.smove('foo', 'bar', 'x', require_number(1, name***REMOVED******REMOVED***;
    client.sismember('foo', 'x', require_number(0, name***REMOVED******REMOVED***;
    client.sismember('bar', 'x', require_number(1, name***REMOVED******REMOVED***;
    client.smove('foo', 'bar', 'x', last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
};

tests.SINTER = function (***REMOVED*** {
    var name = "SINTER";

    client.del('sa'***REMOVED***;
    client.del('sb'***REMOVED***;
    client.del('sc'***REMOVED***;

    client.sadd('sa', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sb', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'd', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sc', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'd', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'e', require_number(1, name***REMOVED******REMOVED***;

    client.sinter('sa', 'sb', function (err, intersection***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(intersection.length, 2, name***REMOVED***;
        assert.deepEqual(buffers_to_strings(intersection***REMOVED***.sort(***REMOVED***, [ 'b', 'c' ], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.sinter('sb', 'sc', function (err, intersection***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(intersection.length, 2, name***REMOVED***;
        assert.deepEqual(buffers_to_strings(intersection***REMOVED***.sort(***REMOVED***, [ 'c', 'd' ], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.sinter('sa', 'sc', function (err, intersection***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(intersection.length, 1, name***REMOVED***;
        assert.equal(intersection[0], 'c', name***REMOVED***;
  ***REMOVED******REMOVED***;

    // 3-way

    client.sinter('sa', 'sb', 'sc', function (err, intersection***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(intersection.length, 1, name***REMOVED***;
        assert.equal(intersection[0], 'c', name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SINTERSTORE = function (***REMOVED*** {
    var name = "SINTERSTORE";

    client.del('sa'***REMOVED***;
    client.del('sb'***REMOVED***;
    client.del('sc'***REMOVED***;
    client.del('foo'***REMOVED***;

    client.sadd('sa', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sb', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'd', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sc', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'd', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'e', require_number(1, name***REMOVED******REMOVED***;

    client.sinterstore('foo', 'sa', 'sb', 'sc', require_number(1, name***REMOVED******REMOVED***;

    client.smembers('foo', function (err, members***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(members***REMOVED***, [ 'c' ], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SUNION = function (***REMOVED*** {
    var name = "SUNION";

    client.del('sa'***REMOVED***;
    client.del('sb'***REMOVED***;
    client.del('sc'***REMOVED***;

    client.sadd('sa', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sb', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'd', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sc', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'd', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'e', require_number(1, name***REMOVED******REMOVED***;

    client.sunion('sa', 'sb', 'sc', function (err, union***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(union***REMOVED***.sort(***REMOVED***, ['a', 'b', 'c', 'd', 'e'], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SUNIONSTORE = function (***REMOVED*** {
    var name = "SUNIONSTORE";

    client.del('sa'***REMOVED***;
    client.del('sb'***REMOVED***;
    client.del('sc'***REMOVED***;
    client.del('foo'***REMOVED***;

    client.sadd('sa', 'a', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sa', 'c', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sb', 'b', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sb', 'd', require_number(1, name***REMOVED******REMOVED***;

    client.sadd('sc', 'c', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'd', require_number(1, name***REMOVED******REMOVED***;
    client.sadd('sc', 'e', require_number(1, name***REMOVED******REMOVED***;

    client.sunionstore('foo', 'sa', 'sb', 'sc', function (err, cardinality***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(cardinality, 5, name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.smembers('foo', function (err, members***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.equal(members.length, 5, name***REMOVED***;
        assert.deepEqual(buffers_to_strings(members***REMOVED***.sort(***REMOVED***, ['a', 'b', 'c', 'd', 'e'], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

// SORT test adapted from Brian Hammond's redis-node-client.js, which has a comprehensive test suite

tests.SORT = function (***REMOVED*** {
    var name = "SORT";

    client.del('y'***REMOVED***;
    client.del('x'***REMOVED***;

    client.rpush('y', 'd', require_number(1, name***REMOVED******REMOVED***;
    client.rpush('y', 'b', require_number(2, name***REMOVED******REMOVED***;
    client.rpush('y', 'a', require_number(3, name***REMOVED******REMOVED***;
    client.rpush('y', 'c', require_number(4, name***REMOVED******REMOVED***;

    client.rpush('x', '3', require_number(1, name***REMOVED******REMOVED***;
    client.rpush('x', '9', require_number(2, name***REMOVED******REMOVED***;
    client.rpush('x', '2', require_number(3, name***REMOVED******REMOVED***;
    client.rpush('x', '4', require_number(4, name***REMOVED******REMOVED***;

    client.set('w3', '4', require_string("OK", name***REMOVED******REMOVED***;
    client.set('w9', '5', require_string("OK", name***REMOVED******REMOVED***;
    client.set('w2', '12', require_string("OK", name***REMOVED******REMOVED***;
    client.set('w4', '6', require_string("OK", name***REMOVED******REMOVED***;

    client.set('o2', 'buz', require_string("OK", name***REMOVED******REMOVED***;
    client.set('o3', 'foo', require_string("OK", name***REMOVED******REMOVED***;
    client.set('o4', 'baz', require_string("OK", name***REMOVED******REMOVED***;
    client.set('o9', 'bar', require_string("OK", name***REMOVED******REMOVED***;

    client.set('p2', 'qux', require_string("OK", name***REMOVED******REMOVED***;
    client.set('p3', 'bux', require_string("OK", name***REMOVED******REMOVED***;
    client.set('p4', 'lux', require_string("OK", name***REMOVED******REMOVED***;
    client.set('p9', 'tux', require_string("OK", name***REMOVED******REMOVED***;

    // Now the data has been setup, we can test.

    // But first, test basic sorting.

    // y = [ d b a c ]
    // sort y ascending = [ a b c d ]
    // sort y descending = [ d c b a ]

    client.sort('y', 'asc', 'alpha', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, ['a', 'b', 'c', 'd'], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.sort('y', 'desc', 'alpha', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, ['d', 'c', 'b', 'a'], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // Now try sorting numbers in a list.
    // x = [ 3, 9, 2, 4 ]

    client.sort('x', 'asc', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, [2, 3, 4, 9], name***REMOVED***;
  ***REMOVED******REMOVED***;

    client.sort('x', 'desc', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, [9, 4, 3, 2], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // Try sorting with a 'by' pattern.

    client.sort('x', 'by', 'w*', 'asc', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, [3, 9, 4, 2], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // Try sorting with a 'by' pattern and 1 'get' pattern.

    client.sort('x', 'by', 'w*', 'asc', 'get', 'o*', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, ['foo', 'bar', 'baz', 'buz'], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // Try sorting with a 'by' pattern and 2 'get' patterns.

    client.sort('x', 'by', 'w*', 'asc', 'get', 'o*', 'get', 'p*', function (err, sorted***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(sorted***REMOVED***, ['foo', 'bux', 'bar', 'tux', 'baz', 'lux', 'buz', 'qux'], name***REMOVED***;
  ***REMOVED******REMOVED***;

    // Try sorting with a 'by' pattern and 2 'get' patterns.
    // Instead of getting back the sorted set/list, store the values to a list.
    // Then check that the values are there in the expected order.

    client.sort('x', 'by', 'w*', 'asc', 'get', 'o*', 'get', 'p*', 'store', 'bacon', function (err***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;

    client.lrange('bacon', 0, -1, function (err, values***REMOVED*** {
        if (err***REMOVED*** {
            assert.fail(err, name***REMOVED***;
      ***REMOVED***
        assert.deepEqual(buffers_to_strings(values***REMOVED***, ['foo', 'bux', 'bar', 'tux', 'baz', 'lux', 'buz', 'qux'], name***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;

    // TODO - sort by hash value
};

tests.MONITOR = function (***REMOVED*** {
    var name = "MONITOR", responses = [], monitor_client;

    if (!server_version_at_least(client, [2, 6, 0]***REMOVED******REMOVED*** {
        console.log("Skipping " + name + " for old Redis server version < 2.6.x"***REMOVED***;
        return next(name***REMOVED***;
  ***REMOVED***

    monitor_client = redis.createClient(***REMOVED***;
    monitor_client.monitor(function (err, res***REMOVED*** {
        client.mget("some", "keys", "foo", "bar"***REMOVED***;
        client.set("json", JSON.stringify({
            foo: "123",
            bar: "sdflkdfsjk",
            another: false
      ***REMOVED******REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
    monitor_client.on("monitor", function (time, args***REMOVED*** {
        // skip monitor command for Redis <= 2.4.16
        if (args[0] === "monitor"***REMOVED*** return;

        responses.push(args***REMOVED***;
        if (responses.length === 2***REMOVED*** {
            assert.strictEqual(5, responses[0].length***REMOVED***;
            assert.strictEqual("mget", responses[0][0]***REMOVED***;
            assert.strictEqual("some", responses[0][1]***REMOVED***;
            assert.strictEqual("keys", responses[0][2]***REMOVED***;
            assert.strictEqual("foo", responses[0][3]***REMOVED***;
            assert.strictEqual("bar", responses[0][4]***REMOVED***;
            assert.strictEqual(3, responses[1].length***REMOVED***;
            assert.strictEqual("set", responses[1][0]***REMOVED***;
            assert.strictEqual("json", responses[1][1]***REMOVED***;
            assert.strictEqual('{"foo":"123","bar":"sdflkdfsjk","another":false}', responses[1][2]***REMOVED***;
            monitor_client.quit(function (err, res***REMOVED*** {
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};

tests.BLPOP = function (***REMOVED*** {
    var name = "BLPOP";

    client.rpush("blocking list", "initial value", function (err, res***REMOVED*** {
        client2.BLPOP("blocking list", 0, function (err, res***REMOVED*** {
            assert.strictEqual("blocking list", res[0].toString(***REMOVED******REMOVED***;
            assert.strictEqual("initial value", res[1].toString(***REMOVED******REMOVED***;

            client.rpush("blocking list", "wait for this value"***REMOVED***;
      ***REMOVED******REMOVED***;
        client2.BLPOP("blocking list", 0, function (err, res***REMOVED*** {
            assert.strictEqual("blocking list", res[0].toString(***REMOVED******REMOVED***;
            assert.strictEqual("wait for this value", res[1].toString(***REMOVED******REMOVED***;
            next(name***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.BLPOP_TIMEOUT = function (***REMOVED*** {
    var name = "BLPOP_TIMEOUT";

    // try to BLPOP the list again, which should be empty.  This should timeout and return null.
    client2.BLPOP("blocking list", 1, function (err, res***REMOVED*** {
        if (err***REMOVED*** {
            throw err;
      ***REMOVED***

        assert.strictEqual(res, null***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.EXPIRE = function (***REMOVED*** {
    var name = "EXPIRE";
    client.set(['expiry key', 'bar'], require_string("OK", name***REMOVED******REMOVED***;
    client.EXPIRE(["expiry key", "1"], require_number_pos(name***REMOVED******REMOVED***;
    setTimeout(function (***REMOVED*** {
        client.exists(["expiry key"], last(name, require_number(0, name***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***, 2000***REMOVED***;
};

tests.TTL = function (***REMOVED*** {
    var name = "TTL";
    client.set(["ttl key", "ttl val"], require_string("OK", name***REMOVED******REMOVED***;
    client.expire(["ttl key", "100"], require_number_pos(name***REMOVED******REMOVED***;
    setTimeout(function (***REMOVED*** {
        client.TTL(["ttl key"], last(name, require_number_pos(0, name***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***, 500***REMOVED***;
};

tests.OPTIONAL_CALLBACK = function (***REMOVED*** {
    var name = "OPTIONAL_CALLBACK";
    client.del("op_cb1"***REMOVED***;
    client.set("op_cb1", "x"***REMOVED***;
    client.get("op_cb1", last(name, require_string("x", name***REMOVED******REMOVED******REMOVED***;
};

tests.OPTIONAL_CALLBACK_UNDEFINED = function (***REMOVED*** {
    var name = "OPTIONAL_CALLBACK_UNDEFINED";
    client.del("op_cb2"***REMOVED***;
    client.set("op_cb2", "y", undefined***REMOVED***;
    client.get("op_cb2", last(name, require_string("y", name***REMOVED******REMOVED******REMOVED***;

    client.set("op_cb_undefined", undefined, undefined***REMOVED***;
};

tests.ENABLE_OFFLINE_QUEUE_TRUE = function (***REMOVED*** {
    var name = "ENABLE_OFFLINE_QUEUE_TRUE";
    var cli = redis.createClient(9999, null, {
        max_attempts: 1
        // default :***REMOVED***
        // enable_offline_queue: true
  ***REMOVED******REMOVED***;
    cli.on('error', function(e***REMOVED*** {
        // ignore, b/c expecting a "can't connect" error
  ***REMOVED******REMOVED***;
    return setTimeout(function(***REMOVED*** {
        cli.set(name, name, function(err, result***REMOVED*** {
            assert.ifError(err***REMOVED***;
      ***REMOVED******REMOVED***;

        return setTimeout(function(***REMOVED***{
            assert.strictEqual(cli.offline_queue.length, 1***REMOVED***;
            return next(name***REMOVED***;
      ***REMOVED***, 25***REMOVED***;
  ***REMOVED***, 50***REMOVED***;
};

tests.ENABLE_OFFLINE_QUEUE_FALSE = function (***REMOVED*** {
    var name = "ENABLE_OFFLINE_QUEUE_FALSE";
    var cli = redis.createClient(9999, null, {
        max_attempts: 1,
        enable_offline_queue: false
  ***REMOVED******REMOVED***;
    cli.on('error', function(***REMOVED*** {
        // ignore, see above
  ***REMOVED******REMOVED***;
    assert.throws(function (***REMOVED*** {
        cli.set(name, name***REMOVED***
  ***REMOVED******REMOVED***
    assert.doesNotThrow(function (***REMOVED*** {
        cli.set(name, name, function (err***REMOVED*** {
            // should callback with an error
            assert.ok(err***REMOVED***;
            setTimeout(function (***REMOVED*** {
                next(name***REMOVED***;
          ***REMOVED***, 50***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
};

tests.SLOWLOG = function (***REMOVED*** {
    var name = "SLOWLOG";
    client.config("set", "slowlog-log-slower-than", 0, require_string("OK", name***REMOVED******REMOVED***;
    client.slowlog("reset", require_string("OK", name***REMOVED******REMOVED***;
    client.set("foo", "bar", require_string("OK", name***REMOVED******REMOVED***;
    client.get("foo", require_string("bar", name***REMOVED******REMOVED***;
    client.slowlog("get", function (err, res***REMOVED*** {
        assert.equal(res.length, 3, name***REMOVED***;
        assert.equal(res[0][3].length, 2, name***REMOVED***;
        assert.deepEqual(res[1][3], ["set", "foo", "bar"], name***REMOVED***;
        assert.deepEqual(res[2][3], ["slowlog", "reset"], name***REMOVED***;
        client.config("set", "slowlog-log-slower-than", 10000, require_string("OK", name***REMOVED******REMOVED***;
        next(name***REMOVED***;
  ***REMOVED******REMOVED***;
}

tests.DOMAIN = function (***REMOVED*** {
    var name = "DOMAIN";

    var domain;
    try {
        domain = require('domain'***REMOVED***.create(***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
        console.log("Skipping " + name + " because this version of node doesn't have domains."***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***

    if (domain***REMOVED*** {
        domain.run(function (***REMOVED*** {
            client.set('domain', 'value', function (err, res***REMOVED*** {
                assert.ok(process.domain***REMOVED***;
                var notFound = res.not.existing.thing; // ohhh nooooo
          ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;

        // this is the expected and desired behavior
        domain.on('error', function (err***REMOVED*** { next(name***REMOVED***; }***REMOVED***;
  ***REMOVED***
};

// TODO - need a better way to test auth, maybe auto-config a local Redis server or something.
// Yes, this is the real password.  Please be nice, thanks.
tests.auth = function (***REMOVED*** {
    var name = "AUTH", client4, ready_count = 0;

    client4 = redis.createClient(9006, "filefish.redistogo.com"***REMOVED***;
    client4.auth("664b1b6aaf134e1ec281945a8de702a9", function (err, res***REMOVED*** {
        assert.strictEqual(null, err, name***REMOVED***;
        assert.strictEqual("OK", res.toString(***REMOVED***, name***REMOVED***;
  ***REMOVED******REMOVED***;

    // test auth, then kill the connection so it'll auto-reconnect and auto-re-auth
    client4.on("ready", function (***REMOVED*** {
        ready_count++;
        if (ready_count === 1***REMOVED*** {
            client4.stream.destroy(***REMOVED***;
      ***REMOVED*** else {
            client4.quit(function (err, res***REMOVED*** {
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};

tests.auth2 = function (***REMOVED*** {
    var name = "AUTH2", client4, ready_count = 0;

    client4 = redis.createClient(9006, "filefish.redistogo.com", {auth_pass: "664b1b6aaf134e1ec281945a8de702a9"}***REMOVED***;

    // test auth, then kill the connection so it'll auto-reconnect and auto-re-auth
    client4.on("ready", function (***REMOVED*** {
        ready_count++;
        if (ready_count === 1***REMOVED*** {
            client4.stream.destroy(***REMOVED***;
      ***REMOVED*** else {
            client4.quit(function (err, res***REMOVED*** {
                next(name***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};

tests.reconnectRetryMaxDelay = function(***REMOVED*** {
    var time = new Date(***REMOVED***.getTime(***REMOVED***,
        name = 'reconnectRetryMaxDelay',
        reconnecting = false;
    var client = redis.createClient(PORT, HOST, {
        retry_max_delay: 1
  ***REMOVED******REMOVED***;
    client.on('ready', function(***REMOVED*** {
        if (!reconnecting***REMOVED*** {
            reconnecting = true;
            client.retry_delay = 1000;
            client.retry_backoff = 1;
            client.stream.end(***REMOVED***;
      ***REMOVED*** else {
            client.end(***REMOVED***;
            var lasted = new Date(***REMOVED***.getTime(***REMOVED*** - time;
            assert.ok(lasted < 1000***REMOVED***;
            next(name***REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};

tests.unref = function (***REMOVED*** {
    var name = "unref";
    var external = fork("./test-unref.js"***REMOVED***;
    var done = false;
    external.on("close", function (code***REMOVED*** {
        assert(code == 0, "test-unref.js failed"***REMOVED***;
        done = true;
  ***REMOVED******REMOVED***
    setTimeout(function (***REMOVED*** {
        if (!done***REMOVED*** {
            external.kill(***REMOVED***;
      ***REMOVED***
        assert(done, "test-unref.js didn't finish in time."***REMOVED***;
        next(name***REMOVED***;
  ***REMOVED***, 500***REMOVED***;
};

all_tests = Object.keys(tests***REMOVED***;
all_start = new Date(***REMOVED***;
test_count = 0;

run_next_test = function run_next_test(***REMOVED*** {
    var test_name = all_tests.shift(***REMOVED***;
    if (typeof tests[test_name] === "function"***REMOVED*** {
        util.print('- \x1b[1m' + test_name.toLowerCase(***REMOVED*** + '\x1b[0m:'***REMOVED***;
        cur_start = new Date(***REMOVED***;
        test_count += 1;
        tests[test_name](***REMOVED***;
  ***REMOVED*** else {
        console.log('\n  completed \x1b[32m%d\x1b[0m tests in \x1b[33m%d\x1b[0m ms\n', test_count, new Date(***REMOVED*** - all_start***REMOVED***;
        client.quit(***REMOVED***;
        client2.quit(***REMOVED***;
        bclient.quit(***REMOVED***;
  ***REMOVED***
};

client.once("ready", function start_tests(***REMOVED*** {
    console.log("Connected to " + client.host + ":" + client.port + ", Redis server version " + client.server_info.redis_version + "\n"***REMOVED***;
    console.log("Using reply parser " + client.reply_parser.name***REMOVED***;

    run_next_test(***REMOVED***;

    connected = true;
}***REMOVED***;

client.on('end', function (***REMOVED*** {
    ended = true;
}***REMOVED***;

// Exit immediately on connection failure, which triggers "exit", below, which fails the test
client.on("error", function (err***REMOVED*** {
    console.error("client: " + err.stack***REMOVED***;
    process.exit(***REMOVED***;
}***REMOVED***;
client2.on("error", function (err***REMOVED*** {
    console.error("client2: " + err.stack***REMOVED***;
    process.exit(***REMOVED***;
}***REMOVED***;
client3.on("error", function (err***REMOVED*** {
    console.error("client3: " + err.stack***REMOVED***;
    process.exit(***REMOVED***;
}***REMOVED***;
bclient.on("error", function (err***REMOVED*** {
    console.error("bclient: " + err.stack***REMOVED***;
    process.exit(***REMOVED***;
}***REMOVED***;

client.on("reconnecting", function (params***REMOVED*** {
    console.log("reconnecting: " + util.inspect(params***REMOVED******REMOVED***;
}***REMOVED***;

process.on('uncaughtException', function (err***REMOVED*** {
    console.error("Uncaught exception: " + err.stack***REMOVED***;
    process.exit(1***REMOVED***;
}***REMOVED***;

process.on('exit', function (code***REMOVED*** {
    assert.equal(true, connected***REMOVED***;
    assert.equal(true, ended***REMOVED***;
}***REMOVED***;
