var redis  = require("redis"***REMOVED***,
    client = redis.createClient(***REMOVED***, set_size = 20;

client.sadd("bigset", "a member"***REMOVED***;
client.sadd("bigset", "another member"***REMOVED***;

while (set_size > 0***REMOVED*** {
    client.sadd("bigset", "member " + set_size***REMOVED***;
    set_size -= 1;
}

// multi chain with an individual callback
client.multi(***REMOVED***
    .scard("bigset"***REMOVED***
    .smembers("bigset"***REMOVED***
    .keys("*", function (err, replies***REMOVED*** {
        client.mget(replies, redis.print***REMOVED***;
  ***REMOVED******REMOVED***
    .dbsize(***REMOVED***
    .exec(function (err, replies***REMOVED*** {
        console.log("MULTI got " + replies.length + " replies"***REMOVED***;
        replies.forEach(function (reply, index***REMOVED*** {
            console.log("Reply " + index + ": " + reply.toString(***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;

client.mset("incr thing", 100, "incr other thing", 1, redis.print***REMOVED***;

// start a separate multi command queue
var multi = client.multi(***REMOVED***;
multi.incr("incr thing", redis.print***REMOVED***;
multi.incr("incr other thing", redis.print***REMOVED***;

// runs immediately
client.get("incr thing", redis.print***REMOVED***; // 100

// drains multi queue and runs atomically
multi.exec(function (err, replies***REMOVED*** {
    console.log(replies***REMOVED***; // 101, 2
}***REMOVED***;

// you can re-run the same transaction if you like
multi.exec(function (err, replies***REMOVED*** {
    console.log(replies***REMOVED***; // 102, 3
    client.quit(***REMOVED***;
}***REMOVED***;
