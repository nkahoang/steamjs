// wrapper for non-node envs
;(function (sax***REMOVED*** {

sax.parser = function (strict, opt***REMOVED*** { return new SAXParser(strict, opt***REMOVED*** }
sax.SAXParser = SAXParser
sax.SAXStream = SAXStream
sax.createStream = createStream

// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths***REMOVED******REMOVED***,
// since that's the earliest that a buffer overrun could occur.  This way, checks are
// as rare as required, but as often as necessary to ensure never crossing this bound.
// Furthermore, buffers are only tested at most once per write(***REMOVED***, so passing a very
// large string into write(***REMOVED*** might have undesirable effects, but this is manageable by
// the caller, so it is assumed to be safe.  Thus, a call to write(***REMOVED*** may, in the extreme
// edge case, result in creating at most one complete copy of the string passed in.
// Set to Infinity to have unlimited buffers.
sax.MAX_BUFFER_LENGTH = 64 * 1024

var buffers = [
  "comment", "sgmlDecl", "textNode", "tagName", "doctype",
  "procInstName", "procInstBody", "entity", "attribName",
  "attribValue", "cdata", "script"
]

sax.EVENTS = // for discoverability.
  [ "text"
  , "processinginstruction"
  , "sgmldeclaration"
  , "doctype"
  , "comment"
  , "attribute"
  , "opentag"
  , "closetag"
  , "opencdata"
  , "cdata"
  , "closecdata"
  , "error"
  , "end"
  , "ready"
  , "script"
  , "opennamespace"
  , "closenamespace"
  ]

function SAXParser (strict, opt***REMOVED*** {
  if (!(this instanceof SAXParser***REMOVED******REMOVED*** return new SAXParser(strict, opt***REMOVED***

  var parser = this
  clearBuffers(parser***REMOVED***
  parser.q = parser.c = ""
  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
  parser.opt = opt || {}
  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
  parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
  parser.tags = []
  parser.closed = parser.closedRoot = parser.sawRoot = false
  parser.tag = parser.error = null
  parser.strict = !!strict
  parser.noscript = !!(strict || parser.opt.noscript***REMOVED***
  parser.state = S.BEGIN
  parser.ENTITIES = Object.create(sax.ENTITIES***REMOVED***
  parser.attribList = []

  // namespaces form a prototype chain.
  // it always points at the current tag,
  // which protos to its parent tag.
  if (parser.opt.xmlns***REMOVED*** parser.ns = Object.create(rootNS***REMOVED***

  // mostly just for error reporting
  parser.trackPosition = parser.opt.position !== false
  if (parser.trackPosition***REMOVED*** {
    parser.position = parser.line = parser.column = 0
***REMOVED***
  emit(parser, "onready"***REMOVED***
}

if (!Object.create***REMOVED*** Object.create = function (o***REMOVED*** {
  function f (***REMOVED*** { this.__proto__ = o }
  f.prototype = o
  return new f
}

if (!Object.getPrototypeOf***REMOVED*** Object.getPrototypeOf = function (o***REMOVED*** {
  return o.__proto__
}

if (!Object.keys***REMOVED*** Object.keys = function (o***REMOVED*** {
  var a = []
  for (var i in o***REMOVED*** if (o.hasOwnProperty(i***REMOVED******REMOVED*** a.push(i***REMOVED***
  return a
}

function checkBufferLength (parser***REMOVED*** {
  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10***REMOVED***
    , maxActual = 0
  for (var i = 0, l = buffers.length; i < l; i ++***REMOVED*** {
    var len = parser[buffers[i]].length
    if (len > maxAllowed***REMOVED*** {
      // Text/cdata nodes can get big, and since they're buffered,
      // we can get here under normal conditions.
      // Avoid issues by emitting the text node now,
      // so at least it won't get any bigger.
      switch (buffers[i]***REMOVED*** {
        case "textNode":
          closeText(parser***REMOVED***
        break

        case "cdata":
          emitNode(parser, "oncdata", parser.cdata***REMOVED***
          parser.cdata = ""
        break

        case "script":
          emitNode(parser, "onscript", parser.script***REMOVED***
          parser.script = ""
        break

        default:
          error(parser, "Max buffer length exceeded: "+buffers[i]***REMOVED***
    ***REMOVED***
  ***REMOVED***
    maxActual = Math.max(maxActual, len***REMOVED***
***REMOVED***
  // schedule the next check for the earliest possible buffer overrun.
  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual***REMOVED***
                             + parser.position
}

function clearBuffers (parser***REMOVED*** {
  for (var i = 0, l = buffers.length; i < l; i ++***REMOVED*** {
    parser[buffers[i]] = ""
***REMOVED***
}

function flushBuffers (parser***REMOVED*** {
  closeText(parser***REMOVED***
  if (parser.cdata !== ""***REMOVED*** {
    emitNode(parser, "oncdata", parser.cdata***REMOVED***
    parser.cdata = ""
***REMOVED***
  if (parser.script !== ""***REMOVED*** {
    emitNode(parser, "onscript", parser.script***REMOVED***
    parser.script = ""
***REMOVED***
}

SAXParser.prototype =
  { end: function (***REMOVED*** { end(this***REMOVED*** }
  , write: write
  , resume: function (***REMOVED*** { this.error = null; return this }
  , close: function (***REMOVED*** { return this.write(null***REMOVED*** }
  , flush: function (***REMOVED*** { flushBuffers(this***REMOVED*** }
***REMOVED***

try {
  var Stream = require("stream"***REMOVED***.Stream
} catch (ex***REMOVED*** {
  var Stream = function (***REMOVED*** {}
}


var streamWraps = sax.EVENTS.filter(function (ev***REMOVED*** {
  return ev !== "error" && ev !== "end"
}***REMOVED***

function createStream (strict, opt***REMOVED*** {
  return new SAXStream(strict, opt***REMOVED***
}

function SAXStream (strict, opt***REMOVED*** {
  if (!(this instanceof SAXStream***REMOVED******REMOVED*** return new SAXStream(strict, opt***REMOVED***

  Stream.apply(this***REMOVED***

  this._parser = new SAXParser(strict, opt***REMOVED***
  this.writable = true
  this.readable = true


  var me = this

  this._parser.onend = function (***REMOVED*** {
    me.emit("end"***REMOVED***
***REMOVED***

  this._parser.onerror = function (er***REMOVED*** {
    me.emit("error", er***REMOVED***

    // if didn't throw, then means error was handled.
    // go ahead and clear error, so we can write again.
    me._parser.error = null
***REMOVED***

  this._decoder = null;

  streamWraps.forEach(function (ev***REMOVED*** {
    Object.defineProperty(me, "on" + ev, {
      get: function (***REMOVED*** { return me._parser["on" + ev] },
      set: function (h***REMOVED*** {
        if (!h***REMOVED*** {
          me.removeAllListeners(ev***REMOVED***
          return me._parser["on"+ev] = h
      ***REMOVED***
        me.on(ev, h***REMOVED***
    ***REMOVED***,
      enumerable: true,
      configurable: false
  ***REMOVED******REMOVED***
***REMOVED******REMOVED***
}

SAXStream.prototype = Object.create(Stream.prototype,
  { constructor: { value: SAXStream } }***REMOVED***

SAXStream.prototype.write = function (data***REMOVED*** {
  if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data***REMOVED******REMOVED*** {
    if (!this._decoder***REMOVED*** {
      var SD = require('string_decoder'***REMOVED***.StringDecoder
      this._decoder = new SD('utf8'***REMOVED***
  ***REMOVED***
    data = this._decoder.write(data***REMOVED***;
***REMOVED***

  this._parser.write(data.toString(***REMOVED******REMOVED***
  this.emit("data", data***REMOVED***
  return true
}

SAXStream.prototype.end = function (chunk***REMOVED*** {
  if (chunk && chunk.length***REMOVED*** this.write(chunk***REMOVED***
  this._parser.end(***REMOVED***
  return true
}

SAXStream.prototype.on = function (ev, handler***REMOVED*** {
  var me = this
  if (!me._parser["on"+ev] && streamWraps.indexOf(ev***REMOVED*** !== -1***REMOVED*** {
    me._parser["on"+ev] = function (***REMOVED*** {
      var args = arguments.length === 1 ? [arguments[0]]
               : Array.apply(null, arguments***REMOVED***
      args.splice(0, 0, ev***REMOVED***
      me.emit.apply(me, args***REMOVED***
  ***REMOVED***
***REMOVED***

  return Stream.prototype.on.call(me, ev, handler***REMOVED***
}



// character classes and tokens
var whitespace = "\r\n\t "
  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  , number = "0124356789"
  , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  // (Letter | "_" | ":"***REMOVED***
  , quote = "'\""
  , entity = number+letter+"#"
  , attribEnd = whitespace + ">"
  , CDATA = "[CDATA["
  , DOCTYPE = "DOCTYPE"
  , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
  , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

// turn all the string character sets into character class objects.
whitespace = charClass(whitespace***REMOVED***
number = charClass(number***REMOVED***
letter = charClass(letter***REMOVED***

// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
// This implementation works on strings, a single character at a time
// as such, it cannot ever support astral-plane characters (10000-EFFFF***REMOVED***
// without a significant breaking change to either this  parser, or the
// JavaScript language.  Implementation of an emoji-capable xml parser
// is left as an exercise for the reader.
var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

quote = charClass(quote***REMOVED***
entity = charClass(entity***REMOVED***
attribEnd = charClass(attribEnd***REMOVED***

function charClass (str***REMOVED*** {
  return str.split(""***REMOVED***.reduce(function (s, c***REMOVED*** {
    s[c] = true
    return s
***REMOVED***, {}***REMOVED***
}

function isRegExp (c***REMOVED*** {
  return Object.prototype.toString.call(c***REMOVED*** === '[object RegExp]'
}

function is (charclass, c***REMOVED*** {
  return isRegExp(charclass***REMOVED*** ? !!c.match(charclass***REMOVED*** : charclass[c]
}

function not (charclass, c***REMOVED*** {
  return !is(charclass, c***REMOVED***
}

var S = 0
sax.STATE =
{ BEGIN                     : S++
, TEXT                      : S++ // general stuff
, TEXT_ENTITY               : S++ // &amp and such.
, OPEN_WAKA                 : S++ // <
, SGML_DECL                 : S++ // <!BLARG
, SGML_DECL_QUOTED          : S++ // <!BLARG foo "bar
, DOCTYPE                   : S++ // <!DOCTYPE
, DOCTYPE_QUOTED            : S++ // <!DOCTYPE "//blah
, DOCTYPE_DTD               : S++ // <!DOCTYPE "//blah" [ ...
, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE "//blah" [ "foo
, COMMENT_STARTING          : S++ // <!-
, COMMENT                   : S++ // <!--
, COMMENT_ENDING            : S++ // <!-- blah -
, COMMENT_ENDED             : S++ // <!-- blah --
, CDATA                     : S++ // <![CDATA[ something
, CDATA_ENDING              : S++ // ]
, CDATA_ENDING_2            : S++ // ]]
, PROC_INST                 : S++ // <?hi
, PROC_INST_BODY            : S++ // <?hi there
, PROC_INST_ENDING          : S++ // <?hi "there" ?
, OPEN_TAG                  : S++ // <strong
, OPEN_TAG_SLASH            : S++ // <strong /
, ATTRIB                    : S++ // <a
, ATTRIB_NAME               : S++ // <a foo
, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _
, ATTRIB_VALUE              : S++ // <a foo=
, ATTRIB_VALUE_QUOTED       : S++ // <a foo="bar
, ATTRIB_VALUE_CLOSED       : S++ // <a foo="bar"
, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar
, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar="&quot;"
, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;
, CLOSE_TAG                 : S++ // </a
, CLOSE_TAG_SAW_WHITE       : S++ // </a   >
, SCRIPT                    : S++ // <script> ...
, SCRIPT_ENDING             : S++ // <script> ... <
}

sax.ENTITIES =
{ "amp" : "&"
, "gt" : ">"
, "lt" : "<"
, "quot" : "\""
, "apos" : "'"
, "AElig" : 198
, "Aacute" : 193
, "Acirc" : 194
, "Agrave" : 192
, "Aring" : 197
, "Atilde" : 195
, "Auml" : 196
, "Ccedil" : 199
, "ETH" : 208
, "Eacute" : 201
, "Ecirc" : 202
, "Egrave" : 200
, "Euml" : 203
, "Iacute" : 205
, "Icirc" : 206
, "Igrave" : 204
, "Iuml" : 207
, "Ntilde" : 209
, "Oacute" : 211
, "Ocirc" : 212
, "Ograve" : 210
, "Oslash" : 216
, "Otilde" : 213
, "Ouml" : 214
, "THORN" : 222
, "Uacute" : 218
, "Ucirc" : 219
, "Ugrave" : 217
, "Uuml" : 220
, "Yacute" : 221
, "aacute" : 225
, "acirc" : 226
, "aelig" : 230
, "agrave" : 224
, "aring" : 229
, "atilde" : 227
, "auml" : 228
, "ccedil" : 231
, "eacute" : 233
, "ecirc" : 234
, "egrave" : 232
, "eth" : 240
, "euml" : 235
, "iacute" : 237
, "icirc" : 238
, "igrave" : 236
, "iuml" : 239
, "ntilde" : 241
, "oacute" : 243
, "ocirc" : 244
, "ograve" : 242
, "oslash" : 248
, "otilde" : 245
, "ouml" : 246
, "szlig" : 223
, "thorn" : 254
, "uacute" : 250
, "ucirc" : 251
, "ugrave" : 249
, "uuml" : 252
, "yacute" : 253
, "yuml" : 255
, "copy" : 169
, "reg" : 174
, "nbsp" : 160
, "iexcl" : 161
, "cent" : 162
, "pound" : 163
, "curren" : 164
, "yen" : 165
, "brvbar" : 166
, "sect" : 167
, "uml" : 168
, "ordf" : 170
, "laquo" : 171
, "not" : 172
, "shy" : 173
, "macr" : 175
, "deg" : 176
, "plusmn" : 177
, "sup1" : 185
, "sup2" : 178
, "sup3" : 179
, "acute" : 180
, "micro" : 181
, "para" : 182
, "middot" : 183
, "cedil" : 184
, "ordm" : 186
, "raquo" : 187
, "frac14" : 188
, "frac12" : 189
, "frac34" : 190
, "iquest" : 191
, "times" : 215
, "divide" : 247
, "OElig" : 338
, "oelig" : 339
, "Scaron" : 352
, "scaron" : 353
, "Yuml" : 376
, "fnof" : 402
, "circ" : 710
, "tilde" : 732
, "Alpha" : 913
, "Beta" : 914
, "Gamma" : 915
, "Delta" : 916
, "Epsilon" : 917
, "Zeta" : 918
, "Eta" : 919
, "Theta" : 920
, "Iota" : 921
, "Kappa" : 922
, "Lambda" : 923
, "Mu" : 924
, "Nu" : 925
, "Xi" : 926
, "Omicron" : 927
, "Pi" : 928
, "Rho" : 929
, "Sigma" : 931
, "Tau" : 932
, "Upsilon" : 933
, "Phi" : 934
, "Chi" : 935
, "Psi" : 936
, "Omega" : 937
, "alpha" : 945
, "beta" : 946
, "gamma" : 947
, "delta" : 948
, "epsilon" : 949
, "zeta" : 950
, "eta" : 951
, "theta" : 952
, "iota" : 953
, "kappa" : 954
, "lambda" : 955
, "mu" : 956
, "nu" : 957
, "xi" : 958
, "omicron" : 959
, "pi" : 960
, "rho" : 961
, "sigmaf" : 962
, "sigma" : 963
, "tau" : 964
, "upsilon" : 965
, "phi" : 966
, "chi" : 967
, "psi" : 968
, "omega" : 969
, "thetasym" : 977
, "upsih" : 978
, "piv" : 982
, "ensp" : 8194
, "emsp" : 8195
, "thinsp" : 8201
, "zwnj" : 8204
, "zwj" : 8205
, "lrm" : 8206
, "rlm" : 8207
, "ndash" : 8211
, "mdash" : 8212
, "lsquo" : 8216
, "rsquo" : 8217
, "sbquo" : 8218
, "ldquo" : 8220
, "rdquo" : 8221
, "bdquo" : 8222
, "dagger" : 8224
, "Dagger" : 8225
, "bull" : 8226
, "hellip" : 8230
, "permil" : 8240
, "prime" : 8242
, "Prime" : 8243
, "lsaquo" : 8249
, "rsaquo" : 8250
, "oline" : 8254
, "frasl" : 8260
, "euro" : 8364
, "image" : 8465
, "weierp" : 8472
, "real" : 8476
, "trade" : 8482
, "alefsym" : 8501
, "larr" : 8592
, "uarr" : 8593
, "rarr" : 8594
, "darr" : 8595
, "harr" : 8596
, "crarr" : 8629
, "lArr" : 8656
, "uArr" : 8657
, "rArr" : 8658
, "dArr" : 8659
, "hArr" : 8660
, "forall" : 8704
, "part" : 8706
, "exist" : 8707
, "empty" : 8709
, "nabla" : 8711
, "isin" : 8712
, "notin" : 8713
, "ni" : 8715
, "prod" : 8719
, "sum" : 8721
, "minus" : 8722
, "lowast" : 8727
, "radic" : 8730
, "prop" : 8733
, "infin" : 8734
, "ang" : 8736
, "and" : 8743
, "or" : 8744
, "cap" : 8745
, "cup" : 8746
, "int" : 8747
, "there4" : 8756
, "sim" : 8764
, "cong" : 8773
, "asymp" : 8776
, "ne" : 8800
, "equiv" : 8801
, "le" : 8804
, "ge" : 8805
, "sub" : 8834
, "sup" : 8835
, "nsub" : 8836
, "sube" : 8838
, "supe" : 8839
, "oplus" : 8853
, "otimes" : 8855
, "perp" : 8869
, "sdot" : 8901
, "lceil" : 8968
, "rceil" : 8969
, "lfloor" : 8970
, "rfloor" : 8971
, "lang" : 9001
, "rang" : 9002
, "loz" : 9674
, "spades" : 9824
, "clubs" : 9827
, "hearts" : 9829
, "diams" : 9830
}

Object.keys(sax.ENTITIES***REMOVED***.forEach(function (key***REMOVED*** {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e***REMOVED*** : e
    sax.ENTITIES[key] = s
}***REMOVED***

for (var S in sax.STATE***REMOVED*** sax.STATE[sax.STATE[S]] = S

// shorthand
S = sax.STATE

function emit (parser, event, data***REMOVED*** {
  parser[event] && parser[event](data***REMOVED***
}

function emitNode (parser, nodeType, data***REMOVED*** {
  if (parser.textNode***REMOVED*** closeText(parser***REMOVED***
  emit(parser, nodeType, data***REMOVED***
}

function closeText (parser***REMOVED*** {
  parser.textNode = textopts(parser.opt, parser.textNode***REMOVED***
  if (parser.textNode***REMOVED*** emit(parser, "ontext", parser.textNode***REMOVED***
  parser.textNode = ""
}

function textopts (opt, text***REMOVED*** {
  if (opt.trim***REMOVED*** text = text.trim(***REMOVED***
  if (opt.normalize***REMOVED*** text = text.replace(/\s+/g, " "***REMOVED***
  return text
}

function error (parser, er***REMOVED*** {
  closeText(parser***REMOVED***
  if (parser.trackPosition***REMOVED*** {
    er += "\nLine: "+parser.line+
          "\nColumn: "+parser.column+
          "\nChar: "+parser.c
***REMOVED***
  er = new Error(er***REMOVED***
  parser.error = er
  emit(parser, "onerror", er***REMOVED***
  return parser
}

function end (parser***REMOVED*** {
  if (!parser.closedRoot***REMOVED*** strictFail(parser, "Unclosed root tag"***REMOVED***
  if ((parser.state !== S.BEGIN***REMOVED*** && (parser.state !== S.TEXT***REMOVED******REMOVED*** error(parser, "Unexpected end"***REMOVED***
  closeText(parser***REMOVED***
  parser.c = ""
  parser.closed = true
  emit(parser, "onend"***REMOVED***
  SAXParser.call(parser, parser.strict, parser.opt***REMOVED***
  return parser
}

function strictFail (parser, message***REMOVED*** {
  if (typeof parser !== 'object' || !(parser instanceof SAXParser***REMOVED******REMOVED***
    throw new Error('bad call to strictFail'***REMOVED***;
  if (parser.strict***REMOVED*** error(parser, message***REMOVED***
}

function newTag (parser***REMOVED*** {
  if (!parser.strict***REMOVED*** parser.tagName = parser.tagName[parser.looseCase](***REMOVED***
  var parent = parser.tags[parser.tags.length - 1] || parser
    , tag = parser.tag = { name : parser.tagName, attributes : {} }

  // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
  if (parser.opt.xmlns***REMOVED*** tag.ns = parent.ns
  parser.attribList.length = 0
}

function qname (name, attribute***REMOVED*** {
  var i = name.indexOf(":"***REMOVED***
    , qualName = i < 0 ? [ "", name ] : name.split(":"***REMOVED***
    , prefix = qualName[0]
    , local = qualName[1]

  // <x "xmlns"="http://foo">
  if (attribute && name === "xmlns"***REMOVED*** {
    prefix = "xmlns"
    local = ""
***REMOVED***

  return { prefix: prefix, local: local }
}

function attrib (parser***REMOVED*** {
  if (!parser.strict***REMOVED*** parser.attribName = parser.attribName[parser.looseCase](***REMOVED***

  if (parser.attribList.indexOf(parser.attribName***REMOVED*** !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName***REMOVED******REMOVED*** {
    return parser.attribName = parser.attribValue = ""
***REMOVED***

  if (parser.opt.xmlns***REMOVED*** {
    var qn = qname(parser.attribName, true***REMOVED***
      , prefix = qn.prefix
      , local = qn.local

    if (prefix === "xmlns"***REMOVED*** {
      // namespace binding attribute; push the binding into scope
      if (local === "xml" && parser.attribValue !== XML_NAMESPACE***REMOVED*** {
        strictFail( parser
                  , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
                  + "Actual: " + parser.attribValue ***REMOVED***
    ***REMOVED*** else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE***REMOVED*** {
        strictFail( parser
                  , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
                  + "Actual: " + parser.attribValue ***REMOVED***
    ***REMOVED*** else {
        var tag = parser.tag
          , parent = parser.tags[parser.tags.length - 1] || parser
        if (tag.ns === parent.ns***REMOVED*** {
          tag.ns = Object.create(parent.ns***REMOVED***
      ***REMOVED***
        tag.ns[local] = parser.attribValue
    ***REMOVED***
  ***REMOVED***

    // defer onattribute events until all attributes have been seen
    // so any new bindings can take effect; preserve attribute order
    // so deferred events can be emitted in document order
    parser.attribList.push([parser.attribName, parser.attribValue]***REMOVED***
***REMOVED*** else {
    // in non-xmlns mode, we can emit the event right away
    parser.tag.attributes[parser.attribName] = parser.attribValue
    emitNode( parser
            , "onattribute"
            , { name: parser.attribName
              , value: parser.attribValue } ***REMOVED***
***REMOVED***

  parser.attribName = parser.attribValue = ""
}

function openTag (parser, selfClosing***REMOVED*** {
  if (parser.opt.xmlns***REMOVED*** {
    // emit namespace binding events
    var tag = parser.tag

    // add namespace info to tag
    var qn = qname(parser.tagName***REMOVED***
    tag.prefix = qn.prefix
    tag.local = qn.local
    tag.uri = tag.ns[qn.prefix] || ""

    if (tag.prefix && !tag.uri***REMOVED*** {
      strictFail(parser, "Unbound namespace prefix: "
                       + JSON.stringify(parser.tagName***REMOVED******REMOVED***
      tag.uri = qn.prefix
  ***REMOVED***

    var parent = parser.tags[parser.tags.length - 1] || parser
    if (tag.ns && parent.ns !== tag.ns***REMOVED*** {
      Object.keys(tag.ns***REMOVED***.forEach(function (p***REMOVED*** {
        emitNode( parser
                , "onopennamespace"
                , { prefix: p , uri: tag.ns[p] } ***REMOVED***
    ***REMOVED******REMOVED***
  ***REMOVED***

    // handle deferred onattribute events
    // Note: do not apply default ns to attributes:
    //   http://www.w3.org/TR/REC-xml-names/#defaulting
    for (var i = 0, l = parser.attribList.length; i < l; i ++***REMOVED*** {
      var nv = parser.attribList[i]
      var name = nv[0]
        , value = nv[1]
        , qualName = qname(name, true***REMOVED***
        , prefix = qualName.prefix
        , local = qualName.local
        , uri = prefix == "" ? "" : (tag.ns[prefix] || ""***REMOVED***
        , a = { name: name
              , value: value
              , prefix: prefix
              , local: local
              , uri: uri
            ***REMOVED***

      // if there's any attributes with an undefined namespace,
      // then fail on them now.
      if (prefix && prefix != "xmlns" && !uri***REMOVED*** {
        strictFail(parser, "Unbound namespace prefix: "
                         + JSON.stringify(prefix***REMOVED******REMOVED***
        a.uri = prefix
    ***REMOVED***
      parser.tag.attributes[name] = a
      emitNode(parser, "onattribute", a***REMOVED***
  ***REMOVED***
    parser.attribList.length = 0
***REMOVED***

  parser.tag.isSelfClosing = !!selfClosing

  // process the tag
  parser.sawRoot = true
  parser.tags.push(parser.tag***REMOVED***
  emitNode(parser, "onopentag", parser.tag***REMOVED***
  if (!selfClosing***REMOVED*** {
    // special case for <script> in non-strict mode.
    if (!parser.noscript && parser.tagName.toLowerCase(***REMOVED*** === "script"***REMOVED*** {
      parser.state = S.SCRIPT
  ***REMOVED*** else {
      parser.state = S.TEXT
  ***REMOVED***
    parser.tag = null
    parser.tagName = ""
***REMOVED***
  parser.attribName = parser.attribValue = ""
  parser.attribList.length = 0
}

function closeTag (parser***REMOVED*** {
  if (!parser.tagName***REMOVED*** {
    strictFail(parser, "Weird empty close tag."***REMOVED***
    parser.textNode += "</>"
    parser.state = S.TEXT
    return
***REMOVED***

  if (parser.script***REMOVED*** {
    if (parser.tagName !== "script"***REMOVED*** {
      parser.script += "</" + parser.tagName + ">"
      parser.tagName = ""
      parser.state = S.SCRIPT
      return
  ***REMOVED***
    emitNode(parser, "onscript", parser.script***REMOVED***
    parser.script = ""
***REMOVED***

  // first make sure that the closing tag actually exists.
  // <a><b></c></b></a> will close everything, otherwise.
  var t = parser.tags.length
  var tagName = parser.tagName
  if (!parser.strict***REMOVED*** tagName = tagName[parser.looseCase](***REMOVED***
  var closeTo = tagName
  while (t --***REMOVED*** {
    var close = parser.tags[t]
    if (close.name !== closeTo***REMOVED*** {
      // fail the first time in strict mode
      strictFail(parser, "Unexpected close tag"***REMOVED***
  ***REMOVED*** else break
***REMOVED***

  // didn't find it.  we already failed for strict, so just abort.
  if (t < 0***REMOVED*** {
    strictFail(parser, "Unmatched closing tag: "+parser.tagName***REMOVED***
    parser.textNode += "</" + parser.tagName + ">"
    parser.state = S.TEXT
    return
***REMOVED***
  parser.tagName = tagName
  var s = parser.tags.length
  while (s --> t***REMOVED*** {
    var tag = parser.tag = parser.tags.pop(***REMOVED***
    parser.tagName = parser.tag.name
    emitNode(parser, "onclosetag", parser.tagName***REMOVED***

    var x = {}
    for (var i in tag.ns***REMOVED*** x[i] = tag.ns[i]

    var parent = parser.tags[parser.tags.length - 1] || parser
    if (parser.opt.xmlns && tag.ns !== parent.ns***REMOVED*** {
      // remove namespace bindings introduced by tag
      Object.keys(tag.ns***REMOVED***.forEach(function (p***REMOVED*** {
        var n = tag.ns[p]
        emitNode(parser, "onclosenamespace", { prefix: p, uri: n }***REMOVED***
    ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***
  if (t === 0***REMOVED*** parser.closedRoot = true
  parser.tagName = parser.attribValue = parser.attribName = ""
  parser.attribList.length = 0
  parser.state = S.TEXT
}

function parseEntity (parser***REMOVED*** {
  var entity = parser.entity
    , entityLC = entity.toLowerCase(***REMOVED***
    , num
    , numStr = ""
  if (parser.ENTITIES[entity]***REMOVED***
    return parser.ENTITIES[entity]
  if (parser.ENTITIES[entityLC]***REMOVED***
    return parser.ENTITIES[entityLC]
  entity = entityLC
  if (entity.charAt(0***REMOVED*** === "#"***REMOVED*** {
    if (entity.charAt(1***REMOVED*** === "x"***REMOVED*** {
      entity = entity.slice(2***REMOVED***
      num = parseInt(entity, 16***REMOVED***
      numStr = num.toString(16***REMOVED***
  ***REMOVED*** else {
      entity = entity.slice(1***REMOVED***
      num = parseInt(entity, 10***REMOVED***
      numStr = num.toString(10***REMOVED***
  ***REMOVED***
***REMOVED***
  entity = entity.replace(/^0+/, ""***REMOVED***
  if (numStr.toLowerCase(***REMOVED*** !== entity***REMOVED*** {
    strictFail(parser, "Invalid character entity"***REMOVED***
    return "&"+parser.entity + ";"
***REMOVED***
  return String.fromCharCode(num***REMOVED***
}

function write (chunk***REMOVED*** {
  var parser = this
  if (this.error***REMOVED*** throw this.error
  if (parser.closed***REMOVED*** return error(parser,
    "Cannot write after close. Assign an onready handler."***REMOVED***
  if (chunk === null***REMOVED*** return end(parser***REMOVED***
  var i = 0, c = ""
  while (parser.c = c = chunk.charAt(i++***REMOVED******REMOVED*** {
    if (parser.trackPosition***REMOVED*** {
      parser.position ++
      if (c === "\n"***REMOVED*** {
        parser.line ++
        parser.column = 0
    ***REMOVED*** else parser.column ++
  ***REMOVED***
    switch (parser.state***REMOVED*** {

      case S.BEGIN:
        if (c === "<"***REMOVED*** {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
      ***REMOVED*** else if (not(whitespace,c***REMOVED******REMOVED*** {
          // have to process this as a text node.
          // weird, but happens.
          strictFail(parser, "Non-whitespace before first tag."***REMOVED***
          parser.textNode = c
          parser.state = S.TEXT
      ***REMOVED***
      continue

      case S.TEXT:
        if (parser.sawRoot && !parser.closedRoot***REMOVED*** {
          var starti = i-1
          while (c && c!=="<" && c!=="&"***REMOVED*** {
            c = chunk.charAt(i++***REMOVED***
            if (c && parser.trackPosition***REMOVED*** {
              parser.position ++
              if (c === "\n"***REMOVED*** {
                parser.line ++
                parser.column = 0
            ***REMOVED*** else parser.column ++
          ***REMOVED***
        ***REMOVED***
          parser.textNode += chunk.substring(starti, i-1***REMOVED***
      ***REMOVED***
        if (c === "<"***REMOVED*** {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
      ***REMOVED*** else {
          if (not(whitespace, c***REMOVED*** && (!parser.sawRoot || parser.closedRoot***REMOVED******REMOVED***
            strictFail(parser, "Text data outside of root node."***REMOVED***
          if (c === "&"***REMOVED*** parser.state = S.TEXT_ENTITY
          else parser.textNode += c
      ***REMOVED***
      continue

      case S.SCRIPT:
        // only non-strict
        if (c === "<"***REMOVED*** {
          parser.state = S.SCRIPT_ENDING
      ***REMOVED*** else parser.script += c
      continue

      case S.SCRIPT_ENDING:
        if (c === "/"***REMOVED*** {
          parser.state = S.CLOSE_TAG
      ***REMOVED*** else {
          parser.script += "<" + c
          parser.state = S.SCRIPT
      ***REMOVED***
      continue

      case S.OPEN_WAKA:
        // either a /, ?, !, or text is coming next.
        if (c === "!"***REMOVED*** {
          parser.state = S.SGML_DECL
          parser.sgmlDecl = ""
      ***REMOVED*** else if (is(whitespace, c***REMOVED******REMOVED*** {
          // wait for it...
      ***REMOVED*** else if (is(nameStart,c***REMOVED******REMOVED*** {
          parser.state = S.OPEN_TAG
          parser.tagName = c
      ***REMOVED*** else if (c === "/"***REMOVED*** {
          parser.state = S.CLOSE_TAG
          parser.tagName = ""
      ***REMOVED*** else if (c === "?"***REMOVED*** {
          parser.state = S.PROC_INST
          parser.procInstName = parser.procInstBody = ""
      ***REMOVED*** else {
          strictFail(parser, "Unencoded <"***REMOVED***
          // if there was some whitespace, then add that in.
          if (parser.startTagPosition + 1 < parser.position***REMOVED*** {
            var pad = parser.position - parser.startTagPosition
            c = new Array(pad***REMOVED***.join(" "***REMOVED*** + c
        ***REMOVED***
          parser.textNode += "<" + c
          parser.state = S.TEXT
      ***REMOVED***
      continue

      case S.SGML_DECL:
        if ((parser.sgmlDecl+c***REMOVED***.toUpperCase(***REMOVED*** === CDATA***REMOVED*** {
          emitNode(parser, "onopencdata"***REMOVED***
          parser.state = S.CDATA
          parser.sgmlDecl = ""
          parser.cdata = ""
      ***REMOVED*** else if (parser.sgmlDecl+c === "--"***REMOVED*** {
          parser.state = S.COMMENT
          parser.comment = ""
          parser.sgmlDecl = ""
      ***REMOVED*** else if ((parser.sgmlDecl+c***REMOVED***.toUpperCase(***REMOVED*** === DOCTYPE***REMOVED*** {
          parser.state = S.DOCTYPE
          if (parser.doctype || parser.sawRoot***REMOVED*** strictFail(parser,
            "Inappropriately located doctype declaration"***REMOVED***
          parser.doctype = ""
          parser.sgmlDecl = ""
      ***REMOVED*** else if (c === ">"***REMOVED*** {
          emitNode(parser, "onsgmldeclaration", parser.sgmlDecl***REMOVED***
          parser.sgmlDecl = ""
          parser.state = S.TEXT
      ***REMOVED*** else if (is(quote, c***REMOVED******REMOVED*** {
          parser.state = S.SGML_DECL_QUOTED
          parser.sgmlDecl += c
      ***REMOVED*** else parser.sgmlDecl += c
      continue

      case S.SGML_DECL_QUOTED:
        if (c === parser.q***REMOVED*** {
          parser.state = S.SGML_DECL
          parser.q = ""
      ***REMOVED***
        parser.sgmlDecl += c
      continue

      case S.DOCTYPE:
        if (c === ">"***REMOVED*** {
          parser.state = S.TEXT
          emitNode(parser, "ondoctype", parser.doctype***REMOVED***
          parser.doctype = true // just remember that we saw it.
      ***REMOVED*** else {
          parser.doctype += c
          if (c === "["***REMOVED*** parser.state = S.DOCTYPE_DTD
          else if (is(quote, c***REMOVED******REMOVED*** {
            parser.state = S.DOCTYPE_QUOTED
            parser.q = c
        ***REMOVED***
      ***REMOVED***
      continue

      case S.DOCTYPE_QUOTED:
        parser.doctype += c
        if (c === parser.q***REMOVED*** {
          parser.q = ""
          parser.state = S.DOCTYPE
      ***REMOVED***
      continue

      case S.DOCTYPE_DTD:
        parser.doctype += c
        if (c === "]"***REMOVED*** parser.state = S.DOCTYPE
        else if (is(quote,c***REMOVED******REMOVED*** {
          parser.state = S.DOCTYPE_DTD_QUOTED
          parser.q = c
      ***REMOVED***
      continue

      case S.DOCTYPE_DTD_QUOTED:
        parser.doctype += c
        if (c === parser.q***REMOVED*** {
          parser.state = S.DOCTYPE_DTD
          parser.q = ""
      ***REMOVED***
      continue

      case S.COMMENT:
        if (c === "-"***REMOVED*** parser.state = S.COMMENT_ENDING
        else parser.comment += c
      continue

      case S.COMMENT_ENDING:
        if (c === "-"***REMOVED*** {
          parser.state = S.COMMENT_ENDED
          parser.comment = textopts(parser.opt, parser.comment***REMOVED***
          if (parser.comment***REMOVED*** emitNode(parser, "oncomment", parser.comment***REMOVED***
          parser.comment = ""
      ***REMOVED*** else {
          parser.comment += "-" + c
          parser.state = S.COMMENT
      ***REMOVED***
      continue

      case S.COMMENT_ENDED:
        if (c !== ">"***REMOVED*** {
          strictFail(parser, "Malformed comment"***REMOVED***
          // allow <!-- blah -- bloo --> in non-strict mode,
          // which is a comment of " blah -- bloo "
          parser.comment += "--" + c
          parser.state = S.COMMENT
      ***REMOVED*** else parser.state = S.TEXT
      continue

      case S.CDATA:
        if (c === "]"***REMOVED*** parser.state = S.CDATA_ENDING
        else parser.cdata += c
      continue

      case S.CDATA_ENDING:
        if (c === "]"***REMOVED*** parser.state = S.CDATA_ENDING_2
        else {
          parser.cdata += "]" + c
          parser.state = S.CDATA
      ***REMOVED***
      continue

      case S.CDATA_ENDING_2:
        if (c === ">"***REMOVED*** {
          if (parser.cdata***REMOVED*** emitNode(parser, "oncdata", parser.cdata***REMOVED***
          emitNode(parser, "onclosecdata"***REMOVED***
          parser.cdata = ""
          parser.state = S.TEXT
      ***REMOVED*** else if (c === "]"***REMOVED*** {
          parser.cdata += "]"
      ***REMOVED*** else {
          parser.cdata += "]]" + c
          parser.state = S.CDATA
      ***REMOVED***
      continue

      case S.PROC_INST:
        if (c === "?"***REMOVED*** parser.state = S.PROC_INST_ENDING
        else if (is(whitespace, c***REMOVED******REMOVED*** parser.state = S.PROC_INST_BODY
        else parser.procInstName += c
      continue

      case S.PROC_INST_BODY:
        if (!parser.procInstBody && is(whitespace, c***REMOVED******REMOVED*** continue
        else if (c === "?"***REMOVED*** parser.state = S.PROC_INST_ENDING
        else parser.procInstBody += c
      continue

      case S.PROC_INST_ENDING:
        if (c === ">"***REMOVED*** {
          emitNode(parser, "onprocessinginstruction", {
            name : parser.procInstName,
            body : parser.procInstBody
        ***REMOVED******REMOVED***
          parser.procInstName = parser.procInstBody = ""
          parser.state = S.TEXT
      ***REMOVED*** else {
          parser.procInstBody += "?" + c
          parser.state = S.PROC_INST_BODY
      ***REMOVED***
      continue

      case S.OPEN_TAG:
        if (is(nameBody, c***REMOVED******REMOVED*** parser.tagName += c
        else {
          newTag(parser***REMOVED***
          if (c === ">"***REMOVED*** openTag(parser***REMOVED***
          else if (c === "/"***REMOVED*** parser.state = S.OPEN_TAG_SLASH
          else {
            if (not(whitespace, c***REMOVED******REMOVED*** strictFail(
              parser, "Invalid character in tag name"***REMOVED***
            parser.state = S.ATTRIB
        ***REMOVED***
      ***REMOVED***
      continue

      case S.OPEN_TAG_SLASH:
        if (c === ">"***REMOVED*** {
          openTag(parser, true***REMOVED***
          closeTag(parser***REMOVED***
      ***REMOVED*** else {
          strictFail(parser, "Forward-slash in opening tag not followed by >"***REMOVED***
          parser.state = S.ATTRIB
      ***REMOVED***
      continue

      case S.ATTRIB:
        // haven't read the attribute name yet.
        if (is(whitespace, c***REMOVED******REMOVED*** continue
        else if (c === ">"***REMOVED*** openTag(parser***REMOVED***
        else if (c === "/"***REMOVED*** parser.state = S.OPEN_TAG_SLASH
        else if (is(nameStart, c***REMOVED******REMOVED*** {
          parser.attribName = c
          parser.attribValue = ""
          parser.state = S.ATTRIB_NAME
      ***REMOVED*** else strictFail(parser, "Invalid attribute name"***REMOVED***
      continue

      case S.ATTRIB_NAME:
        if (c === "="***REMOVED*** parser.state = S.ATTRIB_VALUE
        else if (c === ">"***REMOVED*** {
          strictFail(parser, "Attribute without value"***REMOVED***
          parser.attribValue = parser.attribName
          attrib(parser***REMOVED***
          openTag(parser***REMOVED***
      ***REMOVED***
        else if (is(whitespace, c***REMOVED******REMOVED*** parser.state = S.ATTRIB_NAME_SAW_WHITE
        else if (is(nameBody, c***REMOVED******REMOVED*** parser.attribName += c
        else strictFail(parser, "Invalid attribute name"***REMOVED***
      continue

      case S.ATTRIB_NAME_SAW_WHITE:
        if (c === "="***REMOVED*** parser.state = S.ATTRIB_VALUE
        else if (is(whitespace, c***REMOVED******REMOVED*** continue
        else {
          strictFail(parser, "Attribute without value"***REMOVED***
          parser.tag.attributes[parser.attribName] = ""
          parser.attribValue = ""
          emitNode(parser, "onattribute",
                   { name : parser.attribName, value : "" }***REMOVED***
          parser.attribName = ""
          if (c === ">"***REMOVED*** openTag(parser***REMOVED***
          else if (is(nameStart, c***REMOVED******REMOVED*** {
            parser.attribName = c
            parser.state = S.ATTRIB_NAME
        ***REMOVED*** else {
            strictFail(parser, "Invalid attribute name"***REMOVED***
            parser.state = S.ATTRIB
        ***REMOVED***
      ***REMOVED***
      continue

      case S.ATTRIB_VALUE:
        if (is(whitespace, c***REMOVED******REMOVED*** continue
        else if (is(quote, c***REMOVED******REMOVED*** {
          parser.q = c
          parser.state = S.ATTRIB_VALUE_QUOTED
      ***REMOVED*** else {
          strictFail(parser, "Unquoted attribute value"***REMOVED***
          parser.state = S.ATTRIB_VALUE_UNQUOTED
          parser.attribValue = c
      ***REMOVED***
      continue

      case S.ATTRIB_VALUE_QUOTED:
        if (c !== parser.q***REMOVED*** {
          if (c === "&"***REMOVED*** parser.state = S.ATTRIB_VALUE_ENTITY_Q
          else parser.attribValue += c
          continue
      ***REMOVED***
        attrib(parser***REMOVED***
        parser.q = ""
        parser.state = S.ATTRIB_VALUE_CLOSED
      continue

      case S.ATTRIB_VALUE_CLOSED:
        if (is(whitespace, c***REMOVED******REMOVED*** {
          parser.state = S.ATTRIB
      ***REMOVED*** else if (c === ">"***REMOVED*** openTag(parser***REMOVED***
        else if (c === "/"***REMOVED*** parser.state = S.OPEN_TAG_SLASH
        else if (is(nameStart, c***REMOVED******REMOVED*** {
          strictFail(parser, "No whitespace between attributes"***REMOVED***
          parser.attribName = c
          parser.attribValue = ""
          parser.state = S.ATTRIB_NAME
      ***REMOVED*** else strictFail(parser, "Invalid attribute name"***REMOVED***
      continue

      case S.ATTRIB_VALUE_UNQUOTED:
        if (not(attribEnd,c***REMOVED******REMOVED*** {
          if (c === "&"***REMOVED*** parser.state = S.ATTRIB_VALUE_ENTITY_U
          else parser.attribValue += c
          continue
      ***REMOVED***
        attrib(parser***REMOVED***
        if (c === ">"***REMOVED*** openTag(parser***REMOVED***
        else parser.state = S.ATTRIB
      continue

      case S.CLOSE_TAG:
        if (!parser.tagName***REMOVED*** {
          if (is(whitespace, c***REMOVED******REMOVED*** continue
          else if (not(nameStart, c***REMOVED******REMOVED*** {
            if (parser.script***REMOVED*** {
              parser.script += "</" + c
              parser.state = S.SCRIPT
          ***REMOVED*** else {
              strictFail(parser, "Invalid tagname in closing tag."***REMOVED***
          ***REMOVED***
        ***REMOVED*** else parser.tagName = c
      ***REMOVED***
        else if (c === ">"***REMOVED*** closeTag(parser***REMOVED***
        else if (is(nameBody, c***REMOVED******REMOVED*** parser.tagName += c
        else if (parser.script***REMOVED*** {
          parser.script += "</" + parser.tagName
          parser.tagName = ""
          parser.state = S.SCRIPT
      ***REMOVED*** else {
          if (not(whitespace, c***REMOVED******REMOVED*** strictFail(parser,
            "Invalid tagname in closing tag"***REMOVED***
          parser.state = S.CLOSE_TAG_SAW_WHITE
      ***REMOVED***
      continue

      case S.CLOSE_TAG_SAW_WHITE:
        if (is(whitespace, c***REMOVED******REMOVED*** continue
        if (c === ">"***REMOVED*** closeTag(parser***REMOVED***
        else strictFail(parser, "Invalid characters in closing tag"***REMOVED***
      continue

      case S.TEXT_ENTITY:
      case S.ATTRIB_VALUE_ENTITY_Q:
      case S.ATTRIB_VALUE_ENTITY_U:
        switch(parser.state***REMOVED*** {
          case S.TEXT_ENTITY:
            var returnState = S.TEXT, buffer = "textNode"
          break

          case S.ATTRIB_VALUE_ENTITY_Q:
            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
          break

          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
          break
      ***REMOVED***
        if (c === ";"***REMOVED*** {
          parser[buffer] += parseEntity(parser***REMOVED***
          parser.entity = ""
          parser.state = returnState
      ***REMOVED***
        else if (is(entity, c***REMOVED******REMOVED*** parser.entity += c
        else {
          strictFail(parser, "Invalid character entity"***REMOVED***
          parser[buffer] += "&" + parser.entity + c
          parser.entity = ""
          parser.state = returnState
      ***REMOVED***
      continue

      default:
        throw new Error(parser, "Unknown state: " + parser.state***REMOVED***
  ***REMOVED***
***REMOVED*** // while
  // cdata blocks can get very big under normal conditions. emit and move on.
  // if (parser.state === S.CDATA && parser.cdata***REMOVED*** {
  //   emitNode(parser, "oncdata", parser.cdata***REMOVED***
  //   parser.cdata = ""
  // }
  if (parser.position >= parser.bufferCheckPosition***REMOVED*** checkBufferLength(parser***REMOVED***
  return parser
}

}***REMOVED***(typeof exports === "undefined" ? sax = {} : exports***REMOVED***
