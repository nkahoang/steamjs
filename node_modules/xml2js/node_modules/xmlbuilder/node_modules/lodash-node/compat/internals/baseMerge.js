/**
 * Lo-Dash 2.4.1 (Custom Build***REMOVED*** <http://lodash.com/>
 * Build: `lodash modularize exports="node" -o ./compat/`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var forEach = require('../collections/forEach'***REMOVED***,
    forOwn = require('../objects/forOwn'***REMOVED***,
    isArray = require('../objects/isArray'***REMOVED***,
    isPlainObject = require('../objects/isPlainObject'***REMOVED***;

/**
 * The base implementation of `_.merge` without argument juggling or support
 * for `thisArg` binding.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} [callback] The function to customize merging properties.
 * @param {Array} [stackA=[]] Tracks traversed source objects.
 * @param {Array} [stackB=[]] Associates values with source counterparts.
 */
function baseMerge(object, source, callback, stackA, stackB***REMOVED*** {
  (isArray(source***REMOVED*** ? forEach : forOwn***REMOVED***(source, function(source, key***REMOVED*** {
    var found,
        isArr,
        result = source,
        value = object[key];

    if (source && ((isArr = isArray(source***REMOVED******REMOVED*** || isPlainObject(source***REMOVED******REMOVED******REMOVED*** {
      // avoid merging previously merged cyclic sources
      var stackLength = stackA.length;
      while (stackLength--***REMOVED*** {
        if ((found = stackA[stackLength] == source***REMOVED******REMOVED*** {
          value = stackB[stackLength];
          break;
      ***REMOVED***
    ***REMOVED***
      if (!found***REMOVED*** {
        var isShallow;
        if (callback***REMOVED*** {
          result = callback(value, source***REMOVED***;
          if ((isShallow = typeof result != 'undefined'***REMOVED******REMOVED*** {
            value = result;
        ***REMOVED***
      ***REMOVED***
        if (!isShallow***REMOVED*** {
          value = isArr
            ? (isArray(value***REMOVED*** ? value : []***REMOVED***
            : (isPlainObject(value***REMOVED*** ? value : {}***REMOVED***;
      ***REMOVED***
        // add `source` and associated `value` to the stack of traversed objects
        stackA.push(source***REMOVED***;
        stackB.push(value***REMOVED***;

        // recursively merge objects and arrays (susceptible to call stack limits***REMOVED***
        if (!isShallow***REMOVED*** {
          baseMerge(value, source, callback, stackA, stackB***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    else {
      if (callback***REMOVED*** {
        result = callback(value, source***REMOVED***;
        if (typeof result == 'undefined'***REMOVED*** {
          result = source;
      ***REMOVED***
    ***REMOVED***
      if (typeof result != 'undefined'***REMOVED*** {
        value = result;
    ***REMOVED***
  ***REMOVED***
    object[key] = value;
***REMOVED******REMOVED***;
}

module.exports = baseMerge;
