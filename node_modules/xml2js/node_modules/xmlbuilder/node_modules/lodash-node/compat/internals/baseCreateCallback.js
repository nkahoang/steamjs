/**
 * Lo-Dash 2.4.1 (Custom Build***REMOVED*** <http://lodash.com/>
 * Build: `lodash modularize exports="node" -o ./compat/`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var bind = require('../functions/bind'***REMOVED***,
    identity = require('../utilities/identity'***REMOVED***,
    setBindData = require('./setBindData'***REMOVED***,
    support = require('../support'***REMOVED***;

/** Used to detected named functions */
var reFuncName = /^\s*function[ \n\r\t]+\w/;

/** Used to detect functions containing a `this` reference */
var reThis = /\bthis\b/;

/** Native method shortcuts */
var fnToString = Function.prototype.toString;

/**
 * The base implementation of `_.createCallback` without support for creating
 * "_.pluck" or "_.where" style callbacks.
 *
 * @private
 * @param {*} [func=identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of the created callback.
 * @param {number} [argCount] The number of arguments the callback accepts.
 * @returns {Function} Returns a callback function.
 */
function baseCreateCallback(func, thisArg, argCount***REMOVED*** {
  if (typeof func != 'function'***REMOVED*** {
    return identity;
***REMOVED***
  // exit early for no `thisArg` or already bound by `Function#bind`
  if (typeof thisArg == 'undefined' || !('prototype' in func***REMOVED******REMOVED*** {
    return func;
***REMOVED***
  var bindData = func.__bindData__;
  if (typeof bindData == 'undefined'***REMOVED*** {
    if (support.funcNames***REMOVED*** {
      bindData = !func.name;
  ***REMOVED***
    bindData = bindData || !support.funcDecomp;
    if (!bindData***REMOVED*** {
      var source = fnToString.call(func***REMOVED***;
      if (!support.funcNames***REMOVED*** {
        bindData = !reFuncName.test(source***REMOVED***;
    ***REMOVED***
      if (!bindData***REMOVED*** {
        // checks if `func` references the `this` keyword and stores the result
        bindData = reThis.test(source***REMOVED***;
        setBindData(func, bindData***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  // exit early if there are no `this` references or `func` is bound
  if (bindData === false || (bindData !== true && bindData[1] & 1***REMOVED******REMOVED*** {
    return func;
***REMOVED***
  switch (argCount***REMOVED*** {
    case 1: return function(value***REMOVED*** {
      return func.call(thisArg, value***REMOVED***;
  ***REMOVED***;
    case 2: return function(a, b***REMOVED*** {
      return func.call(thisArg, a, b***REMOVED***;
  ***REMOVED***;
    case 3: return function(value, index, collection***REMOVED*** {
      return func.call(thisArg, value, index, collection***REMOVED***;
  ***REMOVED***;
    case 4: return function(accumulator, value, index, collection***REMOVED*** {
      return func.call(thisArg, accumulator, value, index, collection***REMOVED***;
  ***REMOVED***;
***REMOVED***
  return bind(func, thisArg***REMOVED***;
}

module.exports = baseCreateCallback;
