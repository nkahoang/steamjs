/**
 * Lo-Dash 2.4.1 (Custom Build***REMOVED*** <http://lodash.com/>
 * Build: `lodash modularize underscore exports="node" -o ./underscore/`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var forIn = require('../objects/forIn'***REMOVED***,
    indicatorObject = require('./indicatorObject'***REMOVED***,
    isFunction = require('../objects/isFunction'***REMOVED***,
    objectTypes = require('./objectTypes'***REMOVED***;

/** `Object#toString` result shortcuts */
var arrayClass = '[object Array]',
    boolClass = '[object Boolean]',
    dateClass = '[object Date]',
    numberClass = '[object Number]',
    objectClass = '[object Object]',
    regexpClass = '[object RegExp]',
    stringClass = '[object String]';

/** Used for native method references */
var objectProto = Object.prototype;

/** Used to resolve the internal [[Class]] of values */
var toString = objectProto.toString;

/** Native method shortcuts */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.isEqual`, without support for `thisArg` binding,
 * that allows partial "_.where" style comparisons.
 *
 * @private
 * @param {*} a The value to compare.
 * @param {*} b The other value to compare.
 * @param {Function} [callback] The function to customize comparing values.
 * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `a` objects.
 * @param {Array} [stackB=[]] Tracks traversed `b` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(a, b, stackA, stackB***REMOVED*** {
  if (a === b***REMOVED*** {
    return a !== 0 || (1 / a == 1 / b***REMOVED***;
***REMOVED***
  var type = typeof a,
      otherType = typeof b;

  if (a === a &&
      !(a && objectTypes[type]***REMOVED*** &&
      !(b && objectTypes[otherType]***REMOVED******REMOVED*** {
    return false;
***REMOVED***
  if (a == null || b == null***REMOVED*** {
    return a === b;
***REMOVED***
  var className = toString.call(a***REMOVED***,
      otherClass = toString.call(b***REMOVED***;

  if (className != otherClass***REMOVED*** {
    return false;
***REMOVED***
  switch (className***REMOVED*** {
    case boolClass:
    case dateClass:
      return +a == +b;

    case numberClass:
      return a != +a
        ? b != +b
        : (a == 0 ? (1 / a == 1 / b***REMOVED*** : a == +b***REMOVED***;

    case regexpClass:
    case stringClass:
      return a == String(b***REMOVED***;
***REMOVED***
  var isArr = className == arrayClass;
  if (!isArr***REMOVED*** {
    var aWrapped = hasOwnProperty.call(a, '__wrapped__'***REMOVED***,
        bWrapped = hasOwnProperty.call(b, '__wrapped__'***REMOVED***;

    if (aWrapped || bWrapped***REMOVED*** {
      return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, stackA, stackB***REMOVED***;
  ***REMOVED***
    if (className != objectClass***REMOVED*** {
      return false;
  ***REMOVED***
    var ctorA = a.constructor,
        ctorB = b.constructor;

    if (ctorA != ctorB &&
          !(isFunction(ctorA***REMOVED*** && ctorA instanceof ctorA && isFunction(ctorB***REMOVED*** && ctorB instanceof ctorB***REMOVED*** &&
          ('constructor' in a && 'constructor' in b***REMOVED***
        ***REMOVED*** {
      return false;
  ***REMOVED***
***REMOVED***
  stackA || (stackA = []***REMOVED***;
  stackB || (stackB = []***REMOVED***;

  var length = stackA.length;
  while (length--***REMOVED*** {
    if (stackA[length] == a***REMOVED*** {
      return stackB[length] == b;
  ***REMOVED***
***REMOVED***
  var result = true,
      size = 0;

  stackA.push(a***REMOVED***;
  stackB.push(b***REMOVED***;

  if (isArr***REMOVED*** {
    size = b.length;
    result = size == a.length;

    if (result***REMOVED*** {
      while (size--***REMOVED*** {
        if (!(result = baseIsEqual(a[size], b[size], stackA, stackB***REMOVED******REMOVED******REMOVED*** {
          break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  else {
    forIn(b, function(value, key, b***REMOVED*** {
      if (hasOwnProperty.call(b, key***REMOVED******REMOVED*** {
        size++;
        return !(result = hasOwnProperty.call(a, key***REMOVED*** && baseIsEqual(a[key], value, stackA, stackB***REMOVED******REMOVED*** && indicatorObject;
    ***REMOVED***
  ***REMOVED******REMOVED***;

    if (result***REMOVED*** {
      forIn(a, function(value, key, a***REMOVED*** {
        if (hasOwnProperty.call(a, key***REMOVED******REMOVED*** {
          return !(result = --size > -1***REMOVED*** && indicatorObject;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  stackA.pop(***REMOVED***;
  stackB.pop(***REMOVED***;
  return result;
}

module.exports = baseIsEqual;
