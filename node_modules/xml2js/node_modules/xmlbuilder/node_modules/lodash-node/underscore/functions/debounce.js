/**
 * Lo-Dash 2.4.1 (Custom Build***REMOVED*** <http://lodash.com/>
 * Build: `lodash modularize underscore exports="node" -o ./underscore/`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var isFunction = require('../objects/isFunction'***REMOVED***,
    isObject = require('../objects/isObject'***REMOVED***,
    now = require('../utilities/now'***REMOVED***;

/* Native method shortcuts for methods with the same name as other `lodash` methods */
var nativeMax = Math.max;

/**
 * Creates a function that will delay the execution of `func` until after
 * `wait` milliseconds have elapsed since the last time it was invoked.
 * Provide an options object to indicate that `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
 * to the debounced function will return the result of the last `func` call.
 *
 * Note: If `leading` and `trailing` options are `true` `func` will be called
 * on the trailing edge of the timeout only if the the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * @static
 * @memberOf _
 * @category Functions
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
 * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // avoid costly calculations while the window size is in flux
 * var lazyLayout = _.debounce(calculateLayout, 150***REMOVED***;
 * jQuery(window***REMOVED***.on('resize', lazyLayout***REMOVED***;
 *
 * // execute `sendMail` when the click event is fired, debouncing subsequent calls
 * jQuery('#postbox'***REMOVED***.on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }***REMOVED***;
 *
 * // ensure `batchLog` is executed once after 1 second of debounced calls
 * var source = new EventSource('/stream'***REMOVED***;
 * source.addEventListener('message', _.debounce(batchLog, 250, {
 *   'maxWait': 1000
 * }, false***REMOVED***;
 */
function debounce(func, wait, options***REMOVED*** {
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (!isFunction(func***REMOVED******REMOVED*** {
    throw new TypeError;
***REMOVED***
  wait = nativeMax(0, wait***REMOVED*** || 0;
  if (options === true***REMOVED*** {
    var leading = true;
    trailing = false;
***REMOVED*** else if (isObject(options***REMOVED******REMOVED*** {
    leading = options.leading;
    maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait***REMOVED*** || 0***REMOVED***;
    trailing = 'trailing' in options ? options.trailing : trailing;
***REMOVED***
  var delayed = function(***REMOVED*** {
    var remaining = wait - (now(***REMOVED*** - stamp***REMOVED***;
    if (remaining <= 0***REMOVED*** {
      if (maxTimeoutId***REMOVED*** {
        clearTimeout(maxTimeoutId***REMOVED***;
    ***REMOVED***
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (isCalled***REMOVED*** {
        lastCalled = now(***REMOVED***;
        result = func.apply(thisArg, args***REMOVED***;
        if (!timeoutId && !maxTimeoutId***REMOVED*** {
          args = thisArg = null;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
      timeoutId = setTimeout(delayed, remaining***REMOVED***;
  ***REMOVED***
***REMOVED***;

  var maxDelayed = function(***REMOVED*** {
    if (timeoutId***REMOVED*** {
      clearTimeout(timeoutId***REMOVED***;
  ***REMOVED***
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (trailing || (maxWait !== wait***REMOVED******REMOVED*** {
      lastCalled = now(***REMOVED***;
      result = func.apply(thisArg, args***REMOVED***;
      if (!timeoutId && !maxTimeoutId***REMOVED*** {
        args = thisArg = null;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

  return function(***REMOVED*** {
    args = arguments;
    stamp = now(***REMOVED***;
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading***REMOVED***;

    if (maxWait === false***REMOVED*** {
      var leadingCall = leading && !timeoutId;
  ***REMOVED*** else {
      if (!maxTimeoutId && !leading***REMOVED*** {
        lastCalled = stamp;
    ***REMOVED***
      var remaining = maxWait - (stamp - lastCalled***REMOVED***,
          isCalled = remaining <= 0;

      if (isCalled***REMOVED*** {
        if (maxTimeoutId***REMOVED*** {
          maxTimeoutId = clearTimeout(maxTimeoutId***REMOVED***;
      ***REMOVED***
        lastCalled = stamp;
        result = func.apply(thisArg, args***REMOVED***;
    ***REMOVED***
      else if (!maxTimeoutId***REMOVED*** {
        maxTimeoutId = setTimeout(maxDelayed, remaining***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    if (isCalled && timeoutId***REMOVED*** {
      timeoutId = clearTimeout(timeoutId***REMOVED***;
  ***REMOVED***
    else if (!timeoutId && wait !== maxWait***REMOVED*** {
      timeoutId = setTimeout(delayed, wait***REMOVED***;
  ***REMOVED***
    if (leadingCall***REMOVED*** {
      isCalled = true;
      result = func.apply(thisArg, args***REMOVED***;
  ***REMOVED***
    if (isCalled && !timeoutId && !maxTimeoutId***REMOVED*** {
      args = thisArg = null;
  ***REMOVED***
    return result;
***REMOVED***;
}

module.exports = debounce;
