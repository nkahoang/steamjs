/**
 * Lo-Dash 2.4.1 (Custom Build***REMOVED*** <http://lodash.com/>
 * Build: `lodash modularize modern exports="node" -o ./modern/`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var forEach = require('../collections/forEach'***REMOVED***,
    functions = require('../objects/functions'***REMOVED***,
    isFunction = require('../objects/isFunction'***REMOVED***,
    isObject = require('../objects/isObject'***REMOVED***;

/**
 * Used for `Array` method references.
 *
 * Normally `Array.prototype` would suffice, however, using an array literal
 * avoids issues in Narwhal.
 */
var arrayRef = [];

/** Native method shortcuts */
var push = arrayRef.push;

/**
 * Adds function properties of a source object to the destination object.
 * If `object` is a function methods will be added to its prototype as well.
 *
 * @static
 * @memberOf _
 * @category Utilities
 * @param {Function|Object} [object=lodash] object The destination object.
 * @param {Object} source The object of functions to add.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
 * @example
 *
 * function capitalize(string***REMOVED*** {
 *   return string.charAt(0***REMOVED***.toUpperCase(***REMOVED*** + string.slice(1***REMOVED***.toLowerCase(***REMOVED***;
 * }
 *
 * _.mixin({ 'capitalize': capitalize }***REMOVED***;
 * _.capitalize('fred'***REMOVED***;
 * // => 'Fred'
 *
 * _('fred'***REMOVED***.capitalize(***REMOVED***.value(***REMOVED***;
 * // => 'Fred'
 *
 * _.mixin({ 'capitalize': capitalize }, { 'chain': false }***REMOVED***;
 * _('fred'***REMOVED***.capitalize(***REMOVED***;
 * // => 'Fred'
 */
function mixin(object, source, options***REMOVED*** {
  var chain = true,
      methodNames = source && functions(source***REMOVED***;

  if (options === false***REMOVED*** {
    chain = false;
***REMOVED*** else if (isObject(options***REMOVED*** && 'chain' in options***REMOVED*** {
    chain = options.chain;
***REMOVED***
  var ctor = object,
      isFunc = isFunction(ctor***REMOVED***;

  forEach(methodNames, function(methodName***REMOVED*** {
    var func = object[methodName] = source[methodName];
    if (isFunc***REMOVED*** {
      ctor.prototype[methodName] = function(***REMOVED*** {
        var chainAll = this.__chain__,
            value = this.__wrapped__,
            args = [value];

        push.apply(args, arguments***REMOVED***;
        var result = func.apply(object, args***REMOVED***;
        if (chain || chainAll***REMOVED*** {
          if (value === result && isObject(result***REMOVED******REMOVED*** {
            return this;
        ***REMOVED***
          result = new ctor(result***REMOVED***;
          result.__chain__ = chainAll;
      ***REMOVED***
        return result;
    ***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
}

module.exports = mixin;
