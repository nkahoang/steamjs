/**
 * Lo-Dash 2.4.1 (Custom Build***REMOVED*** <http://lodash.com/>
 * Build: `lodash modularize modern exports="node" -o ./modern/`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var baseCreate = require('./baseCreate'***REMOVED***,
    isObject = require('../objects/isObject'***REMOVED***,
    setBindData = require('./setBindData'***REMOVED***,
    slice = require('./slice'***REMOVED***;

/**
 * Used for `Array` method references.
 *
 * Normally `Array.prototype` would suffice, however, using an array literal
 * avoids issues in Narwhal.
 */
var arrayRef = [];

/** Native method shortcuts */
var push = arrayRef.push;

/**
 * The base implementation of `_.bind` that creates the bound function and
 * sets its meta data.
 *
 * @private
 * @param {Array} bindData The bind data array.
 * @returns {Function} Returns the new bound function.
 */
function baseBind(bindData***REMOVED*** {
  var func = bindData[0],
      partialArgs = bindData[2],
      thisArg = bindData[4];

  function bound(***REMOVED*** {
    // `Function#bind` spec
    // http://es5.github.io/#x15.3.4.5
    if (partialArgs***REMOVED*** {
      // avoid `arguments` object deoptimizations by using `slice` instead
      // of `Array.prototype.slice.call` and not assigning `arguments` to a
      // variable as a ternary expression
      var args = slice(partialArgs***REMOVED***;
      push.apply(args, arguments***REMOVED***;
  ***REMOVED***
    // mimic the constructor's `return` behavior
    // http://es5.github.io/#x13.2.2
    if (this instanceof bound***REMOVED*** {
      // ensure `new bound` is an instance of `func`
      var thisBinding = baseCreate(func.prototype***REMOVED***,
          result = func.apply(thisBinding, args || arguments***REMOVED***;
      return isObject(result***REMOVED*** ? result : thisBinding;
  ***REMOVED***
    return func.apply(thisArg, args || arguments***REMOVED***;
***REMOVED***
  setBindData(bound, bindData***REMOVED***;
  return bound;
}

module.exports = baseBind;
