var Stream = require('stream'***REMOVED***.Stream,
  timers = require('timers'***REMOVED***,
  util = require('util'***REMOVED***;

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('../utils'***REMOVED***.processor(***REMOVED***;

/**
 * ReadStream
 *
 * Returns a stream interface for the **file**.
 *
 * Events
 *  - **data** {function(item***REMOVED*** {}} the data event triggers when a document is ready.
 *  - **end** {function(***REMOVED*** {}} the end event triggers when there is no more documents available.
 *  - **close** {function(***REMOVED*** {}} the close event triggers when the stream is closed.
 *  - **error** {function(err***REMOVED*** {}} the error event triggers if an error happens.
 *
 * @class Represents a GridFS File Stream.
 * @param {Boolean} autoclose automatically close file when the stream reaches the end.
 * @param {GridStore} cursor a cursor object that the stream wraps.
 * @return {ReadStream}
 */
function ReadStream(autoclose, gstore***REMOVED*** {
  if (!(this instanceof ReadStream***REMOVED******REMOVED*** return new ReadStream(autoclose, gstore***REMOVED***;
  Stream.call(this***REMOVED***;

  this.autoclose = !!autoclose;
  this.gstore = gstore;

  this.finalLength = gstore.length - gstore.position;
  this.completedLength = 0;
  this.currentChunkNumber = gstore.currentChunk.chunkNumber;

  this.paused = false;
  this.readable = true;
  this.pendingChunk = null;
  this.executing = false;  
  this.destroyed = false;

  // Calculate the number of chunks
  this.numberOfChunks = Math.ceil(gstore.length/gstore.chunkSize***REMOVED***;

  // This seek start position inside the current chunk
  this.seekStartPosition = gstore.position - (this.currentChunkNumber * gstore.chunkSize***REMOVED***;
  
  var self = this;
  processor(function(***REMOVED*** {
    self._execute(***REMOVED***;
***REMOVED******REMOVED***;
};

/**
 * Inherit from Stream
 * @ignore
 * @api private
 */
ReadStream.prototype.__proto__ = Stream.prototype;

/**
 * Flag stating whether or not this stream is readable.
 */
ReadStream.prototype.readable;

/**
 * Flag stating whether or not this stream is paused.
 */
ReadStream.prototype.paused;

/**
 * @ignore
 * @api private
 */
ReadStream.prototype._execute = function(***REMOVED*** {
  if(this.paused === true || this.readable === false***REMOVED*** {
    return;
***REMOVED***

  var gstore = this.gstore;
  var self = this;
  // Set that we are executing
  this.executing = true;

  var last = false;
  var toRead = 0;

  if(gstore.currentChunk.chunkNumber >= (this.numberOfChunks - 1***REMOVED******REMOVED*** {
    self.executing = false;    
    last = true;    
***REMOVED***

  // Data setup
  var data = null;

  // Read a slice (with seek set if none***REMOVED***
  if(this.seekStartPosition > 0 && (gstore.currentChunk.length(***REMOVED*** - this.seekStartPosition***REMOVED*** > 0***REMOVED*** {
    data = gstore.currentChunk.readSlice(gstore.currentChunk.length(***REMOVED*** - this.seekStartPosition***REMOVED***;
    this.seekStartPosition = 0;
***REMOVED*** else {
    data = gstore.currentChunk.readSlice(gstore.currentChunk.length(***REMOVED******REMOVED***;
***REMOVED***

  var processNext = function(***REMOVED*** {
    if(last === true***REMOVED*** {
      self.readable = false;
      self.emit("end"***REMOVED***;
      
      if(self.autoclose === true***REMOVED*** {
        if(gstore.mode[0] == "w"***REMOVED*** {
          gstore.close(function(err, doc***REMOVED*** {
            if (err***REMOVED*** {
              self.emit("error", err***REMOVED***;
              return;
          ***REMOVED***
            self.readable = false;  
            self.destroyed = true;        
            self.emit("close", doc***REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED*** else {
          self.readable = false;
          self.destroyed = true;        
          self.emit("close"***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
      gstore._nthChunk(gstore.currentChunk.chunkNumber + 1, function(err, chunk***REMOVED*** {
        if(err***REMOVED*** {
          self.readable = false;
          if(self.listeners("error"***REMOVED***.length > 0***REMOVED***
            self.emit("error", err***REMOVED***;
          self.executing = false;
          return;
      ***REMOVED***

        self.pendingChunk = chunk;
        if(self.paused === true***REMOVED*** {
          self.executing = false;
          return;
      ***REMOVED***

        gstore.currentChunk = self.pendingChunk;
        self._execute(***REMOVED***;        
    ***REMOVED******REMOVED***;
  ***REMOVED***    
***REMOVED***

  // Return the data
  if(data != null && gstore.currentChunk.chunkNumber == self.currentChunkNumber***REMOVED*** {
    self.currentChunkNumber = self.currentChunkNumber + 1;
    self.completedLength += data.length;
    self.pendingChunk = null;
    // Send the data
    process.nextTick(function(***REMOVED*** {
      self.emit("data", data***REMOVED***; 
      processNext(***REMOVED***;           
  ***REMOVED******REMOVED***
***REMOVED*** else {
    processNext(***REMOVED***;
***REMOVED***
};

/**
 * Pauses this stream, then no farther events will be fired.
 *
 * @ignore
 * @api public
 */
ReadStream.prototype.pause = function(***REMOVED*** {
  if(!this.executing***REMOVED*** {
    this.paused = true;    
***REMOVED***
};

/**
 * Destroys the stream, then no farther events will be fired.
 *
 * @ignore
 * @api public
 */
ReadStream.prototype.destroy = function(***REMOVED*** {
  if(this.destroyed***REMOVED*** return;
  this.destroyed = true;
  this.readable = false;
  // Emit close event
  this.emit("close"***REMOVED***;
};

/**
 * Resumes this stream.
 *
 * @ignore
 * @api public
 */
ReadStream.prototype.resume = function(***REMOVED*** {
  if(this.paused === false || !this.readable***REMOVED*** {
    return;
***REMOVED***
    
  this.paused = false;
  var self = this;
  processor(function(***REMOVED*** {
    self._execute(***REMOVED***;
***REMOVED******REMOVED***;
};

exports.ReadStream = ReadStream;
