var timers = require('timers'***REMOVED***;

/**
 * Sort functions, Normalize and prepare sort parameters
 */
var formatSortValue = exports.formatSortValue = function(sortDirection***REMOVED*** {
  var value = ("" + sortDirection***REMOVED***.toLowerCase(***REMOVED***;

  switch (value***REMOVED*** {
    case 'ascending':
    case 'asc':
    case '1':
      return 1;
    case 'descending':
    case 'desc':
    case '-1':
      return -1;
    default:
      throw new Error("Illegal sort clause, must be of the form "
                    + "[['field1', '(ascending|descending***REMOVED***'], "
                    + "['field2', '(ascending|descending***REMOVED***']]"***REMOVED***;
***REMOVED***
};

var formattedOrderClause = exports.formattedOrderClause = function(sortValue***REMOVED*** {
  var orderBy = {};

  if (Array.isArray(sortValue***REMOVED******REMOVED*** {
    for(var i = 0; i < sortValue.length; i++***REMOVED*** {
      if(sortValue[i].constructor == String***REMOVED*** {
        orderBy[sortValue[i]] = 1;
    ***REMOVED*** else {
        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]***REMOVED***;
    ***REMOVED***      
  ***REMOVED***
***REMOVED*** else if(Object.prototype.toString.call(sortValue***REMOVED*** === '[object Object]'***REMOVED*** {
    orderBy = sortValue;
***REMOVED*** else if (sortValue.constructor == String***REMOVED*** {
    orderBy[sortValue] = 1;
***REMOVED*** else {
    throw new Error("Illegal sort clause, must be of the form " +
      "[['field1', '(ascending|descending***REMOVED***'], ['field2', '(ascending|descending***REMOVED***']]"***REMOVED***;
***REMOVED***

  return orderBy;
};

exports.encodeInt = function(value***REMOVED*** {
  var buffer = new Buffer(4***REMOVED***;
  buffer[3] = (value >> 24***REMOVED*** & 0xff;      
  buffer[2] = (value >> 16***REMOVED*** & 0xff;
  buffer[1] = (value >> 8***REMOVED*** & 0xff;
  buffer[0] = value & 0xff;
  return buffer;
}

exports.encodeIntInPlace = function(value, buffer, index***REMOVED*** {
  buffer[index + 3] = (value >> 24***REMOVED*** & 0xff;			
	buffer[index + 2] = (value >> 16***REMOVED*** & 0xff;
	buffer[index + 1] = (value >> 8***REMOVED*** & 0xff;
	buffer[index] = value & 0xff;
}

exports.encodeCString = function(string***REMOVED*** {
  var buf = new Buffer(string, 'utf8'***REMOVED***;
  return [buf, new Buffer([0]***REMOVED***];
}

exports.decodeUInt32 = function(array, index***REMOVED*** {
  return array[index] | array[index + 1] << 8 | array[index + 2] << 16 | array[index + 3] << 24;
}

// Decode the int
exports.decodeUInt8 = function(array, index***REMOVED*** {
  return array[index];
}

/**
 * Context insensitive type checks
 */

var toString = Object.prototype.toString;

var isObject = exports.isObject = function (arg***REMOVED*** {
  return '[object Object]' == toString.call(arg***REMOVED***
}

exports.isArray = function (arg***REMOVED*** {
  return Array.isArray(arg***REMOVED*** ||
    'object' == typeof arg && '[object Array]' == toString.call(arg***REMOVED***
}

exports.isDate = function (arg***REMOVED*** {
  return 'object' == typeof arg && '[object Date]' == toString.call(arg***REMOVED***
}

exports.isRegExp = function (arg***REMOVED*** {
  return 'object' == typeof arg && '[object RegExp]' == toString.call(arg***REMOVED***
}

/**
 * Wrap a Mongo error document in an Error instance
 * @ignore
 * @api private
 */
var toError = function(error***REMOVED*** {
  if (error instanceof Error***REMOVED*** return error;

  var msg = error.err || error.errmsg || error.errMessage || error;
  var e = new Error(msg***REMOVED***;
  e.name = 'MongoError';

  // Get all object keys
  var keys = typeof error == 'object'
    ? Object.keys(error***REMOVED***
    : [];

  for(var i = 0; i < keys.length; i++***REMOVED*** {
    e[keys[i]] = error[keys[i]];
***REMOVED***

  return e;
}
exports.toError = toError;

/**
 * Convert a single level object to an array
 * @ignore
 * @api private
 */
exports.objectToArray = function(object***REMOVED*** {
  var list = [];

  for(var name in object***REMOVED*** {
    list.push(object[name]***REMOVED***
***REMOVED***

  return list;
}

/**
 * Handle single command document return
 * @ignore
 * @api private
 */
exports.handleSingleCommandResultReturn = function(override_value_true, override_value_false, callback***REMOVED*** {
  return function(err, result, connection***REMOVED*** {
    if(err && typeof callback == 'function'***REMOVED*** return callback(err, null***REMOVED***;
    if(!result || !result.documents || result.documents.length == 0***REMOVED***
      if(typeof callback == 'function'***REMOVED*** return callback(toError("command failed to return results"***REMOVED***, null***REMOVED***
    if(result && result.documents[0].ok == 1***REMOVED*** {
      if(override_value_true***REMOVED*** return callback(null, override_value_true***REMOVED***
      if(typeof callback == 'function'***REMOVED*** return callback(null, result.documents[0]***REMOVED***;
  ***REMOVED***

    // Return the error from the document
    if(typeof callback == 'function'***REMOVED*** return callback(toError(result.documents[0]***REMOVED***, override_value_false***REMOVED***;    
***REMOVED***
}

/**
 * Return correct processor
 * @ignore
 * @api private
 */
exports.processor = function(***REMOVED*** {
  // Set processor, setImmediate if 0.10 otherwise nextTick
  process.maxTickDepth = Infinity;
  // Only use nextTick
  return process.nextTick;
}

/**
 * Allow setting the socketTimeoutMS on all connections
 * to work around issues such as secondaries blocking due to compaction
 *
 * @ignore
 * @api private
 */
exports.setSocketTimeoutProperty = function(self, options***REMOVED*** {
  Object.defineProperty(self, "socketTimeoutMS", {
      enumerable: true
    , get: function (***REMOVED*** { return options.socketTimeoutMS; }
    , set: function (value***REMOVED*** { 
      // Set the socket timeoutMS value
      options.socketTimeoutMS = value;

      // Get all the connections
      var connections = self.allRawConnections(***REMOVED***;
      for(var i = 0; i < connections.length; i++***REMOVED*** {
        connections[i].socketTimeoutMS = value;
    ***REMOVED***
  ***REMOVED***
***REMOVED******REMOVED***;  
}

/**
 * Determine if the server supports write commands
 *
 * @ignore
 * @api private
 */
exports.hasWriteCommands = function(connection***REMOVED*** {
  return connection != null && connection.serverCapabilities != null && connection.serverCapabilities.hasWriteCommands;
}

/**
 * Fetch server capabilities
 *
 * @ignore
 * @api private
 */
exports.serverCapabilities = function(connection***REMOVED*** {
  return connection != null && connection.serverCapabilities != null && connection.serverCapabilities.hasWriteCommands;
}

/**
 * Create index name based on field spec
 *
 * @ignore
 * @api private
 */
exports.parseIndexOptions = function(fieldOrSpec***REMOVED*** {
  var fieldHash = {};
  var indexes = [];
  var keys;

  // Get all the fields accordingly
  if('string' == typeof fieldOrSpec***REMOVED*** {
    // 'type'
    indexes.push(fieldOrSpec + '_' + 1***REMOVED***;
    fieldHash[fieldOrSpec] = 1;
***REMOVED*** else if(Array.isArray(fieldOrSpec***REMOVED******REMOVED*** {
    fieldOrSpec.forEach(function(f***REMOVED*** {
      if('string' == typeof f***REMOVED*** {
        // [{location:'2d'}, 'type']
        indexes.push(f + '_' + 1***REMOVED***;
        fieldHash[f] = 1;
    ***REMOVED*** else if(Array.isArray(f***REMOVED******REMOVED*** {
        // [['location', '2d'],['type', 1]]
        indexes.push(f[0] + '_' + (f[1] || 1***REMOVED******REMOVED***;
        fieldHash[f[0]] = f[1] || 1;
    ***REMOVED*** else if(isObject(f***REMOVED******REMOVED*** {
        // [{location:'2d'}, {type:1}]
        keys = Object.keys(f***REMOVED***;
        keys.forEach(function(k***REMOVED*** {
          indexes.push(k + '_' + f[k]***REMOVED***;
          fieldHash[k] = f[k];
      ***REMOVED******REMOVED***;
    ***REMOVED*** else {
        // undefined (ignore***REMOVED***
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED*** else if(isObject(fieldOrSpec***REMOVED******REMOVED*** {
    // {location:'2d', type:1}
    keys = Object.keys(fieldOrSpec***REMOVED***;
    keys.forEach(function(key***REMOVED*** {
      indexes.push(key + '_' + fieldOrSpec[key]***REMOVED***;
      fieldHash[key] = fieldOrSpec[key];
  ***REMOVED******REMOVED***;
***REMOVED***

  return {
    name: indexes.join("_"***REMOVED***, keys: keys, fieldHash: fieldHash
***REMOVED***
}
