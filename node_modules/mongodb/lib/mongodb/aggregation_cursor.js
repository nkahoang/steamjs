var ReadPreference = require('./connection/read_preference'***REMOVED***.ReadPreference
	, Readable = require('stream'***REMOVED***.Readable
	, CommandCursor = require('./command_cursor'***REMOVED***.CommandCursor
	, utils = require('./utils'***REMOVED***
	, shared = require('./collection/shared'***REMOVED***
	, inherits = require('util'***REMOVED***.inherits;

var AggregationCursor = function(collection, serverCapabilities, options***REMOVED*** {	
	var pipe = [];
	var self = this;
	var results = null;	
	var _cursor_options = {};
	// Ensure we have options set up
	options = options == null ? {} : options;

	// If a pipeline was provided
	pipe = Array.isArray(options.pipe***REMOVED*** ? options.pipe : pipe;
	// Set passed in batchSize if provided
	if(typeof options.batchSize == 'number'***REMOVED*** _cursor_options.batchSize = options.batchSize;
	// Get the read Preference
	var readPreference = shared._getReadConcern(collection, options***REMOVED***;

	// Set up
	Readable.call(this, {objectMode: true}***REMOVED***;

	// Contains connection
	var connection = null;

	// Set the read preference
	var _options = { 
		readPreference: readPreference
	};

	// Actual command
	var command = {
			aggregate: collection.collectionName
		, pipeline: pipe
		, cursor: _cursor_options
	}

	// If allowDiskUsage is set
	if(typeof options.allowDiskUsage == 'boolean'***REMOVED*** 
		command.allowDiskUsage = options.allowDiskUsage;
	
	// Command cursor (if we support one***REMOVED***
	var commandCursor = new CommandCursor(collection.db, collection, command***REMOVED***;

	// // Internal cursor methods
	// this.find = function(selector***REMOVED*** {
	// 	pipe.push({$match: selector}***REMOVED***;
	// 	return self;
	// }

	// this.unwind = function(unwind***REMOVED*** {
	// 	pipe.push({$unwind: unwind}***REMOVED***;
	// 	return self;
	// }

	// this.group = function(group***REMOVED*** {
	// 	pipe.push({$group: group}***REMOVED***;
	// 	return self;
	// }

	// this.project = function(project***REMOVED*** {
	// 	pipe.push({$project: project}***REMOVED***;
	// 	return self;
	// }

	// this.limit = function(limit***REMOVED*** {
	// 	pipe.push({$limit: limit}***REMOVED***;
	// 	return self;
	// }

	// this.geoNear = function(geoNear***REMOVED*** {
	// 	pipe.push({$geoNear: geoNear}***REMOVED***;
	// 	return self;
	// }

	// this.sort = function(sort***REMOVED*** {
	// 	pipe.push({$sort: sort}***REMOVED***;
	// 	return self;
	// }

	// this.withReadPreference = function(read_preference***REMOVED*** {
	// 	_options.readPreference = read_preference;
	// 	return self;
	// }

	// this.withQueryOptions = function(options***REMOVED*** {
	// 	if(options.batchSize***REMOVED*** {
	// 		_cursor_options.batchSize = options.batchSize;
	// 	}

	// 	// Return the cursor
	// 	return self;
	// }

	// this.skip = function(skip***REMOVED*** {
	// 	pipe.push({$skip: skip}***REMOVED***;
	// 	return self;
	// }

	// this.allowDiskUsage = function(allowDiskUsage***REMOVED*** {
	// 	command.allowDiskUsage = allowDiskUsage;
	// 	return self;
	// }

	this.explain = function(callback***REMOVED*** {
		if(typeof callback != 'function'***REMOVED*** 
			throw utils.toError("AggregationCursor explain requires a callback function"***REMOVED***;
		
		// Add explain options
		_options.explain = true;
		// Execute aggregation pipeline
		collection.aggregate(pipe, _options, function(err, results***REMOVED*** {
			if(err***REMOVED*** return callback(err, null***REMOVED***;
			callback(null, results***REMOVED***;
		}***REMOVED***;
	}

	// this.maxTimeMS = function(maxTimeMS***REMOVED*** {
	// 	if(typeof maxTimeMS != 'number'***REMOVED*** {
	// 		throw new Error("maxTimeMS must be a number"***REMOVED***;
	// 	}

	// 	// Save the maxTimeMS
	// 	_options.maxTimeMS = maxTimeMS
	// 	// Set the maxTimeMS on the command cursor
	// 	commandCursor.maxTimeMS(maxTimeMS***REMOVED***;
	// 	return self;
	// }

	this.get = function(callback***REMOVED*** {
		if(typeof callback != 'function'***REMOVED*** 
			throw utils.toError("AggregationCursor get requires a callback function"***REMOVED***;		
	  // Checkout a connection
	  var _connection = collection.db.serverConfig.checkoutReader(_options.readPreference***REMOVED***;
	  // Fall back
		if(!_connection.serverCapabilities.hasAggregationCursor***REMOVED*** {
			return collection.aggregate(pipe, _options, function(err, results***REMOVED*** {
				if(err***REMOVED*** return callback(err***REMOVED***;
				callback(null, results***REMOVED***;
			}***REMOVED***;			
		}

		// Execute get using command Cursor
		commandCursor.get({connection: _connection}, callback***REMOVED***;
	}

	this.getOne = function(callback***REMOVED*** {
		if(typeof callback != 'function'***REMOVED*** 
			throw utils.toError("AggregationCursor getOne requires a callback function"***REMOVED***;		
		// Set the limit to 1
		pipe.push({$limit: 1}***REMOVED***;
		// For now we have no cursor command so let's just wrap existing results
		collection.aggregate(pipe, _options, function(err, results***REMOVED*** {
			if(err***REMOVED*** return callback(err***REMOVED***;
			callback(null, results[0]***REMOVED***;
		}***REMOVED***;
	}

	this.each = function(callback***REMOVED*** {
	  // Checkout a connection if we have none
	  if(!connection***REMOVED***
	  	connection = collection.db.serverConfig.checkoutReader(_options.readPreference***REMOVED***;
	  
	  // Fall back
		if(!connection.serverCapabilities.hasAggregationCursor***REMOVED*** {
			collection.aggregate(pipe, _options, function(err, _results***REMOVED*** {
				if(err***REMOVED*** return callback(err***REMOVED***;

				while(_results.length > 0***REMOVED*** {
					callback(null, _results.shift(***REMOVED******REMOVED***;
				}

				callback(null, null***REMOVED***;
			}***REMOVED***;
		}

		// Execute each using command Cursor
		commandCursor.each({connection: connection}, callback***REMOVED***;		
	}

	this.next = function(callback***REMOVED*** {
		if(typeof callback != 'function'***REMOVED*** 
			throw utils.toError("AggregationCursor next requires a callback function"***REMOVED***;		

	  // Checkout a connection if we have none
	  if(!connection***REMOVED***
	  	connection = collection.db.serverConfig.checkoutReader(_options.readPreference***REMOVED***;
	  
	  // Fall back
		if(!connection.serverCapabilities.hasAggregationCursor***REMOVED*** {
			if(!results***REMOVED*** {
				// For now we have no cursor command so let's just wrap existing results
				return collection.aggregate(pipe, _options, function(err, _results***REMOVED*** {
					if(err***REMOVED*** return callback(err***REMOVED***;
					results = _results;
	        
	        // Ensure we don't issue undefined
	        var item = results.shift(***REMOVED***;
	        callback(null, item ? item : null***REMOVED***;
				}***REMOVED***;			
			}

	    // Ensure we don't issue undefined
	    var item = results.shift(***REMOVED***;
	    // Return the item
	    return callback(null, item ? item : null***REMOVED***;
	***REMOVED***

		// Execute next using command Cursor
		commandCursor.next({connection: connection}, callback***REMOVED***;		
	}

	//
	// Close method
	//
	this.close = function(callback***REMOVED*** {
		if(typeof callback != 'function'***REMOVED*** 
			throw utils.toError("AggregationCursor close requires a callback function"***REMOVED***;		

	  // Checkout a connection if we have none
	  if(!connection***REMOVED***
	  	connection = collection.db.serverConfig.checkoutReader(_options.readPreference***REMOVED***;

	  // Fall back
		if(!connection.serverCapabilities.hasAggregationCursor***REMOVED*** {
			return callback(null, null***REMOVED***;
		}

		// Execute next using command Cursor
		commandCursor.close({connection: connection}, callback***REMOVED***;		
	}

	//
	// Stream method
	//
	this._read = function(n***REMOVED*** {
		self.next(function(err, result***REMOVED*** {
			if(err***REMOVED*** {
				self.emit('error', err***REMOVED***;
				return self.push(null***REMOVED***;
			}

			self.push(result***REMOVED***;
		}***REMOVED***;
	}
}

// Inherit from Readable
if(Readable != null***REMOVED*** {
	inherits(AggregationCursor, Readable***REMOVED***;	
}

// Exports the Aggregation Framework
exports.AggregationCursor = AggregationCursor;