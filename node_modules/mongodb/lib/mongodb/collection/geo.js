var shared = require('./shared'***REMOVED***
  , utils = require('../utils'***REMOVED***;

var geoNear = function geoNear(x, y, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 2***REMOVED***;
  callback = args.pop(***REMOVED***;
  // Fetch all commands
  options = args.length ? args.shift(***REMOVED*** || {} : {};

  // Build command object
  var commandObject = {
    geoNear:this.collectionName,
    near: [x, y]
***REMOVED***

  // Decorate object if any with known properties
  if(options['num'] != null***REMOVED*** commandObject['num'] = options['num'];
  if(options['maxDistance'] != null***REMOVED*** commandObject['maxDistance'] = options['maxDistance'];
  if(options['distanceMultiplier'] != null***REMOVED*** commandObject['distanceMultiplier'] = options['distanceMultiplier'];
  if(options['query'] != null***REMOVED*** commandObject['query'] = options['query'];
  if(options['spherical'] != null***REMOVED*** commandObject['spherical'] = options['spherical'];
  if(options['uniqueDocs'] != null***REMOVED*** commandObject['uniqueDocs'] = options['uniqueDocs'];
  if(options['includeLocs'] != null***REMOVED*** commandObject['includeLocs'] = options['includeLocs'];

  // Ensure we have the right read preference inheritance
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;

  // Execute the command
  this.db.command(commandObject, options, function (err, res***REMOVED*** {
    if (err***REMOVED*** {
      callback(err***REMOVED***;
  ***REMOVED*** else if (res.err || res.errmsg***REMOVED*** {
      callback(utils.toError(res***REMOVED******REMOVED***;
  ***REMOVED*** else {
      // should we only be returning res.results here? Not sure if the user
      // should see the other return information
      callback(null, res***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
}

var geoHaystackSearch = function geoHaystackSearch(x, y, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 2***REMOVED***;
  callback = args.pop(***REMOVED***;
  // Fetch all commands
  options = args.length ? args.shift(***REMOVED*** || {} : {};

  // Build command object
  var commandObject = {
    geoSearch:this.collectionName,
    near: [x, y]
***REMOVED***

  // Decorate object if any with known properties
  if(options['maxDistance'] != null***REMOVED*** commandObject['maxDistance'] = options['maxDistance'];
  if(options['query'] != null***REMOVED*** commandObject['search'] = options['query'];
  if(options['search'] != null***REMOVED*** commandObject['search'] = options['search'];
  if(options['limit'] != null***REMOVED*** commandObject['limit'] = options['limit'];

  // Ensure we have the right read preference inheritance
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;

  // Execute the command
  this.db.command(commandObject, options, function (err, res***REMOVED*** {
    if (err***REMOVED*** {
      callback(err***REMOVED***;
  ***REMOVED*** else if (res.err || res.errmsg***REMOVED*** {
      callback(utils.toError(res***REMOVED******REMOVED***;
  ***REMOVED*** else {
      // should we only be returning res.results here? Not sure if the user
      // should see the other return information
      callback(null, res***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
}

exports.geoNear = geoNear;
exports.geoHaystackSearch = geoHaystackSearch;
