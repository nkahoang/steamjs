var utils = require('../../utils'***REMOVED***;

// Error codes
var UNKNOWN_ERROR = 8;
var INVALID_BSON_ERROR = 22;
var WRITE_CONCERN_ERROR = 64;
var MULTIPLE_ERROR = 65;

// Insert types
var INSERT = 1;
var UPDATE = 2;
var REMOVE = 3

/**
 * Helper function to define properties
 */
var defineReadOnlyProperty = function(self, name, value***REMOVED*** {
  Object.defineProperty(self, name, {
      enumerable: true
    , get: function(***REMOVED*** {
      return value;
  ***REMOVED***
***REMOVED******REMOVED***;
}

/**
 * Keeps the state of a unordered batch so we can rewrite the results
 * correctly after command execution
 */
var Batch = function(batchType, originalZeroIndex***REMOVED*** {  
  this.originalZeroIndex = originalZeroIndex;
  this.currentIndex = 0;
  this.originalIndexes = [];
  this.batchType = batchType;
  this.operations = [];
  this.size = 0;
}

/**
 * Wraps a legacy operation so we can correctly rewrite it's error
 */
var LegacyOp = function(batchType, operation, index***REMOVED*** {
  this.batchType = batchType;
  this.index = index;
  this.operation = operation;
}

/**
 * Create a new BatchWriteResult instance (INTERNAL TYPE, do not instantiate directly***REMOVED***
 *
 * @class Represents a BatchWriteResult
 * @property **ok** {boolean} did bulk operation correctly execute
 * @property **nInserted** {number} number of inserted documents
 * @property **nUpdated** {number} number of documents updated logically
 * @property **nUpserted** {number} number of upserted documents
 * @property **nModified** {number} number of documents updated physically on disk
 * @property **nRemoved** {number} number of removed documents
 * @param {Object} batchResult internal data structure with results.
 * @return {BatchWriteResult} a BatchWriteResult instance
 */
var BatchWriteResult = function(bulkResult***REMOVED*** {
  defineReadOnlyProperty(this, "ok", bulkResult.ok***REMOVED***;
  defineReadOnlyProperty(this, "nInserted", bulkResult.nInserted***REMOVED***;
  defineReadOnlyProperty(this, "nUpserted", bulkResult.nUpserted***REMOVED***;
  defineReadOnlyProperty(this, "nMatched", bulkResult.nMatched***REMOVED***;
  defineReadOnlyProperty(this, "nModified", bulkResult.nModified***REMOVED***;
  defineReadOnlyProperty(this, "nRemoved", bulkResult.nRemoved***REMOVED***;
  
  /**
   * Return an array of upserted ids
   *
   * @return {Array}
   * @api public
   */
  this.getUpsertedIds = function(***REMOVED*** {
    return bulkResult.upserted;
***REMOVED***

  /**
   * Return the upserted id at position x
   *
   * @param {Number} index the number of the upserted id to return, returns undefined if no result for passed in index
   * @return {Array}
   * @api public
   */
  this.getUpsertedIdAt = function(index***REMOVED*** {
    return bulkResult.upserted[index]; 
***REMOVED***

  /**
   * Return raw internal result
   *
   * @return {Object}
   * @api public
   */
  this.getRawResponse = function(***REMOVED*** {
    return bulkResult;
***REMOVED***

  /**
   * Returns true if the bulk operation contains a write error
   *
   * @return {Boolean}
   * @api public
   */
  this.hasWriteErrors = function(***REMOVED*** {
    return bulkResult.writeErrors.length > 0;
***REMOVED***

  /**
   * Returns the number of write errors off the bulk operation
   *
   * @return {Number}
   * @api public
   */
  this.getWriteErrorCount = function(***REMOVED*** {
    return bulkResult.writeErrors.length;
***REMOVED***

  /**
   * Returns a specific write error object
   *
   * @return {WriteError}
   * @api public
   */
  this.getWriteErrorAt = function(index***REMOVED*** {
    if(index < bulkResult.writeErrors.length***REMOVED*** {
      return bulkResult.writeErrors[index];
  ***REMOVED***
    return null;
***REMOVED***

  /**
   * Retrieve all write errors
   *
   * @return {Array}
   * @api public
   */
  this.getWriteErrors = function(***REMOVED*** {
    return bulkResult.writeErrors;
***REMOVED***

  /**
   * Retrieve the write concern error if any
   *
   * @return {WriteConcernError}
   * @api public
   */
  this.getWriteConcernError = function(***REMOVED*** {
    if(bulkResult.writeConcernErrors.length == 0***REMOVED*** {
      return null;
  ***REMOVED*** else if(bulkResult.writeConcernErrors.length == 1***REMOVED*** {
      // Return the error
      return bulkResult.writeConcernErrors[0];
  ***REMOVED*** else {

      // Combine the errors
      var errmsg = "";
      for(var i = 0; i < bulkResult.writeConcernErrors.length; i++***REMOVED*** {
        var err = bulkResult.writeConcernErrors[i];
        errmsg = errmsg + err.errmsg;
        
        // TODO: Something better
        if(i == 0***REMOVED*** errmsg = errmsg + " and ";
    ***REMOVED***

      return new WriteConcernError({ errmsg : errmsg, code : WRITE_CONCERN_ERROR }***REMOVED***;
  ***REMOVED***
***REMOVED***

  this.toJSON = function(***REMOVED*** {
    return bulkResult;
***REMOVED***

  this.toString = function(***REMOVED*** {
    return "BatchWriteResult(" + this.toJSON(bulkResult***REMOVED*** + "***REMOVED***";
***REMOVED***

  this.isOk = function(***REMOVED*** {
    return bulkResult.ok == 1;
***REMOVED***
}

/**
 * Wraps a write concern error
 */
var WriteConcernError = function(err***REMOVED*** {
  if(!(this instanceof WriteConcernError***REMOVED******REMOVED*** return new WriteConcernError(err***REMOVED***;

  // Define properties
  defineReadOnlyProperty(this, "code", err.code***REMOVED***;
  defineReadOnlyProperty(this, "errmsg", err.errmsg***REMOVED***;

  this.toJSON = function(***REMOVED*** {
    return {code: err.code, errmsg: err.errmsg};
***REMOVED***

  this.toString = function(***REMOVED*** {
    return "WriteConcernError(" + err.errmsg + "***REMOVED***";
***REMOVED***
}

/**
 * Wraps the error
 */
var WriteError = function(err***REMOVED*** {
  if(!(this instanceof WriteError***REMOVED******REMOVED*** return new WriteError(err***REMOVED***;

  // Define properties
  defineReadOnlyProperty(this, "code", err.code***REMOVED***;
  defineReadOnlyProperty(this, "index", err.index***REMOVED***;
  defineReadOnlyProperty(this, "errmsg", err.errmsg***REMOVED***;

  //
  // Define access methods
  this.getOperation = function(***REMOVED*** {
    return err.op;
***REMOVED***

  this.toJSON = function(***REMOVED*** {
    return {code: err.code, index: err.index, errmsg: err.errmsg, op: err.op};
***REMOVED***

  this.toString = function(***REMOVED*** {
    return "WriteError(" + JSON.stringify(this.toJSON(***REMOVED******REMOVED*** + "***REMOVED***";
***REMOVED***
}

/**
 * Merges results into shared data structure
 */
var mergeBatchResults = function(ordered, batch, bulkResult, err, result***REMOVED*** {
  // If we have an error set the result to be the err object
  if(err***REMOVED*** {
    result = err;
***REMOVED***

  // Do we have a top level error stop processing and return
  if(result.ok == 0 && bulkResult.ok == 1***REMOVED*** {
    bulkResult.ok = 0;
    bulkResult.error = utils.toError(result***REMOVED***;
    return;
***REMOVED*** else if(result.ok == 0 && bulkResult.ok == 0***REMOVED*** {
    return;
***REMOVED***

  // If we have an insert Batch type
  if(batch.batchType == INSERT && result.n***REMOVED*** {
    bulkResult.nInserted = bulkResult.nInserted + result.n;
***REMOVED***

  // If we have an insert Batch type
  if(batch.batchType == REMOVE && result.n***REMOVED*** {
    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
***REMOVED***

  var nUpserted = 0;

  // We have an array of upserted values, we need to rewrite the indexes
  if(Array.isArray(result.upserted***REMOVED******REMOVED*** {
    nUpserted = result.upserted.length;

    for(var i = 0; i < result.upserted.length; i++***REMOVED*** {
      bulkResult.upserted.push({
          index: result.upserted[i].index + batch.originalZeroIndex
        , _id: result.upserted[i]._id
    ***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED*** else if(result.upserted***REMOVED*** {

    nUpserted = 1;

    bulkResult.upserted.push({
        index: batch.originalZeroIndex
      , _id: result.upserted
  ***REMOVED******REMOVED***;
***REMOVED***

  // If we have an update Batch type
  if(batch.batchType == UPDATE && result.n***REMOVED*** {
    var nModified = result.nModified;
    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted***REMOVED***;
    
    if(typeof nModified == 'number'***REMOVED*** {
      bulkResult.nModified = bulkResult.nModified + nModified;
  ***REMOVED*** else {
      bulkResult.nModified = null;
  ***REMOVED***
***REMOVED***

  if(Array.isArray(result.writeErrors***REMOVED******REMOVED*** {
    for(var i = 0; i < result.writeErrors.length; i++***REMOVED*** {

      var writeError = {
          index: batch.originalZeroIndex + result.writeErrors[i].index
        , code: result.writeErrors[i].code
        , errmsg: result.writeErrors[i].errmsg
        , op: batch.operations[result.writeErrors[i].index]
    ***REMOVED***;

      bulkResult.writeErrors.push(new WriteError(writeError***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***

  if(result.writeConcernError***REMOVED*** {
    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError***REMOVED******REMOVED***;
***REMOVED***
}

// 
// Merge a legacy result into the master results
var mergeLegacyResults = function(_ordered, _op, _batch, _results, _result, _index***REMOVED*** {
  // If we have an error already
  if(_results.ok == 0***REMOVED*** return false;
  // Handle error
  if((_result.errmsg || _result.err || _result instanceof Error***REMOVED*** && _result.wtimeout != true***REMOVED*** {
    // && ((_result.wtimeout == null && _result.jnote == null && _result.wnote == null***REMOVED******REMOVED*** || _result.err == "norepl"***REMOVED*** {
    var code = _result.code || UNKNOWN_ERROR; // Returned error code or unknown code
    var errmsg = _result.errmsg || _result.err;
    errmsg = errmsg || _result.message;

    // Result is replication issue, rewrite error to match write command      
    if(_result.wnote || _result.wtimeout || _result.jnote***REMOVED*** {
      // Set the code to replication error
      code = WRITE_CONCERN_ERROR;
      // Ensure we get the right error message
      errmsg = _result.wnote || errmsg;
      errmsg = _result.jnote || errmsg;
  ***REMOVED***

    //
    // We have an error that is a show stopper, 16544 and 13 are auth errors that should stop processing
    if(_result.wnote 
      || _result.jnote == "journaling not enabled on this server" 
      || _result.err == "norepl"
      || _result.code == 16544 
      || _result.code == 13***REMOVED*** {
      _results.ok = 0;
      _results.error = utils.toError({code: code, errmsg: errmsg}***REMOVED***;
      return false;
  ***REMOVED***    

    // Create a write error
    var errResult = new WriteError({
        index: _index
      , code: code
      , errmsg: errmsg
      , op: _op      
  ***REMOVED******REMOVED***;
    
    // Err details
    _results.writeErrors.push(errResult***REMOVED***;

    // Check if we any errors
    if(_ordered == true 
      && _result.jnote == null 
      && _result.wnote == null 
      && _result.wtimeout == null***REMOVED*** {
      return false;
  ***REMOVED***
***REMOVED*** else if(_batch.batchType == INSERT***REMOVED*** {
    _results.nInserted = _results.nInserted + 1;
***REMOVED*** else if(_batch.batchType == UPDATE***REMOVED*** {
    // If we have an upserted value or if the user provided a custom _id value
    if(_result.upserted || (!_result.updatedExisting && _result.upserted == null***REMOVED******REMOVED*** {
      _results.nUpserted = _results.nUpserted + 1;
  ***REMOVED*** else {
      _results.nMatched = _results.nMatched + _result.n;
      _results.nModified = null;
   ***REMOVED***
***REMOVED*** else if(_batch.batchType == REMOVE***REMOVED*** {
    _results.nRemoved = _results.nRemoved + _result;
***REMOVED***

  // We have a write concern error, add a write concern error to the results
  if(_result.wtimeout != null || _result.jnote != null || _result.wnote != null***REMOVED*** {
    var error = _result.err || _result.errmsg || _result.wnote || _result.jnote || _result.wtimeout;
    var code = _result.code || WRITE_CONCERN_ERROR;
    // Push a write concern error to the list
    _results.writeConcernErrors.push(new WriteConcernError({errmsg: error, code: code}***REMOVED******REMOVED***;
***REMOVED***

  // We have an upserted field (might happen with a write concern error***REMOVED***
  if(_result.upserted***REMOVED*** {
    _results.upserted.push({
        index: _index
      , _id: _result.upserted
  ***REMOVED******REMOVED***
***REMOVED*** else if(!_result.updatedExisting && _result.upserted == null && _op.q && _op.q._id***REMOVED*** {
    _results.upserted.push({
        index: _index
      , _id: _op.q._id
  ***REMOVED******REMOVED***    
***REMOVED***
}

//
// Clone the options
var cloneOptions = function(options***REMOVED*** {
  var clone = {};
  var keys = Object.keys(options***REMOVED***;
  for(var i = 0; i < keys.length; i++***REMOVED*** {
    clone[keys[i]] = options[keys[i]];
***REMOVED***

  return clone;
}

// Exports symbols
exports.BatchWriteResult = BatchWriteResult;
exports.WriteError = WriteError;
exports.Batch = Batch;
exports.LegacyOp = LegacyOp;
exports.mergeBatchResults = mergeBatchResults;
exports.cloneOptions = cloneOptions;
exports.mergeLegacyResults = mergeLegacyResults;
exports.INVALID_BSON_ERROR = INVALID_BSON_ERROR;
exports.WRITE_CONCERN_ERROR = WRITE_CONCERN_ERROR;
exports.MULTIPLE_ERROR = MULTIPLE_ERROR;
exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
exports.INSERT = INSERT;
exports.UPDATE = UPDATE;
exports.REMOVE = REMOVE;