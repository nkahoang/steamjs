var shared = require('./shared'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , DbCommand = require('../commands/db_command'***REMOVED***.DbCommand;

var stats = function stats(options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 0***REMOVED***;
  callback = args.pop(***REMOVED***;
  // Fetch all commands
  options = args.length ? args.shift(***REMOVED*** || {} : {};

  // Build command object
  var commandObject = {
    collStats:this.collectionName,
***REMOVED***

  // Check if we have the scale value
  if(options['scale'] != null***REMOVED*** commandObject['scale'] = options['scale'];

  // Ensure we have the right read preference inheritance
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;

  // Execute the command
  this.db.command(commandObject, options, callback***REMOVED***;
}

var count = function count(query, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 0***REMOVED***;
  callback = args.pop(***REMOVED***;
  query = args.length ? args.shift(***REMOVED*** || {} : {};
  options = args.length ? args.shift(***REMOVED*** || {} : {};
  var skip = options.skip;
  var limit = options.limit;
  var maxTimeMS = options.maxTimeMS;

  // Final query
  var cmd = {
      'count': this.collectionName
    , 'query': query
    , 'fields': null
***REMOVED***;

  // Add limit and skip if defined
  if(typeof skip == 'number'***REMOVED*** cmd.skip = skip;
  if(typeof limit == 'number'***REMOVED*** cmd.limit = limit;

  // Ensure we have the right read preference inheritance
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;

  // Execute the command
  this.db.command(cmd, options, function(err, result***REMOVED*** {
    if(err***REMOVED*** return callback(err***REMOVED***;
    callback(null, result.n***REMOVED***;
***REMOVED******REMOVED***;
};

var distinct = function distinct(key, query, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
  callback = args.pop(***REMOVED***;
  query = args.length ? args.shift(***REMOVED*** || {} : {};
  options = args.length ? args.shift(***REMOVED*** || {} : {};
  var maxTimeMS = options.maxTimeMS;

  var cmd = {
      'distinct': this.collectionName
    , 'key': key
    , 'query': query
***REMOVED***;

  // Ensure we have the right read preference inheritance
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;

  // Execute the command
  this.db.command(cmd, options, function(err, result***REMOVED*** {
    if(err***REMOVED*** return callback(err***REMOVED***;
    callback(null, result.values***REMOVED***;
***REMOVED******REMOVED***;
};

var rename = function rename (newName, options, callback***REMOVED*** {
  var self = this;
  if(typeof options == 'function'***REMOVED*** {
    callback = options;
    options = {}
***REMOVED***

  // Get collection class
  var Collection = require('../collection'***REMOVED***.Collection;
  // Ensure the new name is valid
  shared.checkCollectionName(newName***REMOVED***;
  
  // Build the command
  var renameCollection = self.db.databaseName + "." + self.collectionName;
  var toCollection = self.db.databaseName + "." + newName;
  var dropTarget = typeof options.dropTarget == 'boolean' ? options.dropTarget : false;
  var cmd = {'renameCollection':renameCollection, 'to':toCollection, 'dropTarget':dropTarget};

  // Execute against admin
  self.db.admin(***REMOVED***.command(cmd, options, function(err, result***REMOVED*** {
    if(err***REMOVED*** return callback(err, null***REMOVED***;
    var doc = result.documents[0];
    // We have an error
    if(doc.errmsg***REMOVED*** return callback(utils.toError(doc***REMOVED***, null***REMOVED***;
    try {
      if(options.new_collection***REMOVED***
        return callback(null, new Collection(self.db, newName, self.db.pkFactory***REMOVED******REMOVED***;
      self.collectionName = newName;
      callback(null, self***REMOVED***;      
  ***REMOVED*** catch(err***REMOVED*** {
      return callback(utils.toError(err***REMOVED***, null***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
};

var options = function options(callback***REMOVED*** {
  this.db.collectionsInfo(this.collectionName, function (err, cursor***REMOVED*** {
    if (err***REMOVED*** return callback(err***REMOVED***;
    cursor.nextObject(function (err, document***REMOVED*** {
      callback(err, document && document.options || null***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
};

var isCapped = function isCapped(callback***REMOVED*** {
  this.options(function(err, document***REMOVED*** {
    if(err != null***REMOVED*** {
      callback(err***REMOVED***;
  ***REMOVED*** else {
      callback(null, document && document.capped***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
};

exports.stats = stats;
exports.count = count;
exports.distinct = distinct;
exports.rename = rename;
exports.options = options;
exports.isCapped = isCapped;