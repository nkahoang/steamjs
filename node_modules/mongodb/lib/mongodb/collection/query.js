var ObjectID = require('bson'***REMOVED***.ObjectID
  , Long = require('bson'***REMOVED***.Long
  , DbCommand = require('../commands/db_command'***REMOVED***.DbCommand
  , CommandCursor = require('../command_cursor'***REMOVED***.CommandCursor
  , Scope = require('../scope'***REMOVED***.Scope
  , shared = require('./shared'***REMOVED***
  , utils = require('../utils'***REMOVED***;

var testForFields = {
    limit: 1, sort: 1, fields:1, skip: 1, hint: 1, explain: 1, snapshot: 1, timeout: 1, tailable: 1, tailableRetryInterval: 1
  , numberOfRetries: 1, awaitdata: 1, exhaust: 1, batchSize: 1, returnKey: 1, maxScan: 1, min: 1, max: 1, showDiskLoc: 1
  , comment: 1, raw: 1, readPreference: 1, partial: 1, read: 1, dbName: 1, oplogReplay: 1, connection: 1
};

//
// Find method
//
var find = function find (***REMOVED*** {
  var options
    , args = Array.prototype.slice.call(arguments, 0***REMOVED***
    , has_callback = typeof args[args.length - 1] === 'function'
    , has_weird_callback = typeof args[0] === 'function'
    , callback = has_callback ? args.pop(***REMOVED*** : (has_weird_callback ? args.shift(***REMOVED*** : null***REMOVED***
    , len = args.length
    , selector = len >= 1 ? args[0] : {}
    , fields = len >= 2 ? args[1] : undefined;

  if(len === 1 && has_weird_callback***REMOVED*** {
    // backwards compat for callback?, options case
    selector = {};
    options = args[0];
***REMOVED***

  if(len === 2 && !Array.isArray(fields***REMOVED******REMOVED*** {
    var fieldKeys = Object.getOwnPropertyNames(fields***REMOVED***;
    var is_option = false;

    for(var i = 0; i < fieldKeys.length; i++***REMOVED*** {
      if(testForFields[fieldKeys[i]] != null***REMOVED*** {
        is_option = true;
        break;
    ***REMOVED***
  ***REMOVED***

    if(is_option***REMOVED*** {
      options = fields;
      fields = undefined;
  ***REMOVED*** else {
      options = {};
  ***REMOVED***
***REMOVED*** else if(len === 2 && Array.isArray(fields***REMOVED*** && !Array.isArray(fields[0]***REMOVED******REMOVED*** {
    var newFields = {};
    // Rewrite the array
    for(var i = 0; i < fields.length; i++***REMOVED*** {
      newFields[fields[i]] = 1;
  ***REMOVED***
    // Set the fields
    fields = newFields;
***REMOVED***

  if(3 === len***REMOVED*** {
    options = args[2];
***REMOVED***

  // Ensure selector is not null
  selector = selector == null ? {} : selector;
  // Validate correctness off the selector
  var object = selector;
  if(Buffer.isBuffer(object***REMOVED******REMOVED*** {
    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
    if(object_size != object.length***REMOVED***  {
      var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]"***REMOVED***;
      error.name = 'MongoError';
      throw error;
  ***REMOVED***
***REMOVED***

  // Validate correctness of the field selector
  var object = fields;
  if(Buffer.isBuffer(object***REMOVED******REMOVED*** {
    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
    if(object_size != object.length***REMOVED***  {
      var error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]"***REMOVED***;
      error.name = 'MongoError';
      throw error;
  ***REMOVED***
***REMOVED***

  // Check special case where we are using an objectId
  if(selector instanceof ObjectID || (selector != null && selector._bsontype == 'ObjectID'***REMOVED******REMOVED*** {
    selector = {_id:selector};
***REMOVED***

  // If it's a serialized fields field we need to just let it through
  // user be warned it better be good
  if(options && options.fields && !(Buffer.isBuffer(options.fields***REMOVED******REMOVED******REMOVED*** {
    fields = {};

    if(Array.isArray(options.fields***REMOVED******REMOVED*** {
      if(!options.fields.length***REMOVED*** {
        fields['_id'] = 1;
    ***REMOVED*** else {
        for (var i = 0, l = options.fields.length; i < l; i++***REMOVED*** {
          fields[options.fields[i]] = 1;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
      fields = options.fields;
  ***REMOVED***
***REMOVED***

  if (!options***REMOVED*** options = {};

  var newOptions = {};
  // Make a shallow copy of options
  for (var key in options***REMOVED*** {
    newOptions[key] = options[key];
***REMOVED***

  newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;
  newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;
  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.raw;
  newOptions.hint = options.hint != null ? shared.normalizeHintField(options.hint***REMOVED*** : this.internalHint;
  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
  // If we have overridden slaveOk otherwise use the default db setting
  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.db.slaveOk;

  // Set option
  var o = newOptions;
  // Support read/readPreference
  if(o["read"] != null***REMOVED*** o["readPreference"] = o["read"];
  // If no readPreference specified set the collection level readPreference
  o.readPreference = o.readPreference ? o.readPreference : this.readPreference;
  // If still no readPreference specified set the db level
  o.readPreference = o.readPreference ? o.readPreference : this.db.options.readPreference;
  // Set slaveok if needed
  if(o.readPreference == "secondary" || o.read == "secondaryOnly"***REMOVED*** o.slaveOk = true;

  // Set the selector
  o.selector = selector;  

  // Create precursor
  var scope = new Scope(this, {}, fields, o***REMOVED***;
  // Callback for backward compatibility
  if(callback***REMOVED*** return callback(null, scope.find(selector***REMOVED******REMOVED***;
  // Return the pre cursor object
  return scope.find(selector***REMOVED***;
};

var findOne = function findOne (***REMOVED*** {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 0***REMOVED***;
  var callback = args.pop(***REMOVED***;
  var cursor = this.find.apply(this, args***REMOVED***.limit(-1***REMOVED***.batchSize(1***REMOVED***;
  
  // Return the item
  cursor.nextObject(function(err, item***REMOVED*** {
    if(err != null***REMOVED*** return callback(utils.toError(err***REMOVED***, null***REMOVED***;
    callback(null, item***REMOVED***;
***REMOVED******REMOVED***;
};

var parallelCollectionScan = function parallelCollectionScan (options, callback***REMOVED*** {  
  var self = this;
  
  if(typeof options == 'function'***REMOVED*** {
    callback = options;
    options = {numCursors: 1};
***REMOVED***

  // Set number of cursors to 1
  options.numCursors = options.numCursors || 1;
  options.batchSize = options.batchSize || 1000;

  // Set read preference if we set one
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;
  
  // Create command object
  var commandObject = {
      parallelCollectionScan: this.collectionName
    , numCursors: options.numCursors
***REMOVED***

  // Execute the command
  this.db.command(commandObject, options, function(err, result***REMOVED*** {
    if(err***REMOVED*** return callback(err, null***REMOVED***;
    if(result == null***REMOVED*** return callback(new Error("no result returned for parallelCollectionScan"***REMOVED***, null***REMOVED***;

    var cursors = [];
    // Create command cursors for each item
    for(var i = 0; i < result.cursors.length; i++***REMOVED*** {
      var rawId = result.cursors[i].cursor.id
      // Convert cursorId to Long if needed
      var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId***REMOVED*** : rawId;

      // Command cursor options
      var commandOptions = {
          batchSize: options.batchSize
        , cursorId: cursorId
        , items: result.cursors[i].cursor.firstBatch
    ***REMOVED***

      // Add a command cursor
      cursors.push(new CommandCursor(self.db, self, {}, commandOptions***REMOVED******REMOVED***;
  ***REMOVED***

    callback(null, cursors***REMOVED***;
***REMOVED******REMOVED***;
}

exports.find = find;
exports.findOne = findOne;
exports.parallelCollectionScan = parallelCollectionScan;
