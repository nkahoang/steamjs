var shared = require('./shared'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , AggregationCursor = require('../aggregation_cursor'***REMOVED***.AggregationCursor
  , Code = require('bson'***REMOVED***.Code  
  , DbCommand = require('../commands/db_command'***REMOVED***.DbCommand;

/**
 * Functions that are passed as scope args must
 * be converted to Code instances.
 * @ignore
 */
function processScope (scope***REMOVED*** {
  if (!utils.isObject(scope***REMOVED******REMOVED*** {
    return scope;
***REMOVED***

  var keys = Object.keys(scope***REMOVED***;
  var i = keys.length;
  var key;

  while (i--***REMOVED*** {
    key = keys[i];
    if ('function' == typeof scope[key]***REMOVED*** {
      scope[key] = new Code(String(scope[key]***REMOVED******REMOVED***;
  ***REMOVED*** else {
      scope[key] = processScope(scope[key]***REMOVED***;
  ***REMOVED***
***REMOVED***

  return scope;
}

var pipe = function(***REMOVED*** {
  return new AggregationCursor(this, this.serverCapabilities***REMOVED***;
}

var mapReduce = function mapReduce (map, reduce, options, callback***REMOVED*** {
  if ('function' === typeof options***REMOVED*** callback = options, options = {};
  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers***REMOVED***
  if(null == options.out***REMOVED*** {
    throw new Error("the out option parameter must be defined, see mongodb docs for possible values"***REMOVED***;
***REMOVED***

  if ('function' === typeof map***REMOVED*** {
    map = map.toString(***REMOVED***;
***REMOVED***

  if ('function' === typeof reduce***REMOVED*** {
    reduce = reduce.toString(***REMOVED***;
***REMOVED***

  if ('function' === typeof options.finalize***REMOVED*** {
    options.finalize = options.finalize.toString(***REMOVED***;
***REMOVED***

  var mapCommandHash = {
      mapreduce: this.collectionName
    , map: map
    , reduce: reduce
***REMOVED***;

  // Add any other options passed in
  for (var name in options***REMOVED*** {
    if ('scope' == name***REMOVED*** {
      mapCommandHash[name] = processScope(options[name]***REMOVED***;
  ***REMOVED*** else {
      mapCommandHash[name] = options[name];
  ***REMOVED***
***REMOVED***

  // Set read preference if we set one
  var readPreference = shared._getReadConcern(this, options***REMOVED***;

  // If we have a read preference and inline is not set as output fail hard
  if((readPreference != false && readPreference != 'primary'***REMOVED*** 
    && options['out'] && (options['out'].inline != 1 && options['out'] != 'inline'***REMOVED******REMOVED*** {
      readPreference = 'primary';    
***REMOVED***

  // self
  var self = this;
  var cmd = DbCommand.createDbCommand(this.db, mapCommandHash***REMOVED***;

  this.db._executeQueryCommand(cmd, {readPreference:readPreference}, function (err, result***REMOVED*** {
    if(err***REMOVED*** return callback(err***REMOVED***;
    if(!result || !result.documents || result.documents.length == 0***REMOVED***
      return callback(Error("command failed to return results"***REMOVED***, null***REMOVED***

    // Check if we have an error
    if(1 != result.documents[0].ok || result.documents[0].err || result.documents[0].errmsg***REMOVED*** {
      return callback(utils.toError(result.documents[0]***REMOVED******REMOVED***;
  ***REMOVED***

    // Create statistics value
    var stats = {};
    if(result.documents[0].timeMillis***REMOVED*** stats['processtime'] = result.documents[0].timeMillis;
    if(result.documents[0].counts***REMOVED*** stats['counts'] = result.documents[0].counts;
    if(result.documents[0].timing***REMOVED*** stats['timing'] = result.documents[0].timing;

    // invoked with inline?
    if(result.documents[0].results***REMOVED*** {
      // If we wish for no verbosity
      if(options['verbose'] == null || !options['verbose']***REMOVED*** {
        return callback(null, result.documents[0].results***REMOVED***;
    ***REMOVED***
      return callback(null, result.documents[0].results, stats***REMOVED***;
  ***REMOVED***

    // The returned collection
    var collection = null;

    // If we have an object it's a different db
    if(result.documents[0].result != null && typeof result.documents[0].result == 'object'***REMOVED*** {
      var doc = result.documents[0].result;
      collection = self.db.db(doc.db***REMOVED***.collection(doc.collection***REMOVED***;
  ***REMOVED*** else {
      // Create a collection object that wraps the result collection
      collection = self.db.collection(result.documents[0].result***REMOVED***
  ***REMOVED***

    // If we wish for no verbosity
    if(options['verbose'] == null || !options['verbose']***REMOVED*** {
      return callback(err, collection***REMOVED***;
  ***REMOVED***

    // Return stats as third set of values
    callback(err, collection, stats***REMOVED***;
***REMOVED******REMOVED***;
};

/**
 * Group function helper
 * @ignore
 */
var groupFunction = function (***REMOVED*** {
  var c = db[ns].find(condition***REMOVED***;
  var map = new Map(***REMOVED***;
  var reduce_function = reduce;

  while (c.hasNext(***REMOVED******REMOVED*** {
    var obj = c.next(***REMOVED***;
    var key = {};

    for (var i = 0, len = keys.length; i < len; ++i***REMOVED*** {
      var k = keys[i];
      key[k] = obj[k];
  ***REMOVED***

    var aggObj = map.get(key***REMOVED***;

    if (aggObj == null***REMOVED*** {
      var newObj = Object.extend({}, key***REMOVED***;
      aggObj = Object.extend(newObj, initial***REMOVED***;
      map.put(key, aggObj***REMOVED***;
  ***REMOVED***

    reduce_function(obj, aggObj***REMOVED***;
***REMOVED***

  return { "result": map.values(***REMOVED*** };
}.toString(***REMOVED***;

var group = function group(keys, condition, initial, reduce, finalize, command, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 3***REMOVED***;
  callback = args.pop(***REMOVED***;
  // Fetch all commands
  reduce = args.length ? args.shift(***REMOVED*** : null;
  finalize = args.length ? args.shift(***REMOVED*** : null;
  command = args.length ? args.shift(***REMOVED*** : null;
  options = args.length ? args.shift(***REMOVED*** || {} : {};

  // Make sure we are backward compatible
  if(!(typeof finalize == 'function'***REMOVED******REMOVED*** {
    command = finalize;
    finalize = null;
***REMOVED***

  if (!Array.isArray(keys***REMOVED*** && keys instanceof Object && typeof(keys***REMOVED*** !== 'function' && !(keys instanceof Code***REMOVED******REMOVED*** {
    keys = Object.keys(keys***REMOVED***;
***REMOVED***

  if(typeof reduce === 'function'***REMOVED*** {
    reduce = reduce.toString(***REMOVED***;
***REMOVED***

  if(typeof finalize === 'function'***REMOVED*** {
    finalize = finalize.toString(***REMOVED***;
***REMOVED***

  // Set up the command as default
  command = command == null ? true : command;

  // Execute using the command
  if(command***REMOVED*** {
    var reduceFunction = reduce instanceof Code
        ? reduce
        : new Code(reduce***REMOVED***;

    var selector = {
      group: {
          'ns': this.collectionName
        , '$reduce': reduceFunction
        , 'cond': condition
        , 'initial': initial
        , 'out': "inline"
    ***REMOVED***
  ***REMOVED***;

    // if finalize is defined
    if(finalize != null***REMOVED*** selector.group['finalize'] = finalize;
    // Set up group selector
    if ('function' === typeof keys || keys instanceof Code***REMOVED*** {
      selector.group.$keyf = keys instanceof Code
        ? keys
        : new Code(keys***REMOVED***;
  ***REMOVED*** else {
      var hash = {};
      keys.forEach(function (key***REMOVED*** {
        hash[key] = 1;
    ***REMOVED******REMOVED***;
      selector.group.key = hash;
  ***REMOVED***

    // Set read preference if we set one
    var readPreference = shared._getReadConcern(this, options***REMOVED***;
    // Execute command
    this.db.command(selector, {readPreference: readPreference}, function(err, result***REMOVED*** {
      if(err***REMOVED*** return callback(err, null***REMOVED***;
      callback(null, result.retval***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED*** else {
    // Create execution scope
    var scope = reduce != null && reduce instanceof Code
      ? reduce.scope
      : {};

    scope.ns = this.collectionName;
    scope.keys = keys;
    scope.condition = condition;
    scope.initial = initial;

    // Pass in the function text to execute within mongodb.
    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString(***REMOVED*** + ';'***REMOVED***;

    this.db.eval(new Code(groupfn, scope***REMOVED***, function (err, results***REMOVED*** {
      if (err***REMOVED*** return callback(err, null***REMOVED***;
      callback(null, results.result || results***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
};

var aggregate = function(pipeline, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 0***REMOVED***;
  callback = args.pop(***REMOVED***;
  var self = this;

  // If we have any of the supported options in the options object
  var opts = args[args.length - 1];
  options = opts.readPreference 
    || opts.explain 
    || opts.cursor 
    || opts.out
    || opts.allowDiskUse ? args.pop(***REMOVED*** : {}
  // If the callback is the option (as for cursor override it***REMOVED***
  if(typeof callback == 'object' && callback != null***REMOVED*** options = callback;

  // Convert operations to an array
  if(!Array.isArray(args[0]***REMOVED******REMOVED*** {
    pipeline = [];
    // Push all the operations to the pipeline
    for(var i = 0; i < args.length; i++***REMOVED*** pipeline.push(args[i]***REMOVED***;
***REMOVED***

  // Is the user requesting a cursor
  if(options.cursor != null && options.out == null***REMOVED*** {
    // Set the aggregation cursor options
    var agg_cursor_options = options.cursor;
    agg_cursor_options.pipe = pipeline;
    agg_cursor_options.allowDiskUse = options.allowDiskUse == null ? false : options.allowDiskUse;
    // Return the aggregation cursor
    return new AggregationCursor(this, this.serverCapabilities, agg_cursor_options***REMOVED***;
***REMOVED***

  // If out was specified
  if(typeof options.out == 'string'***REMOVED*** {
    pipeline.push({$out: options.out}***REMOVED***;
***REMOVED***

  // Build the command
  var command = { aggregate : this.collectionName, pipeline : pipeline};
  // If we have allowDiskUse defined
  if(options.allowDiskUse***REMOVED*** command.allowDiskUse = options.allowDiskUse;

  // Ensure we have the right read preference inheritance
  options.readPreference = shared._getReadConcern(this, options***REMOVED***;
  // If explain has been specified add it
  if(options.explain***REMOVED*** command.explain = options.explain;
  // Execute the command
  this.db.command(command, options, function(err, result***REMOVED*** {
    if(err***REMOVED*** {
      callback(err***REMOVED***;
  ***REMOVED*** else if(result['err'] || result['errmsg']***REMOVED*** {
      callback(utils.toError(result***REMOVED******REMOVED***;
  ***REMOVED*** else if(typeof result == 'object' && result['serverPipeline']***REMOVED*** {
      callback(null, result['serverPipeline']***REMOVED***;
  ***REMOVED*** else if(typeof result == 'object' && result['stages']***REMOVED*** {
      callback(null, result['stages']***REMOVED***;
  ***REMOVED*** else {
      callback(null, result.result***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
}

exports.mapReduce = mapReduce;
exports.group = group;
exports.aggregate = aggregate;
exports.pipe = pipe;