var InsertCommand = require('../commands/insert_command'***REMOVED***.InsertCommand
  , DeleteCommand = require('../commands/delete_command'***REMOVED***.DeleteCommand
  , UpdateCommand = require('../commands/update_command'***REMOVED***.UpdateCommand
  , DbCommand = require('../commands/db_command'***REMOVED***.DbCommand
  , utils = require('../utils'***REMOVED***
  , hasWriteCommands = require('../utils'***REMOVED***.hasWriteCommands
  , shared = require('./shared'***REMOVED***;

/**
 * Precompiled regexes
 * @ignore
 **/
var eErrorMessages = /No matching object found/;

// ***************************************************
// Insert function
// ***************************************************
var insert = function insert (docs, options, callback***REMOVED*** {
  if ('function' === typeof options***REMOVED*** callback = options, options = {};
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;

  // Get a connection
  var connection = this.db.serverConfig.checkoutWriter(***REMOVED***;
  var useLegacyOps = options.useLegacyOps == null || options.useLegacyOps == false ? false : true;
  // If we support write commands let's perform the insert using it  
  if(!useLegacyOps && hasWriteCommands(connection***REMOVED*** 
    && !Buffer.isBuffer(docs***REMOVED*** 
    && !(Array.isArray(docs***REMOVED*** && docs.length > 0 && Buffer.isBuffer(docs[0]***REMOVED******REMOVED******REMOVED*** {
      insertWithWriteCommands(this, Array.isArray(docs***REMOVED*** ? docs : [docs], options, callback***REMOVED***;
      return this
***REMOVED*** 

  // Backwards compatibility
  insertAll(this, Array.isArray(docs***REMOVED*** ? docs : [docs], options, callback***REMOVED***;
  return this;
};

//
// Uses the new write commands available from 2.6 >
//
var insertWithWriteCommands = function(self, docs, options, callback***REMOVED*** {
  // Get the intended namespace for the operation
  var namespace = self.collectionName;

  // Ensure we have no \x00 bytes in the name causing wrong parsing
  if(!!~namespace.indexOf("\x00"***REMOVED******REMOVED*** {
    return callback(new Error("namespace cannot contain a null character"***REMOVED***, null***REMOVED***;
***REMOVED***

  // Check if we have passed in continue on error
  var continueOnError = typeof options['keepGoing'] == 'boolean' 
    ? options['keepGoing'] : false;
  continueOnError = typeof options['continueOnError'] == 'boolean' 
    ? options['continueOnError'] : continueOnError;

  // Do we serialzie functions
  var serializeFunctions = typeof options.serializeFunctions != 'boolean' 
    ? self.serializeFunctions : options.serializeFunctions;

  // Checkout a write connection
  var connection = self.db.serverConfig.checkoutWriter(***REMOVED***;  

  // Collect errorOptions
  var errorOptions = shared._getWriteConcern(self, options***REMOVED***;

  // If we have a write command with no callback and w:0 fail
  if(errorOptions.w && errorOptions.w != 0 && callback == null***REMOVED*** {
    throw new Error("writeConcern requires callback"***REMOVED***
***REMOVED***

  // Add the documents and decorate them with id's if they have none
  for(var index = 0, len = docs.length; index < len; ++index***REMOVED*** {
    var doc = docs[index];

    // Add id to each document if it's not already defined
    if (!(Buffer.isBuffer(doc***REMOVED******REMOVED***
      && doc['_id'] == null
      && self.db.forceServerObjectId != true
      && options.forceServerObjectId != true***REMOVED*** {
        doc['_id'] = self.pkFactory.createPk(***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Single document write
  if(docs.length == 1***REMOVED*** {
    // Create the write command
    var write_command = {
        insert: namespace
      , writeConcern: errorOptions
      , ordered: !continueOnError
      , documents: docs
  ***REMOVED***

    // Execute the write command
    return self.db.command(write_command
      , { connection:connection
        , checkKeys: typeof options.checkKeys == 'boolean' ? options.checkKeys : true
        , serializeFunctions: serializeFunctions
        , writeCommand: true }
      , function(err, result***REMOVED*** {  
        if(errorOptions.w == 0 && typeof callback == 'function'***REMOVED*** return callback(null, null***REMOVED***;
        if(errorOptions.w == 0***REMOVED*** return;
        if(callback == null***REMOVED*** return;
        if(err != null***REMOVED*** {
          return callback(err, null***REMOVED***;
      ***REMOVED***

        // Result has an error
        if(!result.ok || Array.isArray(result.writeErrors***REMOVED*** && result.writeErrors.length > 0***REMOVED*** {
          var error = utils.toError(result.writeErrors[0].errmsg***REMOVED***;
          error.code = result.writeErrors[0].code;
          error.err = result.writeErrors[0].errmsg;
          // Return the error
          return callback(error, null***REMOVED***;
      ***REMOVED***

        // Return the results for a whole batch
        callback(null, docs***REMOVED***
  ***REMOVED******REMOVED***;    
***REMOVED*** else {
    try {
      // Multiple document write (use bulk***REMOVED***
      var bulk = !continueOnError ? self.initializeOrderedBulkOp(***REMOVED*** : self.initializeUnorderedBulkOp(***REMOVED***;
      // Add all the documents
      for(var i = 0; i < docs.length;i++***REMOVED*** {
        bulk.insert(docs[i]***REMOVED***;
    ***REMOVED***

      // Execute the command
      bulk.execute(errorOptions, function(err, result***REMOVED*** {
        if(errorOptions.w == 0 && typeof callback == 'function'***REMOVED*** return callback(null, null***REMOVED***;
        if(errorOptions.w == 0***REMOVED*** return;
        if(callback == null***REMOVED*** return;
        if(err***REMOVED*** return callback(err, null***REMOVED***;
        if(result.hasWriteErrors(***REMOVED******REMOVED*** {
          var error = result.getWriteErrors(***REMOVED***[0];
          error.code = result.getWriteErrors(***REMOVED***[0].code;
          error.err = result.getWriteErrors(***REMOVED***[0].errmsg;        
          // Return the error
          return callback(error, null***REMOVED***;
      ***REMOVED***

        // Return the results for a whole batch
        callback(null, docs***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED*** catch(err***REMOVED*** {
      callback(utils.toError(err***REMOVED***, null***REMOVED***;
  ***REMOVED***
***REMOVED***
}

//
// Uses pre 2.6 OP_INSERT wire protocol
//
var insertAll = function insertAll (self, docs, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = {};
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;

  // Insert options (flags for insert***REMOVED***
  var insertFlags = {};
  // If we have a mongodb version >= 1.9.1 support keepGoing attribute
  if(options['keepGoing'] != null***REMOVED*** {
    insertFlags['keepGoing'] = options['keepGoing'];
***REMOVED***

  // If we have a mongodb version >= 1.9.1 support keepGoing attribute
  if(options['continueOnError'] != null***REMOVED*** {
    insertFlags['continueOnError'] = options['continueOnError'];
***REMOVED***

  // DbName
  var dbName = options['dbName'];
  // If no dbname defined use the db one
  if(dbName == null***REMOVED*** {
    dbName = self.db.databaseName;
***REMOVED***

  // Either use override on the function, or go back to default on either the collection
  // level or db
  if(options['serializeFunctions'] != null***REMOVED*** {
    insertFlags['serializeFunctions'] = options['serializeFunctions'];
***REMOVED*** else {
    insertFlags['serializeFunctions'] = self.serializeFunctions;
***REMOVED***

  // Get checkKeys value
  var checkKeys = typeof options.checkKeys != 'boolean' ? true : options.checkKeys;

  // Pass in options
  var insertCommand = new InsertCommand(
      self.db
    , dbName + "." + self.collectionName, checkKeys, insertFlags***REMOVED***;

  // Add the documents and decorate them with id's if they have none
  for(var index = 0, len = docs.length; index < len; ++index***REMOVED*** {
    var doc = docs[index];

    // Add id to each document if it's not already defined
    if (!(Buffer.isBuffer(doc***REMOVED******REMOVED***
      && doc['_id'] == null
      && self.db.forceServerObjectId != true
      && options.forceServerObjectId != true***REMOVED*** {
        doc['_id'] = self.pkFactory.createPk(***REMOVED***;
  ***REMOVED***

    insertCommand.add(doc***REMOVED***;
***REMOVED***

  // Collect errorOptions
  var errorOptions = shared._getWriteConcern(self, options***REMOVED***;
  // Default command options
  var commandOptions = {};
  // If safe is defined check for error message
  if(shared._hasWriteConcern(errorOptions***REMOVED*** && typeof callback == 'function'***REMOVED*** {
    // Set safe option
    commandOptions['safe'] = errorOptions;
    // If we have an error option
    if(typeof errorOptions == 'object'***REMOVED*** {
      var keys = Object.keys(errorOptions***REMOVED***;
      for(var i = 0; i < keys.length; i++***REMOVED*** {
        commandOptions[keys[i]] = errorOptions[keys[i]];
    ***REMOVED***
  ***REMOVED***

    // If we have a passed in connection use it
    if(options.connection***REMOVED*** {
      commandOptions.connection = options.connection;
  ***REMOVED***

    // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection***REMOVED***
    self.db._executeInsertCommand(insertCommand, commandOptions, handleWriteResults(function (err, error***REMOVED*** {
      if(err***REMOVED*** return callback(err, null***REMOVED***;
      callback(null, docs***REMOVED***;
  ***REMOVED******REMOVED******REMOVED***;
***REMOVED*** else if(shared._hasWriteConcern(errorOptions***REMOVED*** && callback == null***REMOVED*** {
    throw new Error("Cannot use a writeConcern without a provided callback"***REMOVED***;
***REMOVED*** else {
    // Execute the call without a write concern
    var result = self.db._executeInsertCommand(insertCommand, commandOptions***REMOVED***;
    // If no callback just return
    if(!callback***REMOVED*** return;
    // If error return error
    if(result instanceof Error***REMOVED*** {
      return callback(result***REMOVED***;
  ***REMOVED***

    // Otherwise just return
    return callback(null, docs***REMOVED***;
***REMOVED***
};

// ***************************************************
// Remove function
// ***************************************************
var removeWithWriteCommands = function(self, selector, options, callback***REMOVED*** {
  if('function' === typeof selector***REMOVED*** {
    callback = selector;
    selector = options = {};
***REMOVED*** else if ('function' === typeof options***REMOVED*** {
    callback = options;
    options = {};
***REMOVED***

  // Get the intended namespace for the operation
  var namespace = self.collectionName;

  // Ensure we have no \x00 bytes in the name causing wrong parsing
  if(!!~namespace.indexOf("\x00"***REMOVED******REMOVED*** {
    return callback(new Error("namespace cannot contain a null character"***REMOVED***, null***REMOVED***;
***REMOVED***

  // Set default empty selector if none
  selector = selector == null ? {} : selector;

  // Check if we have passed in continue on error
  var continueOnError = typeof options['keepGoing'] == 'boolean' 
    ? options['keepGoing'] : false;
  continueOnError = typeof options['continueOnError'] == 'boolean' 
    ? options['continueOnError'] : continueOnError;

  // Do we serialzie functions
  var serializeFunctions = typeof options.serializeFunctions != 'boolean' 
    ? self.serializeFunctions : options.serializeFunctions;

  // Checkout a write connection
  var connection = self.db.serverConfig.checkoutWriter(***REMOVED***;  

  // Figure out the value of top
  var limit = options.single == true ? 1 : 0;
  var upsert = typeof options.upsert == 'boolean' ? options.upsert : false;

  // Collect errorOptions
  var errorOptions = shared._getWriteConcern(self, options***REMOVED***;

  // If we have a write command with no callback and w:0 fail
  if(errorOptions.w && errorOptions.w != 0 && callback == null***REMOVED*** {
    throw new Error("writeConcern requires callback"***REMOVED***
***REMOVED***

  // Create the write command
  var write_command = {
    delete: namespace,
    writeConcern: errorOptions,
    ordered: !continueOnError,
    deletes: [{
      q : selector,
      limit: limit
  ***REMOVED***]
***REMOVED***

  // Execute the write command
  self.db.command(write_command
    , { connection:connection
      , checkKeys: false
      , serializeFunctions: serializeFunctions
      , writeCommand: true }
    , function(err, result***REMOVED*** {  
      if(errorOptions.w == 0 && typeof callback == 'function'***REMOVED*** return callback(null, null***REMOVED***;
      if(errorOptions.w == 0***REMOVED*** return;
      if(callback == null***REMOVED*** return;
      if(err != null***REMOVED*** {
        return callback(err, null***REMOVED***;
    ***REMOVED***

      // Result has an error
      if(!result.ok || Array.isArray(result.writeErrors***REMOVED*** && result.writeErrors.length > 0***REMOVED*** {
        var error = utils.toError(result.writeErrors[0].errmsg***REMOVED***;
        error.code = result.writeErrors[0].code;
        error.err = result.writeErrors[0].errmsg;
        // Return the error
        return callback(error, null***REMOVED***;
    ***REMOVED***
      
      // Backward compatibility format
      var r = backWardsCompatibiltyResults(result, 'remove'***REMOVED***;      
      // Return the results for a whole batch
      callback(null, r.n, r***REMOVED***
***REMOVED******REMOVED***;
}

var remove = function remove(selector, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = null;
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;

  // Get a connection
  var connection = this.db.serverConfig.checkoutWriter(***REMOVED***;
  var useLegacyOps = options.useLegacyOps == null || options.useLegacyOps == false ? false : true;

  // If we support write commands let's perform the insert using it  
  if(!useLegacyOps && hasWriteCommands(connection***REMOVED*** && !Buffer.isBuffer(selector***REMOVED******REMOVED*** {
    return removeWithWriteCommands(this, selector, options, callback***REMOVED***;
***REMOVED***

  if ('function' === typeof selector***REMOVED*** {
    callback = selector;
    selector = options = {};
***REMOVED*** else if ('function' === typeof options***REMOVED*** {
    callback = options;
    options = {};
***REMOVED***

  // Ensure options
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;
  // Ensure we have at least an empty selector
  selector = selector == null ? {} : selector;
  // Set up flags for the command, if we have a single document remove
  var flags = 0 | (options.single ? 1 : 0***REMOVED***;

  // DbName
  var dbName = options['dbName'];
  // If no dbname defined use the db one
  if(dbName == null***REMOVED*** {
    dbName = this.db.databaseName;
***REMOVED***

  // Create a delete command
  var deleteCommand = new DeleteCommand(
      this.db
    , dbName + "." + this.collectionName
    , selector
    , flags***REMOVED***;

  var self = this;
  var errorOptions = shared._getWriteConcern(self, options***REMOVED***;

  // Execute the command, do not add a callback as it's async
  if(shared._hasWriteConcern(errorOptions***REMOVED*** && typeof callback == 'function'***REMOVED*** {
    // Insert options
    var commandOptions = {};
    // Set safe option
    commandOptions['safe'] = true;
    // If we have an error option
    if(typeof errorOptions == 'object'***REMOVED*** {
      var keys = Object.keys(errorOptions***REMOVED***;
      for(var i = 0; i < keys.length; i++***REMOVED*** {
        commandOptions[keys[i]] = errorOptions[keys[i]];
    ***REMOVED***
  ***REMOVED***

    // If we have a passed in connection use it
    if(options.connection***REMOVED*** {
      commandOptions.connection = options.connection;
  ***REMOVED***

    // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection***REMOVED***
    this.db._executeRemoveCommand(deleteCommand, commandOptions, handleWriteResults(function (err, error***REMOVED*** {
      if(err***REMOVED*** return callback(err, null***REMOVED***;
      callback(null, error[0].n***REMOVED***;
  ***REMOVED******REMOVED******REMOVED***;
***REMOVED*** else if(shared._hasWriteConcern(errorOptions***REMOVED*** && callback == null***REMOVED*** {
    throw new Error("Cannot use a writeConcern without a provided callback"***REMOVED***;
***REMOVED*** else {
    var result = this.db._executeRemoveCommand(deleteCommand***REMOVED***;
    // If no callback just return
    if (!callback***REMOVED*** return;
    // If error return error
    if (result instanceof Error***REMOVED*** {
      return callback(result***REMOVED***;
  ***REMOVED***
    // Otherwise just return
    return callback(***REMOVED***;
***REMOVED***
};

// ***************************************************
// Save function
// ***************************************************
var save = function save(doc, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = null;
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;
  // Throw an error if attempting to perform a bulk operation
  if(Array.isArray(doc***REMOVED******REMOVED*** throw new Error("doc parameter must be a single document"***REMOVED***;
  // Extract the id, if we have one we need to do a update command
  var id = doc['_id'];
  var commandOptions = shared._getWriteConcern(this, options***REMOVED***;
  if(options.connection***REMOVED*** commandOptions.connection = options.connection;

  if(id != null***REMOVED*** {
    commandOptions.upsert = true;
    this.update({ _id: id }, doc, commandOptions, callback***REMOVED***;
***REMOVED*** else {
    this.insert(doc, commandOptions, callback && function (err, docs***REMOVED*** {
      if(err***REMOVED*** return callback(err, null***REMOVED***;

      if(Array.isArray(docs***REMOVED******REMOVED*** {
        callback(err, docs[0]***REMOVED***;
    ***REMOVED*** else {
        callback(err, docs***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***
};

// ***************************************************
// Update document function
// ***************************************************
var updateWithWriteCommands = function(self, selector, document, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = null;
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;

  // Get the intended namespace for the operation
  var namespace = self.collectionName;

  // Ensure we have no \x00 bytes in the name causing wrong parsing
  if(!!~namespace.indexOf("\x00"***REMOVED******REMOVED*** {
    return callback(new Error("namespace cannot contain a null character"***REMOVED***, null***REMOVED***;
***REMOVED***

  // If we are not providing a selector or document throw
  if(selector == null || typeof selector != 'object'***REMOVED*** 
    return callback(new Error("selector must be a valid JavaScript object"***REMOVED******REMOVED***;
  if(document == null || typeof document != 'object'***REMOVED*** 
    return callback(new Error("document must be a valid JavaScript object"***REMOVED******REMOVED***;    

  // Check if we have passed in continue on error
  var continueOnError = typeof options['keepGoing'] == 'boolean' 
    ? options['keepGoing'] : false;
  continueOnError = typeof options['continueOnError'] == 'boolean' 
    ? options['continueOnError'] : continueOnError;

  // Do we serialzie functions
  var serializeFunctions = typeof options.serializeFunctions != 'boolean' 
    ? self.serializeFunctions : options.serializeFunctions;

  // Checkout a write connection
  var connection = self.db.serverConfig.checkoutWriter(***REMOVED***;  

  // Figure out the value of top
  var multi = typeof options.multi == 'boolean' ? options.multi : false;
  var upsert = typeof options.upsert == 'boolean' ? options.upsert : false;

  // Collect errorOptions
  var errorOptions = shared._getWriteConcern(self, options***REMOVED***;

  // If we have a write command with no callback and w:0 fail
  if(errorOptions.w && errorOptions.w != 0 && callback == null***REMOVED*** {
    throw new Error("writeConcern requires callback"***REMOVED***
***REMOVED***

  // Create the write command
  var write_command = {
    update: namespace,
    writeConcern: errorOptions,
    ordered: !continueOnError,
    updates: [{
      q : selector,
      u: document,
      multi: multi,
      upsert: upsert
  ***REMOVED***]
***REMOVED***

  // Check if we have a checkKeys override
  var checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;

  // Execute the write command
  self.db.command(write_command
    , { connection:connection
      , checkKeys: checkKeys
      , serializeFunctions: serializeFunctions
      , writeCommand: true }
    , function(err, result***REMOVED*** { 
      if(errorOptions.w == 0 && typeof callback == 'function'***REMOVED*** return callback(null, null***REMOVED***;
      if(errorOptions.w == 0***REMOVED*** return;
      if(callback == null***REMOVED*** return;

      if(errorOptions.w == 0 && typeof callback == 'function'***REMOVED*** return callback(null, null***REMOVED***;
      if(errorOptions.w == 0***REMOVED*** return;
      if(callback == null***REMOVED*** return;
      if(err != null***REMOVED*** {
        return callback(err, null***REMOVED***;
    ***REMOVED***

      // Result has an error
      if(!result.ok || Array.isArray(result.writeErrors***REMOVED*** && result.writeErrors.length > 0***REMOVED*** {
        var error = utils.toError(result.writeErrors[0].errmsg***REMOVED***;
        error.code = result.writeErrors[0].code;
        error.err = result.writeErrors[0].errmsg;        
        return callback(error, null***REMOVED***;
    ***REMOVED***
      
      // Backward compatibility format
      var r = backWardsCompatibiltyResults(result, 'update'***REMOVED***;
      // Return the results for a whole batch
      callback(null, r.n, r***REMOVED***
***REMOVED******REMOVED***;
}

var backWardsCompatibiltyResults = function(result, op***REMOVED*** {
  // Upserted
  var upsertedValue = null;
  var finalResult = null;
  var updatedExisting = true;

  // We have a single document upserted result
  if(Array.isArray(result.upserted***REMOVED*** || result.upserted != null***REMOVED*** {
    updatedExisting = false;
    upsertedValue = result.upserted;
***REMOVED***

  // Final result
  if(op == 'remove' || op == 'insert'***REMOVED*** {
    finalResult = {ok: true, n: result.n}
***REMOVED*** else {
    finalResult = {ok: true, n: result.n, updatedExisting: updatedExisting}
***REMOVED***

  if(upsertedValue != null***REMOVED*** finalResult.upserted = upsertedValue;
  return finalResult;
}

var handleWriteResults = function handleWriteResults(callback***REMOVED*** {
  return function(err, error***REMOVED*** {
    documents = error && error.documents;
    if(!callback***REMOVED*** return;
    // We have an error
    if(err***REMOVED*** return callback(err, null***REMOVED***;
    // If no document something is terribly wrong
    if(error == null***REMOVED*** return callback(utils.toError("MongoDB did not return a response"***REMOVED******REMOVED***;
    // Handle the case where no result was returned
    if(error != null && documents == null***REMOVED*** {
      if(typeof error.err == 'string'***REMOVED*** {
        return callback(utils.toError(error.err***REMOVED******REMOVED***;  
    ***REMOVED*** else if(typeof error.errmsg == 'string'***REMOVED*** {
        return callback(utils.toError(error.errmsg***REMOVED******REMOVED***;          
    ***REMOVED*** else {
        return callback(utils.toError("Unknown MongoDB error"***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***

    // Handler normal cases
    if(documents[0].err || documents[0].errmsg***REMOVED*** {
      callback(utils.toError(documents[0]***REMOVED******REMOVED***;
  ***REMOVED*** else if(documents[0].jnote || documents[0].wtimeout***REMOVED*** {
      callback(utils.toError(documents[0]***REMOVED******REMOVED***;
  ***REMOVED*** else {
      callback(err, documents***REMOVED***;
  ***REMOVED***
***REMOVED***
}

var update = function update(selector, document, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = null;
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;

  // Get a connection
  var connection = options.connection || this.db.serverConfig.checkoutWriter(***REMOVED***;
  var useLegacyOps = options.useLegacyOps == null || options.useLegacyOps == false ? false : true;
  // If we support write commands let's perform the insert using it  
  if(!useLegacyOps && hasWriteCommands(connection***REMOVED*** && !Buffer.isBuffer(selector***REMOVED*** && !Buffer.isBuffer(document***REMOVED******REMOVED*** {
    return updateWithWriteCommands(this, selector, document, options, callback***REMOVED***;
***REMOVED***

  // DbName
  var dbName = options['dbName'];
  // If no dbname defined use the db one
  if(dbName == null***REMOVED*** {
    dbName = this.db.databaseName;
***REMOVED***

  // If we are not providing a selector or document throw
  if(selector == null || typeof selector != 'object'***REMOVED*** return callback(new Error("selector must be a valid JavaScript object"***REMOVED******REMOVED***;
  if(document == null || typeof document != 'object'***REMOVED*** return callback(new Error("document must be a valid JavaScript object"***REMOVED******REMOVED***;

  // Either use override on the function, or go back to default on either the collection
  // level or db
  if(options['serializeFunctions'] != null***REMOVED*** {
    options['serializeFunctions'] = options['serializeFunctions'];
***REMOVED*** else {
    options['serializeFunctions'] = this.serializeFunctions;
***REMOVED***

  // Build the options command
  var updateCommand = new UpdateCommand(
      this.db
    , dbName + "." + this.collectionName
    , selector
    , document
    , options***REMOVED***;

  var self = this;
  // Unpack the error options if any
  var errorOptions = shared._getWriteConcern(this, options***REMOVED***;
  // If safe is defined check for error message
  if(shared._hasWriteConcern(errorOptions***REMOVED*** && typeof callback == 'function'***REMOVED*** {
    // Insert options
    var commandOptions = {};
    // Set safe option
    commandOptions['safe'] = errorOptions;
    // If we have an error option
    if(typeof errorOptions == 'object'***REMOVED*** {
      var keys = Object.keys(errorOptions***REMOVED***;
      for(var i = 0; i < keys.length; i++***REMOVED*** {
        commandOptions[keys[i]] = errorOptions[keys[i]];
    ***REMOVED***
  ***REMOVED***

    // If we have a passed in connection use it
    if(options.connection***REMOVED*** {
      commandOptions.connection = options.connection;
  ***REMOVED***

    // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection***REMOVED***
    this.db._executeUpdateCommand(updateCommand, commandOptions, handleWriteResults(function(err, error***REMOVED*** {
      if(err***REMOVED*** return callback(err, null***REMOVED***;
      callback(null, error[0].n, error[0]***REMOVED***;
  ***REMOVED******REMOVED******REMOVED***;
***REMOVED*** else if(shared._hasWriteConcern(errorOptions***REMOVED*** && callback == null***REMOVED*** {
    throw new Error("Cannot use a writeConcern without a provided callback"***REMOVED***;
***REMOVED*** else {
    // Execute update
    var result = this.db._executeUpdateCommand(updateCommand***REMOVED***;
    // If no callback just return
    if (!callback***REMOVED*** return;
    // If error return error
    if (result instanceof Error***REMOVED*** {
      return callback(result***REMOVED***;
  ***REMOVED***
    
    // Otherwise just return
    return callback(***REMOVED***;
***REMOVED***
};

// ***************************************************
// findAndModify function
// ***************************************************
var findAndModify = function findAndModify (query, sort, doc, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
  callback = args.pop(***REMOVED***;
  sort = args.length ? args.shift(***REMOVED*** || [] : [];
  doc = args.length ? args.shift(***REMOVED*** : null;
  options = args.length ? args.shift(***REMOVED*** || {} : {};
  var self = this;

  var queryObject = {
      'findandmodify': this.collectionName
    , 'query': query
    , 'sort': utils.formattedOrderClause(sort***REMOVED***
***REMOVED***;

  queryObject.new = options.new ? 1 : 0;
  queryObject.remove = options.remove ? 1 : 0;
  queryObject.upsert = options.upsert ? 1 : 0;

  if (options.fields***REMOVED*** {
    queryObject.fields = options.fields;
***REMOVED***

  if (doc && !options.remove***REMOVED*** {
    queryObject.update = doc;
***REMOVED***

  // Checkout a write connection
  options.connection = self.db.serverConfig.checkoutWriter(***REMOVED***;  

  // Either use override on the function, or go back to default on either the collection
  // level or db
  if(options['serializeFunctions'] != null***REMOVED*** {
    options['serializeFunctions'] = options['serializeFunctions'];
***REMOVED*** else {
    options['serializeFunctions'] = this.serializeFunctions;
***REMOVED***

  // No check on the documents
  options.checkKeys = false

  // Execute the command
  this.db.command(queryObject
    , options, function(err, result***REMOVED*** {
      if(err***REMOVED*** return callback(err, null***REMOVED***;
      return callback(null, result.value, result***REMOVED***;
***REMOVED******REMOVED***;
}

// ***************************************************
// findAndRemove function
// ***************************************************
var findAndRemove = function(query, sort, options, callback***REMOVED*** {
  var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
  callback = args.pop(***REMOVED***;
  sort = args.length ? args.shift(***REMOVED*** || [] : [];
  options = args.length ? args.shift(***REMOVED*** || {} : {};
  // Add the remove option
  options['remove'] = true;
  // Execute the callback
  this.findAndModify(query, sort, null, options, callback***REMOVED***;
}

// Map methods
exports.insert = insert;
exports.remove = remove;
exports.save = save;
exports.update = update;
exports.findAndModify = findAndModify;
exports.findAndRemove = findAndRemove;