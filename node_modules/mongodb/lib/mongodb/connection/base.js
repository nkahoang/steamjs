var EventEmitter = require('events'***REMOVED***.EventEmitter
  , inherits = require('util'***REMOVED***.inherits
  , utils = require('../utils'***REMOVED***
  , mongodb_cr_authenticate = require('../auth/mongodb_cr.js'***REMOVED***.authenticate
  , mongodb_gssapi_authenticate = require('../auth/mongodb_gssapi.js'***REMOVED***.authenticate
  , mongodb_sspi_authenticate = require('../auth/mongodb_sspi.js'***REMOVED***.authenticate
  , mongodb_plain_authenticate = require('../auth/mongodb_plain.js'***REMOVED***.authenticate
  , mongodb_x509_authenticate = require('../auth/mongodb_x509.js'***REMOVED***.authenticate;

var id = 0;

/**
 * Internal class for callback storage
 * @ignore
 */
var CallbackStore = function(***REMOVED*** {
  // Make class an event emitter
  EventEmitter.call(this***REMOVED***;
  // Add a info about call variable
  this._notReplied = {};
  this.id = id++;
}

/**
 * @ignore
 */
inherits(CallbackStore, EventEmitter***REMOVED***;

CallbackStore.prototype.notRepliedToIds = function(***REMOVED*** {
  return Object.keys(this._notReplied***REMOVED***;
}

CallbackStore.prototype.callbackInfo = function(id***REMOVED*** {
  return this._notReplied[id]; 
}

/**
 * Internal class for holding non-executed commands
 * @ignore
 */
var NonExecutedOperationStore = function(config***REMOVED*** {  
  var commands = {
      read: []
    , write_reads: []
    , write: []
***REMOVED***;

  // Execute all callbacks
  var fireCallbacksWithError = function(error, commands***REMOVED*** {
    while(commands.length > 0***REMOVED*** {
      var command = commands.shift(***REMOVED***;
      if(typeof command.callback == 'function'***REMOVED*** {
        command.callback(error***REMOVED***;        
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  this.count = function(***REMOVED*** {
    return commands.read.length
      + commands.write_reads.length
      + commands.write.length;
***REMOVED***

  this.write = function(op***REMOVED*** {
    commands.write.push(op***REMOVED***;
***REMOVED***  

  this.read_from_writer = function(op***REMOVED*** {  
    commands.write_reads.push(op***REMOVED***;
***REMOVED***

  this.read = function(op***REMOVED*** {  
    commands.read.push(op***REMOVED***;
***REMOVED***  

  this.validateBufferLimit = function(numberToFailOn***REMOVED*** {
    if(numberToFailOn == -1 || numberToFailOn == null***REMOVED*** 
      return true;

    // Error passed back
    var error = utils.toError("No connection operations buffering limit of " + numberToFailOn + " reached"***REMOVED***;

    // If we have passed the number of items to buffer we need to fail
    if(numberToFailOn < this.count(***REMOVED******REMOVED*** {
      // Fail all of the callbacks
      fireCallbacksWithError(error, commands.read***REMOVED***;
      fireCallbacksWithError(error, commands.write_reads***REMOVED***;
      fireCallbacksWithError(error, commands.write***REMOVED***;

      // Report back that the buffer has been filled
      return false;
  ***REMOVED***

    // There is still some room to go
    return true;
***REMOVED***

  this.execute_queries = function(executeInsertCommand***REMOVED*** {
    var connection = config.checkoutReader(***REMOVED***;
    if(connection == null || connection instanceof Error***REMOVED*** return;

    // Write out all the queries
    while(commands.read.length > 0***REMOVED*** {
      // Get the next command
      var command = commands.read.shift(***REMOVED***;
      command.options.connection = connection;
      // Execute the next command
      command.executeQueryCommand(command.db, command.db_command, command.options, command.callback***REMOVED***;
  ***REMOVED***
***REMOVED***

  this.execute_writes = function(***REMOVED*** {
    var connection = config.checkoutWriter(***REMOVED***;
    if(connection == null || connection instanceof Error***REMOVED*** return;

    // Write out all the queries to the primary
    while(commands.write_reads.length > 0***REMOVED*** {
      // Get the next command
      var command = commands.write_reads.shift(***REMOVED***;
      command.options.connection = connection;
      // Execute the next command
      command.executeQueryCommand(command.db, command.db_command, command.options, command.callback***REMOVED***;
  ***REMOVED***

    // Execute all write operations
    while(commands.write.length > 0***REMOVED*** {
      // Get the next command
      var command = commands.write.shift(***REMOVED***;
      // Set the connection
      command.options.connection = connection;
      // Execute the next command
      command.executeInsertCommand(command.db, command.db_command, command.options, command.callback***REMOVED***;
  ***REMOVED***  
***REMOVED***
}

/**
 * Internal class for authentication storage
 * @ignore
 */
var AuthStore = function(***REMOVED*** {
  var _auths = [];

  this.add = function(authMechanism, dbName, username, password, authdbName, gssapiServiceName***REMOVED*** {
    // Check for duplicates
    if(!this.contains(dbName***REMOVED******REMOVED*** {
      // Base config
      var config = {
          'username':username
        , 'password':password
        , 'db': dbName
        , 'authMechanism': authMechanism
        , 'gssapiServiceName': gssapiServiceName
    ***REMOVED***;

      // Add auth source if passed in
      if(typeof authdbName == 'string'***REMOVED*** {
        config['authdb'] = authdbName;
    ***REMOVED***

      // Push the config
      _auths.push(config***REMOVED***;
  ***REMOVED***
***REMOVED***  

  this.contains = function(dbName***REMOVED*** {
    for(var i = 0; i < _auths.length; i++***REMOVED*** {
      if(_auths[i].db == dbName***REMOVED*** return true;
  ***REMOVED***

    return false;
***REMOVED***

  this.remove = function(dbName***REMOVED*** {
    var newAuths = [];

    // Filter out all the login details
    for(var i = 0; i < _auths.length; i++***REMOVED*** {
      if(_auths[i].db != dbName***REMOVED*** newAuths.push(_auths[i]***REMOVED***;
  ***REMOVED***

    //  Set the filtered list
    _auths = newAuths;
***REMOVED***

  this.get = function(index***REMOVED*** {
    return _auths[index];
***REMOVED***

  this.length = function(***REMOVED*** {
    return _auths.length;
***REMOVED***

  this.toArray = function(***REMOVED*** {
    return _auths.slice(0***REMOVED***;
***REMOVED***
}

/**
 * Internal class for storing db references
 * @ignore
 */
var DbStore = function(***REMOVED*** {
  var _dbs = [];

  this.add = function(db***REMOVED*** {
    var found = false;
    
    // Only add if it does not exist already
    for(var i = 0; i < _dbs.length; i++***REMOVED*** {
      if(db.databaseName == _dbs[i].databaseName***REMOVED*** found = true;
  ***REMOVED***

    // Only add if it does not already exist
    if(!found***REMOVED*** {
      _dbs.push(db***REMOVED***;    
  ***REMOVED*** 
***REMOVED***

  this.reset = function(***REMOVED*** {
    _dbs = [];
***REMOVED***

  this.db = function(***REMOVED*** {
    return _dbs;
***REMOVED***

  this.fetch = function(databaseName***REMOVED*** {
    // Only add if it does not exist already
    for(var i = 0; i < _dbs.length; i++***REMOVED*** {
      if(databaseName == _dbs[i].databaseName***REMOVED***
        return _dbs[i];
  ***REMOVED***  

    return null;
***REMOVED***

  this.emit = function(event, message, object, reset, filterDb, rethrow_if_no_listeners***REMOVED*** {
    var emitted = false;

    // Not emitted and we have enabled rethrow, let process.uncaughtException
    // deal with the issue
    if(!emitted && rethrow_if_no_listeners***REMOVED*** {
      return process.nextTick(function(***REMOVED*** {
        throw message;      
    ***REMOVED******REMOVED***
  ***REMOVED***

    // Emit the events
    for(var i = 0; i < _dbs.length; i++***REMOVED*** {    
      if(_dbs[i].listeners(event***REMOVED***.length > 0***REMOVED*** {
        if(filterDb == null || filterDb.databaseName !== _dbs[i].databaseName 
          || filterDb.tag !== _dbs[i].tag***REMOVED*** {
          _dbs[i].emit(event, message, object == null ? _dbs[i] : object***REMOVED***;
          emitted = true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    // Emit error message
    if(message 
      && event == 'error' 
      && !emitted
      && rethrow_if_no_listeners 
      && object && object.db***REMOVED*** {
        process.nextTick(function(***REMOVED*** {
          object.db.emit(event, message, null***REMOVED***;      
      ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***
}

var Base = function Base(***REMOVED*** {  
  EventEmitter.call(this***REMOVED***;

  // Callback store is part of connection specification
  if(Base._callBackStore == null***REMOVED*** {
    Base._callBackStore = new CallbackStore(***REMOVED***;
***REMOVED***

  // Create a new callback store  
  this._callBackStore = new CallbackStore(***REMOVED***;
  // All commands not being executed
  this._commandsStore = new NonExecutedOperationStore(this***REMOVED***;
  // Create a new auth store
  this.auth = new AuthStore(***REMOVED***;
  // Contains all the dbs attached to this server config
  this._dbStore = new DbStore(***REMOVED***;
}

/**
 * @ignore
 */
inherits(Base, EventEmitter***REMOVED***;

/**
 * @ignore
 */
Base.prototype._apply_auths = function(db, callback***REMOVED*** {
  _apply_auths_serially(this, db, this.auth.toArray(***REMOVED***, callback***REMOVED***;
}

var _apply_auths_serially = function(self, db, auths, callback***REMOVED*** {
  if(auths.length == 0***REMOVED*** return callback(null, null***REMOVED***;
  // Get the first auth
  var auth = auths.shift(***REMOVED***;
  var connections = self.allRawConnections(***REMOVED***;
  var connectionsLeft = connections.length;
  var options = {};

  if(auth.authMechanism == 'GSSAPI'***REMOVED*** {
    // We have the kerberos library, execute auth process
    if(process.platform == 'win32'***REMOVED*** {
      mongodb_sspi_authenticate(db, auth.username, auth.password, auth.authdb, options, callback***REMOVED***;
  ***REMOVED*** else {
      mongodb_gssapi_authenticate(db, auth.username, auth.password, auth.authdb, options, callback***REMOVED***;
  ***REMOVED***
***REMOVED*** else if(auth.authMechanism == 'MONGODB-CR'***REMOVED*** {
    mongodb_cr_authenticate(db, auth.username, auth.password, auth.authdb, options, callback***REMOVED***;
***REMOVED*** else if(auth.authMechanism == 'PLAIN'***REMOVED*** {
    mongodb_plain_authenticate(db, auth.username, auth.password, auth.authdb, options, callback***REMOVED***;
***REMOVED*** else if(auth.authMechanism == 'MONGODB-X509'***REMOVED*** {
    mongodb_x509_authenticate(db, auth.username, auth.password, auth.authdb, options, callback***REMOVED***;
***REMOVED***
}

/**
 * Fire all the errors
 * @ignore
 */
Base.prototype.__executeAllCallbacksWithError = function(err***REMOVED*** {
  // Check all callbacks
  var keys = Object.keys(this._callBackStore._notReplied***REMOVED***;
  // For each key check if it's a callback that needs to be returned
  for(var j = 0; j < keys.length; j++***REMOVED*** {
    var info = this._callBackStore._notReplied[keys[j]];
    // Execute callback with error
    this._callBackStore.emit(keys[j], err, null***REMOVED***;
    // Remove the key
    delete this._callBackStore._notReplied[keys[j]];
    // Force cleanup _events, node.js seems to set it as a null value
    if(this._callBackStore._events***REMOVED*** {
      delete this._callBackStore._events[keys[j]];
  ***REMOVED***
***REMOVED***
}

/**
 * Fire all the errors
 * @ignore
 */
Base.prototype.__executeAllServerSpecificErrorCallbacks = function(host, port, err***REMOVED*** {  
  // Check all callbacks
  var keys = Object.keys(this._callBackStore._notReplied***REMOVED***;
  // For each key check if it's a callback that needs to be returned
  for(var j = 0; j < keys.length; j++***REMOVED*** {
    var info = this._callBackStore._notReplied[keys[j]];

    if(info.connection***REMOVED*** {
      // Unpack the connection settings
      var _host = info.connection.socketOptions.host;
      var _port = info.connection.socketOptions.port;
      // If the server matches execute the callback with the error
      if(_port == port && _host == host***REMOVED*** {
        this._callBackStore.emit(keys[j], err, null***REMOVED***;
        // Remove the key
        delete this._callBackStore._notReplied[keys[j]];
        // Force cleanup _events, node.js seems to set it as a null value
        if(this._callBackStore._events***REMOVED*** {
          delete this._callBackStore._events[keys[j]];
      ***REMOVED*** 
    ***REMOVED***      
  ***REMOVED***
***REMOVED***
}

/**
 * Register a handler
 * @ignore
 * @api private
 */
Base.prototype._registerHandler = function(db_command, raw, connection, exhaust, callback***REMOVED*** {
  // Check if we have exhausted
  if(typeof exhaust == 'function'***REMOVED*** {
    callback = exhaust;
    exhaust = false;
***REMOVED***

  // Add the callback to the list of handlers
  this._callBackStore.once(db_command.getRequestId(***REMOVED***, callback***REMOVED***;
  // Add the information about the reply
  this._callBackStore._notReplied[db_command.getRequestId(***REMOVED***.toString(***REMOVED***] = {start: new Date(***REMOVED***.getTime(***REMOVED***, 'raw': raw, connection:connection, exhaust:exhaust};
}

/**
 * Re-Register a handler, on the cursor id f.ex
 * @ignore
 * @api private
 */
Base.prototype._reRegisterHandler = function(newId, object, callback***REMOVED*** {
  // Add the callback to the list of handlers
  this._callBackStore.once(newId, object.callback.listener***REMOVED***;
  // Add the information about the reply
  this._callBackStore._notReplied[newId] = object.info;
}

/**
 *
 * @ignore
 * @api private
 */
Base.prototype._flushAllCallHandlers = function(err***REMOVED*** {
  var keys = Object.keys(this._callBackStore._notReplied***REMOVED***;

  for(var i = 0; i < keys.length; i++***REMOVED*** {
    this._callHandler(keys[i], null, err***REMOVED***;
***REMOVED***
}

/**
 *
 * @ignore
 * @api private
 */
Base.prototype._callHandler = function(id, document, err***REMOVED*** {
  var self = this;

  // If there is a callback peform it
  if(this._callBackStore.listeners(id***REMOVED***.length >= 1***REMOVED*** {
    // Get info object
    var info = this._callBackStore._notReplied[id];
    // Delete the current object
    delete this._callBackStore._notReplied[id]; 
    // Call the handle directly don't emit
    var callback = this._callBackStore.listeners(id***REMOVED***[0].listener;
    // Remove the listeners
    this._callBackStore.removeAllListeners(id***REMOVED***;
    // Force key deletion because it nulling it not deleting in 0.10.X
    if(this._callBackStore._events***REMOVED*** {
      delete this._callBackStore._events[id];
  ***REMOVED***

    try {
      // Execute the callback if one was provided
      if(typeof callback == 'function'***REMOVED*** callback(err, document, info.connection***REMOVED***;
  ***REMOVED*** catch(err***REMOVED*** {
      self._emitAcrossAllDbInstances(self, null, "error", utils.toError(err***REMOVED***, self, true, true***REMOVED***;
  ***REMOVED***
***REMOVED***
}

/**
 *
 * @ignore
 * @api private
 */
Base.prototype._hasHandler = function(id***REMOVED*** {
  return this._callBackStore.listeners(id***REMOVED***.length >= 1;
}

/**
 *
 * @ignore
 * @api private
 */
Base.prototype._removeHandler = function(id***REMOVED*** {
  // Remove the information
  if(this._callBackStore._notReplied[id] != null***REMOVED*** delete this._callBackStore._notReplied[id];
  // Remove the callback if it's registered
  this._callBackStore.removeAllListeners(id***REMOVED***;
  // Force cleanup _events, node.js seems to set it as a null value
  if(this._callBackStore._events***REMOVED*** {
    delete this._callBackStore._events[id];
***REMOVED***
}

/**
 *
 * @ignore
 * @api private
 */
Base.prototype._findHandler = function(id***REMOVED*** {
  var info = this._callBackStore._notReplied[id];
  // Return the callback
  return {info:info, callback:(this._callBackStore.listeners(id***REMOVED***.length >= 1***REMOVED*** ? this._callBackStore.listeners(id***REMOVED***[0] : null}
}

/**
 *
 * @ignore
 * @api private
 */
Base.prototype._emitAcrossAllDbInstances = function(server, filterDb, event, message, object, resetConnection, rethrow_if_no_listeners***REMOVED*** {
  if(resetConnection***REMOVED*** {
    var dbs = this._dbStore.db(***REMOVED***;

    for(var i = 0; i < dbs.length; i++***REMOVED*** {
      if(typeof dbs[i].openCalled != 'undefined'***REMOVED***
        dbs[i].openCalled = false;
  ***REMOVED***
***REMOVED***
  
  // Fire event
  this._dbStore.emit(event, message, object, resetConnection, filterDb, rethrow_if_no_listeners***REMOVED***;
}

exports.Base = Base;