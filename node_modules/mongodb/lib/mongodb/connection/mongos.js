var ReadPreference = require('./read_preference'***REMOVED***.ReadPreference
  , Base = require('./base'***REMOVED***.Base
  , Server = require('./server'***REMOVED***.Server
  , format = require('util'***REMOVED***.format
  , timers = require('timers'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , inherits = require('util'***REMOVED***.inherits;

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('../utils'***REMOVED***.processor(***REMOVED***;

/**
 * Mongos constructor provides a connection to a mongos proxy including failover to additional servers
 *
 * Options
 *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean***REMOVED***, keepAlive:(number***REMOVED***, connectTimeoutMS:(number***REMOVED***, socketTimeoutMS:(number***REMOVED******REMOVED***
 *  - **ha** {Boolean, default:true}, turn on high availability, attempts to reconnect to down proxies
 *  - **haInterval** {Number, default:2000}, time between each replicaset status check.
 *
 * @class Represents a Mongos connection with failover to backup proxies
 * @param {Array} list of mongos server objects
 * @param {Object} [options] additional options for the mongos connection
 */
var Mongos = function Mongos(servers, options***REMOVED*** {
  // Set up basic
  if(!(this instanceof Mongos***REMOVED******REMOVED***
    return new Mongos(servers, options***REMOVED***;

  // Set up event emitter
  Base.call(this***REMOVED***;

  // Throw error on wrong setup
  if(servers == null || !Array.isArray(servers***REMOVED*** || servers.length == 0***REMOVED***
    throw new Error("At least one mongos proxy must be in the array"***REMOVED***;

  // Ensure we have at least an empty options object
  this.options = options == null ? {} : options;
  // Set default connection pool options
  this.socketOptions = this.options.socketOptions != null ? this.options.socketOptions : {};
  // Enabled ha
  this.haEnabled = this.options['ha'] == null ? true : this.options['ha'];
  this._haInProgress = false;
  // How often are we checking for new servers in the replicaset
  this.mongosStatusCheckInterval = this.options['haInterval'] == null ? 1000 : this.options['haInterval'];
  // Save all the server connections
  this.servers = servers;
  // Servers we need to attempt reconnect with
  this.downServers = {};
  // Servers that are up
  this.upServers = {};
  // Up servers by ping time
  this.upServersByUpTime = {};
  // Emit open setup
  this.emitOpen = this.options.emitOpen || true;
  // Just contains the current lowest ping time and server
  this.lowestPingTimeServer = null;
  this.lowestPingTime = 0;
  // Connection timeout
  this._connectTimeoutMS = this.socketOptions.connectTimeoutMS
    ? this.socketOptions.connectTimeoutMS
    : 1000;

  // Add options to servers
  for(var i = 0; i < this.servers.length; i++***REMOVED*** {
    var server = this.servers[i];
    server._callBackStore = this._callBackStore;
    server.auto_reconnect = false;
    // Default empty socket options object
    var socketOptions = {host: server.host, port: server.port};
    // If a socket option object exists clone it
    if(this.socketOptions != null***REMOVED*** {
      var keys = Object.keys(this.socketOptions***REMOVED***;
      for(var k = 0; k < keys.length;k++***REMOVED*** socketOptions[keys[i]] = this.socketOptions[keys[i]];
  ***REMOVED***

    // Set socket options
    server.socketOptions = socketOptions;
***REMOVED***

  // Allow setting the socketTimeoutMS on all connections
  // to work around issues such as secondaries blocking due to compaction
  utils.setSocketTimeoutProperty(this, this.socketOptions***REMOVED***;  
}

/**
 * @ignore
 */
inherits(Mongos, Base***REMOVED***;

/**
 * @ignore
 */
Mongos.prototype.isMongos = function(***REMOVED*** {
  return true;
}

/**
 * @ignore
 */
Mongos.prototype.connect = function(db, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = {};
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;
  var self = this;

  // Keep reference to parent
  this.db = db;
  // Set server state to connecting
  this._serverState = 'connecting';
  // Number of total servers that need to initialized (known servers***REMOVED***
  this._numberOfServersLeftToInitialize = this.servers.length;  
  // Connect handler
  var connectHandler = function(_server***REMOVED*** {
    return function(err, result***REMOVED*** {
      self._numberOfServersLeftToInitialize = self._numberOfServersLeftToInitialize - 1;

      // Add the server to the list of servers that are up
      if(!err***REMOVED*** {
        self.upServers[format("%s:%s", _server.host, _server.port***REMOVED***] = _server;
    ***REMOVED***

      // We are done connecting
      if(self._numberOfServersLeftToInitialize == 0***REMOVED*** {
        // If we have no valid mongos server instances error out
        if(Object.keys(self.upServers***REMOVED***.length == 0***REMOVED*** {
          // return self.emit("connectionError", new Error("No valid mongos instances found"***REMOVED******REMOVED***;
          return callback(new Error("No valid mongos instances found"***REMOVED***, null***REMOVED***;
      ***REMOVED***

        // Start ha function if it exists
        if(self.haEnabled***REMOVED*** {
          // Setup the ha process
          if(self._replicasetTimeoutId != null***REMOVED*** clearInterval(self._replicasetTimeoutId***REMOVED***;
          self._replicasetTimeoutId = setInterval(self.mongosCheckFunction, self.mongosStatusCheckInterval***REMOVED***;
      ***REMOVED***

        // Set the mongos to connected
        self._serverState = "connected";

        // Emit the open event
        if(self.emitOpen***REMOVED***
          self._emitAcrossAllDbInstances(self, null, "open", null, null, null***REMOVED***;        

        self._emitAcrossAllDbInstances(self, null, "fullsetup", null, null, null***REMOVED***;      
        // Callback
        callback(null, self.db***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

  // Error handler
  var errorOrCloseHandler = function(_server***REMOVED*** {
    return function(err, result***REMOVED*** {
      // Emit left event, signaling mongos left the ha
      self.emit('left', 'mongos', _server***REMOVED***;
      // Execute all the callbacks with errors
      self.__executeAllCallbacksWithError(err***REMOVED***;
      // Check if we have the server
      var found = false;
      
      // Get the server name
      var server_name = format("%s:%s", _server.host, _server.port***REMOVED***;
      // Add the downed server
      self.downServers[server_name] = _server;
      // Remove the current server from the list
      delete self.upServers[server_name]; 

      // Emit close across all the attached db instances
      if(Object.keys(self.upServers***REMOVED***.length == 0***REMOVED*** {
        self._emitAcrossAllDbInstances(self, null, "close", new Error("mongos disconnected, no valid proxies contactable over tcp"***REMOVED***, null, null***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  // Mongo function
  this.mongosCheckFunction = function(***REMOVED*** {
    // Set as not waiting for check event 
    self._haInProgress = true;
    
    // Servers down
    var numberOfServersLeft = Object.keys(self.downServers***REMOVED***.length;
    
    // Check downed servers
    if(numberOfServersLeft > 0***REMOVED*** {
      for(var name in self.downServers***REMOVED*** {
        // Pop a downed server      
        var downServer = self.downServers[name];
        // Set up the connection options for a Mongos
        var options = {
          auto_reconnect: false,
          returnIsMasterResults: true,
          slaveOk: true,
          poolSize: downServer.poolSize,
          socketOptions: { 
            connectTimeoutMS: self._connectTimeoutMS,
            socketTimeoutMS: self._socketTimeoutMS
        ***REMOVED***          
      ***REMOVED***

        // Create a new server object
        var newServer = new Server(downServer.host, downServer.port, options***REMOVED***;
        // Setup the connection function
        var connectFunction = function(_db, _server, _options, _callback***REMOVED***  {
          return function(***REMOVED*** {
            // Attempt to connect
            _server.connect(_db, _options, function(err, result***REMOVED*** {
              numberOfServersLeft = numberOfServersLeft - 1;

              if(err***REMOVED*** {
                return _callback(err, _server***REMOVED***;
            ***REMOVED*** else {                
                // Set the new server settings
                _server._callBackStore = self._callBackStore;

                // Add server event handlers
                _server.on("close", errorOrCloseHandler(_server***REMOVED******REMOVED***;
                _server.on("timeout", errorOrCloseHandler(_server***REMOVED******REMOVED***;
                _server.on("error", errorOrCloseHandler(_server***REMOVED******REMOVED***;
                
                // Get a read connection
                var _connection = _server.checkoutReader(***REMOVED***;
                // Get the start time
                var startTime = new Date(***REMOVED***.getTime(***REMOVED***;
                
                // Execute ping command to mark each server with the expected times
                self.db.command({ping:1}
                  , {failFast:true, connection:_connection}, function(err, result***REMOVED*** {
                  // Get the start time
                  var endTime = new Date(***REMOVED***.getTime(***REMOVED***;
                  // Mark the server with the ping time
                  _server.runtimeStats['pingMs'] = endTime - startTime;

                  // If we have any buffered commands let's signal reconnect event
                  if(self._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
                    self.emit('reconnect'***REMOVED***;
                ***REMOVED***

                  // Execute any waiting reads
                  self._commandsStore.execute_writes(***REMOVED***;   
                  self._commandsStore.execute_queries(***REMOVED***;   
                  // Callback
                  return _callback(null, _server***REMOVED***;
              ***REMOVED******REMOVED***;
            ***REMOVED***
          ***REMOVED******REMOVED***;
        ***REMOVED***
      ***REMOVED*** 

        // Attempt to connect to the database
        connectFunction(self.db, newServer, options, function(err, _server***REMOVED*** {
          // If we have an error
          if(err***REMOVED*** {
            self.downServers[format("%s:%s", _server.host, _server.port***REMOVED***] = _server;
        ***REMOVED***

          // Connection function
          var connectionFunction = function(_auth, _connection, _callback***REMOVED*** {
            var pending = _auth.length(***REMOVED***;

            for(var j = 0; j < pending; j++***REMOVED*** {
              // Get the auth object
              var _auth = _auth.get(j***REMOVED***;
              // Unpack the parameter
              var username = _auth.username;
              var password = _auth.password;
              var options = { 
                  authMechanism: _auth.authMechanism
                , authSource: _auth.authdb
                , connection: _connection 
            ***REMOVED***;

              // If we have changed the service name
              if(_auth.gssapiServiceName***REMOVED*** 
                options.gssapiServiceName = _auth.gssapiServiceName;

              // Hold any error
              var _error = null;
              // Authenticate against the credentials
              self.db.authenticate(username, password, options, function(err, result***REMOVED*** {
                _error = err != null ? err : _error;
                // Adjust the pending authentication
                pending = pending - 1;
                // Finished up
                if(pending == 0***REMOVED*** _callback(_error ? _error : null, _error ? false : true***REMOVED***;
            ***REMOVED******REMOVED***;
          ***REMOVED***
        ***REMOVED***

          // Run auths against the connections
          if(self.auth.length(***REMOVED*** > 0***REMOVED*** {
            var connections = _server.allRawConnections(***REMOVED***;
            var pendingAuthConn = connections.length;

            // No connections we are done
            if(connections.length == 0***REMOVED*** {
              // Set ha done
              if(numberOfServersLeft == 0***REMOVED*** {
                self._haInProgress = false;
            ***REMOVED***              
          ***REMOVED***

            // Final error object
            var finalError = null;
            // Go over all the connections
            for(var j = 0; j < connections.length; j++***REMOVED*** {
              
              // Execute against all the connections
              connectionFunction(self.auth, connections[j], function(err, result***REMOVED*** {
                // Pending authentication
                pendingAuthConn = pendingAuthConn - 1 ;

                // Save error if any
                finalError = err ? err : finalError;

                // If we are done let's finish up
                if(pendingAuthConn == 0***REMOVED*** {
                  // Set ha done
                  if(numberOfServersLeft == 0***REMOVED*** {
                    self._haInProgress = false;
                ***REMOVED***

                  if(!err***REMOVED*** {
                    add_server(self, _server***REMOVED***;
                ***REMOVED***

                  // If we have any buffered commands let's signal reconnect event
                  if(self._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
                    self.emit('reconnect'***REMOVED***;
                ***REMOVED***

                  // Execute any waiting reads
                  self._commandsStore.execute_writes(***REMOVED***;   
                  self._commandsStore.execute_queries(***REMOVED***;                  
              ***REMOVED***
            ***REMOVED******REMOVED***;
          ***REMOVED***
        ***REMOVED*** else {
            if(!err***REMOVED*** {
              add_server(self, _server***REMOVED***;
          ***REMOVED***

            // Set ha done
            if(numberOfServersLeft == 0***REMOVED*** {
              self._haInProgress = false;

              // If we have any buffered commands let's signal reconnect event
              if(self._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
                self.emit('reconnect'***REMOVED***;
            ***REMOVED***

              // Execute any waiting reads
              self._commandsStore.execute_writes(***REMOVED***;   
              self._commandsStore.execute_queries(***REMOVED***;   
          ***REMOVED***
        ***REMOVED***
      ***REMOVED******REMOVED***(***REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      self._haInProgress = false;
  ***REMOVED***
***REMOVED***

  // Connect all the server instances
  for(var i = 0; i < this.servers.length; i++***REMOVED*** {
    // Get the connection
    var server = this.servers[i];
    server.mongosInstance = this;
    // Add server event handlers
    server.on("close", errorOrCloseHandler(server***REMOVED******REMOVED***;
    server.on("timeout", errorOrCloseHandler(server***REMOVED******REMOVED***;
    server.on("error", errorOrCloseHandler(server***REMOVED******REMOVED***;
    
    // Configuration
    var options = {
      slaveOk: true,
      poolSize: server.poolSize,
      socketOptions: { connectTimeoutMS: self._connectTimeoutMS },
      returnIsMasterResults: true
  ***REMOVED***        

    // Connect the instance
    server.connect(self.db, options, connectHandler(server***REMOVED******REMOVED***;
***REMOVED***
}

/**
 * @ignore
 * Add a server to the list of up servers and sort them by ping time
 */
var add_server = function(self, _server***REMOVED*** {
  // Emit a new server joined
  self.emit('joined', "mongos", null, _server***REMOVED***;
  // Get the server url
  var server_key = format("%s:%s", _server.host, _server.port***REMOVED***;
  // Push to list of valid server
  self.upServers[server_key] = _server;
  // Remove the server from the list of downed servers
  delete self.downServers[server_key];              

  // Sort the keys by ping time
  var keys = Object.keys(self.upServers***REMOVED***;
  var _upServersSorted = {};
  var _upServers = []
  
  // Get all the servers
  for(var name in self.upServers***REMOVED*** {
    _upServers.push(self.upServers[name]***REMOVED***;
***REMOVED***

  // Sort all the server
  _upServers.sort(function(a, b***REMOVED*** {
    return a.runtimeStats['pingMs'] > b.runtimeStats['pingMs'];
***REMOVED******REMOVED***;

  // Rebuild the upServer
  for(var i = 0; i < _upServers.length; i++***REMOVED*** {
    _upServersSorted[format("%s:%s", _upServers[i].host, _upServers[i].port***REMOVED***] = _upServers[i];
***REMOVED***

  // Set the up servers
  self.upServers = _upServersSorted;
}

/**
 * @ignore
 * Just return the currently picked active connection
 */
Mongos.prototype.allServerInstances = function(***REMOVED*** {
  return this.servers;
}

/**
 * Always ourselves
 * @ignore
 */
Mongos.prototype.setReadPreference = function(***REMOVED*** {}

/**
 * @ignore
 */
Mongos.prototype.allRawConnections = function(***REMOVED*** {
  // Neeed to build a complete list of all raw connections, start with master server
  var allConnections = [];
  // Get all connected connections
  for(var name in this.upServers***REMOVED*** {
    allConnections = allConnections.concat(this.upServers[name].allRawConnections(***REMOVED******REMOVED***;
***REMOVED***
  // Return all the conections
  return allConnections;
}

/**
 * @ignore
 */
Mongos.prototype.isConnected = function(***REMOVED*** {
  return Object.keys(this.upServers***REMOVED***.length > 0;
}

/**
 * @ignore
 */
Mongos.prototype.isAutoReconnect = function(***REMOVED*** {
  return true;
}

/**
 * @ignore
 */
Mongos.prototype.canWrite = Mongos.prototype.isConnected;

/**
 * @ignore
 */
Mongos.prototype.canRead = Mongos.prototype.isConnected;

/**
 * @ignore
 */
Mongos.prototype.isDestroyed = function(***REMOVED*** {
  return this._serverState == 'destroyed';
}

/**
 * @ignore
 */
Mongos.prototype.checkoutWriter = function(***REMOVED*** {
  // Checkout a writer
  var keys = Object.keys(this.upServers***REMOVED***;
  if(keys.length == 0***REMOVED*** return null;
  return this.upServers[keys[0]].checkoutWriter(***REMOVED***;
}

/**
 * @ignore
 */
Mongos.prototype.checkoutReader = function(read***REMOVED*** {
  // If read is set to null default to primary
  read = read || 'primary'
  // If we have a read preference object unpack it
  if(read != null && typeof read == 'object' && read['_type'] == 'ReadPreference'***REMOVED*** {
    // Validate if the object is using a valid mode
    if(!read.isValid(***REMOVED******REMOVED*** throw new Error("Illegal readPreference mode specified, " + JSON.stringify(read***REMOVED******REMOVED***;
***REMOVED*** else if(!ReadPreference.isValid(read***REMOVED******REMOVED*** {
    throw new Error("Illegal readPreference mode specified, " + JSON.stringify(read***REMOVED******REMOVED***;
***REMOVED***

  // Checkout a writer
  var keys = Object.keys(this.upServers***REMOVED***;
  if(keys.length == 0***REMOVED*** return null;
  return this.upServers[keys[0]].checkoutWriter(***REMOVED***;
}

/**
 * @ignore
 */
Mongos.prototype.close = function(callback***REMOVED*** {
  var self = this;
  // Set server status as disconnected
  this._serverState = 'destroyed';
  // Number of connections to close
  var numberOfConnectionsToClose = self.servers.length;
  // If we have a ha process running kill it
  if(self._replicasetTimeoutId != null***REMOVED*** clearInterval(self._replicasetTimeoutId***REMOVED***;
  self._replicasetTimeoutId = null;
  
  // Emit close event
  processor(function(***REMOVED*** {
    self._emitAcrossAllDbInstances(self, null, "close", null, null, true***REMOVED***    
***REMOVED******REMOVED***;

  // Flush out any remaining call handlers
  self._flushAllCallHandlers(utils.toError("Connection Closed By Application"***REMOVED******REMOVED***;

  // No up servers just return
  if(Object.keys(this.upServers***REMOVED*** == 0***REMOVED*** {
    return callback(null***REMOVED***;
***REMOVED***

  // Close all the up servers
  for(var name in this.upServers***REMOVED*** {
    this.upServers[name].close(function(err, result***REMOVED*** {
      numberOfConnectionsToClose = numberOfConnectionsToClose - 1;

      // Callback if we have one defined
      if(numberOfConnectionsToClose == 0 && typeof callback == 'function'***REMOVED*** {
        callback(null***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***
}

/**
 * @ignore
 * Return the used state
 */
Mongos.prototype._isUsed = function(***REMOVED*** {
  return this._used;
}

exports.Mongos = Mongos;