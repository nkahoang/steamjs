var Connection = require('./connection'***REMOVED***.Connection,
  ReadPreference = require('./read_preference'***REMOVED***.ReadPreference,
  DbCommand = require('../commands/db_command'***REMOVED***.DbCommand,
  MongoReply = require('../responses/mongo_reply'***REMOVED***.MongoReply,
  ConnectionPool = require('./connection_pool'***REMOVED***.ConnectionPool,
  EventEmitter = require('events'***REMOVED***.EventEmitter,
  ServerCapabilities = require('./server_capabilities'***REMOVED***.ServerCapabilities,
  Base = require('./base'***REMOVED***.Base,
  format = require('util'***REMOVED***.format,
  utils = require('../utils'***REMOVED***,
  timers = require('timers'***REMOVED***,
  inherits = require('util'***REMOVED***.inherits;

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('../utils'***REMOVED***.processor(***REMOVED***;

/**
 * Class representing a single MongoDB Server connection
 *
 * Options
 *  - **ssl** {Boolean, default:false}, use ssl connection (needs to have a mongod server with ssl support***REMOVED***
 *  - **sslValidate** {Boolean, default:false}, validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslCA** {Array, default:null}, Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslCert** {Buffer/String, default:null}, String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslKey** {Buffer/String, default:null}, String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslPass** {Buffer/String, default:null}, String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **poolSize** {Number, default:5}, number of connections in the connection pool, set to 5 as default for legacy reasons.
 *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean***REMOVED***, keepAlive:(number***REMOVED***, connectTimeoutMS:(number***REMOVED***, socketTimeoutMS:(number***REMOVED******REMOVED***
 *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object***REMOVED*** {}, log:function(message, object***REMOVED*** {}, debug:function(message, object***REMOVED*** {}}***REMOVED*****.
 *  - **auto_reconnect** {Boolean, default:false}, reconnect on error.
 *  - **disableDriverBSONSizeCheck** {Boolean, default:false}, force the server to error if the BSON message is to big
 *
 * @class Represents a Server connection.
 * @param {String} host the server host
 * @param {Number} port the server port
 * @param {Object} [options] optional options for insert command
 */
function Server(host, port, options***REMOVED*** {
  // Set up Server instance
  if(!(this instanceof Server***REMOVED******REMOVED*** return new Server(host, port, options***REMOVED***;

  // Set up event emitter
  Base.call(this***REMOVED***;

  // Ensure correct values
  if(port != null && typeof port == 'object'***REMOVED*** {
    options = port;
    port = Connection.DEFAULT_PORT;
***REMOVED***

  var self = this;
  this.host = host;
  this.port = port;
  this.options = options == null ? {} : options;
  this.internalConnection;
  this.internalMaster = false;
  this.connected = false;  
  this.poolSize = this.options.poolSize == null ? 5 : this.options.poolSize;
  this.disableDriverBSONSizeCheck = this.options.disableDriverBSONSizeCheck != null ? this.options.disableDriverBSONSizeCheck : false;
  this._used = false;
  this.replicasetInstance = null;

  // Emit open setup
  this.emitOpen = this.options.emitOpen || true;
  // Set ssl as connection method
  this.ssl = this.options.ssl == null ? false : this.options.ssl;
  // Set ssl validation
  this.sslValidate = this.options.sslValidate == null ? false : this.options.sslValidate;
  // Set the ssl certificate authority (array of Buffer/String keys***REMOVED***
  this.sslCA = Array.isArray(this.options.sslCA***REMOVED*** ? this.options.sslCA : null;
  // Certificate to present to the server
  this.sslCert = this.options.sslCert;
  // Certificate private key if in separate file
  this.sslKey = this.options.sslKey;
  // Password to unlock private key
  this.sslPass = this.options.sslPass;
  // Server capabilities
  this.serverCapabilities = null;
  // Set server name
  this.name = format("%s:%s", host, port***REMOVED***;

  // Ensure we are not trying to validate with no list of certificates
  if(this.sslValidate && (!Array.isArray(this.sslCA***REMOVED*** || this.sslCA.length == 0***REMOVED******REMOVED*** {
    throw new Error("The driver expects an Array of CA certificates in the sslCA parameter when enabling sslValidate"***REMOVED***;
***REMOVED***

  // Contains the isMaster information returned from the server
  this.isMasterDoc;

  // Set default connection pool options
  this.socketOptions = this.options.socketOptions != null ? this.options.socketOptions : {};
  if(this.disableDriverBSONSizeCheck***REMOVED*** this.socketOptions.disableDriverBSONSizeCheck = this.disableDriverBSONSizeCheck;

  // Set ssl up if it's defined
  if(this.ssl***REMOVED*** {
    this.socketOptions.ssl = true;
    // Set ssl validation
    this.socketOptions.sslValidate = this.sslValidate == null ? false : this.sslValidate;
    // Set the ssl certificate authority (array of Buffer/String keys***REMOVED***
    this.socketOptions.sslCA = Array.isArray(this.sslCA***REMOVED*** ? this.sslCA : null;
    // Set certificate to present
    this.socketOptions.sslCert = this.sslCert;
    // Set certificate to present
    this.socketOptions.sslKey = this.sslKey;
    // Password to unlock private key
    this.socketOptions.sslPass = this.sslPass;
***REMOVED***

  // Set up logger if any set
  this.logger = this.options.logger != null
    && (typeof this.options.logger.debug == 'function'***REMOVED***
    && (typeof this.options.logger.error == 'function'***REMOVED***
    && (typeof this.options.logger.log == 'function'***REMOVED***
      ? this.options.logger : {error:function(message, object***REMOVED*** {}, log:function(message, object***REMOVED*** {}, debug:function(message, object***REMOVED*** {}};

  // Just keeps list of events we allow
  this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[], timeout:[]};
  // Internal state of server connection
  this._serverState = 'disconnected';
  // Contains state information about server connection
  this._state = {'runtimeStats': {'queryStats':new RunningStats(***REMOVED***}};
  // Do we record server stats or not
  this.recordQueryStats = false;

  // Allow setting the socketTimeoutMS on all connections
  // to work around issues such as secondaries blocking due to compaction
  utils.setSocketTimeoutProperty(this, this.socketOptions***REMOVED***;
};

/**
 * @ignore
 */
inherits(Server, Base***REMOVED***;

//
//  Deprecated, USE ReadPreferences class
//
Server.READ_PRIMARY = ReadPreference.PRIMARY;
Server.READ_SECONDARY = ReadPreference.SECONDARY_PREFERRED;
Server.READ_SECONDARY_ONLY = ReadPreference.SECONDARY;

/**
 * Always ourselves
 * @ignore
 */
Server.prototype.setReadPreference = function(readPreference***REMOVED*** {
  this._readPreference = readPreference;  
}

/**
 * @ignore
 */
Server.prototype.isMongos = function(***REMOVED*** {
  return this.isMasterDoc != null && this.isMasterDoc['msg'] == "isdbgrid" ? true : false;
}

/**
 * @ignore
 */
Server.prototype._isUsed = function(***REMOVED*** {
  return this._used;
}

/**
 * @ignore
 */
Server.prototype.close = function(callback***REMOVED*** {
  // Set server status as disconnected
  this._serverState = 'destroyed';
  // Remove all local listeners
  this.removeAllListeners(***REMOVED***;

  if(this.connectionPool != null***REMOVED*** {
    // Remove all the listeners on the pool so it does not fire messages all over the place
    this.connectionPool.removeAllEventListeners(***REMOVED***;
    // Close the connection if it's open
    this.connectionPool.stop(true***REMOVED***;
***REMOVED***

  // Emit close event
  if(this.db && !this.isSetMember(***REMOVED******REMOVED*** {
    var self = this;
    processor(function(***REMOVED*** {
      self._emitAcrossAllDbInstances(self, null, "close", null, null, true***REMOVED***
  ***REMOVED******REMOVED***

    // Flush out any remaining call handlers
    self._flushAllCallHandlers(utils.toError("Connection Closed By Application"***REMOVED******REMOVED***;
***REMOVED***

  // Peform callback if present
  if(typeof callback === 'function'***REMOVED*** callback(null***REMOVED***;
};

Server.prototype.isDestroyed = function(***REMOVED*** {
  return this._serverState == 'destroyed';
}

/**
 * @ignore
 */
Server.prototype.isConnected = function(***REMOVED*** {
  return this.connectionPool != null && this.connectionPool.isConnected(***REMOVED***;
}

/**
 * @ignore
 */
Server.prototype.canWrite = Server.prototype.isConnected;
Server.prototype.canRead = Server.prototype.isConnected;

Server.prototype.isAutoReconnect = function(***REMOVED*** {
  if(this.isSetMember(***REMOVED******REMOVED*** return false;
  return this.options.auto_reconnect != null ? this.options.auto_reconnect : true;
}

/**
 * @ignore
 */
Server.prototype.allServerInstances = function(***REMOVED*** {
  return [this];
}

/**
 * @ignore
 */
Server.prototype.isSetMember = function(***REMOVED*** {
  return this.replicasetInstance != null || this.mongosInstance != null;
}

/**
 * Assigns a replica set to this `server`.
 *
 * @param {ReplSet} replset
 * @ignore
 */
Server.prototype.assignReplicaSet = function (replset***REMOVED*** {
  this.replicasetInstance = replset;
  this.inheritReplSetOptionsFrom(replset***REMOVED***;
  this.enableRecordQueryStats(replset.recordQueryStats***REMOVED***;
}

/**
 * Takes needed options from `replset` and overwrites
 * our own options.
 *
 * @param {ReplSet} replset
 * @ignore
 */
Server.prototype.inheritReplSetOptionsFrom = function (replset***REMOVED*** {
  this.socketOptions = {};
  this.socketOptions.connectTimeoutMS = replset.options.socketOptions.connectTimeoutMS || 30000;

  if(replset.options.ssl***REMOVED*** {
    // Set ssl on
    this.socketOptions.ssl = true;
    // Set ssl validation
    this.socketOptions.sslValidate = replset.options.sslValidate == null ? false : replset.options.sslValidate;
    // Set the ssl certificate authority (array of Buffer/String keys***REMOVED***
    this.socketOptions.sslCA = Array.isArray(replset.options.sslCA***REMOVED*** ? replset.options.sslCA : null;
    // Set certificate to present
    this.socketOptions.sslCert = replset.options.sslCert;
    // Set certificate to present
    this.socketOptions.sslKey = replset.options.sslKey;
    // Password to unlock private key
    this.socketOptions.sslPass = replset.options.sslPass;
***REMOVED***

  // If a socket option object exists clone it
  if(utils.isObject(replset.options.socketOptions***REMOVED******REMOVED*** {
    var keys = Object.keys(replset.options.socketOptions***REMOVED***;
    for(var i = 0; i < keys.length; i++***REMOVED***
      this.socketOptions[keys[i]] = replset.options.socketOptions[keys[i]];
***REMOVED***
}

/**
 * Opens this server connection.
 *
 * @ignore
 */
Server.prototype.connect = function(dbInstance, options, callback***REMOVED*** {
  if('function' === typeof options***REMOVED*** callback = options, options = {};
  if(options == null***REMOVED*** options = {};
  if(!('function' === typeof callback***REMOVED******REMOVED*** callback = null;
  var self = this;
  // Save the options
  this.options = options;

  // Currently needed to work around problems with multiple connections in a pool with ssl
  // TODO fix if possible
  if(this.ssl == true***REMOVED*** {
    // Set up socket options for ssl
    this.socketOptions.ssl = true;
    // Set ssl validation
    this.socketOptions.sslValidate = this.sslValidate == null ? false : this.sslValidate;
    // Set the ssl certificate authority (array of Buffer/String keys***REMOVED***
    this.socketOptions.sslCA = Array.isArray(this.sslCA***REMOVED*** ? this.sslCA : null;
    // Set certificate to present
    this.socketOptions.sslCert = this.sslCert;
    // Set certificate to present
    this.socketOptions.sslKey = this.sslKey;
    // Password to unlock private key
    this.socketOptions.sslPass = this.sslPass;
***REMOVED***

  // Let's connect
  var server = this;
  // Let's us override the main receiver of events
  var eventReceiver = options.eventReceiver != null ? options.eventReceiver : this;
  // Save reference to dbInstance
  this.db = dbInstance;  // `db` property matches ReplSet and Mongos
  this.dbInstances = [dbInstance];

  // Force connection pool if there is one
  if(server.connectionPool***REMOVED*** server.connectionPool.stop(***REMOVED***;
  // Set server state to connecting
  this._serverState = 'connecting';

  if(server.connectionPool != null***REMOVED*** {
    // Remove all the listeners on the pool so it does not fire messages all over the place
    this.connectionPool.removeAllEventListeners(***REMOVED***;
    // Close the connection if it's open
    this.connectionPool.stop(true***REMOVED***;    
***REMOVED***

  this.connectionPool = new ConnectionPool(this.host, this.port, this.poolSize, dbInstance.bson, this.socketOptions***REMOVED***;
  var connectionPool = this.connectionPool;
  // If ssl is not enabled don't wait between the pool connections
  if(this.ssl == null || !this.ssl***REMOVED*** connectionPool._timeToWait = null;
  // Set logger on pool
  connectionPool.logger = this.logger;
  connectionPool.bson = dbInstance.bson;

  // Set basic parameters passed in
  var returnIsMasterResults = options.returnIsMasterResults == null ? false : options.returnIsMasterResults;

  // Create a default connect handler, overriden when using replicasets
  var connectCallback = function(_server***REMOVED*** {
    return function(err, reply***REMOVED*** {  
      // ensure no callbacks get called twice
      var internalCallback = callback;
      callback = null;
      
      // Assign the server
      _server = _server != null ? _server : server;
      
      // If something close down the connection and removed the callback before
      // proxy killed connection etc, ignore the erorr as close event was isssued
      if(err != null && internalCallback == null***REMOVED*** return;
      // Internal callback
      if(err != null***REMOVED*** return internalCallback(err, null, _server***REMOVED***;
      _server.master = reply.documents[0].ismaster == 1 ? true : false;
      _server.connectionPool.setMaxBsonSize(reply.documents[0].maxBsonObjectSize***REMOVED***;
      _server.connectionPool.setMaxMessageSizeBytes(reply.documents[0].maxMessageSizeBytes***REMOVED***;
      _server.connectionPool.setMaxWriteBatchSize(reply.documents[0].maxWriteBatchSize***REMOVED***;
      // Set server state to connEcted
      _server._serverState = 'connected';
      // Set server as connected
      _server.connected = true;
      // Save document returned so we can query it
      _server.isMasterDoc = reply.documents[0];
      
      if(self.emitOpen***REMOVED*** {        
        _server._emitAcrossAllDbInstances(_server, eventReceiver, "open", null, returnIsMasterResults ? reply : null, null***REMOVED***;        
        self.emitOpen = false;
    ***REMOVED*** else {
        _server._emitAcrossAllDbInstances(_server, eventReceiver, "reconnect", null, returnIsMasterResults ? reply : null, null***REMOVED***;        
    ***REMOVED***

      // Set server capabilities
      server.serverCapabilities = new ServerCapabilities(_server.isMasterDoc***REMOVED***;      

      // If we have it set to returnIsMasterResults
      if(returnIsMasterResults***REMOVED*** {
        internalCallback(null, reply, _server***REMOVED***;
    ***REMOVED*** else {
        internalCallback(null, dbInstance, _server***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

  // Let's us override the main connect callback
  var connectHandler = options.connectHandler == null ? connectCallback(server***REMOVED*** : options.connectHandler;

  // Set up on connect method
  connectionPool.on("poolReady", function(***REMOVED*** {
    // Create db command and Add the callback to the list of callbacks by the request id (mapping outgoing messages to correct callbacks***REMOVED***
    var db_command = DbCommand.NcreateIsMasterCommand(dbInstance, dbInstance.databaseName***REMOVED***;
    // Check out a reader from the pool
    var connection = connectionPool.checkoutConnection(***REMOVED***;
    // Register handler for messages
    server._registerHandler(db_command, false, connection, connectHandler***REMOVED***;
    // Write the command out
    connection.write(db_command***REMOVED***;
***REMOVED******REMOVED***

  // Set up item connection
  connectionPool.on("message", function(message***REMOVED*** {
    // Attempt to parse the message
    try {
      // Create a new mongo reply
      var mongoReply = new MongoReply(***REMOVED***
      // Parse the header
      mongoReply.parseHeader(message, connectionPool.bson***REMOVED***

      // If message size is not the same as the buffer size
      // something went terribly wrong somewhere
      if(mongoReply.messageLength != message.length***REMOVED*** {
        // Emit the error
        if(eventReceiver.listeners("error"***REMOVED*** && eventReceiver.listeners("error"***REMOVED***.length > 0***REMOVED*** eventReceiver.emit("error", new Error("bson length is different from message length"***REMOVED***, server***REMOVED***;
        // Remove all listeners
        server.removeAllListeners(***REMOVED***;
    ***REMOVED*** else {
        var startDate = new Date(***REMOVED***.getTime(***REMOVED***;

        // Callback instance
        var callbackInfo = server._findHandler(mongoReply.responseTo.toString(***REMOVED******REMOVED***;

        // The command executed another request, log the handler again under that request id
        if(mongoReply.requestId > 0 && mongoReply.cursorId.toString(***REMOVED*** != "0" 
          && callbackInfo && callbackInfo.info && callbackInfo.info.exhaust***REMOVED*** {
            server._reRegisterHandler(mongoReply.requestId, callbackInfo***REMOVED***;
      ***REMOVED***
        // Parse the body
        mongoReply.parseBody(message, connectionPool.bson, callbackInfo.info.raw, function(err***REMOVED*** {
          if(err != null***REMOVED*** {
            // If pool connection is already closed
            if(server._serverState === 'disconnected'***REMOVED*** return;
            // Set server state to disconnected
            server._serverState = 'disconnected';
            // Remove all listeners and close the connection pool
            server.removeAllListeners(***REMOVED***;
            connectionPool.stop(true***REMOVED***;

            // If we have a callback return the error
            if(typeof callback === 'function'***REMOVED*** {
              // ensure no callbacks get called twice
              var internalCallback = callback;
              callback = null;
              // Perform callback
              internalCallback(err, null, server***REMOVED***;
          ***REMOVED*** else if(server.isSetMember(***REMOVED******REMOVED*** {
              if(server.listeners("parseError"***REMOVED*** && server.listeners("parseError"***REMOVED***.length > 0***REMOVED*** server.emit("parseError", utils.toError(err***REMOVED***, server***REMOVED***;
          ***REMOVED*** else {
              if(eventReceiver.listeners("parseError"***REMOVED*** && eventReceiver.listeners("parseError"***REMOVED***.length > 0***REMOVED*** eventReceiver.emit("parseError", utils.toError(err***REMOVED***, server***REMOVED***;
          ***REMOVED***

            // If we are a single server connection fire errors correctly
            if(!server.isSetMember(***REMOVED******REMOVED*** {
              // Fire all callback errors
              server.__executeAllCallbacksWithError(err***REMOVED***;
              // Emit error
              server._emitAcrossAllDbInstances(server, eventReceiver, "parseError", server, null, true***REMOVED***;
          ***REMOVED***
            // Short cut
            return;
        ***REMOVED***

          // Let's record the stats info if it's enabled
          if(server.recordQueryStats == true && server._state['runtimeStats'] != null
            && server._state.runtimeStats['queryStats'] instanceof RunningStats***REMOVED*** {
            // Add data point to the running statistics object
            server._state.runtimeStats.queryStats.push(new Date(***REMOVED***.getTime(***REMOVED*** - callbackInfo.info.start***REMOVED***;
        ***REMOVED***

          // Dispatch the call
          server._callHandler(mongoReply.responseTo, mongoReply, null***REMOVED***;

          // If we have an error about the server not being master or primary
          if((mongoReply.responseFlag & (1 << 1***REMOVED******REMOVED*** != 0
            && mongoReply.documents[0].code
            && mongoReply.documents[0].code == 13436***REMOVED*** {
              server.close(***REMOVED***;
        ***REMOVED***
      ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** catch (err***REMOVED*** {
      // Throw error in next tick
      processor(function(***REMOVED*** {
        throw err;
    ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED******REMOVED***;

  // Handle timeout
  connectionPool.on("timeout", function(err***REMOVED*** {
    // If pool connection is already closed
    if(server._serverState === 'disconnected' 
      || server._serverState === 'destroyed'***REMOVED*** return;
    // Set server state to disconnected
    server._serverState = 'disconnected';
    // If we have a callback return the error
    if(typeof callback === 'function'***REMOVED*** {
      // ensure no callbacks get called twice
      var internalCallback = callback;
      callback = null;
      // Perform callback
      internalCallback(err, null, server***REMOVED***;
  ***REMOVED*** else if(server.isSetMember(***REMOVED******REMOVED*** {
      if(server.listeners("timeout"***REMOVED*** && server.listeners("timeout"***REMOVED***.length > 0***REMOVED*** server.emit("timeout", err, server***REMOVED***;
  ***REMOVED*** else {
      if(eventReceiver.listeners("timeout"***REMOVED*** && eventReceiver.listeners("timeout"***REMOVED***.length > 0***REMOVED*** eventReceiver.emit("timeout", err, server***REMOVED***;
  ***REMOVED***

    // If we are a single server connection fire errors correctly
    if(!server.isSetMember(***REMOVED******REMOVED*** {
      // Fire all callback errors
      server.__executeAllCallbacksWithError(err***REMOVED***;
      // Emit error
      server._emitAcrossAllDbInstances(server, eventReceiver, "timeout", err, server, true***REMOVED***;
  ***REMOVED***

    // If we have autoConnect enabled let's fire up an attempt to reconnect
    if(server.isAutoReconnect(***REMOVED*** 
      && !server.isSetMember(***REMOVED***
      && (server._serverState != 'destroyed'***REMOVED***
      && !server._reconnectInProgreess***REMOVED*** {
      // Set the number of retries
      server._reconnect_retries = server.db.numberOfRetries;
      // Attempt reconnect
      server._reconnectInProgreess = true;
      setTimeout(__attemptReconnect(server***REMOVED***, server.db.retryMiliSeconds***REMOVED***;
  ***REMOVED***    
***REMOVED******REMOVED***;

  // Handle errors
  connectionPool.on("error", function(message, connection, error_options***REMOVED*** {
    // If pool connection is already closed
    if(server._serverState === 'disconnected' 
      || server._serverState === 'destroyed'***REMOVED*** return;
    
    // Set server state to disconnected
    server._serverState = 'disconnected';
    // Error message
    var error_message = new Error(message && message.err ? message.err : message***REMOVED***;
    // Error message coming from ssl
    if(error_options && error_options.ssl***REMOVED*** error_message.ssl = true;

    // If we have a callback return the error
    if(typeof callback === 'function'***REMOVED*** {
      // ensure no callbacks get called twice
      var internalCallback = callback;
      callback = null;
      // Perform callback
      internalCallback(error_message, null, server***REMOVED***;
  ***REMOVED*** else if(server.isSetMember(***REMOVED******REMOVED*** {
      if(server.listeners("error"***REMOVED*** && server.listeners("error"***REMOVED***.length > 0***REMOVED*** server.emit("error", error_message, server***REMOVED***;
  ***REMOVED*** else {
      if(eventReceiver.listeners("error"***REMOVED*** && eventReceiver.listeners("error"***REMOVED***.length > 0***REMOVED*** eventReceiver.emit("error", error_message, server***REMOVED***;
  ***REMOVED***

    // If we are a single server connection fire errors correctly
    if(!server.isSetMember(***REMOVED******REMOVED*** {
      // Fire all callback errors
      server.__executeAllCallbacksWithError(error_message***REMOVED***;
      // Emit error
      server._emitAcrossAllDbInstances(server, eventReceiver, "error", error_message, server, true***REMOVED***;
  ***REMOVED***

    // If we have autoConnect enabled let's fire up an attempt to reconnect
    if(server.isAutoReconnect(***REMOVED*** 
      && !server.isSetMember(***REMOVED***
      && (server._serverState != 'destroyed'***REMOVED***
      && !server._reconnectInProgreess***REMOVED*** {

      // Set the number of retries
      server._reconnect_retries = server.db.numberOfRetries;
      // Attempt reconnect
      server._reconnectInProgreess = true;
      setTimeout(__attemptReconnect(server***REMOVED***, server.db.retryMiliSeconds***REMOVED***;
  ***REMOVED***    
***REMOVED******REMOVED***;

  // Handle close events
  connectionPool.on("close", function(***REMOVED*** {
    // If pool connection is already closed
    if(server._serverState === 'disconnected' 
      || server._serverState === 'destroyed'***REMOVED*** return;
    // Set server state to disconnected
    server._serverState = 'disconnected';
    // If we have a callback return the error
    if(typeof callback == 'function'***REMOVED*** {
      // ensure no callbacks get called twice
      var internalCallback = callback;
      callback = null;
      // Perform callback
      internalCallback(new Error("connection closed"***REMOVED***, null, server***REMOVED***;
  ***REMOVED*** else if(server.isSetMember(***REMOVED******REMOVED*** {
      if(server.listeners("close"***REMOVED*** && server.listeners("close"***REMOVED***.length > 0***REMOVED*** server.emit("close", new Error("connection closed"***REMOVED***, server***REMOVED***;
  ***REMOVED*** else {
      if(eventReceiver.listeners("close"***REMOVED*** && eventReceiver.listeners("close"***REMOVED***.length > 0***REMOVED*** eventReceiver.emit("close", new Error("connection closed"***REMOVED***, server***REMOVED***;
  ***REMOVED***

    // If we are a single server connection fire errors correctly
    if(!server.isSetMember(***REMOVED******REMOVED*** {
      // Fire all callback errors
      server.__executeAllCallbacksWithError(new Error("connection closed"***REMOVED******REMOVED***;
      // Emit error
      server._emitAcrossAllDbInstances(server, eventReceiver, "close", server, null, true***REMOVED***;
  ***REMOVED***

    // If we have autoConnect enabled let's fire up an attempt to reconnect
    if(server.isAutoReconnect(***REMOVED*** 
      && !server.isSetMember(***REMOVED***
      && (server._serverState != 'destroyed'***REMOVED***
      && !server._reconnectInProgreess***REMOVED*** {

      // Set the number of retries
      server._reconnect_retries = server.db.numberOfRetries;  
      // Attempt reconnect
      server._reconnectInProgreess = true;
      setTimeout(__attemptReconnect(server***REMOVED***, server.db.retryMiliSeconds***REMOVED***;
  ***REMOVED***    
***REMOVED******REMOVED***;

  /**
   * @ignore
   */
  var __attemptReconnect = function(server***REMOVED*** {
    return function(***REMOVED*** {
      // Attempt reconnect
      server.connect(server.db, server.options, function(err, result***REMOVED*** {
        server._reconnect_retries = server._reconnect_retries - 1;

        if(err***REMOVED*** {
          // Retry
          if(server._reconnect_retries == 0 || server._serverState == 'destroyed'***REMOVED*** {
            server._serverState = 'connected';
            server._reconnectInProgreess = false
            // Fire all callback errors
            return server.__executeAllCallbacksWithError(new Error("failed to reconnect to server"***REMOVED******REMOVED***;
        ***REMOVED*** else {
            return setTimeout(__attemptReconnect(server***REMOVED***, server.db.retryMiliSeconds***REMOVED***;
        ***REMOVED***
      ***REMOVED*** else {
          // Set as authenticating (isConnected will be false***REMOVED***
          server._serverState = 'authenticating';
          // Apply any auths, we don't try to catch any errors here
          // as there are nowhere to simply propagate them to
          self._apply_auths(server.db, function(err, result***REMOVED*** {            
            server._serverState = 'connected';
            server._reconnectInProgreess = false;

            // If we have any buffered commands let's signal reconnect event
            if(server._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
              server.emit('reconnect'***REMOVED***;
          ***REMOVED***

            // Execute any buffered reads and writes
            server._commandsStore.execute_queries(***REMOVED***;
            server._commandsStore.execute_writes(***REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED*** 
    ***REMOVED******REMOVED***;      
  ***REMOVED***
***REMOVED***

  // If we have a parser error we are in an unknown state, close everything and emit
  // error
  connectionPool.on("parseError", function(err***REMOVED*** {
    // If pool connection is already closed
    if(server._serverState === 'disconnected' 
      || server._serverState === 'destroyed'***REMOVED*** return;
    // Set server state to disconnected
    server._serverState = 'disconnected';
    // If we have a callback return the error
    if(typeof callback === 'function'***REMOVED*** {
      // ensure no callbacks get called twice
      var internalCallback = callback;
      callback = null;
      // Perform callback
      internalCallback(utils.toError(err***REMOVED***, null, server***REMOVED***;
  ***REMOVED*** else if(server.isSetMember(***REMOVED******REMOVED*** {
      if(server.listeners("parseError"***REMOVED*** && server.listeners("parseError"***REMOVED***.length > 0***REMOVED*** server.emit("parseError", utils.toError(err***REMOVED***, server***REMOVED***;
  ***REMOVED*** else {
      if(eventReceiver.listeners("parseError"***REMOVED*** && eventReceiver.listeners("parseError"***REMOVED***.length > 0***REMOVED*** eventReceiver.emit("parseError", utils.toError(err***REMOVED***, server***REMOVED***;
  ***REMOVED***

    // If we are a single server connection fire errors correctly
    if(!server.isSetMember(***REMOVED******REMOVED*** {
      // Fire all callback errors
      server.__executeAllCallbacksWithError(utils.toError(err***REMOVED******REMOVED***;
      // Emit error
      server._emitAcrossAllDbInstances(server, eventReceiver, "parseError", server, null, true***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;

  // Boot up connection poole, pass in a locator of callbacks
  connectionPool.start(***REMOVED***;
}

/**
 * @ignore
 */
Server.prototype.allRawConnections = function(***REMOVED*** {
  return this.connectionPool != null ? this.connectionPool.getAllConnections(***REMOVED*** : [];
}

/**
 * Check if a writer can be provided
 * @ignore
 */
var canCheckoutWriter = function(self, read***REMOVED*** {
  // We cannot write to an arbiter or secondary server
  if(self.isMasterDoc && self.isMasterDoc['arbiterOnly'] == true***REMOVED*** {
    return new Error("Cannot write to an arbiter"***REMOVED***;
***REMOVED*** if(self.isMasterDoc && self.isMasterDoc['secondary'] == true***REMOVED*** {
    return new Error("Cannot write to a secondary"***REMOVED***;
***REMOVED*** else if(read == true && self._readPreference == ReadPreference.SECONDARY && self.isMasterDoc && self.isMasterDoc['ismaster'] == true***REMOVED*** {
    return new Error("Cannot read from primary when secondary only specified"***REMOVED***;
***REMOVED*** else if(!self.isMasterDoc***REMOVED*** {
    return new Error("Cannot determine state of server"***REMOVED***;
***REMOVED***

  // Return no error
  return null;
}

/**
 * @ignore
 */
Server.prototype.checkoutWriter = function(read***REMOVED*** {
  if(this._serverState == 'disconnected' || this._serverState == 'destroyed'***REMOVED***
    return null;
  if(read == true***REMOVED*** return this.connectionPool.checkoutConnection(***REMOVED***;
  // Check if are allowed to do a checkout (if we try to use an arbiter f.ex***REMOVED***
  var result = canCheckoutWriter(this, read***REMOVED***;
  // If the result is null check out a writer
  if(result == null && this.connectionPool != null***REMOVED*** {
    var connection = this.connectionPool.checkoutConnection(***REMOVED***;
    // Add server capabilities to the connection
    if(connection***REMOVED***
      connection.serverCapabilities = this.serverCapabilities;
    return connection;
***REMOVED*** else if(result == null***REMOVED*** {
    return null;
***REMOVED*** else {
    return result;
***REMOVED***
}

/**
 * Check if a reader can be provided
 * @ignore
 */
var canCheckoutReader = function(self***REMOVED*** {
  // We cannot write to an arbiter or secondary server
  if(self.isMasterDoc && self.isMasterDoc['arbiterOnly'] == true && self.isSetMember(***REMOVED******REMOVED*** {
    return new Error("Cannot write to an arbiter"***REMOVED***;
***REMOVED*** else if(self._readPreference != null***REMOVED*** {
    // If the read preference is Primary and the instance is not a master return an error
    if((self._readPreference == ReadPreference.PRIMARY***REMOVED*** && self.isMasterDoc && self.isMasterDoc['ismaster'] != true***REMOVED*** {
      return new Error("Read preference is Server.PRIMARY and server is not master"***REMOVED***;
  ***REMOVED*** else if(self._readPreference == ReadPreference.SECONDARY && self.isMasterDoc && self.isMasterDoc['ismaster'] == true***REMOVED*** {
      return new Error("Cannot read from primary when secondary only specified"***REMOVED***;
  ***REMOVED***
***REMOVED*** else if(!self.isMasterDoc***REMOVED*** {
    return new Error("Cannot determine state of server"***REMOVED***;
***REMOVED***

  // Return no error
  return null;
}

/**
 * @ignore
 */
Server.prototype.checkoutReader = function(read***REMOVED*** {
  if(this._serverState == 'disconnected' || this._serverState == 'destroyed'***REMOVED***
    return null;
  // Check if are allowed to do a checkout (if we try to use an arbiter f.ex***REMOVED***
  var result = canCheckoutReader(this***REMOVED***;
  // If the result is null check out a writer
  if(result == null && this.connectionPool != null***REMOVED*** {
    var connection = this.connectionPool.checkoutConnection(***REMOVED***;
    // Add server capabilities to the connection
    if(connection***REMOVED***
      connection.serverCapabilities = this.serverCapabilities;
    return connection;
***REMOVED*** else if(result == null***REMOVED*** {
    return null;
***REMOVED*** else {
    return result;
***REMOVED***
}

/**
 * @ignore
 */
Server.prototype.enableRecordQueryStats = function(enable***REMOVED*** {
  this.recordQueryStats = enable;
}

/**
 * Internal statistics object used for calculating average and standard devitation on
 * running queries
 * @ignore
 */
var RunningStats = function(***REMOVED*** {
  var self = this;
  this.m_n = 0;
  this.m_oldM = 0.0;
  this.m_oldS = 0.0;
  this.m_newM = 0.0;
  this.m_newS = 0.0;

  // Define getters
  Object.defineProperty(this, "numDataValues", { enumerable: true
    , get: function (***REMOVED*** { return this.m_n; }
***REMOVED******REMOVED***;

  Object.defineProperty(this, "mean", { enumerable: true
    , get: function (***REMOVED*** { return (this.m_n > 0***REMOVED*** ? this.m_newM : 0.0; }
***REMOVED******REMOVED***;

  Object.defineProperty(this, "variance", { enumerable: true
    , get: function (***REMOVED*** { return ((this.m_n > 1***REMOVED*** ? this.m_newS/(this.m_n - 1***REMOVED*** : 0.0***REMOVED***; }
***REMOVED******REMOVED***;

  Object.defineProperty(this, "standardDeviation", { enumerable: true
    , get: function (***REMOVED*** { return Math.sqrt(this.variance***REMOVED***; }
***REMOVED******REMOVED***;

  Object.defineProperty(this, "sScore", { enumerable: true
    , get: function (***REMOVED*** {
      var bottom = this.mean + this.standardDeviation;
      if(bottom == 0***REMOVED*** return 0;
      return ((2 * this.mean * this.standardDeviation***REMOVED***/(bottom***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
}

/**
 * @ignore
 */
RunningStats.prototype.push = function(x***REMOVED*** {
  // Update the number of samples
  this.m_n = this.m_n + 1;
  
  // See Knuth TAOCP vol 2, 3rd edition, page 232
  if(this.m_n == 1***REMOVED*** {
    this.m_oldM = this.m_newM = x;
    this.m_oldS = 0.0;
***REMOVED*** else {
    this.m_newM = this.m_oldM + (x - this.m_oldM***REMOVED*** / this.m_n;
    this.m_newS = this.m_oldS + (x - this.m_oldM***REMOVED*** * (x - this.m_newM***REMOVED***;
    // set up for next iteration
    this.m_oldM = this.m_newM;
    this.m_oldS = this.m_newS;
***REMOVED***
}

/**
 * @ignore
 */
Object.defineProperty(Server.prototype, "autoReconnect", { enumerable: true
  , get: function (***REMOVED*** {
      return this.options['auto_reconnect'] == null ? false : this.options['auto_reconnect'];
  ***REMOVED***
}***REMOVED***;

/**
 * @ignore
 */
Object.defineProperty(Server.prototype, "connection", { enumerable: true
  , get: function (***REMOVED*** {
      return this.internalConnection;
  ***REMOVED***
  , set: function(connection***REMOVED*** {
      this.internalConnection = connection;
  ***REMOVED***
}***REMOVED***;

/**
 * @ignore
 */
Object.defineProperty(Server.prototype, "master", { enumerable: true
  , get: function (***REMOVED*** {
      return this.internalMaster;
  ***REMOVED***
  , set: function(value***REMOVED*** {
      this.internalMaster = value;
  ***REMOVED***
}***REMOVED***;

/**
 * @ignore
 */
Object.defineProperty(Server.prototype, "primary", { enumerable: true
  , get: function (***REMOVED*** {
      return this;
  ***REMOVED***
}***REMOVED***;

/**
 * Getter for query Stats
 * @ignore
 */
Object.defineProperty(Server.prototype, "queryStats", { enumerable: true
  , get: function (***REMOVED*** {
      return this._state.runtimeStats.queryStats;
  ***REMOVED***
}***REMOVED***;

/**
 * @ignore
 */
Object.defineProperty(Server.prototype, "runtimeStats", { enumerable: true
  , get: function (***REMOVED*** {
      return this._state.runtimeStats;
  ***REMOVED***
}***REMOVED***;

/**
 * Get Read Preference method
 * @ignore
 */
Object.defineProperty(Server.prototype, "readPreference", { enumerable: true
  , get: function (***REMOVED*** {
      if(this._readPreference == null && this.readSecondary***REMOVED*** {
        return Server.READ_SECONDARY;
    ***REMOVED*** else if(this._readPreference == null && !this.readSecondary***REMOVED*** {
        return Server.READ_PRIMARY;
    ***REMOVED*** else {
        return this._readPreference;
    ***REMOVED***
  ***REMOVED***
}***REMOVED***;

/**
 * @ignore
 */
exports.Server = Server;
