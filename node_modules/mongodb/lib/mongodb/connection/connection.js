var utils = require('./connection_utils'***REMOVED***,
  inherits = require('util'***REMOVED***.inherits,
  net = require('net'***REMOVED***,
  EventEmitter = require('events'***REMOVED***.EventEmitter,
  inherits = require('util'***REMOVED***.inherits,
  binaryutils = require('../utils'***REMOVED***,
  tls = require('tls'***REMOVED***;

var Connection = exports.Connection = function(id, socketOptions***REMOVED*** {
  var self = this;
  // Set up event emitter
  EventEmitter.call(this***REMOVED***;
  // Store all socket options
  this.socketOptions = socketOptions ? socketOptions : {host:'localhost', port:27017, domainSocket:false};
  // Set keep alive default if not overriden
  if(this.socketOptions.keepAlive == null && (process.platform !== "sunos" || process.platform !== "win32"***REMOVED******REMOVED*** this.socketOptions.keepAlive = 100;
  // Id for the connection
  this.id = id;
  // State of the connection
  this.connected = false;
  // Set if this is a domain socket
  this.domainSocket = this.socketOptions.domainSocket;

  // Supported min and max wire protocol
  this.minWireVersion = 0;
  this.maxWireVersion = 2;

  //
  // Connection parsing state
  //
  this.maxBsonSize = socketOptions.maxBsonSize ? socketOptions.maxBsonSize : Connection.DEFAULT_MAX_BSON_SIZE;
  this.maxMessageSizeBytes = socketOptions.maxMessageSizeBytes ? socketOptions.maxMessageSizeBytes : Connection.DEFAULT_MAX_MESSAGE_SIZE;
  this.maxNumberOfDocsInBatch = socketOptions.maxWriteBatchSize ? socketOptions.maxWriteBatchSize : Connection.DEFAULT_MAX_WRITE_BATCH_SIZE;
  // Contains the current message bytes
  this.buffer = null;
  // Contains the current message size
  this.sizeOfMessage = 0;
  // Contains the readIndex for the messaage
  this.bytesRead = 0;
  // Contains spill over bytes from additional messages
  this.stubBuffer = 0;

  // Just keeps list of events we allow
  this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[], timeout:[], end:[]};

  // Just keeps list of events we allow
  resetHandlers(this, false***REMOVED***;
  
  // Bson object
  this.maxBsonSettings = {
      disableDriverBSONSizeCheck: this.socketOptions['disableDriverBSONSizeCheck'] || false
    , maxBsonSize: this.maxBsonSize
    , maxMessageSizeBytes: this.maxMessageSizeBytes
***REMOVED***

  // Allow setting the socketTimeoutMS on all connections
  // to work around issues such as secondaries blocking due to compaction
  Object.defineProperty(this, "socketTimeoutMS", {
      enumerable: true
    , get: function (***REMOVED*** { return self.socketOptions.socketTimeoutMS; }
    , set: function (value***REMOVED*** { 
      // Set the socket timeoutMS value
      self.socketOptions.socketTimeoutMS = value;
      // Set the physical connection timeout
      self.connection.setTimeout(self.socketOptions.socketTimeoutMS***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;  
}

// Set max bson size
Connection.DEFAULT_MAX_BSON_SIZE = 1024 * 1024 * 4;
// Set default to max bson to avoid overflow or bad guesses
Connection.DEFAULT_MAX_MESSAGE_SIZE = Connection.DEFAULT_MAX_BSON_SIZE;
// Max default write bulk ops
Connection.DEFAULT_MAX_WRITE_BATCH_SIZE = 2000;

// Inherit event emitter so we can emit stuff wohoo
inherits(Connection, EventEmitter***REMOVED***;

Connection.prototype.start = function(***REMOVED*** {
  var self = this;

  // If we have a normal connection
  if(this.socketOptions.ssl***REMOVED*** {
    // Create new connection instance
    if(this.domainSocket***REMOVED*** {
      this.connection = net.createConnection(this.socketOptions.host***REMOVED***;
  ***REMOVED*** else {
      this.connection = net.createConnection(this.socketOptions.port, this.socketOptions.host***REMOVED***;
  ***REMOVED***
    if(this.logger != null && this.logger.doDebug***REMOVED***{
      this.logger.debug("opened connection", this.socketOptions***REMOVED***;
  ***REMOVED***

    // Set options on the socket
    this.connection.setTimeout(this.socketOptions.connectTimeoutMS != null ? this.socketOptions.connectTimeoutMS : this.socketOptions.timeout***REMOVED***;
    // Work around for 0.4.X
    if(process.version.indexOf("v0.4"***REMOVED*** == -1***REMOVED*** this.connection.setNoDelay(this.socketOptions.noDelay***REMOVED***;
    // Set keep alive if defined
    if(process.version.indexOf("v0.4"***REMOVED*** == -1***REMOVED*** {
      if(this.socketOptions.keepAlive > 0***REMOVED*** {
        this.connection.setKeepAlive(true, this.socketOptions.keepAlive***REMOVED***;
    ***REMOVED*** else {
        this.connection.setKeepAlive(false***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    // Check if the driver should validate the certificate
    var validate_certificates = this.socketOptions.sslValidate == true ? true : false;

    // Create options for the tls connection
    var tls_options = {
        socket: this.connection
      , rejectUnauthorized: false
  ***REMOVED***

    // If we wish to validate the certificate we have provided a ca store
    if(validate_certificates***REMOVED*** {
      tls_options.ca = this.socketOptions.sslCA;
  ***REMOVED***

    // If we have a certificate to present
    if(this.socketOptions.sslCert***REMOVED*** {      
      tls_options.cert = this.socketOptions.sslCert;
      tls_options.key = this.socketOptions.sslKey;
  ***REMOVED***

    // If the driver has been provided a private key password
    if(this.socketOptions.sslPass***REMOVED*** {
      tls_options.passphrase = this.socketOptions.sslPass;
  ***REMOVED***

    // Contains the cleartext stream
    var cleartext = null;
    // Attempt to establish a TLS connection to the server
    try {
      cleartext = tls.connect(this.socketOptions.port, this.socketOptions.host, tls_options, function(***REMOVED*** {      
        // If we have a ssl certificate validation error return an error
        if(cleartext.authorizationError && validate_certificates***REMOVED*** {          
          // Emit an error
          return self.emit("error", cleartext.authorizationError, self, {ssl:true}***REMOVED***;        
      ***REMOVED***
        
        // Connect to the server
        connectHandler(self***REMOVED***(***REMOVED***;
    ***REMOVED******REMOVED***      
  ***REMOVED*** catch(err***REMOVED*** {
      return self.emit("error", "SSL connection failed", self, {ssl:true}***REMOVED***;
  ***REMOVED***

    // Save the output stream
    this.writeSteam = cleartext;

    // Set up data handler for the clear stream
    cleartext.on("data", createDataHandler(this***REMOVED******REMOVED***;
    // Do any handling of end event of the stream
    cleartext.on("end", endHandler(this***REMOVED******REMOVED***;
    cleartext.on("error", errorHandler(this***REMOVED******REMOVED***;    

    // Handle any errors
    this.connection.on("error", errorHandler(this***REMOVED******REMOVED***;    
    // Handle timeout
    this.connection.on("timeout", timeoutHandler(this***REMOVED******REMOVED***;
    // Handle drain event
    this.connection.on("drain", drainHandler(this***REMOVED******REMOVED***;
    // Handle the close event
    this.connection.on("close", closeHandler(this***REMOVED******REMOVED***;
***REMOVED*** else {
    // Create new connection instance
    if(this.domainSocket***REMOVED*** {
      this.connection = net.createConnection(this.socketOptions.host***REMOVED***;
  ***REMOVED*** else {
      this.connection = net.createConnection(this.socketOptions.port, this.socketOptions.host***REMOVED***;
  ***REMOVED***
    if(this.logger != null && this.logger.doDebug***REMOVED***{
      this.logger.debug("opened connection", this.socketOptions***REMOVED***;
  ***REMOVED***

    // Set options on the socket
    this.connection.setTimeout(this.socketOptions.connectTimeoutMS != null ? this.socketOptions.connectTimeoutMS : this.socketOptions.timeout***REMOVED***;
    // Work around for 0.4.X
    if(process.version.indexOf("v0.4"***REMOVED*** == -1***REMOVED*** this.connection.setNoDelay(this.socketOptions.noDelay***REMOVED***;
    // Set keep alive if defined
    if(process.version.indexOf("v0.4"***REMOVED*** == -1***REMOVED*** {
      if(this.socketOptions.keepAlive > 0***REMOVED*** {
        this.connection.setKeepAlive(true, this.socketOptions.keepAlive***REMOVED***;
    ***REMOVED*** else {
        this.connection.setKeepAlive(false***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    // Set up write stream
    this.writeSteam = this.connection;
    // Add handlers
    this.connection.on("error", errorHandler(this***REMOVED******REMOVED***;
    // Add all handlers to the socket to manage it
    this.connection.on("connect", connectHandler(this***REMOVED******REMOVED***;
    // this.connection.on("end", endHandler(this***REMOVED******REMOVED***;
    this.connection.on("data", createDataHandler(this***REMOVED******REMOVED***;
    this.connection.on("timeout", timeoutHandler(this***REMOVED******REMOVED***;
    this.connection.on("drain", drainHandler(this***REMOVED******REMOVED***;
    this.connection.on("close", closeHandler(this***REMOVED******REMOVED***;
***REMOVED***
}

// Check if the sockets are live
Connection.prototype.isConnected = function(***REMOVED*** {
  return this.connected && !this.connection.destroyed && this.connection.writable && this.connection.readable;
}

// Validate if the driver supports this server
Connection.prototype.isCompatible = function(***REMOVED*** {
  if(this.serverCapabilities == null***REMOVED*** return true;
  // Is compatible with backward server
  if(this.serverCapabilities.minWireVersion == 0 
    && this.serverCapabilities.maxWireVersion ==0***REMOVED*** return true;

  // Check if we overlap
  if(this.serverCapabilities.minWireVersion >= this.minWireVersion
    && this.serverCapabilities.maxWireVersion <= this.maxWireVersion***REMOVED*** return true;

  // Not compatible
  return false;
}

// Write the data out to the socket
Connection.prototype.write = function(command, callback***REMOVED*** {
  try {
    // If we have a list off commands to be executed on the same socket
    if(Array.isArray(command***REMOVED******REMOVED*** {
      for(var i = 0; i < command.length; i++***REMOVED*** {
        try {
          // Pass in the bson validation settings (validate early***REMOVED***
          var binaryCommand = command[i].toBinary(this.maxBsonSettings***REMOVED***

          if(this.logger != null && this.logger.doDebug***REMOVED*** 
            this.logger.debug("writing command to mongodb", {binary: binaryCommand, json: command[i]}***REMOVED***;

          this.writeSteam.write(binaryCommand***REMOVED***;
      ***REMOVED*** catch(err***REMOVED*** {
          return callback(err, null***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
      try {
        // Pass in the bson validation settings (validate early***REMOVED***
        var binaryCommand = command.toBinary(this.maxBsonSettings***REMOVED***
        // Do we have a logger active log the event
        if(this.logger != null && this.logger.doDebug***REMOVED*** 
          this.logger.debug("writing command to mongodb", {binary: binaryCommand, json: command}***REMOVED***;
        // Write the binary command out to socket
        this.writeSteam.write(binaryCommand***REMOVED***;
    ***REMOVED*** catch(err***REMOVED*** {
        return callback(err, null***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED*** catch (err***REMOVED*** {
    if(typeof callback === 'function'***REMOVED*** callback(err***REMOVED***;
***REMOVED***
}

// Force the closure of the connection
Connection.prototype.close = function(***REMOVED*** {
  // clear out all the listeners
  resetHandlers(this, true***REMOVED***;
  // Add a dummy error listener to catch any weird last moment errors (and ignore them***REMOVED***
  this.connection.on("error", function(***REMOVED*** {}***REMOVED***
  // destroy connection
  this.connection.destroy(***REMOVED***;
  if(this.logger != null && this.logger.doDebug***REMOVED***{
    this.logger.debug("closed connection", this.connection***REMOVED***;
***REMOVED***
}

// Reset all handlers
var resetHandlers = function(self, clearListeners***REMOVED*** {
  self.eventHandlers = {error:[], connect:[], close:[], end:[], timeout:[], parseError:[], message:[]};

  // If we want to clear all the listeners
  if(clearListeners && self.connection != null***REMOVED*** {
    var keys = Object.keys(self.eventHandlers***REMOVED***;
    // Remove all listeners
    for(var i = 0; i < keys.length; i++***REMOVED*** {
      self.connection.removeAllListeners(keys[i]***REMOVED***;
  ***REMOVED***
***REMOVED***
}

//
// Handlers
//

// Connect handler
var connectHandler = function(self***REMOVED*** {
  return function(data***REMOVED*** {
    // Set connected
    self.connected = true;
    // Now that we are connected set the socket timeout
    self.connection.setTimeout(self.socketOptions.socketTimeoutMS != null ? self.socketOptions.socketTimeoutMS : self.socketOptions.timeout***REMOVED***;
    // Emit the connect event with no error
    self.emit("connect", null, self***REMOVED***;
***REMOVED***
}

var createDataHandler = exports.Connection.createDataHandler = function(self***REMOVED*** {
  // We need to handle the parsing of the data
  // and emit the messages when there is a complete one
  return function(data***REMOVED*** {
    // Parse until we are done with the data
    while(data.length > 0***REMOVED*** {
      // If we still have bytes to read on the current message
      if(self.bytesRead > 0 && self.sizeOfMessage > 0***REMOVED*** {
        // Calculate the amount of remaining bytes
        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;
        // Check if the current chunk contains the rest of the message
        if(remainingBytesToRead > data.length***REMOVED*** {
          // Copy the new data into the exiting buffer (should have been allocated when we know the message size***REMOVED***
          data.copy(self.buffer, self.bytesRead***REMOVED***;
          // Adjust the number of bytes read so it point to the correct index in the buffer
          self.bytesRead = self.bytesRead + data.length;

          // Reset state of buffer
          data = new Buffer(0***REMOVED***;
      ***REMOVED*** else {
          // Copy the missing part of the data into our current buffer
          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead***REMOVED***;
          // Slice the overflow into a new buffer that we will then re-parse
          data = data.slice(remainingBytesToRead***REMOVED***;

          // Emit current complete message
          try {
            var emitBuffer = self.buffer;
            // Reset state of buffer
            self.buffer = null;
            self.sizeOfMessage = 0;
            self.bytesRead = 0;
            self.stubBuffer = null;
            // Emit the buffer
            self.emit("message", emitBuffer, self***REMOVED***;
        ***REMOVED*** catch(err***REMOVED*** {
            var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
              sizeOfMessage:self.sizeOfMessage,
              bytesRead:self.bytesRead,
              stubBuffer:self.stubBuffer}};
            if(self.logger != null && self.logger.doError***REMOVED*** self.logger.error("parseError", errorObject***REMOVED***;
            // We got a parse Error fire it off then keep going
            self.emit("parseError", errorObject, self***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else {
        // Stub buffer is kept in case we don't get enough bytes to determine the
        // size of the message (< 4 bytes***REMOVED***
        if(self.stubBuffer != null && self.stubBuffer.length > 0***REMOVED*** {

          // If we have enough bytes to determine the message size let's do it
          if(self.stubBuffer.length + data.length > 4***REMOVED*** {
            // Prepad the data
            var newData = new Buffer(self.stubBuffer.length + data.length***REMOVED***;
            self.stubBuffer.copy(newData, 0***REMOVED***;
            data.copy(newData, self.stubBuffer.length***REMOVED***;
            // Reassign for parsing
            data = newData;

            // Reset state of buffer
            self.buffer = null;
            self.sizeOfMessage = 0;
            self.bytesRead = 0;
            self.stubBuffer = null;

        ***REMOVED*** else {

            // Add the the bytes to the stub buffer
            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length***REMOVED***;
            // Copy existing stub buffer
            self.stubBuffer.copy(newStubBuffer, 0***REMOVED***;
            // Copy missing part of the data
            data.copy(newStubBuffer, self.stubBuffer.length***REMOVED***;
            // Exit parsing loop
            data = new Buffer(0***REMOVED***;
        ***REMOVED***
      ***REMOVED*** else {
          if(data.length > 4***REMOVED*** {
            // Retrieve the message size
            var sizeOfMessage = binaryutils.decodeUInt32(data, 0***REMOVED***;
            // If we have a negative sizeOfMessage emit error and return
            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonSize***REMOVED*** {
              var errorObject = {err:"socketHandler", trace:'', bin:self.buffer, parseState:{
                sizeOfMessage: sizeOfMessage,
                bytesRead: self.bytesRead,
                stubBuffer: self.stubBuffer}};
              if(self.logger != null && self.logger.doError***REMOVED*** self.logger.error("parseError", errorObject***REMOVED***;
              // We got a parse Error fire it off then keep going
              self.emit("parseError", errorObject, self***REMOVED***;
              return;
          ***REMOVED***

            // Ensure that the size of message is larger than 0 and less than the max allowed
            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonSize && sizeOfMessage > data.length***REMOVED*** {
              self.buffer = new Buffer(sizeOfMessage***REMOVED***;
              // Copy all the data into the buffer
              data.copy(self.buffer, 0***REMOVED***;
              // Update bytes read
              self.bytesRead = data.length;
              // Update sizeOfMessage
              self.sizeOfMessage = sizeOfMessage;
              // Ensure stub buffer is null
              self.stubBuffer = null;
              // Exit parsing loop
              data = new Buffer(0***REMOVED***;

          ***REMOVED*** else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonSize && sizeOfMessage == data.length***REMOVED*** {
              try {
                var emitBuffer = data;
                // Reset state of buffer
                self.buffer = null;
                self.sizeOfMessage = 0;
                self.bytesRead = 0;
                self.stubBuffer = null;
                // Exit parsing loop
                data = new Buffer(0***REMOVED***;
                // Emit the message
                self.emit("message", emitBuffer, self***REMOVED***;
            ***REMOVED*** catch (err***REMOVED*** {
                var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
                  sizeOfMessage:self.sizeOfMessage,
                  bytesRead:self.bytesRead,
                  stubBuffer:self.stubBuffer}};
                if(self.logger != null && self.logger.doError***REMOVED*** self.logger.error("parseError", errorObject***REMOVED***;
                // We got a parse Error fire it off then keep going
                self.emit("parseError", errorObject, self***REMOVED***;
            ***REMOVED***
          ***REMOVED*** else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonSize***REMOVED*** {
              var errorObject = {err:"socketHandler", trace:null, bin:data, parseState:{
                sizeOfMessage:sizeOfMessage,
                bytesRead:0,
                buffer:null,
                stubBuffer:null}};
              if(self.logger != null && self.logger.doError***REMOVED*** self.logger.error("parseError", errorObject***REMOVED***;
              // We got a parse Error fire it off then keep going
              self.emit("parseError", errorObject, self***REMOVED***;

              // Clear out the state of the parser
              self.buffer = null;
              self.sizeOfMessage = 0;
              self.bytesRead = 0;
              self.stubBuffer = null;
              // Exit parsing loop
              data = new Buffer(0***REMOVED***;

          ***REMOVED*** else {
              try {
                var emitBuffer = data.slice(0, sizeOfMessage***REMOVED***;
                // Reset state of buffer
                self.buffer = null;
                self.sizeOfMessage = 0;
                self.bytesRead = 0;
                self.stubBuffer = null;
                // Copy rest of message
                data = data.slice(sizeOfMessage***REMOVED***;
                // Emit the message
                self.emit("message", emitBuffer, self***REMOVED***;
            ***REMOVED*** catch (err***REMOVED*** {
                var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
                  sizeOfMessage:sizeOfMessage,
                  bytesRead:self.bytesRead,
                  stubBuffer:self.stubBuffer}};
                if(self.logger != null && self.logger.doError***REMOVED*** self.logger.error("parseError", errorObject***REMOVED***;
                // We got a parse Error fire it off then keep going
                self.emit("parseError", errorObject, self***REMOVED***;
            ***REMOVED***

          ***REMOVED***
        ***REMOVED*** else {
            // Create a buffer that contains the space for the non-complete message
            self.stubBuffer = new Buffer(data.length***REMOVED***
            // Copy the data to the stub buffer
            data.copy(self.stubBuffer, 0***REMOVED***;
            // Exit parsing loop
            data = new Buffer(0***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
}

var endHandler = function(self***REMOVED*** {
  return function(***REMOVED*** {
    // Set connected to false
    self.connected = false;
    // Emit end event
    self.emit("end", {err: 'connection received Fin packet from [' + self.socketOptions.host + ':' + self.socketOptions.port + ']'}, self***REMOVED***;
***REMOVED***
}

var timeoutHandler = function(self***REMOVED*** {
  return function(***REMOVED*** {
    // Set connected to false
    self.connected = false;
    // Emit timeout event
    self.emit("timeout", {err: 'connection to [' + self.socketOptions.host + ':' + self.socketOptions.port + '] timed out'}, self***REMOVED***;
***REMOVED***
}

var drainHandler = function(self***REMOVED*** {
  return function(***REMOVED*** {
***REMOVED***
}

var errorHandler = function(self***REMOVED*** {
  return function(err***REMOVED*** {
    self.connection.destroy(***REMOVED***;
    // Set connected to false
    self.connected = false;
    // Emit error
    self.emit("error", {err: 'failed to connect to [' + self.socketOptions.host + ':' + self.socketOptions.port + ']'}, self***REMOVED***;
***REMOVED***
}

var closeHandler = function(self***REMOVED*** {
  return function(hadError***REMOVED*** {
    // If we have an error during the connection phase
    if(hadError && !self.connected***REMOVED*** {
      // Set disconnected
      self.connected = false;
      // Emit error
      self.emit("error", {err: 'failed to connect to [' + self.socketOptions.host + ':' + self.socketOptions.port + ']'}, self***REMOVED***;
  ***REMOVED*** else {
      // Set disconnected
      self.connected = false;
      // Emit close
      self.emit("close", {err: 'connection closed to [' + self.socketOptions.host + ':' + self.socketOptions.port + ']'}, self***REMOVED***;
  ***REMOVED***
***REMOVED***
}

// Some basic defaults
Connection.DEFAULT_PORT = 27017;







