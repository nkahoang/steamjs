var Server = require("../../server"***REMOVED***.Server
  , format = require('util'***REMOVED***.format;

// The ping strategy uses pings each server and records the
// elapsed time for the server so it can pick a server based on lowest
// return time for the db command {ping:true}
var PingStrategy = exports.PingStrategy = function(replicaset, secondaryAcceptableLatencyMS***REMOVED*** {
  this.replicaset = replicaset;
  this.secondaryAcceptableLatencyMS = secondaryAcceptableLatencyMS;
  this.state = 'disconnected';
  // Interval of ping attempts
  this.pingInterval = replicaset.options.socketOptions.pingInterval || 5000;
  // Timeout for ping response, default - no timeout
  this.pingTimeout = replicaset.options.socketOptions.pingTimeout || null;
  // Class instance
  this.Db = require("../../../db"***REMOVED***.Db;
  // Active db connections
  this.dbs = {};
  // Current server index
  this.index = 0;
  // Logger api
  this.Logger = null;
}

// Starts any needed code
PingStrategy.prototype.start = function(callback***REMOVED*** {
  // already running?
  if ('connected' == this.state***REMOVED*** return;

  this.state = 'connected';

  // Start ping server
  this._pingServer(callback***REMOVED***;
}

// Stops and kills any processes running
PingStrategy.prototype.stop = function(callback***REMOVED*** {
  // Stop the ping process
  this.state = 'disconnected';

  // Stop all the server instances
  for(var key in this.dbs***REMOVED*** {
    this.dbs[key].close(***REMOVED***;
***REMOVED***

  // optional callback
  callback && callback(null, null***REMOVED***;
}

PingStrategy.prototype.checkoutConnection = function(tags, secondaryCandidates***REMOVED*** {
  // Servers are picked based on the lowest ping time and then servers that lower than that + secondaryAcceptableLatencyMS
  // Create a list of candidat servers, containing the primary if available
  var candidateServers = [];
  var self = this;

  // If we have not provided a list of candidate servers use the default setup
  if(!Array.isArray(secondaryCandidates***REMOVED******REMOVED*** {
    candidateServers = this.replicaset._state.master != null ? [this.replicaset._state.master] : [];
    // Add all the secondaries
    var keys = Object.keys(this.replicaset._state.secondaries***REMOVED***;
    for(var i = 0; i < keys.length; i++***REMOVED*** {
      candidateServers.push(this.replicaset._state.secondaries[keys[i]]***REMOVED***
  ***REMOVED***
***REMOVED*** else {
    candidateServers = secondaryCandidates;
***REMOVED***

  // Final list of eligable server
  var finalCandidates = [];

  // If we have tags filter by tags
  if(tags != null && typeof tags == 'object'***REMOVED*** {
    // If we have an array or single tag selection
    var tagObjects = Array.isArray(tags***REMOVED*** ? tags : [tags];
    // Iterate over all tags until we find a candidate server
    for(var _i = 0; _i < tagObjects.length; _i++***REMOVED*** {
      // Grab a tag object
      var tagObject = tagObjects[_i];
      // Matching keys
      var matchingKeys = Object.keys(tagObject***REMOVED***;
      // Remove any that are not tagged correctly
      for(var i = 0; i < candidateServers.length; i++***REMOVED*** {
        var server = candidateServers[i];
        // If we have tags match
        if(server.tags != null***REMOVED*** {
          var matching = true;

          // Ensure we have all the values
          for(var j = 0; j < matchingKeys.length; j++***REMOVED*** {
            if(server.tags[matchingKeys[j]] != tagObject[matchingKeys[j]]***REMOVED*** {
              matching = false;
              break;
          ***REMOVED***
        ***REMOVED***

          // If we have a match add it to the list of matching servers
          if(matching***REMOVED*** {
            finalCandidates.push(server***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else {
    // Final array candidates
    var finalCandidates = candidateServers;
***REMOVED***

  // Filter out any non-connected servers
  finalCandidates = finalCandidates.filter(function(s***REMOVED*** {
    return s.isConnected(***REMOVED***;
***REMOVED******REMOVED***

  // Sort by ping time
  finalCandidates.sort(function(a, b***REMOVED*** {
    return a.runtimeStats['pingMs'] > b.runtimeStats['pingMs'];
***REMOVED******REMOVED***;

  if(0 === finalCandidates.length***REMOVED***
    return new Error("No replica set members available for query"***REMOVED***;

  // find lowest server with a ping time
  var lowest = finalCandidates.filter(function (server***REMOVED*** {
    return undefined != server.runtimeStats.pingMs;
***REMOVED******REMOVED***[0];

  if(!lowest***REMOVED*** {
    lowest = finalCandidates[0];
***REMOVED***

  // convert to integer
  var lowestPing = lowest.runtimeStats.pingMs | 0;
  
  // determine acceptable latency
  var acceptable = lowestPing + this.secondaryAcceptableLatencyMS;

  // remove any server responding slower than acceptable
  var len = finalCandidates.length;
  while(len--***REMOVED*** {
    if(finalCandidates[len].runtimeStats['pingMs'] > acceptable***REMOVED*** {
      finalCandidates.splice(len, 1***REMOVED***;
  ***REMOVED***
***REMOVED***

  if(self.logger && self.logger.debug***REMOVED*** {    
    self.logger.debug("Ping strategy selection order for tags", tags***REMOVED***;
    finalCandidates.forEach(function(c***REMOVED*** {
      self.logger.debug(format("%s:%s = %s ms", c.host, c.port, c.runtimeStats['pingMs']***REMOVED***, null***REMOVED***;
  ***REMOVED******REMOVED***    
***REMOVED***

  // If no candidates available return an error
  if(finalCandidates.length == 0***REMOVED***
    return new Error("No replica set members available for query"***REMOVED***;

  // Ensure no we don't overflow
  this.index = this.index % finalCandidates.length
  // Pick a random acceptable server  
  var connection = finalCandidates[this.index].checkoutReader(***REMOVED***;
  // Point to next candidate (round robin style***REMOVED***
  this.index = this.index + 1;

  if(self.logger && self.logger.debug***REMOVED*** {    
    if(connection***REMOVED***
      self.logger.debug("picked server %s:%s", connection.socketOptions.host, connection.socketOptions.port***REMOVED***;
***REMOVED***

  return connection;
}

PingStrategy.prototype._pingServer = function(callback***REMOVED*** {
  var self = this;

  // Ping server function
  var pingFunction = function(***REMOVED*** {
    // Our state changed to disconnected or destroyed return
    if(self.state == 'disconnected' || self.state == 'destroyed'***REMOVED*** return;
    // If the replicaset is destroyed return
    if(self.replicaset.isDestroyed(***REMOVED*** || self.replicaset._serverState == 'disconnected'***REMOVED*** return

    // Create a list of all servers we can send the ismaster command to
    var allServers = self.replicaset._state.master != null ? [self.replicaset._state.master] : [];

    // Secondary keys
    var keys = Object.keys(self.replicaset._state.secondaries***REMOVED***;
    // Add all secondaries
    for(var i = 0; i < keys.length; i++***REMOVED*** {
      allServers.push(self.replicaset._state.secondaries[keys[i]]***REMOVED***;
  ***REMOVED***

    // Number of server entries
    var numberOfEntries = allServers.length;

    // We got keys
    for(var i = 0; i < allServers.length; i++***REMOVED*** {

      // We got a server instance
      var server = allServers[i];

      // Create a new server object, avoid using internal connections as they might
      // be in an illegal state
      new function(serverInstance***REMOVED*** {
        var _db = self.dbs[serverInstance.host + ":" + serverInstance.port];
        // If we have a db
        if(_db != null***REMOVED*** {
          // Startup time of the command
          var startTime = Date.now(***REMOVED***;

          // Execute ping command in own scope
          var _ping = function(__db, __serverInstance***REMOVED*** {

            // Server unavailable. Checks only if pingTimeout defined & greater than 0
            var _failTimer = self.pingTimeout ? setTimeout(function (***REMOVED*** {
              if(null != __serverInstance.runtimeStats && __serverInstance.isConnected(***REMOVED******REMOVED*** {
                __serverInstance.close(***REMOVED***;
            ***REMOVED***
          ***REMOVED***, self.pingTimeout***REMOVED*** : null;

            // Execute ping on this connection
            __db.executeDbCommand({ping:1}, {failFast:true}, function(err***REMOVED*** {

              // Server available
              clearTimeout(_failTimer***REMOVED***;

              // Emit the ping
              self.replicaset.emit("ping", err, serverInstance***REMOVED***;

              if(err***REMOVED*** {
                delete self.dbs[__db.serverConfig.host + ":" + __db.serverConfig.port];
                __db.close(***REMOVED***;
                return done(***REMOVED***;
            ***REMOVED***

              if(null != __serverInstance.runtimeStats && __serverInstance.isConnected(***REMOVED******REMOVED*** {
                __serverInstance.runtimeStats['pingMs'] = Date.now(***REMOVED*** - startTime;
            ***REMOVED***

              __db.executeDbCommand({ismaster:1}, {failFast:true}, function(err, result***REMOVED*** {
                // Emit the ping
                self.replicaset.emit("ping_ismaster", err, result, serverInstance***REMOVED***;

                if(err***REMOVED*** {
                  delete self.dbs[__db.serverConfig.host + ":" + __db.serverConfig.port];
                  __db.close(***REMOVED***;
                  return done(***REMOVED***;
              ***REMOVED***

                // Process the ismaster for the server
                if(result && result.documents && self.replicaset.processIsMaster***REMOVED*** {
                  self.replicaset.processIsMaster(__serverInstance, result.documents[0]***REMOVED***;
              ***REMOVED***

                // Done with the pinging
                done(***REMOVED***;
            ***REMOVED******REMOVED***;
          ***REMOVED******REMOVED***;            
        ***REMOVED***;
          // Ping
          _ping(_db, serverInstance***REMOVED***;
      ***REMOVED*** else {
          var connectTimeoutMS = self.replicaset.options.socketOptions 
            ? self.replicaset.options.socketOptions.connectTimeoutMS : 0

          // Create a new master connection
          var _server = new Server(serverInstance.host, serverInstance.port, {
            auto_reconnect: false,
            returnIsMasterResults: true,
            slaveOk: true,
            poolSize: 1,
            socketOptions: { connectTimeoutMS: connectTimeoutMS },
            ssl: self.replicaset.options.ssl,
            sslValidate: self.replicaset.options.sslValidate,
            sslCA: self.replicaset.options.sslCA,
            sslCert: self.replicaset.options.sslCert,
            sslKey: self.replicaset.options.sslKey,
            sslPass: self.replicaset.options.sslPass
        ***REMOVED******REMOVED***;

          // Create Db instance        
          var _db = new self.Db('local', _server, { safe: true }***REMOVED***;
          _db.on("close", function(***REMOVED*** {
            delete self.dbs[this.serverConfig.host + ":" + this.serverConfig.port];
        ***REMOVED******REMOVED***

          var _ping = function(__db, __serverInstance***REMOVED*** {
            if(self.state == 'disconnected'***REMOVED*** {
              self.stop(***REMOVED***;
              return;
          ***REMOVED***

            __db.open(function(err, db***REMOVED*** {  
              // Emit ping connect
              self.replicaset.emit("ping_connect", err, __serverInstance***REMOVED***;

              if(self.state == 'disconnected' && __db != null***REMOVED*** {
                return __db.close(***REMOVED***;
            ***REMOVED***

              if(err***REMOVED*** {
                delete self.dbs[__db.serverConfig.host + ":" + __db.serverConfig.port];
                __db.close(***REMOVED***;
                return done(***REMOVED***;
            ***REMOVED***

              // Save instance
              self.dbs[__db.serverConfig.host + ":" + __db.serverConfig.port] = __db;

              // Startup time of the command
              var startTime = Date.now(***REMOVED***;

              // Execute ping on this connection
              __db.executeDbCommand({ping:1}, {failFast:true}, function(err***REMOVED*** {
                self.replicaset.emit("ping", err, __serverInstance***REMOVED***;
                
                if(err***REMOVED*** {
                  delete self.dbs[__db.serverConfig.host + ":" + __db.serverConfig.port];
                  __db.close(***REMOVED***;
                  return done(***REMOVED***;
              ***REMOVED***

                if(null != __serverInstance.runtimeStats && __serverInstance.isConnected(***REMOVED******REMOVED*** {
                  __serverInstance.runtimeStats['pingMs'] = Date.now(***REMOVED*** - startTime;
              ***REMOVED***

                __db.executeDbCommand({ismaster:1}, {failFast:true}, function(err, result***REMOVED*** {
                  self.replicaset.emit("ping_ismaster", err, result, __serverInstance***REMOVED***;

                  if(err***REMOVED*** {
                    delete self.dbs[__db.serverConfig.host + ":" + __db.serverConfig.port];
                    __db.close(***REMOVED***;
                    return done(***REMOVED***;
                ***REMOVED***
    
                  // Process the ismaster for the server
                  if(result && result.documents && self.replicaset.processIsMaster***REMOVED*** {
                    self.replicaset.processIsMaster(__serverInstance, result.documents[0]***REMOVED***;
                ***REMOVED***

                  // Done with the pinging
                  done(***REMOVED***;
              ***REMOVED******REMOVED***;
            ***REMOVED******REMOVED***;
          ***REMOVED******REMOVED***;            
        ***REMOVED***;

          // Ping the server
          _ping(_db, serverInstance***REMOVED***;
      ***REMOVED***

        function done(***REMOVED*** {
          // Adjust the number of checks
          numberOfEntries--;

          // If we are done with all results coming back trigger ping again
          if(0 === numberOfEntries && 'connected' == self.state***REMOVED*** {
            setTimeout(pingFunction, self.pingInterval***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***(server***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Start pingFunction
  pingFunction(***REMOVED***;

  callback && callback(null***REMOVED***;
}
