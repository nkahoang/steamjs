// The Statistics strategy uses the measure of each end-start time for each
// query executed against the db to calculate the mean, variance and standard deviation
// and pick the server which the lowest mean and deviation
var StatisticsStrategy = exports.StatisticsStrategy = function(replicaset***REMOVED*** {
  this.replicaset = replicaset;
  // Logger api
  this.Logger = null;  
}

// Starts any needed code
StatisticsStrategy.prototype.start = function(callback***REMOVED*** {
  callback && callback(null, null***REMOVED***;
}

StatisticsStrategy.prototype.stop = function(callback***REMOVED*** {
  callback && callback(null, null***REMOVED***;
}

StatisticsStrategy.prototype.checkoutConnection = function(tags, secondaryCandidates***REMOVED*** {
  // Servers are picked based on the lowest ping time and then servers that lower than that + secondaryAcceptableLatencyMS
  // Create a list of candidat servers, containing the primary if available
  var candidateServers = [];

  // If we have not provided a list of candidate servers use the default setup
  if(!Array.isArray(secondaryCandidates***REMOVED******REMOVED*** {
    candidateServers = this.replicaset._state.master != null ? [this.replicaset._state.master] : [];
    // Add all the secondaries
    var keys = Object.keys(this.replicaset._state.secondaries***REMOVED***;
    for(var i = 0; i < keys.length; i++***REMOVED*** {
      candidateServers.push(this.replicaset._state.secondaries[keys[i]]***REMOVED***
  ***REMOVED***
***REMOVED*** else {
    candidateServers = secondaryCandidates;
***REMOVED***

  // Final list of eligable server
  var finalCandidates = [];

  // If we have tags filter by tags
  if(tags != null && typeof tags == 'object'***REMOVED*** {
    // If we have an array or single tag selection
    var tagObjects = Array.isArray(tags***REMOVED*** ? tags : [tags];
    // Iterate over all tags until we find a candidate server
    for(var _i = 0; _i < tagObjects.length; _i++***REMOVED*** {
      // Grab a tag object
      var tagObject = tagObjects[_i];
      // Matching keys
      var matchingKeys = Object.keys(tagObject***REMOVED***;
      // Remove any that are not tagged correctly
      for(var i = 0; i < candidateServers.length; i++***REMOVED*** {
        var server = candidateServers[i];
        // If we have tags match
        if(server.tags != null***REMOVED*** {
          var matching = true;

          // Ensure we have all the values
          for(var j = 0; j < matchingKeys.length; j++***REMOVED*** {
            if(server.tags[matchingKeys[j]] != tagObject[matchingKeys[j]]***REMOVED*** {
              matching = false;
              break;
          ***REMOVED***
        ***REMOVED***

          // If we have a match add it to the list of matching servers
          if(matching***REMOVED*** {
            finalCandidates.push(server***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else {
    // Final array candidates
    var finalCandidates = candidateServers;
***REMOVED***

  finalCandidates.sort(function(a, b***REMOVED*** {
    return a.runtimeStats.queryStats.sScore > b.runtimeStats.queryStats.sScore;
***REMOVED******REMOVED***;

  // If no candidates available return an error
  if(finalCandidates.length == 0***REMOVED*** return new Error("No replica set members available for query"***REMOVED***;

  var bestCandidates = [finalCandidates[0]];
  for (var i = 1; i < finalCandidates.length; ++i***REMOVED*** {
    if (finalCandidates[i].runtimeStats.queryStats.sScore > finalCandidates[i - 1].runtimeStats.queryStats.sScore***REMOVED*** {
      break;
  ***REMOVED*** else {
      bestCandidates.push(finalCandidates[i]***REMOVED***;
  ***REMOVED***
***REMOVED***

  return bestCandidates[Math.floor(Math.random(***REMOVED*** * bestCandidates.length***REMOVED***].checkoutReader(***REMOVED***;
}
