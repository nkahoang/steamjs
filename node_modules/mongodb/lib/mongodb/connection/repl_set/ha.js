var DbCommand = require('../../commands/db_command'***REMOVED***.DbCommand
  , format = require('util'***REMOVED***.format;

var HighAvailabilityProcess = function(replset, options***REMOVED*** {  
  this.replset = replset;
  this.options = options;
  this.server = null;
  this.state = HighAvailabilityProcess.INIT;
  this.selectedIndex = 0;
}

HighAvailabilityProcess.INIT = 'init';
HighAvailabilityProcess.RUNNING = 'running';
HighAvailabilityProcess.STOPPED = 'stopped';

HighAvailabilityProcess.prototype.start = function(***REMOVED*** {  
  var self = this;
  if(this.replset._state 
    && Object.keys(this.replset._state.addresses***REMOVED***.length == 0***REMOVED*** {
    if(this.server***REMOVED*** this.server.close(***REMOVED***;
    this.state = HighAvailabilityProcess.STOPPED;
    return;      
***REMOVED***

  if(this.server***REMOVED*** this.server.close(***REMOVED***;
  // Start the running
  this._haProcessInProcess = false;
  this.state = HighAvailabilityProcess.RUNNING;
  
  // Get all possible reader servers
  var candidate_servers = this.replset._state.getAllReadServers(***REMOVED***;
  if(candidate_servers.length == 0***REMOVED*** {
    return;
***REMOVED***

  // Select a candidate server for the connection
  var server = candidate_servers[this.selectedIndex % candidate_servers.length];
  this.selectedIndex = this.selectedIndex + 1;
  
  // Unpack connection options
  var connectTimeoutMS = self.options.connectTimeoutMS || 10000;
  var socketTimeoutMS = self.options.socketTimeoutMS || 30000;

  // Just ensure we don't have a full cycle dependency
  var Db = require('../../db'***REMOVED***.Db
  var Server = require('../server'***REMOVED***.Server;

  // Set up a new server instance
  var newServer = new Server(server.host, server.port, {
      auto_reconnect: false
    , returnIsMasterResults: true
    , poolSize: 1
    , socketOptions: { 
        connectTimeoutMS: connectTimeoutMS,
        socketTimeoutMS: socketTimeoutMS,
        keepAlive: 100
    ***REMOVED***
    , ssl: self.replset.options.ssl
    , sslValidate: self.replset.options.sslValidate
    , sslCA: self.replset.options.sslCA
    , sslCert: self.replset.options.sslCert
    , sslKey: self.replset.options.sslKey
    , sslPass: self.replset.options.sslPass
***REMOVED******REMOVED***;

  // Create new dummy db for app
  self.db = new Db('local', newServer, {w:1}***REMOVED***;

  // Set up the event listeners
  newServer.once("error", _handle(this, newServer***REMOVED******REMOVED***;
  newServer.once("close", _handle(this, newServer***REMOVED******REMOVED***;
  newServer.once("timeout", _handle(this, newServer***REMOVED******REMOVED***;
  newServer.name = format("%s:%s", server.host, server.port***REMOVED***;

  // Let's attempt a connection over here
  newServer.connect(self.db, function(err, result, _server***REMOVED*** {
    // Emit ha_connect
    self.replset.emit("ha_connect", err, result, _server***REMOVED***;

    if(self.state == HighAvailabilityProcess.STOPPED***REMOVED*** {
      _server.close(***REMOVED***;
  ***REMOVED***

    if(err***REMOVED*** {
      // Close the server
      _server.close(***REMOVED***;
      // Check if we can even do HA (is there anything running***REMOVED***
      if(Object.keys(self.replset._state.addresses***REMOVED***.length == 0***REMOVED*** {
        return;
    ***REMOVED***
      
      // Let's boot the ha timeout settings
      setTimeout(function(***REMOVED*** {
        self.start(***REMOVED***;
    ***REMOVED***, self.options.haInterval***REMOVED***;
  ***REMOVED*** else {
      self.server = _server;
      // Let's boot the ha timeout settings
      setTimeout(_timeoutHandle(self***REMOVED***, self.options.haInterval***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
}

HighAvailabilityProcess.prototype.stop = function(***REMOVED*** {
  this.state = HighAvailabilityProcess.STOPPED;
  if(this.server***REMOVED*** this.server.close(***REMOVED***;
}

var _timeoutHandle = function(self***REMOVED*** {
  return function(***REMOVED*** {
    if(self.state == HighAvailabilityProcess.STOPPED***REMOVED*** {
      // Stop all server instances
      for(var name in self.replset._state.addresses***REMOVED*** {
        self.replset._state.addresses[name].close(***REMOVED***;
        delete self.replset._state.addresses[name];
    ***REMOVED***

      // Finished pinging
      return;
  ***REMOVED***

    // If the server is connected
    if(self.server.isConnected(***REMOVED*** && !self._haProcessInProcess***REMOVED*** {
      // Start HA process
      self._haProcessInProcess = true;
      // Execute is master command
      self.db._executeQueryCommand(DbCommand.createIsMasterCommand(self.db***REMOVED***, 
          {failFast:true, connection: self.server.checkoutReader(***REMOVED***}
        , function(err, res***REMOVED*** {
          // Emit ha event
          self.replset.emit("ha_ismaster", err, res***REMOVED***;

          // If we have an error close
          if(err***REMOVED*** {
            self.server.close(***REMOVED***;
            // Re-run loop
            return setTimeout(_timeoutHandle(self***REMOVED***, self.options.haInterval***REMOVED***;
        ***REMOVED***

          // Master document
          var master = res.documents[0];
          var hosts = master.hosts || [];
          var reconnect_servers = [];
          var state = self.replset._state;

          // We are in recovery mode, let's remove the current server
          if(!master.ismaster 
            && !master.secondary
            && state.addresses[master.me]***REMOVED*** {
              self.server.close(***REMOVED***;
              state.addresses[master.me].close(***REMOVED***;
              delete state.secondaries[master.me];
              // Re-run loop
              return setTimeout(_timeoutHandle(self***REMOVED***, self.options.haInterval***REMOVED***;
        ***REMOVED***

          // We have a new master different front he current one
          if((master.primary && state.master == null***REMOVED***
            || (master.primary && state.master.name != master.primary***REMOVED******REMOVED*** {

            // Locate the primary and set it
            if(state.addresses[master.primary]***REMOVED*** {
              if(state.master***REMOVED*** state.master.close(***REMOVED***;
              delete state.secondaries[master.primary];
              state.master = state.addresses[master.primary];
          ***REMOVED***

            // Emit joined event due to primary change
            self.replset.emit('joined', "primary", master, state.master***REMOVED***;
            
            // Set up the changes
            if(state.master != null && state.master.isMasterDoc != null***REMOVED*** {
              state.master.isMasterDoc.ismaster = true;
              state.master.isMasterDoc.secondary = false;                
          ***REMOVED*** else if(state.master != null***REMOVED*** {
              state.master.isMasterDoc = master;
              state.master.isMasterDoc.ismaster = true;
              state.master.isMasterDoc.secondary = false;                
          ***REMOVED***

            // If we have any buffered commands let's signal reconnect event
            if(self.replset._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
              self.replset.emit('reconnect'***REMOVED***;
          ***REMOVED***

            // Execute any waiting commands (queries or writes***REMOVED***
            self.replset._commandsStore.execute_queries(***REMOVED***;
            self.replset._commandsStore.execute_writes(***REMOVED***;   
        ***REMOVED***

          // For all the hosts let's check that we have connections
          for(var i = 0; i < hosts.length; i++***REMOVED*** {
            var host = hosts[i];
            
            // Check if we need to reconnect to a server
            if(state.addresses[host] == null***REMOVED*** {
              reconnect_servers.push(host***REMOVED***;
          ***REMOVED*** else if(state.addresses[host] && !state.addresses[host].isConnected(***REMOVED******REMOVED*** {
              state.addresses[host].close(***REMOVED***;
              delete state.secondaries[host];
              reconnect_servers.push(host***REMOVED***;              
          ***REMOVED***
        ***REMOVED***

          // Let's reconnect to any server needed
          if(reconnect_servers.length > 0***REMOVED*** {
            _reconnect_servers(self, reconnect_servers***REMOVED***;  
        ***REMOVED*** else {
            self._haProcessInProcess = false
            return setTimeout(_timeoutHandle(self***REMOVED***, self.options.haInterval***REMOVED***;
        ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED*** else if(!self.server.isConnected(***REMOVED******REMOVED*** {
      setTimeout(function(***REMOVED*** {
        return self.start(***REMOVED***;
    ***REMOVED***, self.options.haInterval***REMOVED***;
  ***REMOVED*** else {
      setTimeout(_timeoutHandle(self***REMOVED***, self.options.haInterval***REMOVED***;
  ***REMOVED***
***REMOVED***
}

var _reconnect_servers = function(self, reconnect_servers***REMOVED*** {
  if(reconnect_servers.length == 0***REMOVED*** {
    self._haProcessInProcess = false    
    return setTimeout(_timeoutHandle(self***REMOVED***, self.options.haInterval***REMOVED***;
***REMOVED***

  // Unpack connection options
  var connectTimeoutMS = self.options.connectTimeoutMS || 10000;
  var socketTimeoutMS = self.options.socketTimeoutMS || 0;

  // Server class
  var Db = require('../../db'***REMOVED***.Db
  var Server = require('../server'***REMOVED***.Server;
  // Get the host
  var host = reconnect_servers.shift(***REMOVED***;
  // Split it up
  var _host = host.split(":"***REMOVED***[0];
  var _port = parseInt(host.split(":"***REMOVED***[1], 10***REMOVED***;

  // Set up a new server instance
  var newServer = new Server(_host, _port, {
      auto_reconnect: false
    , returnIsMasterResults: true
    , poolSize: self.options.poolSize
    , socketOptions: { 
        connectTimeoutMS: connectTimeoutMS,
        socketTimeoutMS: socketTimeoutMS
    ***REMOVED***
    , ssl: self.replset.options.ssl
    , sslValidate: self.replset.options.sslValidate
    , sslCA: self.replset.options.sslCA
    , sslCert: self.replset.options.sslCert
    , sslKey: self.replset.options.sslKey
    , sslPass: self.replset.options.sslPass
***REMOVED******REMOVED***;

  // Create new dummy db for app
  var db = new Db('local', newServer, {w:1}***REMOVED***;
  var state = self.replset._state;

  // Set up the event listeners
  newServer.once("error", _repl_set_handler("error", self.replset, newServer***REMOVED******REMOVED***;
  newServer.once("close", _repl_set_handler("close", self.replset, newServer***REMOVED******REMOVED***;
  newServer.once("timeout", _repl_set_handler("timeout", self.replset, newServer***REMOVED******REMOVED***;

  // Set shared state
  newServer.name = host;
  newServer._callBackStore = self.replset._callBackStore;
  newServer.replicasetInstance = self.replset;
  newServer.enableRecordQueryStats(self.replset.recordQueryStats***REMOVED***;

  // Let's attempt a connection over here
  newServer.connect(db, function(err, result, _server***REMOVED*** {
    // Emit ha_connect
    self.replset.emit("ha_connect", err, result, _server***REMOVED***;

    if(self.state == HighAvailabilityProcess.STOPPED***REMOVED*** {
      _server.close(***REMOVED***;
  ***REMOVED***

    // If we connected let's check what kind of server we have
    if(!err***REMOVED*** {
      _apply_auths(self, db, _server, function(err, result***REMOVED*** {
        if(err***REMOVED*** {
          _server.close(***REMOVED***;
          // Process the next server
          return setTimeout(function(***REMOVED*** {
            _reconnect_servers(self, reconnect_servers***REMOVED***;  
        ***REMOVED***, self.options.haInterval***REMOVED***;                      
      ***REMOVED***
        
        var doc = _server.isMasterDoc;    
        // Fire error on any unknown callbacks for this server
        self.replset.__executeAllServerSpecificErrorCallbacks(_server.socketOptions.host, _server.socketOptions.port, err***REMOVED***;    

        if(doc.ismaster***REMOVED*** {
          // Emit primary added
          self.replset.emit('joined', "primary", doc, _server***REMOVED***;

          // If it was a secondary remove it
          if(state.secondaries[doc.me]***REMOVED*** {
            delete state.secondaries[doc.me];
        ***REMOVED***

          // Override any server in list of addresses
          state.addresses[doc.me] = _server;
          // Set server as master
          state.master = _server;

          // If we have any buffered commands let's signal reconnect event
          if(self.replset._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
            self.replset.emit('reconnect'***REMOVED***;
        ***REMOVED***

          // Execute any waiting writes
          self.replset._commandsStore.execute_writes(***REMOVED***;   
      ***REMOVED*** else if(doc.secondary***REMOVED*** {
          // Emit secondary added
          self.replset.emit('joined', "secondary", doc, _server***REMOVED***;
          // Add the secondary to the state
          state.secondaries[doc.me] = _server;
          // Override any server in list of addresses
          state.addresses[doc.me] = _server;

          // If we have any buffered commands let's signal reconnect event
          if(self.replset._commandsStore.count(***REMOVED*** > 0***REMOVED*** {
            self.replset.emit('reconnect'***REMOVED***;
        ***REMOVED***

          // Execute any waiting reads
          self.replset._commandsStore.execute_queries(***REMOVED***;   
      ***REMOVED*** else {
          _server.close(***REMOVED***;
      ***REMOVED***

        // Set any tags on the instance server
        _server.name = doc.me;
        _server.tags = doc.tags;
        // Process the next server
        setTimeout(function(***REMOVED*** {
          _reconnect_servers(self, reconnect_servers***REMOVED***;  
      ***REMOVED***, self.options.haInterval***REMOVED***;            
    ***REMOVED******REMOVED***;
  ***REMOVED*** else {
      _server.close(***REMOVED***;
      self.replset.__executeAllServerSpecificErrorCallbacks(_server.socketOptions.host, _server.socketOptions.port, err***REMOVED***;    

      setTimeout(function(***REMOVED*** {
        _reconnect_servers(self, reconnect_servers***REMOVED***;  
    ***REMOVED***, self.options.haInterval***REMOVED***;            
  ***REMOVED***
***REMOVED******REMOVED***;
}

var _apply_auths = function(self, _db, _server, _callback***REMOVED*** {
  if(self.replset.auth.length(***REMOVED*** == 0***REMOVED*** return _callback(null***REMOVED***;
  // Apply any authentication needed
  if(self.replset.auth.length(***REMOVED*** > 0***REMOVED*** {
    var pending = self.replset.auth.length(***REMOVED***;
    var connections = _server.allRawConnections(***REMOVED***;
    var pendingAuthConn = connections.length;

    // Connection function
    var connectionFunction = function(_auth, _connection, __callback***REMOVED*** {
      var pending = _auth.length(***REMOVED***;

      for(var j = 0; j < pending; j++***REMOVED*** {
        // Get the auth object
        var _auth = _auth.get(j***REMOVED***;
        // Unpack the parameter
        var username = _auth.username;
        var password = _auth.password;
        var options = { 
            authMechanism: _auth.authMechanism            
          , authSource: _auth.authdb
          , connection: _connection 
      ***REMOVED***;

        // If we have changed the service name
        if(_auth.gssapiServiceName***REMOVED*** 
          options.gssapiServiceName = _auth.gssapiServiceName;
        
        // Hold any error
        var _error = null;
        
        // Authenticate against the credentials
        _db.authenticate(username, password, options, function(err, result***REMOVED*** {
          _error = err != null ? err : _error;
          // Adjust the pending authentication
          pending = pending - 1;
          // Finished up
          if(pending == 0***REMOVED*** __callback(_error ? _error : null, _error ? false : true***REMOVED***;
      ***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***

    // Final error object
    var finalError = null;
    // Iterate over all the connections
    for(var i = 0; i < connections.length; i++***REMOVED*** {
      connectionFunction(self.replset.auth, connections[i], function(err, result***REMOVED*** {
        // Pending authentication
        pendingAuthConn = pendingAuthConn - 1 ;

        // Save error if any
        finalError = err ? err : finalError;

        // If we are done let's finish up
        if(pendingAuthConn == 0***REMOVED*** {
          _callback(null***REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
}

var _handle = function(self, server***REMOVED*** {
  return function(err***REMOVED*** {
    server.close(***REMOVED***;    
***REMOVED***
}

var _repl_set_handler = function(event, self, server***REMOVED*** {
  var ReplSet = require('./repl_set'***REMOVED***.ReplSet;

  return function(err, doc***REMOVED*** {
    server.close(***REMOVED***;

    // The event happened to a primary
    // Remove it from play
    if(self._state.isPrimary(server***REMOVED******REMOVED*** {
      self._state.master == null;
      self._serverState = ReplSet.REPLSET_READ_ONLY;
  ***REMOVED*** else if(self._state.isSecondary(server***REMOVED******REMOVED*** {
      delete self._state.secondaries[server.name];
  ***REMOVED***

    // Unpack variables
    var host = server.socketOptions.host;
    var port = server.socketOptions.port;

    // Fire error on any unknown callbacks
    self.__executeAllServerSpecificErrorCallbacks(host, port, err***REMOVED***;    
***REMOVED***
}

exports.HighAvailabilityProcess = HighAvailabilityProcess;
