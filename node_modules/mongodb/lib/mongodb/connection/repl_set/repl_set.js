var ReadPreference = require('../read_preference'***REMOVED***.ReadPreference
  , DbCommand = require('../../commands/db_command'***REMOVED***.DbCommand
  , inherits = require('util'***REMOVED***.inherits
  , format = require('util'***REMOVED***.format
  , timers = require('timers'***REMOVED***
  , Server = require('../server'***REMOVED***.Server
  , utils = require('../../utils'***REMOVED***
  , PingStrategy = require('./strategies/ping_strategy'***REMOVED***.PingStrategy
  , StatisticsStrategy = require('./strategies/statistics_strategy'***REMOVED***.StatisticsStrategy
  , Options = require('./options'***REMOVED***.Options
  , ReplSetState = require('./repl_set_state'***REMOVED***.ReplSetState
  , HighAvailabilityProcess = require('./ha'***REMOVED***.HighAvailabilityProcess
  , Base = require('../base'***REMOVED***.Base;

var STATE_STARTING_PHASE_1 = 0;
var STATE_PRIMARY = 1;
var STATE_SECONDARY = 2;
var STATE_RECOVERING = 3;
var STATE_FATAL_ERROR = 4;
var STATE_STARTING_PHASE_2 = 5;
var STATE_UNKNOWN = 6;
var STATE_ARBITER = 7;
var STATE_DOWN = 8;
var STATE_ROLLBACK = 9;

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('../../utils'***REMOVED***.processor(***REMOVED***;

/**
 * ReplSet constructor provides replicaset functionality
 *
 * Options
 *  - **ha** {Boolean, default:true}, turn on high availability.
 *  - **haInterval** {Number, default:2000}, time between each replicaset status check.
 *  - **reconnectWait** {Number, default:1000}, time to wait in miliseconds before attempting reconnect.
 *  - **retries** {Number, default:30}, number of times to attempt a replicaset reconnect.
 *  - **rs_name** {String}, the name of the replicaset to connect to.
 *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean***REMOVED***, keepAlive:(number***REMOVED***, connectTimeoutMS:(number***REMOVED***, socketTimeoutMS:(number***REMOVED******REMOVED***
 *  - **strategy** {String, default:'ping'}, selection strategy for reads choose between (ping, statistical and none, default is ping***REMOVED***
 *  - **secondaryAcceptableLatencyMS** {Number, default:15}, sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15***REMOVED*** ms***REMOVED***
 *  - **connectWithNoPrimary** {Boolean, default:false}, sets if the driver should connect even if no primary is available
 *  - **connectArbiter** {Boolean, default:false}, sets if the driver should connect to arbiters or not.
 *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object***REMOVED*** {}, log:function(message, object***REMOVED*** {}, debug:function(message, object***REMOVED*** {}}***REMOVED*****.
 *  - **poolSize** {Number, default:5}, number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
 *  - **ssl** {Boolean, default:false}, use ssl connection (needs to have a mongod server with ssl support***REMOVED***
 *  - **sslValidate** {Boolean, default:false}, validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslCA** {Array, default:null}, Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslCert** {Buffer/String, default:null}, String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslKey** {Buffer/String, default:null}, String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *  - **sslPass** {Buffer/String, default:null}, String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher***REMOVED***
 *
 * @class Represents a 
 Replicaset Configuration
 * @param {Array} list of server objects participating in the replicaset.
 * @param {Object} [options] additional options for the replicaset connection.
 */
var ReplSet = exports.ReplSet = function(servers, options***REMOVED*** {
  // Set up basic
  if(!(this instanceof ReplSet***REMOVED******REMOVED***
    return new ReplSet(servers, options***REMOVED***;

  // Set up event emitter
  Base.call(this***REMOVED***;

  // Ensure we have a list of servers
  if(!Array.isArray(servers***REMOVED******REMOVED*** throw Error("The parameter must be an array of servers and contain at least one server"***REMOVED***;
  // Ensure no Mongos's
  for(var i = 0; i < servers.length; i++***REMOVED*** {
    if(!(servers[i] instanceof Server***REMOVED******REMOVED*** throw new Error("list of servers must be of type Server"***REMOVED***;
***REMOVED***

  // Save the options
  this.options = new Options(options***REMOVED***;
  // Ensure basic validation of options
  this.options.init(***REMOVED***;

  // Server state
  this._serverState = ReplSet.REPLSET_DISCONNECTED;
  // Add high availability process
  this._haProcess = new HighAvailabilityProcess(this, this.options***REMOVED***;

  // Let's iterate over all the provided server objects and decorate them
  this.servers = this.options.decorateAndClean(servers, this._callBackStore***REMOVED***;
  // Throw error if no seed servers
  if(this.servers.length == 0***REMOVED*** throw new Error("No valid seed servers in the array"***REMOVED***;

  // Let's set up our strategy object for picking secondaries
  if(this.options.strategy == 'ping'***REMOVED*** {
    // Create a new instance
    this.strategyInstance = new PingStrategy(this, this.options.secondaryAcceptableLatencyMS***REMOVED***;
***REMOVED*** else if(this.options.strategy == 'statistical'***REMOVED*** {
    // Set strategy as statistical
    this.strategyInstance = new StatisticsStrategy(this***REMOVED***;
    // Add enable query information
    this.enableRecordQueryStats(true***REMOVED***;
***REMOVED***

  this.emitOpen = this.options.emitOpen || true;
  // Set up a clean state
  this._state = new ReplSetState(this***REMOVED***;
  // Current round robin selected server
  this._currentServerChoice = 0;
  // Ensure up the server callbacks
  for(var i = 0; i < this.servers.length; i++***REMOVED*** {
    this.servers[i]._callBackStore = this._callBackStore;
    this.servers[i].name = format("%s:%s", this.servers[i].host, this.servers[i].port***REMOVED***
    this.servers[i].replicasetInstance = this;
    this.servers[i].options.auto_reconnect = false;
    this.servers[i].inheritReplSetOptionsFrom(this***REMOVED***;
***REMOVED***

  // Allow setting the socketTimeoutMS on all connections
  // to work around issues such as secondaries blocking due to compaction
  utils.setSocketTimeoutProperty(this, this.options.socketOptions***REMOVED***;
}

/**
 * @ignore
 */
inherits(ReplSet, Base***REMOVED***;

// Replicaset states
ReplSet.REPLSET_CONNECTING = 'connecting';
ReplSet.REPLSET_DISCONNECTED = 'disconnected';
ReplSet.REPLSET_CONNECTED = 'connected';
ReplSet.REPLSET_RECONNECTING = 'reconnecting';
ReplSet.REPLSET_DESTROYED = 'destroyed';
ReplSet.REPLSET_READ_ONLY = 'readonly';

ReplSet.prototype.isAutoReconnect = function(***REMOVED*** {
  return true;
}

ReplSet.prototype.canWrite = function(***REMOVED*** {
  return this._state.master && this._state.master.isConnected(***REMOVED***;
}

ReplSet.prototype.canRead = function(read***REMOVED*** {
  if((read == ReadPreference.PRIMARY 
      || (typeof read == 'object' && read.mode == ReadPreference.PRIMARY***REMOVED***
      || read == null || read == false***REMOVED*** && (this._state.master == null || !this._state.master.isConnected(***REMOVED******REMOVED******REMOVED*** return false;
  return Object.keys(this._state.secondaries***REMOVED***.length > 0;
}

/**
 * @ignore
 */
ReplSet.prototype.enableRecordQueryStats = function(enable***REMOVED*** {
  // Set the global enable record query stats
  this.recordQueryStats = enable;

  // Enable all the servers
  for(var i = 0; i < this.servers.length; i++***REMOVED*** {
    this.servers[i].enableRecordQueryStats(enable***REMOVED***;
***REMOVED***
}

/**
 * @ignore
 */
ReplSet.prototype.setReadPreference = function(preference***REMOVED*** {
  this.options.readPreference = preference;
}

ReplSet.prototype.connect = function(parent, options, callback***REMOVED*** {
  if(this._serverState != ReplSet.REPLSET_DISCONNECTED***REMOVED*** 
    return callback(new Error("in process of connection"***REMOVED******REMOVED***;

  // If no callback throw
  if(!(typeof callback == 'function'***REMOVED******REMOVED*** 
    throw new Error("cannot call ReplSet.prototype.connect with no callback function"***REMOVED***;

  var self = this;
  // Save db reference
  this.options.db = parent;
  // Set replicaset as connecting
  this._serverState = ReplSet.REPLSET_CONNECTING
  // Copy all the servers to our list of seeds
  var candidateServers = this.servers.slice(0***REMOVED***;
  // Pop the first server
  var server = candidateServers.pop(***REMOVED***;
  server.name = format("%s:%s", server.host, server.port***REMOVED***;
  // Set up the options
  var opts = {
    returnIsMasterResults: true,
    eventReceiver: server
***REMOVED***

  // Register some event listeners
  this.once("fullsetup", function(err, db, replset***REMOVED*** {
    // Set state to connected
    self._serverState = ReplSet.REPLSET_CONNECTED;
    // Stop any process running
    if(self._haProcess***REMOVED*** self._haProcess.stop(***REMOVED***;
    // Start the HA process
    self._haProcess.start(***REMOVED***;

    // Emit fullsetup
    processor(function(***REMOVED*** {
      if(self.emitOpen***REMOVED***
        self._emitAcrossAllDbInstances(self, null, "open", null, null, null***REMOVED***;        

      self._emitAcrossAllDbInstances(self, null, "fullsetup", null, null, null***REMOVED***;        
  ***REMOVED******REMOVED***;

    // If we have a strategy defined start it
    if(self.strategyInstance***REMOVED*** {
      self.strategyInstance.start(***REMOVED***;
  ***REMOVED***

    // Finishing up the call
    callback(err, db, replset***REMOVED***;
***REMOVED******REMOVED***;

  // Errors
  this.once("connectionError", function(err, result***REMOVED*** {
    callback(err, result***REMOVED***;
***REMOVED******REMOVED***;

  // Attempt to connect to the server
  server.connect(this.options.db, opts, _connectHandler(this, candidateServers, server***REMOVED******REMOVED***;
}

ReplSet.prototype.close = function(callback***REMOVED*** {  
  var self = this;
  // Set as destroyed
  this._serverState = ReplSet.REPLSET_DESTROYED;
  // Stop the ha
  this._haProcess.stop(***REMOVED***;
  
  // If we have a strategy stop it
  if(this.strategyInstance***REMOVED*** {
    this.strategyInstance.stop(***REMOVED***;
***REMOVED***

  // Kill all servers available
  for(var name in this._state.addresses***REMOVED*** {
    this._state.addresses[name].close(***REMOVED***;
***REMOVED***

  // Clean out the state
  this._state = new ReplSetState(this***REMOVED***; 
  
  // Emit close event
  processor(function(***REMOVED*** {
    self._emitAcrossAllDbInstances(self, null, "close", null, null, true***REMOVED***    
***REMOVED******REMOVED***;

  // Flush out any remaining call handlers
  self._flushAllCallHandlers(utils.toError("Connection Closed By Application"***REMOVED******REMOVED***;

  // Callback
  if(typeof callback == 'function'***REMOVED*** 
    return callback(null, null***REMOVED***;
}

/**
 * Creates a new server for the `replset` based on `host`.
 *
 * @param {String} host - host:port pair (localhost:27017***REMOVED***
 * @param {ReplSet} replset - the ReplSet instance
 * @return {Server}
 * @ignore
 */
var createServer = function(self, host, options***REMOVED*** {
  // copy existing socket options to new server
  var socketOptions = {}
  if(options.socketOptions***REMOVED*** {
    var keys = Object.keys(options.socketOptions***REMOVED***;
    for(var k = 0; k < keys.length; k++***REMOVED*** {
      socketOptions[keys[k]] = options.socketOptions[keys[k]];
  ***REMOVED***
***REMOVED***

  var parts = host.split(/:/***REMOVED***;
  if(1 === parts.length***REMOVED*** {
    parts[1] = Connection.DEFAULT_PORT;
***REMOVED***

  socketOptions.host = parts[0];
  socketOptions.port = parseInt(parts[1], 10***REMOVED***;

  var serverOptions = {
    readPreference: options.readPreference,
    socketOptions: socketOptions,
    poolSize: options.poolSize,
    logger: options.logger,
    auto_reconnect: false,
    ssl: options.ssl,
    sslValidate: options.sslValidate,
    sslCA: options.sslCA,
    sslCert: options.sslCert,
    sslKey: options.sslKey,
    sslPass: options.sslPass
***REMOVED***

  var server = new Server(socketOptions.host, socketOptions.port, serverOptions***REMOVED***;
  // Set up shared state
  server._callBackStore = self._callBackStore;
  server.replicasetInstance = self;
  server.enableRecordQueryStats(self.recordQueryStats***REMOVED***;
  // Set up event handlers
  server.on("close", _handler("close", self, server***REMOVED******REMOVED***;
  server.on("error", _handler("error", self, server***REMOVED******REMOVED***;
  server.on("timeout", _handler("timeout", self, server***REMOVED******REMOVED***;
  return server;
}

var _handler = function(event, self, server***REMOVED*** {
  return function(err, doc***REMOVED*** {
    // The event happened to a primary
    // Remove it from play
    if(self._state.isPrimary(server***REMOVED******REMOVED*** {    
      // Emit that the primary left the replicaset
      self.emit('left', 'primary', server***REMOVED***;
      // Get the current master
      var current_master = self._state.master;
      self._state.master = null;
      self._serverState = ReplSet.REPLSET_READ_ONLY;
    
      if(current_master != null***REMOVED*** {
        // Unpack variables
        var host = current_master.socketOptions.host;
        var port = current_master.socketOptions.port;

        // Fire error on any unknown callbacks
        self.__executeAllServerSpecificErrorCallbacks(host, port, err***REMOVED***;        
    ***REMOVED***
  ***REMOVED*** else if(self._state.isSecondary(server***REMOVED******REMOVED*** {
      // Emit that a secondary left the replicaset
      self.emit('left', 'secondary', server***REMOVED***;
      // Delete from the list
      delete self._state.secondaries[server.name];
  ***REMOVED***

    // If there is no more connections left and the setting is not destroyed
    // set to disconnected
    if(Object.keys(self._state.addresses***REMOVED***.length == 0 
      && self._serverState != ReplSet.REPLSET_DESTROYED***REMOVED*** {
        self._serverState = ReplSet.REPLSET_DISCONNECTED;

        // Emit close across all the attached db instances
        self._dbStore.emit("close", new Error("replicaset disconnected, no valid servers contactable over tcp"***REMOVED***, null, true***REMOVED***;
  ***REMOVED***

    // Unpack variables
    var host = server.socketOptions.host;
    var port = server.socketOptions.port;

    // Fire error on any unknown callbacks
    self.__executeAllServerSpecificErrorCallbacks(host, port, err***REMOVED***;
***REMOVED***
}

var locateNewServers = function(self, state, candidateServers, ismaster***REMOVED*** {
  // Retrieve the host
  var hosts = ismaster.hosts;
  // In candidate servers
  var inCandidateServers = function(name, candidateServers***REMOVED*** {
    for(var i = 0; i < candidateServers.length; i++***REMOVED*** {
      if(candidateServers[i].name == name***REMOVED*** return true;
  ***REMOVED***

    return false;
***REMOVED***

  // New servers
  var newServers = [];
  if(Array.isArray(hosts***REMOVED******REMOVED*** {
    // Let's go over all the hosts
    for(var i = 0; i < hosts.length; i++***REMOVED*** {
      if(!state.contains(hosts[i]***REMOVED*** 
        && !inCandidateServers(hosts[i], candidateServers***REMOVED******REMOVED*** {
          newServers.push(createServer(self, hosts[i], self.options***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***    
***REMOVED***

  // Return list of possible new servers
  return newServers;
}

var _connectHandler = function(self, candidateServers, instanceServer***REMOVED*** {
  return function(err, doc***REMOVED*** {
    // If we have an error add to the list
    if(err***REMOVED*** {
      self._state.errors[instanceServer.name] = instanceServer;
  ***REMOVED*** else {
      delete self._state.errors[instanceServer.name];
  ***REMOVED***

    if(!err***REMOVED*** {      
      var ismaster = doc.documents[0]

      // Error the server if 
      if(!ismaster.ismaster
        && !ismaster.secondary***REMOVED*** {
        self._state.errors[instanceServer.name] = instanceServer;
    ***REMOVED***
  ***REMOVED***


    // No error let's analyse the ismaster command
    if(!err && self._state.errors[instanceServer.name] == null***REMOVED*** {
      var ismaster = doc.documents[0]

      // If no replicaset name exists set the current one
      if(self.options.rs_name == null***REMOVED*** {
        self.options.rs_name = ismaster.setName;
    ***REMOVED***

      // If we have a member that is not part of the set let's finish up
      if(typeof ismaster.setName == 'string' && ismaster.setName != self.options.rs_name***REMOVED*** {
        return self.emit("connectionError", new Error("Replicaset name " + ismaster.setName + " does not match specified name " + self.options.rs_name***REMOVED******REMOVED***;
    ***REMOVED***

      // Add the error handlers
      instanceServer.on("close", _handler("close", self, instanceServer***REMOVED******REMOVED***;
      instanceServer.on("error", _handler("error", self, instanceServer***REMOVED******REMOVED***;
      instanceServer.on("timeout", _handler("timeout", self, instanceServer***REMOVED******REMOVED***;
      
      // Set any tags on the instance server
      instanceServer.name = ismaster.me;
      instanceServer.tags = ismaster.tags;

      // Add the server to the list
      self._state.addServer(instanceServer, ismaster***REMOVED***;

      // Check if we have more servers to add (only check when done with initial set***REMOVED***
      if(candidateServers.length == 0***REMOVED*** {
        // Get additional new servers that are not currently in set
        var new_servers = locateNewServers(self, self._state, candidateServers, ismaster***REMOVED***;

        // Locate any new servers that have not errored out yet
        for(var i = 0; i < new_servers.length; i++***REMOVED*** {
          if(self._state.errors[new_servers[i].name] == null***REMOVED*** {
            candidateServers.push(new_servers[i]***REMOVED***            
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    // If the candidate server list is empty and no valid servers
    if(candidateServers.length == 0 &&
      !self._state.hasValidServers(***REMOVED******REMOVED*** {
        return self.emit("connectionError", new Error("No valid replicaset instance servers found"***REMOVED******REMOVED***;
  ***REMOVED*** else if(candidateServers.length == 0***REMOVED*** {      
      if(!self.options.connectWithNoPrimary && (self._state.master == null || !self._state.master.isConnected(***REMOVED******REMOVED******REMOVED*** {
        return self.emit("connectionError", new Error("No primary found in set"***REMOVED******REMOVED***;
    ***REMOVED***
      return self.emit("fullsetup", null, self.options.db, self***REMOVED***;
  ***REMOVED***
        
    // Let's connect the next server    
    var nextServer = candidateServers.pop(***REMOVED***;
  
    // Set up the options
    var opts = {
      returnIsMasterResults: true,
      eventReceiver: nextServer
  ***REMOVED***

    // Attempt to connect to the server
    nextServer.connect(self.options.db, opts, _connectHandler(self, candidateServers, nextServer***REMOVED******REMOVED***;
***REMOVED***
}

ReplSet.prototype.isDestroyed = function(***REMOVED*** {
  return this._serverState == ReplSet.REPLSET_DESTROYED;
}

ReplSet.prototype.isConnected = function(read***REMOVED*** {
  var isConnected = false;  

  if(read == null || read == ReadPreference.PRIMARY || read == false***REMOVED***
    isConnected = this._state.master != null && this._state.master.isConnected(***REMOVED***;

  if((read == ReadPreference.PRIMARY_PREFERRED || read == ReadPreference.SECONDARY_PREFERRED || read == ReadPreference.NEAREST***REMOVED***
    && ((this._state.master != null && this._state.master.isConnected(***REMOVED******REMOVED***
    || (this._state && this._state.secondaries && Object.keys(this._state.secondaries***REMOVED***.length > 0***REMOVED******REMOVED******REMOVED*** {
      isConnected = true;
***REMOVED*** else if(read == ReadPreference.SECONDARY***REMOVED*** {
    isConnected = this._state && this._state.secondaries && Object.keys(this._state.secondaries***REMOVED***.length > 0;
***REMOVED***

  // No valid connection return false
  return isConnected;
}

ReplSet.prototype.isMongos = function(***REMOVED*** {
  return false;
}

ReplSet.prototype.checkoutWriter = function(***REMOVED*** {
  if(this._state.master***REMOVED*** return this._state.master.checkoutWriter(***REMOVED***;
  return new Error("no writer connection available"***REMOVED***;
}

ReplSet.prototype.processIsMaster = function(_server, _ismaster***REMOVED*** {
  // Server in recovery mode, remove it from available servers
  if(!_ismaster.ismaster && !_ismaster.secondary***REMOVED*** {
    // Locate the actual server
    var server = this._state.addresses[_server.name];
    // Close the server, simulating the closing of the connection
    // to get right removal semantics
    if(server***REMOVED*** server.close(***REMOVED***;
    // Execute any callback errors
    _handler(null, this, server***REMOVED***(new Error("server is in recovery mode"***REMOVED******REMOVED***;
***REMOVED***
}

ReplSet.prototype.allRawConnections = function(***REMOVED*** {
  var connections = [];

  for(var name in this._state.addresses***REMOVED*** {
    connections = connections.concat(this._state.addresses[name].allRawConnections(***REMOVED******REMOVED***;
***REMOVED***

  return connections;
}

/**
 * @ignore
 */
ReplSet.prototype.allServerInstances = function(***REMOVED*** {
  var self = this;
  // If no state yet return empty
  if(!self._state***REMOVED*** return [];
  // Close all the servers (concatenate entire list of servers first for ease***REMOVED***
  var allServers = self._state.master != null ? [self._state.master] : [];

  // Secondary keys
  var keys = Object.keys(self._state.secondaries***REMOVED***;
  // Add all secondaries
  for(var i = 0; i < keys.length; i++***REMOVED*** {
    allServers.push(self._state.secondaries[keys[i]]***REMOVED***;
***REMOVED***

  // Return complete list of all servers
  return allServers;
}

/**
 * @ignore
 */
ReplSet.prototype.checkoutReader = function(readPreference, tags***REMOVED*** {
  var connection = null;

  // If we have a read preference object unpack it
  if(typeof readPreference == 'object' && readPreference['_type'] == 'ReadPreference'***REMOVED*** {
    // Validate if the object is using a valid mode
    if(!readPreference.isValid(***REMOVED******REMOVED*** throw new Error("Illegal readPreference mode specified, " + JSON.stringify(readPreference.mode***REMOVED******REMOVED***;
    // Set the tag
    tags = readPreference.tags;
    readPreference = readPreference.mode;
***REMOVED*** else if(typeof readPreference == 'object' && readPreference['_type'] != 'ReadPreference'***REMOVED*** {
    return new Error("read preferences must be either a string or an instance of ReadPreference"***REMOVED***;
***REMOVED***

  // Set up our read Preference, allowing us to override the readPreference
  var finalReadPreference = readPreference != null ? readPreference : this.options.readPreference;

  // Ensure we unpack a reference
  if(finalReadPreference != null && typeof finalReadPreference == 'object' && finalReadPreference['_type'] == 'ReadPreference'***REMOVED*** {
    // Validate if the object is using a valid mode
    if(!finalReadPreference.isValid(***REMOVED******REMOVED*** throw new Error("Illegal readPreference mode specified, " + JSON.stringify(finalReadPreference.mode***REMOVED******REMOVED***;
    // Set the tag
    tags = finalReadPreference.tags;
    readPreference = finalReadPreference.mode;
***REMOVED***

  // Finalize the read preference setup
  finalReadPreference = finalReadPreference == true ? ReadPreference.SECONDARY_PREFERRED : finalReadPreference;
  finalReadPreference = finalReadPreference == null ? ReadPreference.PRIMARY : finalReadPreference;

  // If we are reading from a primary
  if(finalReadPreference == 'primary'***REMOVED*** {
    // If we provide a tags set send an error
    if(typeof tags == 'object' && tags != null***REMOVED*** {
      return new Error("PRIMARY cannot be combined with tags"***REMOVED***;
  ***REMOVED***

    // If we provide a tags set send an error
    if(this._state.master == null***REMOVED*** {
      return new Error("No replica set primary available for query with ReadPreference PRIMARY"***REMOVED***;
  ***REMOVED***

    // Checkout a writer
    return this.checkoutWriter(***REMOVED***;
***REMOVED***

  // If we have specified to read from a secondary server grab a random one and read
  // from it, otherwise just pass the primary connection
  if((this.options.readSecondary || finalReadPreference == ReadPreference.SECONDARY_PREFERRED || finalReadPreference == ReadPreference.SECONDARY***REMOVED*** && Object.keys(this._state.secondaries***REMOVED***.length > 0***REMOVED*** {
    // If we have tags, look for servers matching the specific tag
    if(this.strategyInstance != null***REMOVED*** {
      // Only pick from secondaries
      var _secondaries = [];
      for(var key in this._state.secondaries***REMOVED*** {
        _secondaries.push(this._state.secondaries[key]***REMOVED***;
    ***REMOVED***

      if(finalReadPreference == ReadPreference.SECONDARY***REMOVED*** {
        // Check out the nearest from only the secondaries
        connection = this.strategyInstance.checkoutConnection(tags, _secondaries***REMOVED***;
    ***REMOVED*** else {
        connection = this.strategyInstance.checkoutConnection(tags, _secondaries***REMOVED***;
        // No candidate servers that match the tags, error
        if(connection == null || connection instanceof Error***REMOVED*** {
          // No secondary server avilable, attemp to checkout a primary server
          connection = this.checkoutWriter(***REMOVED***;
          // If no connection return an error
          if(connection == null || connection instanceof Error***REMOVED*** {
            return new Error("No replica set members available for query"***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if(tags != null && typeof tags == 'object'***REMOVED*** {
      // Get connection
      connection = _pickFromTags(this, tags***REMOVED***;// = function(self, readPreference, tags***REMOVED*** {
      // No candidate servers that match the tags, error
      if(connection == null***REMOVED*** {
        return new Error("No replica set members available for query"***REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      connection = _roundRobin(this, tags***REMOVED***;
  ***REMOVED***
***REMOVED*** else if(finalReadPreference == ReadPreference.PRIMARY_PREFERRED***REMOVED*** {
    // Check if there is a primary available and return that if possible
    connection = this.checkoutWriter(***REMOVED***;
    // If no connection available checkout a secondary
    if(connection == null || connection instanceof Error***REMOVED*** {
      // If we have tags, look for servers matching the specific tag
      if(tags != null && typeof tags == 'object'***REMOVED*** {
        // Get connection
        connection = _pickFromTags(this, tags***REMOVED***;// = function(self, readPreference, tags***REMOVED*** {
        // No candidate servers that match the tags, error
        if(connection == null***REMOVED*** {
          return new Error("No replica set members available for query"***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else {
        connection = _roundRobin(this, tags***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if(finalReadPreference == ReadPreference.SECONDARY_PREFERRED***REMOVED*** {
    // If we have tags, look for servers matching the specific tag
    if(this.strategyInstance != null***REMOVED*** {
      connection = this.strategyInstance.checkoutConnection(tags***REMOVED***;
      
      // No candidate servers that match the tags, error
      if(connection == null || connection instanceof Error***REMOVED*** {
        // No secondary server avilable, attemp to checkout a primary server
        connection = this.checkoutWriter(***REMOVED***;
        // If no connection return an error
        if(connection == null || connection instanceof Error***REMOVED*** {
          var preferenceName = finalReadPreference == ReadPreference.SECONDARY ? 'secondary' : finalReadPreference;
          return new Error("No replica set member available for query with ReadPreference " + preferenceName + " and tags " + JSON.stringify(tags***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if(tags != null && typeof tags == 'object'***REMOVED*** {
      // Get connection
      connection = _pickFromTags(this, tags***REMOVED***;// = function(self, readPreference, tags***REMOVED*** {
      // No candidate servers that match the tags, error
      if(connection == null***REMOVED*** {
        // No secondary server avilable, attemp to checkout a primary server
        connection = this.checkoutWriter(***REMOVED***;
        // If no connection return an error
        if(connection == null || connection instanceof Error***REMOVED*** {
          var preferenceName = finalReadPreference == ReadPreference.SECONDARY ? 'secondary' : finalReadPreference;
          return new Error("No replica set member available for query with ReadPreference " + preferenceName + " and tags " + JSON.stringify(tags***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if(finalReadPreference == ReadPreference.NEAREST && this.strategyInstance != null***REMOVED*** {
    connection = this.strategyInstance.checkoutConnection(tags***REMOVED***;
***REMOVED*** else if(finalReadPreference == ReadPreference.NEAREST && this.strategyInstance == null***REMOVED*** {
    return new Error("A strategy for calculating nearness must be enabled such as ping or statistical"***REMOVED***;
***REMOVED*** else if(finalReadPreference == ReadPreference.SECONDARY && Object.keys(this._state.secondaries***REMOVED***.length == 0***REMOVED*** {
    if(tags != null && typeof tags == 'object'***REMOVED*** {
      var preferenceName = finalReadPreference == ReadPreference.SECONDARY ? 'secondary' : finalReadPreference;
      return new Error("No replica set member available for query with ReadPreference " + preferenceName + " and tags " + JSON.stringify(tags***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return new Error("No replica set secondary available for query with ReadPreference SECONDARY"***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    connection = this.checkoutWriter(***REMOVED***;
***REMOVED***

  // Return the connection
  return connection;
}

/**
 * @ignore
 */
var _pickFromTags = function(self, tags***REMOVED*** {
  // If we have an array or single tag selection
  var tagObjects = Array.isArray(tags***REMOVED*** ? tags : [tags];
  // Iterate over all tags until we find a candidate server
  for(var _i = 0; _i < tagObjects.length; _i++***REMOVED*** {
    // Grab a tag object
    var tagObject = tagObjects[_i];
    // Matching keys
    var matchingKeys = Object.keys(tagObject***REMOVED***;
    // Match all the servers that match the provdided tags
    var keys = Object.keys(self._state.secondaries***REMOVED***;
    var candidateServers = [];

    for(var i = 0; i < keys.length; i++***REMOVED*** {
      var server = self._state.secondaries[keys[i]];
      // If we have tags match
      if(server.tags != null***REMOVED*** {
        var matching = true;
        // Ensure we have all the values
        for(var j = 0; j < matchingKeys.length; j++***REMOVED*** {
          if(server.tags[matchingKeys[j]] != tagObject[matchingKeys[j]]***REMOVED*** {
            matching = false;
            break;
        ***REMOVED***
      ***REMOVED***

        // If we have a match add it to the list of matching servers
        if(matching***REMOVED*** {
          candidateServers.push(server***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    // If we have a candidate server return
    if(candidateServers.length > 0***REMOVED*** {
      if(self.strategyInstance***REMOVED*** return self.strategyInstance.checkoutConnection(tags, candidateServers***REMOVED***;
      // Set instance to return
      return candidateServers[Math.floor(Math.random(***REMOVED*** * candidateServers.length***REMOVED***].checkoutReader(***REMOVED***;
  ***REMOVED***
***REMOVED***

  // No connection found
  return null;
}

/**
 * Pick a secondary using round robin
 *
 * @ignore
 */
function _roundRobin (replset, tags***REMOVED*** {
  var keys = Object.keys(replset._state.secondaries***REMOVED***;
  // Update index
  replset._currentServerChoice = replset._currentServerChoice + 1;
  // Pick a server
  var key = keys[replset._currentServerChoice % keys.length];

  var conn = null != replset._state.secondaries[key]
    ? replset._state.secondaries[key].checkoutReader(***REMOVED***
    : null;

  // If connection is null fallback to first available secondary
  if(null == conn***REMOVED*** {
    conn = pickFirstConnectedSecondary(replset, tags***REMOVED***;
***REMOVED***

  return conn;
}

/**
 * @ignore
 */
var pickFirstConnectedSecondary = function pickFirstConnectedSecondary(self, tags***REMOVED*** {
  var keys = Object.keys(self._state.secondaries***REMOVED***;
  var connection;

  // Find first available reader if any
  for(var i = 0; i < keys.length; i++***REMOVED*** {
    connection = self._state.secondaries[keys[i]].checkoutReader(***REMOVED***;
    if(connection***REMOVED*** return connection;
***REMOVED***

  // If we still have a null, read from primary if it's not secondary only
  if(self._readPreference == ReadPreference.SECONDARY_PREFERRED***REMOVED*** {
    connection = self._state.master.checkoutReader(***REMOVED***;
    if(connection***REMOVED*** return connection;
***REMOVED***

  var preferenceName = self._readPreference == ReadPreference.SECONDARY_PREFERRED
    ? 'secondary'
    : self._readPreference;

  return new Error("No replica set member available for query with ReadPreference "
                  + preferenceName + " and tags " + JSON.stringify(tags***REMOVED******REMOVED***;
}

/**
 * Get list of secondaries
 * @ignore
 */
Object.defineProperty(ReplSet.prototype, "secondaries", {enumerable: true
  , get: function(***REMOVED*** {
      return utils.objectToArray(this._state.secondaries***REMOVED***;
  ***REMOVED***
}***REMOVED***;

/**
 * Get list of secondaries
 * @ignore
 */
Object.defineProperty(ReplSet.prototype, "arbiters", {enumerable: true
  , get: function(***REMOVED*** {
      return utils.objectToArray(this._state.arbiters***REMOVED***;
  ***REMOVED***
}***REMOVED***;

