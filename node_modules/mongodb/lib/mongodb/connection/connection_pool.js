var utils = require('./connection_utils'***REMOVED***,
  inherits = require('util'***REMOVED***.inherits,
  net = require('net'***REMOVED***,
  timers = require('timers'***REMOVED***,
  EventEmitter = require('events'***REMOVED***.EventEmitter,
  inherits = require('util'***REMOVED***.inherits,
  MongoReply = require("../responses/mongo_reply"***REMOVED***.MongoReply,
  Connection = require("./connection"***REMOVED***.Connection;

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('../utils'***REMOVED***.processor(***REMOVED***;

var ConnectionPool = exports.ConnectionPool = function(host, port, poolSize, bson, socketOptions***REMOVED*** {
  if(typeof host !== 'string'***REMOVED*** {
    throw new Error("host must be specified [" + host + "]"***REMOVED***;
***REMOVED***

  // Set up event emitter
  EventEmitter.call(this***REMOVED***;

  // Keep all options for the socket in a specific collection allowing the user to specify the
  // Wished upon socket connection parameters
  this.socketOptions = typeof socketOptions === 'object' ? socketOptions : {};
  this.socketOptions.host = host;
  this.socketOptions.port = port;
  this.socketOptions.domainSocket = false;
  this.bson = bson;
  // PoolSize is always + 1 for special reserved "measurment" socket (like ping, stats etc***REMOVED***
  this.poolSize = poolSize;
  this.minPoolSize = Math.floor(this.poolSize / 2***REMOVED*** + 1;

  // Check if the host is a socket
  if(host.match(/^\//***REMOVED******REMOVED*** {
    this.socketOptions.domainSocket = true;
***REMOVED*** else if(typeof port === 'string'***REMOVED*** {
    try { 
      port = parseInt(port, 10***REMOVED***; 
  ***REMOVED*** catch(err***REMOVED*** { 
      new Error("port must be specified or valid integer["  + port + "]"***REMOVED***; 
  ***REMOVED***
***REMOVED*** else if(typeof port !== 'number'***REMOVED*** {
    throw new Error("port must be specified ["  + port + "]"***REMOVED***;
***REMOVED***

  // Set default settings for the socket options
  utils.setIntegerParameter(this.socketOptions, 'timeout', 0***REMOVED***;
  // Delay before writing out the data to the server
  utils.setBooleanParameter(this.socketOptions, 'noDelay', true***REMOVED***;
  // Delay before writing out the data to the server
  utils.setIntegerParameter(this.socketOptions, 'keepAlive', 0***REMOVED***;
  // Set the encoding of the data read, default is binary == null
  utils.setStringParameter(this.socketOptions, 'encoding', null***REMOVED***;
  // Allows you to set a throttling bufferSize if you need to stop overflows
  utils.setIntegerParameter(this.socketOptions, 'bufferSize', 0***REMOVED***;

  // Internal structures
  this.openConnections = [];
  // Assign connection id's
  this.connectionId = 0;

  // Current index for selection of pool connection
  this.currentConnectionIndex = 0;
  // The pool state
  this._poolState = 'disconnected';
  // timeout control
  this._timeout = false;
  // Time to wait between connections for the pool
  this._timeToWait = 10;
}

inherits(ConnectionPool, EventEmitter***REMOVED***;

ConnectionPool.prototype.setMaxBsonSize = function(maxBsonSize***REMOVED*** {
  if(maxBsonSize == null***REMOVED***{
    maxBsonSize = Connection.DEFAULT_MAX_BSON_SIZE;
***REMOVED***

  for(var i = 0; i < this.openConnections.length; i++***REMOVED*** {
    this.openConnections[i].maxBsonSize = maxBsonSize;
    this.openConnections[i].maxBsonSettings.maxBsonSize = maxBsonSize;
***REMOVED***
}

ConnectionPool.prototype.setMaxMessageSizeBytes = function(maxMessageSizeBytes***REMOVED*** {
  if(maxMessageSizeBytes == null***REMOVED***{
    maxMessageSizeBytes = Connection.DEFAULT_MAX_MESSAGE_SIZE;
***REMOVED***

  for(var i = 0; i < this.openConnections.length; i++***REMOVED*** {
    this.openConnections[i].maxMessageSizeBytes = maxMessageSizeBytes;
    this.openConnections[i].maxBsonSettings.maxMessageSizeBytes = maxMessageSizeBytes;
***REMOVED***
}

ConnectionPool.prototype.setMaxWriteBatchSize = function(maxWriteBatchSize***REMOVED*** {
  if(maxWriteBatchSize == null***REMOVED***{
    maxWriteBatchSize = Connection.DEFAULT_MAX_WRITE_BATCH_SIZE;
***REMOVED***

  for(var i = 0; i < this.openConnections.length; i++***REMOVED*** {
    this.openConnections[i].maxWriteBatchSize = maxWriteBatchSize;
***REMOVED***  
}

// Start a function
var _connect = function(_self***REMOVED*** {
  // return new function(***REMOVED*** {
    // Create a new connection instance
    var connection = new Connection(_self.connectionId++, _self.socketOptions***REMOVED***;
    // Set logger on pool
    connection.logger = _self.logger;
    // Connect handler
    connection.on("connect", function(err, connection***REMOVED*** {
      // Add connection to list of open connections
      _self.openConnections.push(connection***REMOVED***;
      // If the number of open connections is equal to the poolSize signal ready pool
      if(_self.openConnections.length === _self.poolSize && _self._poolState !== 'disconnected'***REMOVED*** {
        // Set connected
        _self._poolState = 'connected';
        // Emit pool ready
        _self.emit("poolReady"***REMOVED***;
    ***REMOVED*** else if(_self.openConnections.length < _self.poolSize***REMOVED*** {
        // Wait a little bit of time to let the close event happen if the server closes the connection
        // so we don't leave hanging connections around
        if(typeof _self._timeToWait == 'number'***REMOVED*** {
          setTimeout(function(***REMOVED*** {
            // If we are still connecting (no close events fired in between start another connection***REMOVED***
            if(_self._poolState == 'connecting'***REMOVED*** {
              _connect(_self***REMOVED***;
          ***REMOVED***
        ***REMOVED***, _self._timeToWait***REMOVED***;
      ***REMOVED*** else {
          processor(function(***REMOVED*** {
            // If we are still connecting (no close events fired in between start another connection***REMOVED***
            if(_self._poolState == 'connecting'***REMOVED*** {
              _connect(_self***REMOVED***;
          ***REMOVED***
        ***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED******REMOVED***;

    var numberOfErrors = 0

    // Error handler
    connection.on("error", function(err, connection, error_options***REMOVED*** {
      numberOfErrors++;
      // If we are already disconnected ignore the event
      if(_self._poolState != 'disconnected' && _self.listeners("error"***REMOVED***.length > 0***REMOVED*** {
        _self.emit("error", err, connection, error_options***REMOVED***;
    ***REMOVED***

      // Close the connection
      connection.close(***REMOVED***;
      // Set pool as disconnected
      _self._poolState = 'disconnected';
      // Stop the pool
      _self.stop(***REMOVED***;
  ***REMOVED******REMOVED***;

    // Close handler
    connection.on("close", function(***REMOVED*** {
      // If we are already disconnected ignore the event
      if(_self._poolState !== 'disconnected' && _self.listeners("close"***REMOVED***.length > 0***REMOVED*** {
        _self.emit("close"***REMOVED***;
    ***REMOVED***

      // Set disconnected
      _self._poolState = 'disconnected';
      // Stop
      _self.stop(***REMOVED***;
  ***REMOVED******REMOVED***;

    // Timeout handler
    connection.on("timeout", function(err, connection***REMOVED*** {
      // If we are already disconnected ignore the event
      if(_self._poolState !== 'disconnected' && _self.listeners("timeout"***REMOVED***.length > 0***REMOVED*** {
        _self.emit("timeout", err***REMOVED***;
    ***REMOVED***

      // Close the connection
      connection.close(***REMOVED***;
      // Set disconnected
      _self._poolState = 'disconnected';
      _self.stop(***REMOVED***;
  ***REMOVED******REMOVED***;

    // Parse error, needs a complete shutdown of the pool
    connection.on("parseError", function(***REMOVED*** {
      // If we are already disconnected ignore the event
      if(_self._poolState !== 'disconnected' && _self.listeners("parseError"***REMOVED***.length > 0***REMOVED*** {
        _self.emit("parseError", new Error("parseError occured"***REMOVED******REMOVED***;
    ***REMOVED***

      // Set disconnected
      _self._poolState = 'disconnected';
      _self.stop(***REMOVED***;
  ***REMOVED******REMOVED***;

    connection.on("message", function(message***REMOVED*** {
      _self.emit("message", message***REMOVED***;
  ***REMOVED******REMOVED***;

    // Start connection in the next tick
    connection.start(***REMOVED***;
  // }(***REMOVED***;
}


// Start method, will throw error if no listeners are available
// Pass in an instance of the listener that contains the api for
// finding callbacks for a given message etc.
ConnectionPool.prototype.start = function(***REMOVED*** {
  var markerDate = new Date(***REMOVED***.getTime(***REMOVED***;
  var self = this;

  if(this.listeners("poolReady"***REMOVED***.length == 0***REMOVED*** {
    throw "pool must have at least one listener ready that responds to the [poolReady] event";
***REMOVED***

  // Set pool state to connecting
  this._poolState = 'connecting';
  this._timeout = false;

  _connect(self***REMOVED***;
}

// Restart a connection pool (on a close the pool might be in a wrong state***REMOVED***
ConnectionPool.prototype.restart = function(***REMOVED*** {
  // Close all connections
  this.stop(false***REMOVED***;
  // Now restart the pool
  this.start(***REMOVED***;
}

// Stop the connections in the pool
ConnectionPool.prototype.stop = function(removeListeners***REMOVED*** {
  removeListeners = removeListeners == null ? true : removeListeners;
  // Set disconnected
  this._poolState = 'disconnected';

  // Clear all listeners if specified
  if(removeListeners***REMOVED*** {
    this.removeAllEventListeners(***REMOVED***;
***REMOVED***

  // Close all connections
  for(var i = 0; i < this.openConnections.length; i++***REMOVED*** {
    this.openConnections[i].close(***REMOVED***;
***REMOVED***

  // Clean up
  this.openConnections = [];
}

// Check the status of the connection
ConnectionPool.prototype.isConnected = function(***REMOVED*** {
  // return this._poolState === 'connected';
  return this.openConnections.length > 0 && this.openConnections[0].isConnected(***REMOVED***;
}

// Checkout a connection from the pool for usage, or grab a specific pool instance
ConnectionPool.prototype.checkoutConnection = function(id***REMOVED*** {
  var index = (this.currentConnectionIndex++ % (this.openConnections.length***REMOVED******REMOVED***;
  var connection = this.openConnections[index];
  return connection;
}

ConnectionPool.prototype.getAllConnections = function(***REMOVED*** {
  return this.openConnections;
}

// Remove all non-needed event listeners
ConnectionPool.prototype.removeAllEventListeners = function(***REMOVED*** {
  this.removeAllListeners("close"***REMOVED***;
  this.removeAllListeners("error"***REMOVED***;
  this.removeAllListeners("timeout"***REMOVED***;
  this.removeAllListeners("connect"***REMOVED***;
  this.removeAllListeners("end"***REMOVED***;
  this.removeAllListeners("parseError"***REMOVED***;
  this.removeAllListeners("message"***REMOVED***;
  this.removeAllListeners("poolReady"***REMOVED***;
}






















