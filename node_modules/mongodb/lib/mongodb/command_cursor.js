var Long = require('bson'***REMOVED***.Long
  , Readable = require('stream'***REMOVED***.Readable
  , GetMoreCommand = require('./commands/get_more_command'***REMOVED***.GetMoreCommand
  , inherits = require('util'***REMOVED***.inherits;

var CommandCursor = function(db, collection, command, options***REMOVED*** {  
  // Ensure empty options if no options passed
  options = options || {};  
  
  // Set up
  Readable.call(this, {objectMode: true}***REMOVED***;

  // Default cursor id is 0
  var cursorId = options.cursorId || Long.fromInt(0***REMOVED***;
  var zeroCursor = Long.fromInt(0***REMOVED***;
  var state = 'init';
  var batchSize = options.batchSize || 0;

  // Hardcode batch size
  if(command && command.cursor***REMOVED*** {
    command.cursor.batchSize = 1;
    batchSize = command.cursor.batchSize || 0;
***REMOVED***

  // BatchSize
  var raw = options.raw || false;
  var readPreference = options.readPreference || 'primary';

  // Checkout a connection
  var connection = db.serverConfig.checkoutReader(readPreference***REMOVED***;
  // MaxTimeMS
  var maxTimeMS = options.maxTimeMS;

  // Contains all the items
  var items = options.items || null;

  // Execute getmore
  var getMore = function(callback***REMOVED*** {
    // Resolve more of the cursor using the getMore command
    var getMoreCommand = new GetMoreCommand(db
      , db.databaseName + "." + collection.collectionName
      , batchSize
      , cursorId
    ***REMOVED***;

    // Set up options
    var command_options = { connection:connection };

    // Execute the getMore Command
    db._executeQueryCommand(getMoreCommand, command_options, function(err, result***REMOVED*** {
      if(err***REMOVED*** {
        items = [];
        state = 'closed';
        return callback(err***REMOVED***;
    ***REMOVED***

      // Return all the documents
      callback(null, result***REMOVED***;
  ***REMOVED******REMOVED***;    
***REMOVED***

  var exhaustGetMore = function(callback***REMOVED*** {
    getMore(function(err, result***REMOVED*** {
      if(err***REMOVED*** {
        items = [];
        state = 'closed';
        return callback(err, null***REMOVED***;
    ***REMOVED***

      // Add the items
      items = items.concat(result.documents***REMOVED***;      

      // Set the cursor id
      cursorId = result.cursorId;
      if(typeof cursorId == 'number'***REMOVED*** cursorId = Long.fromNumber(cursorId***REMOVED***;
      
      // If the cursor is done
      if(result.cursorId.equals(zeroCursor***REMOVED******REMOVED*** {
        return callback(null, items***REMOVED***;
    ***REMOVED*** 

      // Check the cursor id
      exhaustGetMore(callback***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  var exhaustGetMoreEach = function(callback***REMOVED*** {
    getMore(function(err, result***REMOVED*** {
      if(err***REMOVED*** {
        items = [];
        state = 'closed';
        return callback(err, null***REMOVED***;
    ***REMOVED***

      // Add the items
      items = result.documents;

      // Emit all the items in the first batch
      while(items.length > 0***REMOVED*** {
        callback(null, items.shift(***REMOVED******REMOVED***;
    ***REMOVED***
      
      // Set the cursor id
      cursorId = result.cursorId;
      if(typeof cursorId == 'number'***REMOVED*** cursorId = Long.fromNumber(cursorId***REMOVED***;

      // If the cursor is done
      if(result.cursorId.equals(zeroCursor***REMOVED******REMOVED*** {
        state = "closed";
        return callback(null, null***REMOVED***;
    ***REMOVED*** 
      
      // Check the cursor id
      exhaustGetMoreEach(callback***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  //
  // Get all the elements
  //
  this.get = function(options, callback***REMOVED*** {
    if(typeof options == 'function'***REMOVED*** {
      callback = options;
      options = {};
  ***REMOVED***

    // Set the connection to the passed in one if it's provided
    connection = options.connection ? options.connection : connection;

    // Command options
    var _options = {connection:connection};
    if(typeof maxTimeMS == 'number'***REMOVED*** _options.maxTimeMS = maxTimeMS;

    // If we have a cursor Id already not equal to 0 we are just going to
    // exhaust the cursor
    if(cursorId.notEquals(zeroCursor***REMOVED******REMOVED*** {
      // If no items set an empty array
      items = items || [];
      // Exhaust the cursor
      return exhaustGetMore(callback***REMOVED***;
  ***REMOVED***

    // Execute the internal command first
    db.command(command, _options, function(err, result***REMOVED*** {
      if(err***REMOVED*** {
        state = 'closed';
        return callback(err, null***REMOVED***;
    ***REMOVED***

      // Retrieve the cursor id
      cursorId = result.cursor.id;
      if(typeof cursorId == 'number'***REMOVED*** cursorId = Long.fromNumber(cursorId***REMOVED***;

      // Validate cursorId
      if(cursorId.equals(zeroCursor***REMOVED******REMOVED*** {
        return callback(null, result.cursor.firstBatch***REMOVED***;
    ***REMOVED***;

      // Add to the items
      items = result.cursor.firstBatch;
      // Execute the getMore
      exhaustGetMore(callback***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  //
  // Iterate over all the items
  //
  this.each = function(options, callback***REMOVED*** {
    if(typeof options == 'function'***REMOVED*** {
      callback = options;
      options = {};
  ***REMOVED***

    // If it's a closed cursor return error
    if(this.isClosed(***REMOVED******REMOVED*** return callback(new Error("cursor is closed"***REMOVED******REMOVED***;
    // Set the connection to the passed in one if it's provided
    connection = options.connection ? options.connection : connection;
  
    // Command options
    var _options = {connection:connection};
    if(typeof maxTimeMS == 'number'***REMOVED*** _options.maxTimeMS = maxTimeMS;

    // If we have a cursor Id already not equal to 0 we are just going to
    // exhaust the cursor
    if(cursorId.notEquals(zeroCursor***REMOVED******REMOVED*** {
      // If no items set an empty array
      items = items || [];

      // Emit all the items in the first batch
      while(items.length > 0***REMOVED*** {
        callback(null, items.shift(***REMOVED******REMOVED***;
    ***REMOVED***

      // Exhaust the cursor
      return exhaustGetMoreEach(callback***REMOVED***;
  ***REMOVED***

    // Execute the internal command first
    db.command(command, _options, function(err, result***REMOVED*** {
      if(err***REMOVED*** {
        state = 'closed';
        return callback(err, null***REMOVED***;
    ***REMOVED***

      // Get all the items
      items = result.cursor.firstBatch;

      // Emit all the items in the first batch
      while(items.length > 0***REMOVED*** {
        callback(null, items.shift(***REMOVED******REMOVED***;
    ***REMOVED***

      // Retrieve the cursor id
      cursorId = result.cursor.id;
      if(typeof cursorId == 'number'***REMOVED*** cursorId = Long.fromNumber(cursorId***REMOVED***;

      // If no cursor we just finish up the current batch of items
      if(cursorId.equals(zeroCursor***REMOVED******REMOVED*** {
        state = 'closed';        
        return callback(null, null***REMOVED***;
    ***REMOVED***

      // Emit each until no more getMore's
      exhaustGetMoreEach(callback***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  //
  // Get the next object
  //
  this.next = function(options, callback***REMOVED*** {
    if(typeof options == 'function'***REMOVED*** {
      callback = options;
      options = {};
  ***REMOVED***

    // If it's a closed cursor return error
    if(this.isClosed(***REMOVED******REMOVED*** return callback(new Error("cursor is closed"***REMOVED******REMOVED***;

    // Set the connection to the passed in one if it's provided
    connection = options.connection ? options.connection : connection;
  
    // Command options
    var _options = {connection:connection};
    if(typeof maxTimeMS == 'number'***REMOVED*** _options.maxTimeMS = maxTimeMS;

    // If we have a cursor Id already not equal to 0 we are just going to
    // going to bypass the command execution
    if(cursorId.notEquals(zeroCursor***REMOVED******REMOVED*** {
      items = items || [];
  ***REMOVED***    

    // Execute the internal command first
    if(!items***REMOVED*** {
      db.command(command, _options, function(err, result***REMOVED*** {
        if(err***REMOVED*** {
          state = 'closed';
          return callback(err, null***REMOVED***;
      ***REMOVED***

        // Retrieve the cursor id
        cursorId = result.cursor.id;
        if(typeof cursorId == 'number'***REMOVED*** cursorId = Long.fromNumber(cursorId***REMOVED***;
        // Get the first batch results
        items = result.cursor.firstBatch;
        // We have items return the first one
        if(items.length > 0***REMOVED*** {
          callback(null, items.shift(***REMOVED******REMOVED***;
      ***REMOVED*** else {
          state = 'closed';
          callback(null, null***REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED*** else if(items.length > 0***REMOVED*** {
      callback(null, items.shift(***REMOVED******REMOVED***;
  ***REMOVED*** else if(items.length == 0 && cursorId.equals(zeroCursor***REMOVED******REMOVED*** {
      state = 'closed';
      callback(null, null***REMOVED***;
  ***REMOVED*** else {
      // Execute a getMore
      getMore(function(err, result***REMOVED*** {
        if(err***REMOVED*** {
          state = 'closed';
          return callback(err, null***REMOVED***;
      ***REMOVED***

        // Set the cursor id
        cursorId = result.cursorId;
        if(typeof cursorId == 'number'***REMOVED*** cursorId = Long.fromNumber(cursorId***REMOVED***;

        // Add the items
        items = items.concat(result.documents***REMOVED***;
        // If no more items
        if(items.length == 0***REMOVED*** {
          state = 'closed';
          return callback(null, null***REMOVED***;
      ***REMOVED***

        // Return the item
        return callback(null, items.shift(***REMOVED******REMOVED***;
    ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***

  // Validate if the cursor is closed
  this.isClosed = function(***REMOVED*** {
    return state == 'closed';
***REMOVED***

  // Allow us to set the MaxTimeMS
  this.maxTimeMS = function(_maxTimeMS***REMOVED*** {
    maxTimeMS = _maxTimeMS;
***REMOVED***

  // Close the cursor sending a kill cursor command if needed
  this.close = function(callback***REMOVED*** {
    // Close the cursor if not needed
    if(cursorId instanceof Long && cursorId.greaterThan(Long.fromInt(0***REMOVED******REMOVED******REMOVED*** {
      try {
        var command = new KillCursorCommand(this.db, [cursorId]***REMOVED***;
        // Added an empty callback to ensure we don't throw any null exceptions
        db._executeQueryCommand(command, {connection:connection}***REMOVED***;
    ***REMOVED*** catch(err***REMOVED*** {}
  ***REMOVED***

    // Null out the connection
    connection = null;
    // Reset cursor id
    cursorId = Long.fromInt(0***REMOVED***;
    // Set to closed status
    state = 'closed';
    // Clear out all the items
    items = null;

    if(callback***REMOVED*** {
      callback(null, null***REMOVED***;
  ***REMOVED***    
***REMOVED***

  //
  // Stream method
  //
  this._read = function(n***REMOVED*** {
    var self = this;
    // Read the next command cursor doc
    self.next(function(err, result***REMOVED*** {
      if(err***REMOVED*** {
        self.emit('error', err***REMOVED***;
        return self.push(null***REMOVED***;
    ***REMOVED***

      self.push(result***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
}

// Inherit from Readable
if(Readable != null***REMOVED*** {
  inherits(CommandCursor, Readable***REMOVED***;  
}

exports.CommandCursor = CommandCursor;