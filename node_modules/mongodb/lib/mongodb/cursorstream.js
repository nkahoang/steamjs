var timers = require('timers'***REMOVED***;

// Set processor, setImmediate if 0.10 otherwise nextTick
var processor = require('./utils'***REMOVED***.processor(***REMOVED***;

/**
 * Module dependecies.
 */
var Stream = require('stream'***REMOVED***.Stream;

/**
 * CursorStream
 *
 * Returns a stream interface for the **cursor**.
 *
 * Options
 *  - **transform** {Function} function of type function(object***REMOVED*** { return transformed }, allows for transformation of data before emitting.
 *
 * Events
 *  - **data** {function(item***REMOVED*** {}} the data event triggers when a document is ready.
 *  - **error** {function(err***REMOVED*** {}} the error event triggers if an error happens.
 *  - **close** {function(***REMOVED*** {}} the end event triggers when there is no more documents available.
 *
 * @class Represents a CursorStream.
 * @param {Cursor} cursor a cursor object that the stream wraps.
 * @return {Stream}
 */
function CursorStream(cursor, options***REMOVED*** {
  if(!(this instanceof CursorStream***REMOVED******REMOVED*** return new CursorStream(cursor***REMOVED***;
  options = options ? options : {};

  Stream.call(this***REMOVED***;

  this.readable = true;
  this.paused = false;
  this._cursor = cursor;
  this._destroyed = null;
  this.options = options;

  // give time to hook up events
  var self = this;
  process.nextTick(function(***REMOVED*** {
    self._init(***REMOVED***;      
***REMOVED******REMOVED***;
}

/**
 * Inherit from Stream
 * @ignore
 * @api private
 */
CursorStream.prototype.__proto__ = Stream.prototype;

/**
 * Flag stating whether or not this stream is readable.
 */
CursorStream.prototype.readable;

/**
 * Flag stating whether or not this stream is paused.
 */
CursorStream.prototype.paused;

/**
 * Initialize the cursor.
 * @ignore
 * @api private
 */
CursorStream.prototype._init = function (***REMOVED*** {
  if (this._destroyed***REMOVED*** return;
  this._next(***REMOVED***;
}

/**
 * Pull the next document from the cursor.
 * @ignore
 * @api private
 */
CursorStream.prototype._next = function (***REMOVED*** {
  if(this.paused || this._destroyed***REMOVED*** return;

  var self = this;
  // Get the next object
  processor(function(***REMOVED*** {
    if(self.paused || self._destroyed***REMOVED*** return;

    self._cursor.nextObject(function (err, doc***REMOVED*** {
      self._onNextObject(err, doc***REMOVED***;
  ***REMOVED******REMOVED***;    
***REMOVED******REMOVED***;
}

/**
 * Handle each document as its returned from the cursor.
 * @ignore
 * @api private
 */
CursorStream.prototype._onNextObject = function (err, doc***REMOVED*** {
  if(err***REMOVED*** return this.destroy(err***REMOVED***;

  // when doc is null we hit the end of the cursor
  if(!doc && (this._cursor.state == 1 || this._cursor.state == 2***REMOVED******REMOVED*** {
    this.emit('end'***REMOVED***
    return this.destroy(***REMOVED***;
***REMOVED*** else if(doc***REMOVED*** {
    var data = typeof this.options.transform == 'function' ? this.options.transform(doc***REMOVED*** : doc;
    this.emit('data', data***REMOVED***;
    this._next(***REMOVED***;
***REMOVED***
}

/**
 * Pauses the stream.
 *
 * @api public
 */
CursorStream.prototype.pause = function (***REMOVED*** {
  this.paused = true;
}

/**
 * Resumes the stream.
 *
 * @api public
 */
CursorStream.prototype.resume = function (***REMOVED*** {
  var self = this;

  // Don't do anything if we are not paused
  if(!this.paused***REMOVED*** return;
  if(!this._cursor.state == 3***REMOVED*** return;

  process.nextTick(function(***REMOVED*** {
    self.paused = false;
    // Only trigger more fetching if the cursor is open
    self._next(***REMOVED***;
***REMOVED******REMOVED***
}

/**
 * Destroys the stream, closing the underlying
 * cursor. No more events will be emitted.
 *
 * @api public
 */
CursorStream.prototype.destroy = function (err***REMOVED*** {
  if (this._destroyed***REMOVED*** return;
  this._destroyed = true;
  this.readable = false;

  this._cursor.close(***REMOVED***;

  if(err***REMOVED*** {
    this.emit('error', err***REMOVED***;
***REMOVED***

  this.emit('close'***REMOVED***;
}

// TODO - maybe implement the raw option to pass binary?
//CursorStream.prototype.setEncoding = function (***REMOVED*** {
//}

module.exports = exports = CursorStream;
