#include "kerberos.h"
#include <stdlib.h>
#include "worker.h"
#include "kerberos_context.h"

#ifndef ARRAY_SIZE
# define ARRAY_SIZE(a***REMOVED*** (sizeof((a***REMOVED******REMOVED*** / sizeof((a***REMOVED***[0]***REMOVED******REMOVED***
#endif

Persistent<FunctionTemplate> Kerberos::constructor_template;

// Call structs
typedef struct AuthGSSClientCall {
  uint32_t  flags;
  char *uri;
} AuthGSSClientCall;

typedef struct AuthGSSClientStepCall {
  KerberosContext *context;
  char *challenge;
} AuthGSSClientStepCall;

typedef struct AuthGSSClientUnwrapCall {
  KerberosContext *context;
  char *challenge;
} AuthGSSClientUnwrapCall;

typedef struct AuthGSSClientWrapCall {
  KerberosContext *context;
  char *challenge;
  char *user_name;
} AuthGSSClientWrapCall;

typedef struct AuthGSSClientCleanCall {
  KerberosContext *context;
} AuthGSSClientCleanCall;

// VException object (causes throw in calling code***REMOVED***
static Handle<Value> VException(const char *msg***REMOVED*** {
  HandleScope scope;
  return ThrowException(Exception::Error(String::New(msg***REMOVED******REMOVED******REMOVED***;
}

Kerberos::Kerberos(***REMOVED*** : ObjectWrap(***REMOVED*** {
}

void Kerberos::Initialize(v8::Handle<v8::Object> target***REMOVED*** {
  // Grab the scope of the call from Node
  HandleScope scope;
  // Define a new function template
  Local<FunctionTemplate> t = FunctionTemplate::New(Kerberos::New***REMOVED***;
  constructor_template = Persistent<FunctionTemplate>::New(t***REMOVED***;
  constructor_template->InstanceTemplate(***REMOVED***->SetInternalFieldCount(1***REMOVED***;
  constructor_template->SetClassName(String::NewSymbol("Kerberos"***REMOVED******REMOVED***;

  // Set up method for the Kerberos instance
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "authGSSClientInit", AuthGSSClientInit***REMOVED***;  
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "authGSSClientStep", AuthGSSClientStep***REMOVED***;  
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "authGSSClientUnwrap", AuthGSSClientUnwrap***REMOVED***;
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "authGSSClientWrap", AuthGSSClientWrap***REMOVED***;
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "authGSSClientClean", AuthGSSClientClean***REMOVED***;

  // Set the symbol
  target->ForceSet(String::NewSymbol("Kerberos"***REMOVED***, constructor_template->GetFunction(***REMOVED******REMOVED***;
}

Handle<Value> Kerberos::New(const Arguments &args***REMOVED*** {
  // Create a Kerberos instance
  Kerberos *kerberos = new Kerberos(***REMOVED***;
  // Return the kerberos object
  kerberos->Wrap(args.This(***REMOVED******REMOVED***;
  return args.This(***REMOVED***;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// authGSSClientInit
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void _authGSSClientInit(Worker *worker***REMOVED*** {
  gss_client_state *state;
  gss_client_response *response;

  // Allocate state
  state = (gss_client_state ****REMOVED***malloc(sizeof(gss_client_state***REMOVED******REMOVED***;
  
  // Unpack the parameter data struct
  AuthGSSClientCall *call = (AuthGSSClientCall ****REMOVED***worker->parameters;
  // Start the kerberos client
  response = authenticate_gss_client_init(call->uri, call->flags, state***REMOVED***;

  // Release the parameter struct memory
  free(call->uri***REMOVED***;
  free(call***REMOVED***;

  // If we have an error mark worker as having had an error
  if(response->return_code == AUTH_GSS_ERROR***REMOVED*** {
    worker->error = TRUE;
    worker->error_code = response->return_code;
    worker->error_message = response->message;
***REMOVED*** else {
    worker->return_value = state;
***REMOVED***

  // Free structure
  free(response***REMOVED***;
}

static Handle<Value> _map_authGSSClientInit(Worker *worker***REMOVED*** {
  HandleScope scope;

  KerberosContext *context = KerberosContext::New(***REMOVED***;
  context->state = (gss_client_state ****REMOVED***worker->return_value;
  // Persistent<Value> _context = Persistent<Value>::New(context->handle_***REMOVED***;
  return scope.Close(context->handle_***REMOVED***;
}

// Initialize method
Handle<Value> Kerberos::AuthGSSClientInit(const Arguments &args***REMOVED*** {
  HandleScope scope;

  // Ensure valid call
  if(args.Length(***REMOVED*** != 3***REMOVED*** return VException("Requires a service string uri, integer flags and a callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 3 && !args[0]->IsString(***REMOVED*** && !args[1]->IsInt32(***REMOVED*** && !args[2]->IsFunction(***REMOVED******REMOVED*** 
      return VException("Requires a service string uri, integer flags and a callback function"***REMOVED***;    

  Local<String> service = args[0]->ToString(***REMOVED***;
  // Convert uri string to c-string
  char *service_str = (char ****REMOVED***calloc(service->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  // Write v8 string to c-string
  service->WriteUtf8(service_str***REMOVED***;

  // Allocate a structure
  AuthGSSClientCall *call = (AuthGSSClientCall ****REMOVED***calloc(1, sizeof(AuthGSSClientCall***REMOVED******REMOVED***;
  call->flags =args[1]->ToInt32(***REMOVED***->Uint32Value(***REMOVED***;
  call->uri = service_str;

  // Unpack the callback
  Local<Function> callback = Local<Function>::Cast(args[2]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _authGSSClientInit;
  worker->mapper = _map_authGSSClientInit;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Kerberos::Process, (uv_after_work_cb***REMOVED***Kerberos::After***REMOVED***;
  // Return no value as it's callback based
  return scope.Close(Undefined(***REMOVED******REMOVED***;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// authGSSClientStep
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void _authGSSClientStep(Worker *worker***REMOVED*** {
  gss_client_state *state;
  gss_client_response *response;
  char *challenge;

  // Unpack the parameter data struct
  AuthGSSClientStepCall *call = (AuthGSSClientStepCall ****REMOVED***worker->parameters;
  // Get the state
  state = call->context->state;
  challenge = call->challenge;

  // Check what kind of challenge we have
  if(call->challenge == NULL***REMOVED*** {
    challenge = (char ****REMOVED***"";
***REMOVED***

  // Perform authentication step
  response = authenticate_gss_client_step(state, challenge***REMOVED***;

  // If we have an error mark worker as having had an error
  if(response->return_code == AUTH_GSS_ERROR***REMOVED*** {
    worker->error = TRUE;
    worker->error_code = response->return_code;
    worker->error_message = response->message;
***REMOVED*** else {
    worker->return_code = response->return_code;
***REMOVED***

  // Free up structure
  if(call->challenge != NULL***REMOVED*** free(call->challenge***REMOVED***;
  free(call***REMOVED***;
  free(response***REMOVED***;
}

static Handle<Value> _map_authGSSClientStep(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Return the return code
  return scope.Close(Int32::New(worker->return_code***REMOVED******REMOVED***;
}

// Initialize method
Handle<Value> Kerberos::AuthGSSClientStep(const Arguments &args***REMOVED*** {
  HandleScope scope;

  // Ensure valid call
  if(args.Length(***REMOVED*** != 2 && args.Length(***REMOVED*** != 3***REMOVED*** return VException("Requires a GSS context, optional challenge string and callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 2 && !KerberosContext::HasInstance(args[0]***REMOVED******REMOVED*** return VException("Requires a GSS context, optional challenge string and callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 3 && !KerberosContext::HasInstance(args[0]***REMOVED*** && !args[1]->IsString(***REMOVED******REMOVED*** return VException("Requires a GSS context, optional challenge string and callback function"***REMOVED***;

  // Challenge string
  char *challenge_str = NULL;
  // Let's unpack the parameters
  Local<Object> object = args[0]->ToObject(***REMOVED***;
  KerberosContext *kerberos_context = KerberosContext::Unwrap<KerberosContext>(object***REMOVED***;

  // If we have a challenge string
  if(args.Length(***REMOVED*** == 3***REMOVED*** {
    // Unpack the challenge string
    Local<String> challenge = args[1]->ToString(***REMOVED***;
    // Convert uri string to c-string
    challenge_str = (char ****REMOVED***calloc(challenge->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    // Write v8 string to c-string
    challenge->WriteUtf8(challenge_str***REMOVED***;    
***REMOVED***

  // Allocate a structure
  AuthGSSClientStepCall *call = (AuthGSSClientStepCall ****REMOVED***calloc(1, sizeof(AuthGSSClientCall***REMOVED******REMOVED***;
  call->context = kerberos_context;
  call->challenge = challenge_str;

  // Unpack the callback
  Local<Function> callback = Local<Function>::Cast(args[2]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _authGSSClientStep;
  worker->mapper = _map_authGSSClientStep;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Kerberos::Process, (uv_after_work_cb***REMOVED***Kerberos::After***REMOVED***;

  // Return no value as it's callback based
  return scope.Close(Undefined(***REMOVED******REMOVED***;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// authGSSClientUnwrap
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void _authGSSClientUnwrap(Worker *worker***REMOVED*** {
  gss_client_response *response;
  char *challenge;

  // Unpack the parameter data struct
  AuthGSSClientUnwrapCall *call = (AuthGSSClientUnwrapCall ****REMOVED***worker->parameters;
  challenge = call->challenge;

  // Check what kind of challenge we have
  if(call->challenge == NULL***REMOVED*** {
    challenge = (char ****REMOVED***"";
***REMOVED***

  // Perform authentication step
  response = authenticate_gss_client_unwrap(call->context->state, challenge***REMOVED***;

  // If we have an error mark worker as having had an error
  if(response->return_code == AUTH_GSS_ERROR***REMOVED*** {
    worker->error = TRUE;
    worker->error_code = response->return_code;
    worker->error_message = response->message;
***REMOVED*** else {
    worker->return_code = response->return_code;
***REMOVED***

  // Free up structure
  if(call->challenge != NULL***REMOVED*** free(call->challenge***REMOVED***;
  free(call***REMOVED***;
  free(response***REMOVED***;
}

static Handle<Value> _map_authGSSClientUnwrap(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Return the return code
  return scope.Close(Int32::New(worker->return_code***REMOVED******REMOVED***;
}

// Initialize method
Handle<Value> Kerberos::AuthGSSClientUnwrap(const Arguments &args***REMOVED*** {
  HandleScope scope;

  // Ensure valid call
  if(args.Length(***REMOVED*** != 2 && args.Length(***REMOVED*** != 3***REMOVED*** return VException("Requires a GSS context, optional challenge string and callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 2 && !KerberosContext::HasInstance(args[0]***REMOVED*** && !args[1]->IsFunction(***REMOVED******REMOVED*** return VException("Requires a GSS context, optional challenge string and callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 3 && !KerberosContext::HasInstance(args[0]***REMOVED*** && !args[1]->IsString(***REMOVED*** && !args[2]->IsFunction(***REMOVED******REMOVED*** return VException("Requires a GSS context, optional challenge string and callback function"***REMOVED***;

  // Challenge string
  char *challenge_str = NULL;
  // Let's unpack the parameters
  Local<Object> object = args[0]->ToObject(***REMOVED***;
  KerberosContext *kerberos_context = KerberosContext::Unwrap<KerberosContext>(object***REMOVED***;

  // If we have a challenge string
  if(args.Length(***REMOVED*** == 3***REMOVED*** {
    // Unpack the challenge string
    Local<String> challenge = args[1]->ToString(***REMOVED***;
    // Convert uri string to c-string
    challenge_str = (char ****REMOVED***calloc(challenge->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    // Write v8 string to c-string
    challenge->WriteUtf8(challenge_str***REMOVED***;    
***REMOVED***

  // Allocate a structure
  AuthGSSClientUnwrapCall *call = (AuthGSSClientUnwrapCall ****REMOVED***calloc(1, sizeof(AuthGSSClientUnwrapCall***REMOVED******REMOVED***;
  call->context = kerberos_context;
  call->challenge = challenge_str;

  // Unpack the callback
  Local<Function> callback = args.Length(***REMOVED*** == 3 ? Local<Function>::Cast(args[2]***REMOVED*** : Local<Function>::Cast(args[1]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _authGSSClientUnwrap;
  worker->mapper = _map_authGSSClientUnwrap;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Kerberos::Process, (uv_after_work_cb***REMOVED***Kerberos::After***REMOVED***;

  // Return no value as it's callback based
  return scope.Close(Undefined(***REMOVED******REMOVED***;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// authGSSClientWrap
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void _authGSSClientWrap(Worker *worker***REMOVED*** {
  gss_client_response *response;
  char *user_name = NULL;

  // Unpack the parameter data struct
  AuthGSSClientWrapCall *call = (AuthGSSClientWrapCall ****REMOVED***worker->parameters;
  user_name = call->user_name;  

  // Check what kind of challenge we have
  if(call->user_name == NULL***REMOVED*** {
    user_name = (char ****REMOVED***"";
***REMOVED***

  // Perform authentication step
  response = authenticate_gss_client_wrap(call->context->state, call->challenge, user_name***REMOVED***;

  // If we have an error mark worker as having had an error
  if(response->return_code == AUTH_GSS_ERROR***REMOVED*** {
    worker->error = TRUE;
    worker->error_code = response->return_code;
    worker->error_message = response->message;
***REMOVED*** else {
    worker->return_code = response->return_code;
***REMOVED***

  // Free up structure
  if(call->challenge != NULL***REMOVED*** free(call->challenge***REMOVED***;
  if(call->user_name != NULL***REMOVED*** free(call->user_name***REMOVED***;
  free(call***REMOVED***;
  free(response***REMOVED***;
}

static Handle<Value> _map_authGSSClientWrap(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Return the return code
  return scope.Close(Int32::New(worker->return_code***REMOVED******REMOVED***;
}

// Initialize method
Handle<Value> Kerberos::AuthGSSClientWrap(const Arguments &args***REMOVED*** {
  HandleScope scope;

  // Ensure valid call
  if(args.Length(***REMOVED*** != 3 && args.Length(***REMOVED*** != 4***REMOVED*** return VException("Requires a GSS context, the result from the authGSSClientResponse after authGSSClientUnwrap, optional user name and callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 3 && !KerberosContext::HasInstance(args[0]***REMOVED*** && !args[1]->IsString(***REMOVED*** && !args[2]->IsFunction(***REMOVED******REMOVED*** return VException("Requires a GSS context, the result from the authGSSClientResponse after authGSSClientUnwrap, optional user name and callback function"***REMOVED***;
  if(args.Length(***REMOVED*** == 4 && !KerberosContext::HasInstance(args[0]***REMOVED*** && !args[1]->IsString(***REMOVED*** && !args[2]->IsString(***REMOVED*** && !args[2]->IsFunction(***REMOVED******REMOVED*** return VException("Requires a GSS context, the result from the authGSSClientResponse after authGSSClientUnwrap, optional user name and callback function"***REMOVED***;

  // Challenge string
  char *challenge_str = NULL;
  char *user_name_str = NULL;
  
  // Let's unpack the kerberos context
  Local<Object> object = args[0]->ToObject(***REMOVED***;
  KerberosContext *kerberos_context = KerberosContext::Unwrap<KerberosContext>(object***REMOVED***;

  // Unpack the challenge string
  Local<String> challenge = args[1]->ToString(***REMOVED***;
  // Convert uri string to c-string
  challenge_str = (char ****REMOVED***calloc(challenge->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  // Write v8 string to c-string
  challenge->WriteUtf8(challenge_str***REMOVED***;    

  // If we have a user string
  if(args.Length(***REMOVED*** == 4***REMOVED*** {
    // Unpack user name
    Local<String> user_name = args[2]->ToString(***REMOVED***;
    // Convert uri string to c-string
    user_name_str = (char ****REMOVED***calloc(user_name->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    // Write v8 string to c-string
    user_name->WriteUtf8(user_name_str***REMOVED***;
***REMOVED***

  // Allocate a structure
  AuthGSSClientWrapCall *call = (AuthGSSClientWrapCall ****REMOVED***calloc(1, sizeof(AuthGSSClientWrapCall***REMOVED******REMOVED***;
  call->context = kerberos_context;
  call->challenge = challenge_str;
  call->user_name = user_name_str;

  // Unpack the callback
  Local<Function> callback = args.Length(***REMOVED*** == 4 ? Local<Function>::Cast(args[3]***REMOVED*** : Local<Function>::Cast(args[2]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _authGSSClientWrap;
  worker->mapper = _map_authGSSClientWrap;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Kerberos::Process, (uv_after_work_cb***REMOVED***Kerberos::After***REMOVED***;

  // Return no value as it's callback based
  return scope.Close(Undefined(***REMOVED******REMOVED***;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// authGSSClientWrap
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void _authGSSClientClean(Worker *worker***REMOVED*** {
  gss_client_response *response;

  // Unpack the parameter data struct
  AuthGSSClientCleanCall *call = (AuthGSSClientCleanCall ****REMOVED***worker->parameters;

  // Perform authentication step
  response = authenticate_gss_client_clean(call->context->state***REMOVED***;

  // If we have an error mark worker as having had an error
  if(response->return_code == AUTH_GSS_ERROR***REMOVED*** {
    worker->error = TRUE;
    worker->error_code = response->return_code;
    worker->error_message = response->message;
***REMOVED*** else {
    worker->return_code = response->return_code;
***REMOVED***

  // Free up structure
  free(call***REMOVED***;
  free(response***REMOVED***;
}

static Handle<Value> _map_authGSSClientClean(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Return the return code
  return scope.Close(Int32::New(worker->return_code***REMOVED******REMOVED***;
}

// Initialize method
Handle<Value> Kerberos::AuthGSSClientClean(const Arguments &args***REMOVED*** {
  HandleScope scope;

  // // Ensure valid call
  if(args.Length(***REMOVED*** != 2***REMOVED*** return VException("Requires a GSS context and callback function"***REMOVED***;
  if(!KerberosContext::HasInstance(args[0]***REMOVED*** && !args[1]->IsFunction(***REMOVED******REMOVED*** return VException("Requires a GSS context and callback function"***REMOVED***;

  // Let's unpack the kerberos context
  Local<Object> object = args[0]->ToObject(***REMOVED***;
  KerberosContext *kerberos_context = KerberosContext::Unwrap<KerberosContext>(object***REMOVED***;

  // Allocate a structure
  AuthGSSClientCleanCall *call = (AuthGSSClientCleanCall ****REMOVED***calloc(1, sizeof(AuthGSSClientCleanCall***REMOVED******REMOVED***;
  call->context = kerberos_context;

  // Unpack the callback
  Local<Function> callback = Local<Function>::Cast(args[1]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _authGSSClientClean;
  worker->mapper = _map_authGSSClientClean;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Kerberos::Process, (uv_after_work_cb***REMOVED***Kerberos::After***REMOVED***;

  // Return no value as it's callback based
  return scope.Close(Undefined(***REMOVED******REMOVED***;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// UV Lib callbacks
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void Kerberos::Process(uv_work_t* work_req***REMOVED*** {
  // Grab the worker
  Worker *worker = static_cast<Worker*>(work_req->data***REMOVED***;
  // Execute the worker code
  worker->execute(worker***REMOVED***;
}

void Kerberos::After(uv_work_t* work_req***REMOVED*** {
  // Grab the scope of the call from Node
  v8::HandleScope scope;

  // Get the worker reference
  Worker *worker = static_cast<Worker*>(work_req->data***REMOVED***;

  // If we have an error
  if(worker->error***REMOVED*** {
    v8::Local<v8::Value> err = v8::Exception::Error(v8::String::New(worker->error_message***REMOVED******REMOVED***;
    Local<Object> obj = err->ToObject(***REMOVED***;
    obj->Set(NODE_PSYMBOL("code"***REMOVED***, Int32::New(worker->error_code***REMOVED******REMOVED***;
    v8::Local<v8::Value> args[2] = { err, v8::Local<v8::Value>::New(v8::Null(***REMOVED******REMOVED*** };
    // Execute the error
    v8::TryCatch try_catch;
    // Call the callback
    worker->callback->Call(v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***, ARRAY_SIZE(args***REMOVED***, args***REMOVED***;
    // If we have an exception handle it as a fatalexception
    if (try_catch.HasCaught(***REMOVED******REMOVED*** {
      node::FatalException(try_catch***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    // // Map the data
    v8::Handle<v8::Value> result = worker->mapper(worker***REMOVED***;
    // Set up the callback with a null first
    v8::Handle<v8::Value> args[2] = { v8::Local<v8::Value>::New(v8::Null(***REMOVED******REMOVED***, result};
    // Wrap the callback function call in a TryCatch so that we can call
    // node's FatalException afterwards. This makes it possible to catch
    // the exception from JavaScript land using the
    // process.on('uncaughtException'***REMOVED*** event.
    v8::TryCatch try_catch;
    // Call the callback
    worker->callback->Call(v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***, ARRAY_SIZE(args***REMOVED***, args***REMOVED***;
    // If we have an exception handle it as a fatalexception
    if (try_catch.HasCaught(***REMOVED******REMOVED*** {
      node::FatalException(try_catch***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Clean up the memory
  worker->callback.Dispose(***REMOVED***;
  delete worker;
}

// Exporting function
extern "C" void init(Handle<Object> target***REMOVED*** {
  HandleScope scope;
  Kerberos::Initialize(target***REMOVED***;
  KerberosContext::Initialize(target***REMOVED***;
}

NODE_MODULE(kerberos, init***REMOVED***;
