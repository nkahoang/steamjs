#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <v8.h>
#include <node.h>
#include <node_buffer.h>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <limits>

#include "security_context.h"
#include "security_buffer_descriptor.h"

#ifndef ARRAY_SIZE
# define ARRAY_SIZE(a***REMOVED*** (sizeof((a***REMOVED******REMOVED*** / sizeof((a***REMOVED***[0]***REMOVED******REMOVED***
#endif

static LPSTR DisplaySECError(DWORD ErrCode***REMOVED***;

static Handle<Value> VException(const char *msg***REMOVED*** {
  HandleScope scope;
  return ThrowException(Exception::Error(String::New(msg***REMOVED******REMOVED******REMOVED***;
};

static Handle<Value> VExceptionErrNo(const char *msg, const int errorNumber***REMOVED*** {
  HandleScope scope;

  Local<Value> err = Exception::Error(String::New(msg***REMOVED******REMOVED***;
  Local<Object> obj = err->ToObject(***REMOVED***;
  obj->Set(NODE_PSYMBOL("code"***REMOVED***, Int32::New(errorNumber***REMOVED******REMOVED***;
  return ThrowException(err***REMOVED***;
};

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// UV Lib callbacks
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void Process(uv_work_t* work_req***REMOVED*** {
  // Grab the worker
  Worker *worker = static_cast<Worker*>(work_req->data***REMOVED***;
  // Execute the worker code
  worker->execute(worker***REMOVED***;
}

static void After(uv_work_t* work_req***REMOVED*** {
  // Grab the scope of the call from Node
  v8::HandleScope scope;

  // Get the worker reference
  Worker *worker = static_cast<Worker*>(work_req->data***REMOVED***;

  // If we have an error
  if(worker->error***REMOVED*** {
    v8::Local<v8::Value> err = v8::Exception::Error(v8::String::New(worker->error_message***REMOVED******REMOVED***;
    Local<Object> obj = err->ToObject(***REMOVED***;
    obj->Set(NODE_PSYMBOL("code"***REMOVED***, Int32::New(worker->error_code***REMOVED******REMOVED***;
    v8::Local<v8::Value> args[2] = { err, v8::Local<v8::Value>::New(v8::Null(***REMOVED******REMOVED*** };
    // Execute the error
    v8::TryCatch try_catch;
    // Call the callback
    worker->callback->Call(v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***, ARRAY_SIZE(args***REMOVED***, args***REMOVED***;
    // If we have an exception handle it as a fatalexception
    if (try_catch.HasCaught(***REMOVED******REMOVED*** {
      node::FatalException(try_catch***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    // // Map the data
    v8::Handle<v8::Value> result = worker->mapper(worker***REMOVED***;
    // Set up the callback with a null first
    v8::Handle<v8::Value> args[2] = { v8::Local<v8::Value>::New(v8::Null(***REMOVED******REMOVED***, result};
    // Wrap the callback function call in a TryCatch so that we can call
    // node's FatalException afterwards. This makes it possible to catch
    // the exception from JavaScript land using the
    // process.on('uncaughtException'***REMOVED*** event.
    v8::TryCatch try_catch;
    // Call the callback
    worker->callback->Call(v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***, ARRAY_SIZE(args***REMOVED***, args***REMOVED***;
    // If we have an exception handle it as a fatalexception
    if (try_catch.HasCaught(***REMOVED******REMOVED*** {
      node::FatalException(try_catch***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Clean up the memory
  worker->callback.Dispose(***REMOVED***;
  free(worker->parameters***REMOVED***;
  delete worker;
}

Persistent<FunctionTemplate> SecurityContext::constructor_template;

SecurityContext::SecurityContext(***REMOVED*** : ObjectWrap(***REMOVED*** {
}

SecurityContext::~SecurityContext(***REMOVED*** {
  if(this->hasContext***REMOVED*** {
    _sspi_DeleteSecurityContext(&this->m_Context***REMOVED***;
***REMOVED***
}

Handle<Value> SecurityContext::New(const Arguments &args***REMOVED*** {
  HandleScope scope;    

  PSecurityFunctionTable pSecurityInterface = NULL;
  DWORD dwNumOfPkgs;
  SECURITY_STATUS status;

  // Create code object
  SecurityContext *security_obj = new SecurityContext(***REMOVED***;
  // Get security table interface
  pSecurityInterface = _ssip_InitSecurityInterface(***REMOVED***;
  // Call the security interface
  status = (*pSecurityInterface->EnumerateSecurityPackages***REMOVED***(
                                                    &dwNumOfPkgs, 
                                                    &security_obj->m_PkgInfo***REMOVED***;
  if(status != SEC_E_OK***REMOVED*** {
    printf(TEXT("Failed in retrieving security packages, Error: %x"***REMOVED***, GetLastError(***REMOVED******REMOVED***;
    return VException("Failed in retrieving security packages"***REMOVED***;
***REMOVED***

  // Wrap it
  security_obj->Wrap(args.This(***REMOVED******REMOVED***;
  // Return the object
  return args.This(***REMOVED***;    
}

Handle<Value> SecurityContext::InitializeContextSync(const Arguments &args***REMOVED*** {
  HandleScope scope;  
  char *service_principal_name_str = NULL, *input_str = NULL, *decoded_input_str = NULL;
  BYTE *out_bound_data_str = NULL;
  int decoded_input_str_length = NULL;
  // Store reference to security credentials
  SecurityCredentials *security_credentials = NULL;
  // Status of operation
  SECURITY_STATUS status;

  // We need 3 parameters
  if(args.Length(***REMOVED*** != 3***REMOVED***
    return VException("Initialize must be called with either [credential:SecurityCredential, servicePrincipalName:string, input:string]"***REMOVED***;

  // First parameter must be an instance of SecurityCredentials
  if(!SecurityCredentials::HasInstance(args[0]***REMOVED******REMOVED***
    return VException("First parameter for Initialize must be an instance of SecurityCredentials"***REMOVED***;

  // Second parameter must be a string
  if(!args[1]->IsString(***REMOVED******REMOVED***
    return VException("Second parameter for Initialize must be a string"***REMOVED***;

  // Third parameter must be a base64 encoded string
  if(!args[2]->IsString(***REMOVED******REMOVED***
    return VException("Second parameter for Initialize must be a string"***REMOVED***;

  // Let's unpack the values
  Local<String> service_principal_name = args[1]->ToString(***REMOVED***;
  service_principal_name_str = (char ****REMOVED***calloc(service_principal_name->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  service_principal_name->WriteUtf8(service_principal_name_str***REMOVED***;

  // Unpack the user name
  Local<String> input = args[2]->ToString(***REMOVED***;

  if(input->Utf8Length(***REMOVED*** > 0***REMOVED*** {
    input_str = (char ****REMOVED***calloc(input->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    input->WriteUtf8(input_str***REMOVED***;

    // Now let's get the base64 decoded string
    decoded_input_str = (char ****REMOVED***base64_decode(input_str, &decoded_input_str_length***REMOVED***;
***REMOVED***

  // Unpack the Security credentials
  security_credentials = ObjectWrap::Unwrap<SecurityCredentials>(args[0]->ToObject(***REMOVED******REMOVED***;

  // Create Security context instance
  Local<Object> security_context_value = constructor_template->GetFunction(***REMOVED***->NewInstance(***REMOVED***;
  // Unwrap the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(security_context_value***REMOVED***;
  // Add a reference to the security_credentials
  security_context->security_credentials = security_credentials;

  // Structures used for c calls
  SecBufferDesc ibd, obd;
  SecBuffer ib, ob;

  // 
  // Prepare data structure for returned data from SSPI
  ob.BufferType = SECBUFFER_TOKEN;
  ob.cbBuffer = security_context->m_PkgInfo->cbMaxToken;
  // Allocate space for return data
  out_bound_data_str = new BYTE[ob.cbBuffer + sizeof(DWORD***REMOVED***];
  ob.pvBuffer = out_bound_data_str;
  // prepare buffer description
  obd.cBuffers  = 1;
  obd.ulVersion = SECBUFFER_VERSION;
  obd.pBuffers  = &ob;

  //
  // Prepare the data we are passing to the SSPI method
  if(input->Utf8Length(***REMOVED*** > 0***REMOVED*** {
    ib.BufferType = SECBUFFER_TOKEN;
    ib.cbBuffer   = decoded_input_str_length;
    ib.pvBuffer   = decoded_input_str;
    // prepare buffer description
    ibd.cBuffers  = 1;
    ibd.ulVersion = SECBUFFER_VERSION;
    ibd.pBuffers  = &ib;    
***REMOVED***

  // Perform initialization step
  status = _sspi_initializeSecurityContext(
      &security_credentials->m_Credentials
    , NULL
    , const_cast<TCHAR*>(service_principal_name_str***REMOVED***
    , 0x02  // MUTUAL
    , 0
    , 0     // Network
    , input->Utf8Length(***REMOVED*** > 0 ? &ibd : NULL
    , 0
    , &security_context->m_Context
    , &obd
    , &security_context->CtxtAttr
    , &security_context->Expiration
  ***REMOVED***;

  // If we have a ok or continue let's prepare the result
  if(status == SEC_E_OK 
    || status == SEC_I_COMPLETE_NEEDED
    || status == SEC_I_CONTINUE_NEEDED
    || status == SEC_I_COMPLETE_AND_CONTINUE
  ***REMOVED*** {
    security_context->hasContext = true;
    security_context->payload = base64_encode((const unsigned char ****REMOVED***ob.pvBuffer, ob.cbBuffer***REMOVED***;
***REMOVED*** else {
    LPSTR err_message = DisplaySECError(status***REMOVED***;

    if(err_message != NULL***REMOVED*** {
      return VExceptionErrNo(err_message, status***REMOVED***;
  ***REMOVED*** else {
      return VExceptionErrNo("Unknown error", status***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Return security context
  return scope.Close(security_context_value***REMOVED***;
}

//
//  Async InitializeContext
//
typedef struct SecurityContextStaticInitializeCall {
  char *service_principal_name_str;
  char *decoded_input_str;
  int decoded_input_str_length;
  SecurityContext *context;
} SecurityContextStaticInitializeCall;

static void _initializeContext(Worker *worker***REMOVED*** {
  // Status of operation
  SECURITY_STATUS status;
  BYTE *out_bound_data_str = NULL;
  SecurityContextStaticInitializeCall *call = (SecurityContextStaticInitializeCall ****REMOVED***worker->parameters;

  // Structures used for c calls
  SecBufferDesc ibd, obd;
  SecBuffer ib, ob;

  // 
  // Prepare data structure for returned data from SSPI
  ob.BufferType = SECBUFFER_TOKEN;
  ob.cbBuffer = call->context->m_PkgInfo->cbMaxToken;
  // Allocate space for return data
  out_bound_data_str = new BYTE[ob.cbBuffer + sizeof(DWORD***REMOVED***];
  ob.pvBuffer = out_bound_data_str;
  // prepare buffer description
  obd.cBuffers  = 1;
  obd.ulVersion = SECBUFFER_VERSION;
  obd.pBuffers  = &ob;

  //
  // Prepare the data we are passing to the SSPI method
  if(call->decoded_input_str_length > 0***REMOVED*** {
    ib.BufferType = SECBUFFER_TOKEN;
    ib.cbBuffer   = call->decoded_input_str_length;
    ib.pvBuffer   = call->decoded_input_str;
    // prepare buffer description
    ibd.cBuffers  = 1;
    ibd.ulVersion = SECBUFFER_VERSION;
    ibd.pBuffers  = &ib;    
***REMOVED***

  // Perform initialization step
  status = _sspi_initializeSecurityContext(
      &call->context->security_credentials->m_Credentials
    , NULL
    , const_cast<TCHAR*>(call->service_principal_name_str***REMOVED***
    , 0x02  // MUTUAL
    , 0
    , 0     // Network
    , call->decoded_input_str_length > 0 ? &ibd : NULL
    , 0
    , &call->context->m_Context
    , &obd
    , &call->context->CtxtAttr
    , &call->context->Expiration
  ***REMOVED***;

  // If we have a ok or continue let's prepare the result
  if(status == SEC_E_OK 
    || status == SEC_I_COMPLETE_NEEDED
    || status == SEC_I_CONTINUE_NEEDED
    || status == SEC_I_COMPLETE_AND_CONTINUE
  ***REMOVED*** {
    call->context->hasContext = true;
    call->context->payload = base64_encode((const unsigned char ****REMOVED***ob.pvBuffer, ob.cbBuffer***REMOVED***;

    // Set the context
    worker->return_code = status;
    worker->return_value = call->context;
***REMOVED*** else {
    worker->error = TRUE;
    worker->error_code = status;
    worker->error_message = DisplaySECError(status***REMOVED***;
***REMOVED***

  // Clean up data
  if(call->decoded_input_str != NULL***REMOVED*** free(call->decoded_input_str***REMOVED***;
  if(call->service_principal_name_str != NULL***REMOVED*** free(call->service_principal_name_str***REMOVED***;
}

static Handle<Value> _map_initializeContext(Worker *worker***REMOVED*** {
  HandleScope scope;

  // Unwrap the security context
  SecurityContext *context = (SecurityContext ****REMOVED***worker->return_value;
  // Return the value
  return scope.Close(context->handle_***REMOVED***;
}

Handle<Value> SecurityContext::InitializeContext(const Arguments &args***REMOVED*** {
  HandleScope scope;  
  char *service_principal_name_str = NULL, *input_str = NULL, *decoded_input_str = NULL;
  int decoded_input_str_length = NULL;
  // Store reference to security credentials
  SecurityCredentials *security_credentials = NULL;

  // We need 3 parameters
  if(args.Length(***REMOVED*** != 4***REMOVED***
    return VException("Initialize must be called with [credential:SecurityCredential, servicePrincipalName:string, input:string, callback:function]"***REMOVED***;

  // First parameter must be an instance of SecurityCredentials
  if(!SecurityCredentials::HasInstance(args[0]***REMOVED******REMOVED***
    return VException("First parameter for Initialize must be an instance of SecurityCredentials"***REMOVED***;

  // Second parameter must be a string
  if(!args[1]->IsString(***REMOVED******REMOVED***
    return VException("Second parameter for Initialize must be a string"***REMOVED***;

  // Third parameter must be a base64 encoded string
  if(!args[2]->IsString(***REMOVED******REMOVED***
    return VException("Second parameter for Initialize must be a string"***REMOVED***;

  // Third parameter must be a callback
  if(!args[3]->IsFunction(***REMOVED******REMOVED***
    return VException("Third parameter for Initialize must be a callback function"***REMOVED***;

  // Let's unpack the values
  Local<String> service_principal_name = args[1]->ToString(***REMOVED***;
  service_principal_name_str = (char ****REMOVED***calloc(service_principal_name->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  service_principal_name->WriteUtf8(service_principal_name_str***REMOVED***;

  // Unpack the user name
  Local<String> input = args[2]->ToString(***REMOVED***;

  if(input->Utf8Length(***REMOVED*** > 0***REMOVED*** {
    input_str = (char ****REMOVED***calloc(input->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    input->WriteUtf8(input_str***REMOVED***;

    // Now let's get the base64 decoded string
    decoded_input_str = (char ****REMOVED***base64_decode(input_str, &decoded_input_str_length***REMOVED***;
    // Free original allocation
    free(input_str***REMOVED***;
***REMOVED***

  // Unpack the Security credentials
  security_credentials = ObjectWrap::Unwrap<SecurityCredentials>(args[0]->ToObject(***REMOVED******REMOVED***;
  // Create Security context instance
  Local<Object> security_context_value = constructor_template->GetFunction(***REMOVED***->NewInstance(***REMOVED***;
  // Unwrap the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(security_context_value***REMOVED***;
  // Add a reference to the security_credentials
  security_context->security_credentials = security_credentials;

  // Build the call function
  SecurityContextStaticInitializeCall *call = (SecurityContextStaticInitializeCall ****REMOVED***calloc(1, sizeof(SecurityContextStaticInitializeCall***REMOVED******REMOVED***;
  call->context = security_context;
  call->decoded_input_str = decoded_input_str;
  call->decoded_input_str_length = decoded_input_str_length;
  call->service_principal_name_str = service_principal_name_str;

  // Callback
  Local<Function> callback = Local<Function>::Cast(args[3]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _initializeContext;
  worker->mapper = _map_initializeContext;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Process, (uv_after_work_cb***REMOVED***After***REMOVED***;

  // Return no value
  return scope.Close(Undefined(***REMOVED******REMOVED***;  
}

Handle<Value> SecurityContext::PayloadGetter(Local<String> property, const AccessorInfo& info***REMOVED*** {
  HandleScope scope;
  // Unpack the context object
  SecurityContext *context = ObjectWrap::Unwrap<SecurityContext>(info.Holder(***REMOVED******REMOVED***;
  // Return the low bits
  return scope.Close(String::New(context->payload***REMOVED******REMOVED***;
}

Handle<Value> SecurityContext::HasContextGetter(Local<String> property, const AccessorInfo& info***REMOVED*** {
  HandleScope scope;
  // Unpack the context object
  SecurityContext *context = ObjectWrap::Unwrap<SecurityContext>(info.Holder(***REMOVED******REMOVED***;
  // Return the low bits
  return scope.Close(Boolean::New(context->hasContext***REMOVED******REMOVED***;  
}

//
//  Async InitializeContextStep
//
typedef struct SecurityContextStepStaticInitializeCall {
  char *service_principal_name_str;
  char *decoded_input_str;
  int decoded_input_str_length;
  SecurityContext *context;
} SecurityContextStepStaticInitializeCall;

static void _initializeContextStep(Worker *worker***REMOVED*** {
  // Outbound data array
  BYTE *out_bound_data_str = NULL;
  // Status of operation
  SECURITY_STATUS status;
  // Unpack data
  SecurityContextStepStaticInitializeCall *call = (SecurityContextStepStaticInitializeCall ****REMOVED***worker->parameters;
  SecurityContext *context = call->context;
  // Structures used for c calls
  SecBufferDesc ibd, obd;
  SecBuffer ib, ob;

  // 
  // Prepare data structure for returned data from SSPI
  ob.BufferType = SECBUFFER_TOKEN;
  ob.cbBuffer = context->m_PkgInfo->cbMaxToken;
  // Allocate space for return data
  out_bound_data_str = new BYTE[ob.cbBuffer + sizeof(DWORD***REMOVED***];
  ob.pvBuffer = out_bound_data_str;
  // prepare buffer description
  obd.cBuffers  = 1;
  obd.ulVersion = SECBUFFER_VERSION;
  obd.pBuffers  = &ob;

  //
  // Prepare the data we are passing to the SSPI method
  if(call->decoded_input_str_length > 0***REMOVED*** {
    ib.BufferType = SECBUFFER_TOKEN;
    ib.cbBuffer   = call->decoded_input_str_length;
    ib.pvBuffer   = call->decoded_input_str;
    // prepare buffer description
    ibd.cBuffers  = 1;
    ibd.ulVersion = SECBUFFER_VERSION;
    ibd.pBuffers  = &ib;    
***REMOVED***

  // Perform initialization step
  status = _sspi_initializeSecurityContext(
      &context->security_credentials->m_Credentials
    , context->hasContext == true ? &context->m_Context : NULL
    , const_cast<TCHAR*>(call->service_principal_name_str***REMOVED***
    , 0x02  // MUTUAL
    , 0
    , 0     // Network
    , call->decoded_input_str_length ? &ibd : NULL
    , 0
    , &context->m_Context
    , &obd
    , &context->CtxtAttr
    , &context->Expiration
  ***REMOVED***;

  // If we have a ok or continue let's prepare the result
  if(status == SEC_E_OK 
    || status == SEC_I_COMPLETE_NEEDED
    || status == SEC_I_CONTINUE_NEEDED
    || status == SEC_I_COMPLETE_AND_CONTINUE
  ***REMOVED*** {
    // Set the new payload
    if(context->payload != NULL***REMOVED*** free(context->payload***REMOVED***;
    context->payload = base64_encode((const unsigned char ****REMOVED***ob.pvBuffer, ob.cbBuffer***REMOVED***;
    worker->return_code = status;
    worker->return_value = context;
***REMOVED*** else {
    worker->error = TRUE;
    worker->error_code = status;
    worker->error_message = DisplaySECError(status***REMOVED***;
***REMOVED***

  // Clean up data
  if(call->decoded_input_str != NULL***REMOVED*** free(call->decoded_input_str***REMOVED***;
  if(call->service_principal_name_str != NULL***REMOVED*** free(call->service_principal_name_str***REMOVED***;
}

static Handle<Value> _map_initializeContextStep(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Unwrap the security context
  SecurityContext *context = (SecurityContext ****REMOVED***worker->return_value;
  // Return the value
  return scope.Close(context->handle_***REMOVED***;
}

Handle<Value> SecurityContext::InitalizeStep(const Arguments &args***REMOVED*** {
  HandleScope scope;

  char *service_principal_name_str = NULL, *input_str = NULL, *decoded_input_str = NULL;
  int decoded_input_str_length = NULL;

  // We need 3 parameters
  if(args.Length(***REMOVED*** != 3***REMOVED***
    return VException("Initialize must be called with [servicePrincipalName:string, input:string, callback:function]"***REMOVED***;

  // Second parameter must be a string
  if(!args[0]->IsString(***REMOVED******REMOVED***
    return VException("First parameter for Initialize must be a string"***REMOVED***;

  // Third parameter must be a base64 encoded string
  if(!args[1]->IsString(***REMOVED******REMOVED***
    return VException("Second parameter for Initialize must be a string"***REMOVED***;

  // Third parameter must be a base64 encoded string
  if(!args[2]->IsFunction(***REMOVED******REMOVED***
    return VException("Third parameter for Initialize must be a callback function"***REMOVED***;

  // Let's unpack the values
  Local<String> service_principal_name = args[0]->ToString(***REMOVED***;
  service_principal_name_str = (char ****REMOVED***calloc(service_principal_name->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  service_principal_name->WriteUtf8(service_principal_name_str***REMOVED***;

  // Unpack the user name
  Local<String> input = args[1]->ToString(***REMOVED***;

  if(input->Utf8Length(***REMOVED*** > 0***REMOVED*** {
    input_str = (char ****REMOVED***calloc(input->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    input->WriteUtf8(input_str***REMOVED***;
    // Now let's get the base64 decoded string
    decoded_input_str = (char ****REMOVED***base64_decode(input_str, &decoded_input_str_length***REMOVED***;
    // Free input string
    free(input_str***REMOVED***;
***REMOVED***

  // Unwrap the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;

  // Create call structure
  SecurityContextStepStaticInitializeCall *call = (SecurityContextStepStaticInitializeCall ****REMOVED***calloc(1, sizeof(SecurityContextStepStaticInitializeCall***REMOVED******REMOVED***;
  call->context = security_context;
  call->decoded_input_str = decoded_input_str;
  call->decoded_input_str_length = decoded_input_str_length;
  call->service_principal_name_str = service_principal_name_str;

  // Callback
  Local<Function> callback = Local<Function>::Cast(args[2]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _initializeContextStep;
  worker->mapper = _map_initializeContextStep;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Process, (uv_after_work_cb***REMOVED***After***REMOVED***;

  // Return undefined
  return scope.Close(Undefined(***REMOVED******REMOVED***;  
}

Handle<Value> SecurityContext::InitalizeStepSync(const Arguments &args***REMOVED*** {
  HandleScope scope;

  char *service_principal_name_str = NULL, *input_str = NULL, *decoded_input_str = NULL;
  BYTE *out_bound_data_str = NULL;
  int decoded_input_str_length = NULL;
  // Status of operation
  SECURITY_STATUS status;

  // We need 3 parameters
  if(args.Length(***REMOVED*** != 2***REMOVED***
    return VException("Initialize must be called with [servicePrincipalName:string, input:string]"***REMOVED***;

  // Second parameter must be a string
  if(!args[0]->IsString(***REMOVED******REMOVED***
    return VException("First parameter for Initialize must be a string"***REMOVED***;

  // Third parameter must be a base64 encoded string
  if(!args[1]->IsString(***REMOVED******REMOVED***
    return VException("Second parameter for Initialize must be a string"***REMOVED***;

  // Let's unpack the values
  Local<String> service_principal_name = args[0]->ToString(***REMOVED***;
  service_principal_name_str = (char ****REMOVED***calloc(service_principal_name->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  service_principal_name->WriteUtf8(service_principal_name_str***REMOVED***;

  // Unpack the user name
  Local<String> input = args[1]->ToString(***REMOVED***;

  if(input->Utf8Length(***REMOVED*** > 0***REMOVED*** {
    input_str = (char ****REMOVED***calloc(input->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    input->WriteUtf8(input_str***REMOVED***;
    // Now let's get the base64 decoded string
    decoded_input_str = (char ****REMOVED***base64_decode(input_str, &decoded_input_str_length***REMOVED***;
***REMOVED***

  // Unpack the long object
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;  
  SecurityCredentials *security_credentials = security_context->security_credentials;

  // Structures used for c calls
  SecBufferDesc ibd, obd;
  SecBuffer ib, ob;

  // 
  // Prepare data structure for returned data from SSPI
  ob.BufferType = SECBUFFER_TOKEN;
  ob.cbBuffer = security_context->m_PkgInfo->cbMaxToken;
  // Allocate space for return data
  out_bound_data_str = new BYTE[ob.cbBuffer + sizeof(DWORD***REMOVED***];
  ob.pvBuffer = out_bound_data_str;
  // prepare buffer description
  obd.cBuffers  = 1;
  obd.ulVersion = SECBUFFER_VERSION;
  obd.pBuffers  = &ob;

  //
  // Prepare the data we are passing to the SSPI method
  if(input->Utf8Length(***REMOVED*** > 0***REMOVED*** {
    ib.BufferType = SECBUFFER_TOKEN;
    ib.cbBuffer   = decoded_input_str_length;
    ib.pvBuffer   = decoded_input_str;
    // prepare buffer description
    ibd.cBuffers  = 1;
    ibd.ulVersion = SECBUFFER_VERSION;
    ibd.pBuffers  = &ib;    
***REMOVED***

  // Perform initialization step
  status = _sspi_initializeSecurityContext(
      &security_credentials->m_Credentials
    , security_context->hasContext == true ? &security_context->m_Context : NULL
    , const_cast<TCHAR*>(service_principal_name_str***REMOVED***
    , 0x02  // MUTUAL
    , 0
    , 0     // Network
    , input->Utf8Length(***REMOVED*** > 0 ? &ibd : NULL
    , 0
    , &security_context->m_Context
    , &obd
    , &security_context->CtxtAttr
    , &security_context->Expiration
  ***REMOVED***;

  // If we have a ok or continue let's prepare the result
  if(status == SEC_E_OK 
    || status == SEC_I_COMPLETE_NEEDED
    || status == SEC_I_CONTINUE_NEEDED
    || status == SEC_I_COMPLETE_AND_CONTINUE
  ***REMOVED*** {
    // Set the new payload
    if(security_context->payload != NULL***REMOVED*** free(security_context->payload***REMOVED***;
    security_context->payload = base64_encode((const unsigned char ****REMOVED***ob.pvBuffer, ob.cbBuffer***REMOVED***;
***REMOVED*** else {
    LPSTR err_message = DisplaySECError(status***REMOVED***;

    if(err_message != NULL***REMOVED*** {
      return VExceptionErrNo(err_message, status***REMOVED***;
  ***REMOVED*** else {
      return VExceptionErrNo("Unknown error", status***REMOVED***;
  ***REMOVED***
***REMOVED***

  return scope.Close(Null(***REMOVED******REMOVED***;
}

//
//  Async EncryptMessage
//
typedef struct SecurityContextEncryptMessageCall {
  SecurityContext *context;
  SecurityBufferDescriptor *descriptor;
  unsigned long flags;
} SecurityContextEncryptMessageCall;

static void _encryptMessage(Worker *worker***REMOVED*** {
  SECURITY_STATUS status;
  // Unpack call
  SecurityContextEncryptMessageCall *call = (SecurityContextEncryptMessageCall ****REMOVED***worker->parameters;
  // Unpack the security context
  SecurityContext *context = call->context;
  SecurityBufferDescriptor *descriptor = call->descriptor;

  // Let's execute encryption
  status = _sspi_EncryptMessage(
      &context->m_Context
    , call->flags
    , &descriptor->secBufferDesc
    , 0
  ***REMOVED***;

  // We've got ok
  if(status == SEC_E_OK***REMOVED*** {
    int bytesToAllocate = (int***REMOVED***descriptor->bufferSize(***REMOVED***;    
    // Free up existing payload
    if(context->payload != NULL***REMOVED*** free(context->payload***REMOVED***;
    // Save the payload
    context->payload = base64_encode((unsigned char ****REMOVED***descriptor->toBuffer(***REMOVED***, bytesToAllocate***REMOVED***;
    // Set result
    worker->return_code = status;
    worker->return_value = context;
***REMOVED*** else {
    worker->error = TRUE;
    worker->error_code = status;
    worker->error_message = DisplaySECError(status***REMOVED***;
***REMOVED***
}

static Handle<Value> _map_encryptMessage(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Unwrap the security context
  SecurityContext *context = (SecurityContext ****REMOVED***worker->return_value;
  // Return the value
  return scope.Close(context->handle_***REMOVED***;
}

Handle<Value> SecurityContext::EncryptMessage(const Arguments &args***REMOVED*** {
  HandleScope scope;

  if(args.Length(***REMOVED*** != 3***REMOVED***
    return VException("EncryptMessage takes an instance of SecurityBufferDescriptor, an integer flag and a callback function"***REMOVED***;  
  if(!SecurityBufferDescriptor::HasInstance(args[0]***REMOVED******REMOVED***
    return VException("EncryptMessage takes an instance of SecurityBufferDescriptor, an integer flag and a callback function"***REMOVED***;  
  if(!args[1]->IsUint32(***REMOVED******REMOVED***
    return VException("EncryptMessage takes an instance of SecurityBufferDescriptor, an integer flag and a callback function"***REMOVED***;  
  if(!args[2]->IsFunction(***REMOVED******REMOVED***
    return VException("EncryptMessage takes an instance of SecurityBufferDescriptor, an integer flag and a callback function"***REMOVED***;  

  // Unpack the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;

  // Unpack the descriptor
  SecurityBufferDescriptor *descriptor = ObjectWrap::Unwrap<SecurityBufferDescriptor>(args[0]->ToObject(***REMOVED******REMOVED***;

  // Create call structure
  SecurityContextEncryptMessageCall *call = (SecurityContextEncryptMessageCall ****REMOVED***calloc(1, sizeof(SecurityContextEncryptMessageCall***REMOVED******REMOVED***;
  call->context = security_context;
  call->descriptor = descriptor;
  call->flags = (unsigned long***REMOVED***args[1]->ToInteger(***REMOVED***->Value(***REMOVED***;

  // Callback
  Local<Function> callback = Local<Function>::Cast(args[2]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _encryptMessage;
  worker->mapper = _map_encryptMessage;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Process, (uv_after_work_cb***REMOVED***After***REMOVED***;

  // Return undefined
  return scope.Close(Undefined(***REMOVED******REMOVED***;  
}

Handle<Value> SecurityContext::EncryptMessageSync(const Arguments &args***REMOVED*** {
  HandleScope scope;
  SECURITY_STATUS status;

  if(args.Length(***REMOVED*** != 2***REMOVED***
    return VException("EncryptMessageSync takes an instance of SecurityBufferDescriptor and an integer flag"***REMOVED***;  
  if(!SecurityBufferDescriptor::HasInstance(args[0]***REMOVED******REMOVED***
    return VException("EncryptMessageSync takes an instance of SecurityBufferDescriptor and an integer flag"***REMOVED***;  
  if(!args[1]->IsUint32(***REMOVED******REMOVED***
    return VException("EncryptMessageSync takes an instance of SecurityBufferDescriptor and an integer flag"***REMOVED***;  

  // Unpack the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;

  // Unpack the descriptor
  SecurityBufferDescriptor *descriptor = ObjectWrap::Unwrap<SecurityBufferDescriptor>(args[0]->ToObject(***REMOVED******REMOVED***;

  // Let's execute encryption
  status = _sspi_EncryptMessage(
      &security_context->m_Context
    , (unsigned long***REMOVED***args[1]->ToInteger(***REMOVED***->Value(***REMOVED***
    , &descriptor->secBufferDesc
    , 0
  ***REMOVED***;

  // We've got ok
  if(status == SEC_E_OK***REMOVED*** {
    int bytesToAllocate = (int***REMOVED***descriptor->bufferSize(***REMOVED***;    
    // Free up existing payload
    if(security_context->payload != NULL***REMOVED*** free(security_context->payload***REMOVED***;
    // Save the payload
    security_context->payload = base64_encode((unsigned char ****REMOVED***descriptor->toBuffer(***REMOVED***, bytesToAllocate***REMOVED***;
***REMOVED*** else {
    LPSTR err_message = DisplaySECError(status***REMOVED***;

    if(err_message != NULL***REMOVED*** {
      return VExceptionErrNo(err_message, status***REMOVED***;
  ***REMOVED*** else {
      return VExceptionErrNo("Unknown error", status***REMOVED***;
  ***REMOVED***
***REMOVED***

  return scope.Close(Null(***REMOVED******REMOVED***;
}

//
//  Async DecryptMessage
//
typedef struct SecurityContextDecryptMessageCall {
  SecurityContext *context;
  SecurityBufferDescriptor *descriptor;
} SecurityContextDecryptMessageCall;

static void _decryptMessage(Worker *worker***REMOVED*** {
  unsigned long quality = 0;
  SECURITY_STATUS status;
  
  // Unpack parameters
  SecurityContextDecryptMessageCall *call = (SecurityContextDecryptMessageCall ****REMOVED***worker->parameters;
  SecurityContext *context = call->context;
  SecurityBufferDescriptor *descriptor = call->descriptor;

  // Let's execute encryption
  status = _sspi_DecryptMessage(
      &context->m_Context
    , &descriptor->secBufferDesc
    , 0
    , (unsigned long***REMOVED***&quality
  ***REMOVED***;

  // We've got ok
  if(status == SEC_E_OK***REMOVED*** {
    int bytesToAllocate = (int***REMOVED***descriptor->bufferSize(***REMOVED***;    
    // Free up existing payload
    if(context->payload != NULL***REMOVED*** free(context->payload***REMOVED***;
    // Save the payload
    context->payload = base64_encode((unsigned char ****REMOVED***descriptor->toBuffer(***REMOVED***, bytesToAllocate***REMOVED***;
    // Set return values
    worker->return_code = status;
    worker->return_value = context;
***REMOVED*** else {
    worker->error = TRUE;
    worker->error_code = status;
    worker->error_message = DisplaySECError(status***REMOVED***;
***REMOVED***
}

static Handle<Value> _map_decryptMessage(Worker *worker***REMOVED*** {
  HandleScope scope;
  // Unwrap the security context
  SecurityContext *context = (SecurityContext ****REMOVED***worker->return_value;
  // Return the value
  return scope.Close(context->handle_***REMOVED***;
}

Handle<Value> SecurityContext::DecryptMessage(const Arguments &args***REMOVED*** {
  HandleScope scope;

  if(args.Length(***REMOVED*** != 2***REMOVED***
    return VException("DecryptMessage takes an instance of SecurityBufferDescriptor and a callback function"***REMOVED***;
  if(!SecurityBufferDescriptor::HasInstance(args[0]***REMOVED******REMOVED***
    return VException("DecryptMessage takes an instance of SecurityBufferDescriptor and a callback function"***REMOVED***;
  if(!args[1]->IsFunction(***REMOVED******REMOVED***
    return VException("DecryptMessage takes an instance of SecurityBufferDescriptor and a callback function"***REMOVED***;

  // Unpack the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;
  // Unpack the descriptor
  SecurityBufferDescriptor *descriptor = ObjectWrap::Unwrap<SecurityBufferDescriptor>(args[0]->ToObject(***REMOVED******REMOVED***;
  // Create call structure
  SecurityContextDecryptMessageCall *call = (SecurityContextDecryptMessageCall ****REMOVED***calloc(1, sizeof(SecurityContextDecryptMessageCall***REMOVED******REMOVED***;
  call->context = security_context;
  call->descriptor = descriptor;

  // Callback
  Local<Function> callback = Local<Function>::Cast(args[1]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _decryptMessage;
  worker->mapper = _map_decryptMessage;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Process, (uv_after_work_cb***REMOVED***After***REMOVED***;

  // Return undefined
  return scope.Close(Undefined(***REMOVED******REMOVED***;  
}

Handle<Value> SecurityContext::DecryptMessageSync(const Arguments &args***REMOVED*** {
  HandleScope scope;
  unsigned long quality = 0;
  SECURITY_STATUS status;

  if(args.Length(***REMOVED*** != 1***REMOVED***
    return VException("DecryptMessageSync takes an instance of SecurityBufferDescriptor"***REMOVED***;
  if(!SecurityBufferDescriptor::HasInstance(args[0]***REMOVED******REMOVED***
    return VException("DecryptMessageSync takes an instance of SecurityBufferDescriptor"***REMOVED***;

  // Unpack the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;

  // Unpack the descriptor
  SecurityBufferDescriptor *descriptor = ObjectWrap::Unwrap<SecurityBufferDescriptor>(args[0]->ToObject(***REMOVED******REMOVED***;

  // Let's execute encryption
  status = _sspi_DecryptMessage(
      &security_context->m_Context
    , &descriptor->secBufferDesc
    , 0
    , (unsigned long***REMOVED***&quality
  ***REMOVED***;

  // We've got ok
  if(status == SEC_E_OK***REMOVED*** {
    int bytesToAllocate = (int***REMOVED***descriptor->bufferSize(***REMOVED***;    
    // Free up existing payload
    if(security_context->payload != NULL***REMOVED*** free(security_context->payload***REMOVED***;
    // Save the payload
    security_context->payload = base64_encode((unsigned char ****REMOVED***descriptor->toBuffer(***REMOVED***, bytesToAllocate***REMOVED***;
***REMOVED*** else {
    LPSTR err_message = DisplaySECError(status***REMOVED***;

    if(err_message != NULL***REMOVED*** {
      return VExceptionErrNo(err_message, status***REMOVED***;
  ***REMOVED*** else {
      return VExceptionErrNo("Unknown error", status***REMOVED***;
  ***REMOVED***
***REMOVED***

  return scope.Close(Null(***REMOVED******REMOVED***;
}

//
//  Async QueryContextAttributes
//
typedef struct SecurityContextQueryContextAttributesCall {
  SecurityContext *context;
  uint32_t attribute;
} SecurityContextQueryContextAttributesCall;

static void _queryContextAttributes(Worker *worker***REMOVED*** {
  SECURITY_STATUS status;

  // Cast to data structure
  SecurityContextQueryContextAttributesCall *call = (SecurityContextQueryContextAttributesCall ****REMOVED***worker->parameters;  

  // Allocate some space
  SecPkgContext_Sizes *sizes = (SecPkgContext_Sizes ****REMOVED***calloc(1, sizeof(SecPkgContext_Sizes***REMOVED******REMOVED***;
  // Let's grab the query context attribute
  status = _sspi_QueryContextAttributes(
    &call->context->m_Context,
    call->attribute,
    sizes
  ***REMOVED***;  
  
  if(status == SEC_E_OK***REMOVED*** {
    worker->return_code = status;
    worker->return_value = sizes;
***REMOVED*** else {
    worker->error = TRUE;
    worker->error_code = status;
    worker->error_message = DisplaySECError(status***REMOVED***;
***REMOVED***
}

static Handle<Value> _map_queryContextAttributes(Worker *worker***REMOVED*** {
  HandleScope scope;

  // Cast to data structure
  SecurityContextQueryContextAttributesCall *call = (SecurityContextQueryContextAttributesCall ****REMOVED***worker->parameters;  
  // Unpack the attribute
  uint32_t attribute = call->attribute;

  // Convert data
  if(attribute == SECPKG_ATTR_SIZES***REMOVED*** {
    SecPkgContext_Sizes *sizes = (SecPkgContext_Sizes ****REMOVED***worker->return_value;
    // Create object
    Local<Object> value = Object::New(***REMOVED***;
    value->Set(String::New("maxToken"***REMOVED***, Integer::New(sizes->cbMaxToken***REMOVED******REMOVED***;
    value->Set(String::New("maxSignature"***REMOVED***, Integer::New(sizes->cbMaxSignature***REMOVED******REMOVED***;
    value->Set(String::New("blockSize"***REMOVED***, Integer::New(sizes->cbBlockSize***REMOVED******REMOVED***;
    value->Set(String::New("securityTrailer"***REMOVED***, Integer::New(sizes->cbSecurityTrailer***REMOVED******REMOVED***;
    return scope.Close(value***REMOVED***;
***REMOVED***

  // Return the value
  return scope.Close(Null(***REMOVED******REMOVED***;
}

Handle<Value> SecurityContext::QueryContextAttributes(const Arguments &args***REMOVED*** {
  HandleScope scope;

  if(args.Length(***REMOVED*** != 2***REMOVED***
    return VException("QueryContextAttributesSync method takes a an integer Attribute specifier and a callback function"***REMOVED***;
  if(!args[0]->IsInt32(***REMOVED******REMOVED***
    return VException("QueryContextAttributes method takes a an integer Attribute specifier and a callback function"***REMOVED***;
  if(!args[1]->IsFunction(***REMOVED******REMOVED***
    return VException("QueryContextAttributes method takes a an integer Attribute specifier and a callback function"***REMOVED***;

  // Unpack the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;

  // Unpack the int value
  uint32_t attribute = args[0]->ToInt32(***REMOVED***->Value(***REMOVED***;  

  // Check that we have a supported attribute
  if(attribute != SECPKG_ATTR_SIZES***REMOVED*** 
    return VException("QueryContextAttributes only supports the SECPKG_ATTR_SIZES attribute"***REMOVED***;

  // Create call structure
  SecurityContextQueryContextAttributesCall *call = (SecurityContextQueryContextAttributesCall ****REMOVED***calloc(1, sizeof(SecurityContextQueryContextAttributesCall***REMOVED******REMOVED***;
  call->attribute = attribute;
  call->context = security_context;

  // Callback
  Local<Function> callback = Local<Function>::Cast(args[1]***REMOVED***;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _queryContextAttributes;
  worker->mapper = _map_queryContextAttributes;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, Process, (uv_after_work_cb***REMOVED***After***REMOVED***;

  // Return undefined
  return scope.Close(Undefined(***REMOVED******REMOVED***;  
}

Handle<Value> SecurityContext::QueryContextAttributesSync(const Arguments &args***REMOVED*** {
  HandleScope scope;
  SECURITY_STATUS status;

  if(args.Length(***REMOVED*** != 1***REMOVED***
    return VException("QueryContextAttributesSync method takes a an integer Attribute specifier"***REMOVED***;
  if(!args[0]->IsInt32(***REMOVED******REMOVED***
    return VException("QueryContextAttributesSync method takes a an integer Attribute specifier"***REMOVED***;

  // Unpack the security context
  SecurityContext *security_context = ObjectWrap::Unwrap<SecurityContext>(args.This(***REMOVED******REMOVED***;
  uint32_t attribute = args[0]->ToInt32(***REMOVED***->Value(***REMOVED***;

  if(attribute != SECPKG_ATTR_SIZES***REMOVED*** 
    return VException("QueryContextAttributes only supports the SECPKG_ATTR_SIZES attribute"***REMOVED***;

  // Check what attribute we are asking for
  if(attribute == SECPKG_ATTR_SIZES***REMOVED*** {
    SecPkgContext_Sizes sizes;

    // Let's grab the query context attribute
    status = _sspi_QueryContextAttributes(
      &security_context->m_Context,
      attribute,
      &sizes
    ***REMOVED***;  
    
    if(status == SEC_E_OK***REMOVED*** {
      Local<Object> value = Object::New(***REMOVED***;
      value->Set(String::New("maxToken"***REMOVED***, Integer::New(sizes.cbMaxToken***REMOVED******REMOVED***;
      value->Set(String::New("maxSignature"***REMOVED***, Integer::New(sizes.cbMaxSignature***REMOVED******REMOVED***;
      value->Set(String::New("blockSize"***REMOVED***, Integer::New(sizes.cbBlockSize***REMOVED******REMOVED***;
      value->Set(String::New("securityTrailer"***REMOVED***, Integer::New(sizes.cbSecurityTrailer***REMOVED******REMOVED***;
      return scope.Close(value***REMOVED***;
  ***REMOVED*** else {
      LPSTR err_message = DisplaySECError(status***REMOVED***;

      if(err_message != NULL***REMOVED*** {
        return VExceptionErrNo(err_message, status***REMOVED***;
    ***REMOVED*** else {
        return VExceptionErrNo("Unknown error", status***REMOVED***;
    ***REMOVED***      
  ***REMOVED***
***REMOVED***

  return scope.Close(Null(***REMOVED******REMOVED***;
}

void SecurityContext::Initialize(Handle<Object> target***REMOVED*** {
  // Grab the scope of the call from Node
  HandleScope scope;
  // Define a new function template
  Local<FunctionTemplate> t = FunctionTemplate::New(New***REMOVED***;
  constructor_template = Persistent<FunctionTemplate>::New(t***REMOVED***;
  constructor_template->InstanceTemplate(***REMOVED***->SetInternalFieldCount(1***REMOVED***;
  constructor_template->SetClassName(String::NewSymbol("SecurityContext"***REMOVED******REMOVED***;

  // Class methods
  NODE_SET_METHOD(constructor_template, "initializeSync", InitializeContextSync***REMOVED***;
  NODE_SET_METHOD(constructor_template, "initialize", InitializeContext***REMOVED***;
  
  // Set up method for the instance
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "initializeSync", InitalizeStepSync***REMOVED***;
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "initialize", InitalizeStep***REMOVED***;

  NODE_SET_PROTOTYPE_METHOD(constructor_template, "decryptMessageSync", DecryptMessageSync***REMOVED***;
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "decryptMessage", DecryptMessage***REMOVED***;

  NODE_SET_PROTOTYPE_METHOD(constructor_template, "queryContextAttributesSync", QueryContextAttributesSync***REMOVED***;
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "queryContextAttributes", QueryContextAttributes***REMOVED***;

  NODE_SET_PROTOTYPE_METHOD(constructor_template, "encryptMessageSync", EncryptMessageSync***REMOVED***;
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "encryptMessage", EncryptMessage***REMOVED***;

  // Getters for correct serialization of the object  
  constructor_template->InstanceTemplate(***REMOVED***->SetAccessor(String::NewSymbol("payload"***REMOVED***, PayloadGetter***REMOVED***;
  // Getters for correct serialization of the object  
  constructor_template->InstanceTemplate(***REMOVED***->SetAccessor(String::NewSymbol("hasContext"***REMOVED***, HasContextGetter***REMOVED***;

  // Set template class name
  target->Set(String::NewSymbol("SecurityContext"***REMOVED***, constructor_template->GetFunction(***REMOVED******REMOVED***;  
}

static LPSTR DisplaySECError(DWORD ErrCode***REMOVED*** {
  LPSTR pszName = NULL; // WinError.h

  switch(ErrCode***REMOVED*** {
    case SEC_E_BUFFER_TOO_SMALL:
      pszName = "SEC_E_BUFFER_TOO_SMALL - The message buffer is too small. Used with the Digest SSP.";
      break;

    case SEC_E_CRYPTO_SYSTEM_INVALID:
      pszName = "SEC_E_CRYPTO_SYSTEM_INVALID - The cipher chosen for the security context is not supported. Used with the Digest SSP."; 
      break;
    case SEC_E_INCOMPLETE_MESSAGE:
      pszName = "SEC_E_INCOMPLETE_MESSAGE - The data in the input buffer is incomplete. The application needs to read more data from the server and call DecryptMessageSync (General***REMOVED*** again."; 
      break;

    case SEC_E_INVALID_HANDLE:
      pszName = "SEC_E_INVALID_HANDLE - A context handle that is not valid was specified in the phContext parameter. Used with the Digest and Schannel SSPs."; 
      break;

    case SEC_E_INVALID_TOKEN:
      pszName = "SEC_E_INVALID_TOKEN - The buffers are of the wrong type or no buffer of type SECBUFFER_DATA was found. Used with the Schannel SSP."; 
      break;
        
    case SEC_E_MESSAGE_ALTERED:
      pszName = "SEC_E_MESSAGE_ALTERED - The message has been altered. Used with the Digest and Schannel SSPs."; 
      break;
        
    case SEC_E_OUT_OF_SEQUENCE:
      pszName = "SEC_E_OUT_OF_SEQUENCE - The message was not received in the correct sequence."; 
      break;
        
    case SEC_E_QOP_NOT_SUPPORTED:
      pszName = "SEC_E_QOP_NOT_SUPPORTED - Neither confidentiality nor integrity are supported by the security context. Used with the Digest SSP."; 
      break;
        
    case SEC_I_CONTEXT_EXPIRED:
      pszName = "SEC_I_CONTEXT_EXPIRED - The message sender has finished using the connection and has initiated a shutdown."; 
      break;
        
    case SEC_I_RENEGOTIATE:
      pszName = "SEC_I_RENEGOTIATE - The remote party requires a new handshake sequence or the application has just initiated a shutdown."; 
      break;
        
    case SEC_E_ENCRYPT_FAILURE:
      pszName = "SEC_E_ENCRYPT_FAILURE - The specified data could not be encrypted."; 
      break;
        
    case SEC_E_DECRYPT_FAILURE:
      pszName = "SEC_E_DECRYPT_FAILURE - The specified data could not be decrypted."; 
      break;
    case -1:
      pszName = "Failed to load security.dll library"; 
      break;
***REMOVED***

  return pszName;
}

