#include <node.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <v8.h>
#include <node_buffer.h>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <limits>

#define SECURITY_WIN32 1

#include "security_buffer_descriptor.h"
#include "security_buffer.h"

static Handle<Value> VException(const char *msg***REMOVED*** {
  HandleScope scope;
  return ThrowException(Exception::Error(String::New(msg***REMOVED******REMOVED******REMOVED***;
};

Persistent<FunctionTemplate> SecurityBufferDescriptor::constructor_template;

SecurityBufferDescriptor::SecurityBufferDescriptor(***REMOVED*** : ObjectWrap(***REMOVED*** {
}

SecurityBufferDescriptor::SecurityBufferDescriptor(Persistent<Array> arrayObject***REMOVED*** : ObjectWrap(***REMOVED*** {
  SecurityBuffer *security_obj = NULL;
  // Safe reference to array
  this->arrayObject = arrayObject;

  // Unpack the array and ensure we have a valid descriptor
  this->secBufferDesc.cBuffers = arrayObject->Length(***REMOVED***;
  this->secBufferDesc.ulVersion = SECBUFFER_VERSION;

  if(arrayObject->Length(***REMOVED*** == 1***REMOVED*** {
    // Unwrap  the buffer
    security_obj = ObjectWrap::Unwrap<SecurityBuffer>(arrayObject->Get(0***REMOVED***->ToObject(***REMOVED******REMOVED***;
    // Assign the buffer
    this->secBufferDesc.pBuffers = &security_obj->sec_buffer;
***REMOVED*** else {
    this->secBufferDesc.pBuffers = new SecBuffer[arrayObject->Length(***REMOVED***];
    this->secBufferDesc.cBuffers = arrayObject->Length(***REMOVED***;
    
    // Assign the buffers
    for(uint32_t i = 0; i < arrayObject->Length(***REMOVED***; i++***REMOVED*** {
      security_obj = ObjectWrap::Unwrap<SecurityBuffer>(arrayObject->Get(i***REMOVED***->ToObject(***REMOVED******REMOVED***;
      this->secBufferDesc.pBuffers[i].BufferType = security_obj->sec_buffer.BufferType;
      this->secBufferDesc.pBuffers[i].pvBuffer = security_obj->sec_buffer.pvBuffer;
      this->secBufferDesc.pBuffers[i].cbBuffer = security_obj->sec_buffer.cbBuffer;
  ***REMOVED***
***REMOVED***
}

SecurityBufferDescriptor::~SecurityBufferDescriptor(***REMOVED*** {
}

size_t SecurityBufferDescriptor::bufferSize(***REMOVED*** {
  SecurityBuffer *security_obj = NULL;

  if(this->secBufferDesc.cBuffers == 1***REMOVED*** {
    security_obj = ObjectWrap::Unwrap<SecurityBuffer>(arrayObject->Get(0***REMOVED***->ToObject(***REMOVED******REMOVED***;
    return security_obj->size;
***REMOVED*** else {
    int bytesToAllocate = 0;

    for(unsigned int i = 0; i < this->secBufferDesc.cBuffers; i++***REMOVED*** {
      bytesToAllocate += this->secBufferDesc.pBuffers[i].cbBuffer;
  ***REMOVED***

    // Return total size
    return bytesToAllocate;
***REMOVED***
}

char *SecurityBufferDescriptor::toBuffer(***REMOVED*** {
  SecurityBuffer *security_obj = NULL;
  char *data = NULL;

  if(this->secBufferDesc.cBuffers == 1***REMOVED*** {
    security_obj = ObjectWrap::Unwrap<SecurityBuffer>(arrayObject->Get(0***REMOVED***->ToObject(***REMOVED******REMOVED***;
    data = (char ****REMOVED***malloc(security_obj->size * sizeof(char***REMOVED******REMOVED***;
    memcpy(data, security_obj->data, security_obj->size***REMOVED***;
***REMOVED*** else {
    size_t bytesToAllocate = this->bufferSize(***REMOVED***;
    char *data = (char ****REMOVED***calloc(bytesToAllocate, sizeof(char***REMOVED******REMOVED***;
    int offset = 0;

    for(unsigned int i = 0; i < this->secBufferDesc.cBuffers; i++***REMOVED*** {
      memcpy((data + offset***REMOVED***, this->secBufferDesc.pBuffers[i].pvBuffer, this->secBufferDesc.pBuffers[i].cbBuffer***REMOVED***;
      offset +=this->secBufferDesc.pBuffers[i].cbBuffer;
  ***REMOVED***

    // Return the data
    return data;
***REMOVED***

  return data;
}

Handle<Value> SecurityBufferDescriptor::New(const Arguments &args***REMOVED*** {
  HandleScope scope;  
  SecurityBufferDescriptor *security_obj;
  Persistent<Array> arrayObject;

  if(args.Length(***REMOVED*** != 1***REMOVED***
    return VException("There must be 1 argument passed in where the first argument is a [int32 or an Array of SecurityBuffers]"***REMOVED***;

  if(!args[0]->IsInt32(***REMOVED*** && !args[0]->IsArray(***REMOVED******REMOVED***
    return VException("There must be 1 argument passed in where the first argument is a [int32 or an Array of SecurityBuffers]"***REMOVED***;

  if(args[0]->IsArray(***REMOVED******REMOVED*** {
    Handle<Array> array = Handle<Array>::Cast(args[0]***REMOVED***;
    // Iterate over all items and ensure we the right type
    for(uint32_t i = 0; i < array->Length(***REMOVED***; i++***REMOVED*** {
      if(!SecurityBuffer::HasInstance(array->Get(i***REMOVED******REMOVED******REMOVED*** {
        return VException("There must be 1 argument passed in where the first argument is a [int32 or an Array of SecurityBuffers]"***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  // We have a single integer
  if(args[0]->IsInt32(***REMOVED******REMOVED*** {
    // Create new SecurityBuffer instance
    Local<Value> argv[] = {Int32::New(0x02***REMOVED***, args[0]};
    Handle<Value> security_buffer = SecurityBuffer::constructor_template->GetFunction(***REMOVED***->NewInstance(2, argv***REMOVED***;    
    // Create a new array
    Local<Array> array = Array::New(1***REMOVED***;
    // Set the first value
    array->Set(0, security_buffer***REMOVED***;
    // Create persistent handle
    arrayObject = Persistent<Array>::New(array***REMOVED***;
    // Create descriptor
    security_obj = new SecurityBufferDescriptor(arrayObject***REMOVED***;
***REMOVED*** else {
    arrayObject = Persistent<Array>::New(Handle<Array>::Cast(args[0]***REMOVED******REMOVED***;
    security_obj = new SecurityBufferDescriptor(arrayObject***REMOVED***;
***REMOVED***

  // Wrap it
  security_obj->Wrap(args.This(***REMOVED******REMOVED***;
  // Return the object
  return args.This(***REMOVED***;    
}

Handle<Value> SecurityBufferDescriptor::ToBuffer(const Arguments &args***REMOVED*** {
  HandleScope scope; 

  // Unpack the Security Buffer object
  SecurityBufferDescriptor *security_obj = ObjectWrap::Unwrap<SecurityBufferDescriptor>(args.This(***REMOVED******REMOVED***;

  // Get the buffer
  char *buffer_data = security_obj->toBuffer(***REMOVED***;
  size_t buffer_size = security_obj->bufferSize(***REMOVED***;

  // Create a Buffer
  Buffer *buffer = Buffer::New(buffer_data, buffer_size***REMOVED***;

  // Return the buffer
  return scope.Close(buffer->handle_***REMOVED***;  
}

void SecurityBufferDescriptor::Initialize(Handle<Object> target***REMOVED*** {
  // Grab the scope of the call from Node
  HandleScope scope;
  // Define a new function template
  Local<FunctionTemplate> t = FunctionTemplate::New(New***REMOVED***;
  constructor_template = Persistent<FunctionTemplate>::New(t***REMOVED***;
  constructor_template->InstanceTemplate(***REMOVED***->SetInternalFieldCount(1***REMOVED***;
  constructor_template->SetClassName(String::NewSymbol("SecurityBufferDescriptor"***REMOVED******REMOVED***;

  // Set up method for the Kerberos instance
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "toBuffer", ToBuffer***REMOVED***;

  target->Set(String::NewSymbol("SecurityBufferDescriptor"***REMOVED***, constructor_template->GetFunction(***REMOVED******REMOVED***;
}
