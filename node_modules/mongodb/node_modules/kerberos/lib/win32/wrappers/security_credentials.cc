#include <node.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <v8.h>
#include <node_buffer.h>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <limits>

#include "security_credentials.h"

#ifndef ARRAY_SIZE
# define ARRAY_SIZE(a***REMOVED*** (sizeof((a***REMOVED******REMOVED*** / sizeof((a***REMOVED***[0]***REMOVED******REMOVED***
#endif

static LPSTR DisplaySECError(DWORD ErrCode***REMOVED***;

static Handle<Value> VException(const char *msg***REMOVED*** {
  HandleScope scope;
  return ThrowException(Exception::Error(String::New(msg***REMOVED******REMOVED******REMOVED***;
};

static Handle<Value> VExceptionErrNo(const char *msg, const int errorNumber***REMOVED*** {
  HandleScope scope;

  Local<Value> err = Exception::Error(String::New(msg***REMOVED******REMOVED***;
  Local<Object> obj = err->ToObject(***REMOVED***;
  obj->Set(NODE_PSYMBOL("code"***REMOVED***, Int32::New(errorNumber***REMOVED******REMOVED***;
  return ThrowException(err***REMOVED***;
};

Persistent<FunctionTemplate> SecurityCredentials::constructor_template;

SecurityCredentials::SecurityCredentials(***REMOVED*** : ObjectWrap(***REMOVED*** {
}

SecurityCredentials::~SecurityCredentials(***REMOVED*** {
}

Handle<Value> SecurityCredentials::New(const Arguments &args***REMOVED*** {
  HandleScope scope;  

  // Create security credentials instance
  SecurityCredentials *security_credentials = new SecurityCredentials(***REMOVED***;
  // Wrap it
  security_credentials->Wrap(args.This(***REMOVED******REMOVED***;
  // Return the object
  return args.This(***REMOVED***;
}

Handle<Value> SecurityCredentials::AquireSync(const Arguments &args***REMOVED*** {
  HandleScope scope;  
  char *package_str = NULL, *username_str = NULL, *password_str = NULL, *domain_str = NULL;
  // Status of operation
  SECURITY_STATUS status;

  // Unpack the variables
  if(args.Length(***REMOVED*** != 2 && args.Length(***REMOVED*** != 3 && args.Length(***REMOVED*** != 4***REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string]]"***REMOVED***;

  if(!args[0]->IsString(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string]]"***REMOVED***;

  if(!args[1]->IsString(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string]]"***REMOVED***;

  if(args.Length(***REMOVED*** == 3 && !args[2]->IsString(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string]]"***REMOVED***;

  if(args.Length(***REMOVED*** == 4 && (!args[3]->IsString(***REMOVED*** && !args[3]->IsUndefined(***REMOVED*** && !args[3]->IsNull(***REMOVED******REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string]]"***REMOVED***;

  // Unpack the package
  Local<String> package = args[0]->ToString(***REMOVED***;
  package_str = (char ****REMOVED***calloc(package->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  package->WriteUtf8(package_str***REMOVED***;

  // Unpack the user name
  Local<String> username = args[1]->ToString(***REMOVED***;
  username_str = (char ****REMOVED***calloc(username->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  username->WriteUtf8(username_str***REMOVED***;

  // If we have a password
  if(args.Length(***REMOVED*** == 3 || args.Length(***REMOVED*** == 4***REMOVED*** {
    Local<String> password = args[2]->ToString(***REMOVED***;
    password_str = (char ****REMOVED***calloc(password->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    password->WriteUtf8(password_str***REMOVED***;    
***REMOVED***

  // If we have a domain
  if(args.Length(***REMOVED*** == 4 && args[3]->IsString(***REMOVED******REMOVED*** {
    Local<String> domain = args[3]->ToString(***REMOVED***;
    domain_str = (char ****REMOVED***calloc(domain->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    domain->WriteUtf8(domain_str***REMOVED***;    
***REMOVED***

  // Create Security instance
  Local<Object> security_credentials_value = constructor_template->GetFunction(***REMOVED***->NewInstance(***REMOVED***;

  // Unwrap the credentials
  SecurityCredentials *security_credentials = ObjectWrap::Unwrap<SecurityCredentials>(security_credentials_value***REMOVED***;

  // If we have domain string
  if(domain_str != NULL***REMOVED*** {
    security_credentials->m_Identity.Domain = USTR(_tcsdup(domain_str***REMOVED******REMOVED***;
    security_credentials->m_Identity.DomainLength = (unsigned long***REMOVED***_tcslen(domain_str***REMOVED***;
***REMOVED*** else {
    security_credentials->m_Identity.Domain = NULL;
    security_credentials->m_Identity.DomainLength = 0;
***REMOVED***

  // Set up the user
  security_credentials->m_Identity.User = USTR(_tcsdup(username_str***REMOVED******REMOVED***;
  security_credentials->m_Identity.UserLength = (unsigned long***REMOVED***_tcslen(username_str***REMOVED***;

  // If we have a password string
  if(password_str != NULL***REMOVED*** {
    // Set up the password
    security_credentials->m_Identity.Password = USTR(_tcsdup(password_str***REMOVED******REMOVED***;
    security_credentials->m_Identity.PasswordLength = (unsigned long***REMOVED***_tcslen(password_str***REMOVED***;    
***REMOVED***

  #ifdef _UNICODE
    security_credentials->m_Identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
  #else
    security_credentials->m_Identity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
  #endif

  // Attempt to acquire credentials
  status = _sspi_AcquireCredentialsHandle(
    NULL,
    package_str,
    SECPKG_CRED_OUTBOUND,
    NULL, 
    password_str != NULL ? &security_credentials->m_Identity : NULL,
    NULL, NULL,
    &security_credentials->m_Credentials,
    &security_credentials->Expiration
  ***REMOVED***;

  // We have an error
  if(status != SEC_E_OK***REMOVED*** {
    LPSTR err_message = DisplaySECError(status***REMOVED***;

    if(err_message != NULL***REMOVED*** {
      return VExceptionErrNo(err_message, status***REMOVED***;
  ***REMOVED*** else {
      return VExceptionErrNo("Unknown error", status***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Make object persistent
  Persistent<Object> persistent = Persistent<Object>::New(security_credentials_value***REMOVED***;
  // Return the object
  return scope.Close(persistent***REMOVED***;
}

// Call structs
typedef struct SecurityCredentialCall {
  char *package_str;
  char *username_str;
  char *password_str;
  char *domain_str;
  SecurityCredentials *credentials;
} SecurityCredentialCall;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// authGSSClientInit
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void _authSSPIAquire(Worker *worker***REMOVED*** {
  // Status of operation
  SECURITY_STATUS status;

  // Unpack data
  SecurityCredentialCall *call = (SecurityCredentialCall ****REMOVED***worker->parameters;  

  // Unwrap the credentials
  SecurityCredentials *security_credentials = (SecurityCredentials ****REMOVED***call->credentials;

  // If we have domain string
  if(call->domain_str != NULL***REMOVED*** {
    security_credentials->m_Identity.Domain = USTR(_tcsdup(call->domain_str***REMOVED******REMOVED***;
    security_credentials->m_Identity.DomainLength = (unsigned long***REMOVED***_tcslen(call->domain_str***REMOVED***;
***REMOVED*** else {
    security_credentials->m_Identity.Domain = NULL;
    security_credentials->m_Identity.DomainLength = 0;
***REMOVED***

  // Set up the user
  security_credentials->m_Identity.User = USTR(_tcsdup(call->username_str***REMOVED******REMOVED***;
  security_credentials->m_Identity.UserLength = (unsigned long***REMOVED***_tcslen(call->username_str***REMOVED***;

  // If we have a password string
  if(call->password_str != NULL***REMOVED*** {
    // Set up the password
    security_credentials->m_Identity.Password = USTR(_tcsdup(call->password_str***REMOVED******REMOVED***;
    security_credentials->m_Identity.PasswordLength = (unsigned long***REMOVED***_tcslen(call->password_str***REMOVED***;    
***REMOVED***

  #ifdef _UNICODE
    security_credentials->m_Identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
  #else
    security_credentials->m_Identity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
  #endif

  // Attempt to acquire credentials
  status = _sspi_AcquireCredentialsHandle(
    NULL,
    call->package_str,
    SECPKG_CRED_OUTBOUND,
    NULL, 
    call->password_str != NULL ? &security_credentials->m_Identity : NULL,
    NULL, NULL,
    &security_credentials->m_Credentials,
    &security_credentials->Expiration
  ***REMOVED***;

  // We have an error
  if(status != SEC_E_OK***REMOVED*** {
    worker->error = TRUE;
    worker->error_code = status;
    worker->error_message = DisplaySECError(status***REMOVED***;
***REMOVED*** else {
    worker->return_code = status;
    worker->return_value = security_credentials;
***REMOVED***

  // Free up parameter structure
  if(call->package_str != NULL***REMOVED*** free(call->package_str***REMOVED***;
  if(call->domain_str != NULL***REMOVED*** free(call->domain_str***REMOVED***;
  if(call->password_str != NULL***REMOVED*** free(call->password_str***REMOVED***;
  if(call->username_str != NULL***REMOVED*** free(call->username_str***REMOVED***;
  free(call***REMOVED***;
}

static Handle<Value> _map_authSSPIAquire(Worker *worker***REMOVED*** {
  HandleScope scope;

  // Unpack the credentials
  SecurityCredentials *security_credentials = (SecurityCredentials ****REMOVED***worker->return_value;
  // Make object persistent
  Persistent<Object> persistent = Persistent<Object>::New(security_credentials->handle_***REMOVED***;
  // Return the object
  return scope.Close(persistent***REMOVED***;
}

Handle<Value> SecurityCredentials::Aquire(const Arguments &args***REMOVED*** {
  HandleScope scope;  
  char *package_str = NULL, *username_str = NULL, *password_str = NULL, *domain_str = NULL;
  // Unpack the variables
  if(args.Length(***REMOVED*** != 2 && args.Length(***REMOVED*** != 3 && args.Length(***REMOVED*** != 4 && args.Length(***REMOVED*** != 5***REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string], callback:function]"***REMOVED***;

  if(!args[0]->IsString(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string], callback:function]"***REMOVED***;

  if(!args[1]->IsString(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string], callback:function]"***REMOVED***;

  if(args.Length(***REMOVED*** == 3 && (!args[2]->IsString(***REMOVED*** && !args[2]->IsFunction(***REMOVED******REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string], callback:function]"***REMOVED***;

  if(args.Length(***REMOVED*** == 4 && (!args[3]->IsString(***REMOVED*** && !args[3]->IsUndefined(***REMOVED*** && !args[3]->IsNull(***REMOVED******REMOVED*** && !args[3]->IsFunction(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string], callback:function]"***REMOVED***;

  if(args.Length(***REMOVED*** == 5 && !args[4]->IsFunction(***REMOVED******REMOVED***
    return VException("Aquire must be called with either [package:string, username:string, [password:string, domain:string], callback:function]"***REMOVED***;

  Local<Function> callback;

  // Figure out which parameter is the callback
  if(args.Length(***REMOVED*** == 5***REMOVED*** {
    callback = Local<Function>::Cast(args[4]***REMOVED***;
***REMOVED*** else if(args.Length(***REMOVED*** == 4***REMOVED*** {
    callback = Local<Function>::Cast(args[3]***REMOVED***;
***REMOVED*** else if(args.Length(***REMOVED*** == 3***REMOVED*** {
    callback = Local<Function>::Cast(args[2]***REMOVED***;
***REMOVED***

  // Unpack the package
  Local<String> package = args[0]->ToString(***REMOVED***;
  package_str = (char ****REMOVED***calloc(package->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  package->WriteUtf8(package_str***REMOVED***;

  // Unpack the user name
  Local<String> username = args[1]->ToString(***REMOVED***;
  username_str = (char ****REMOVED***calloc(username->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
  username->WriteUtf8(username_str***REMOVED***;

  // If we have a password
  if(args.Length(***REMOVED*** == 3 || args.Length(***REMOVED*** == 4 || args.Length(***REMOVED*** == 5***REMOVED*** {
    Local<String> password = args[2]->ToString(***REMOVED***;
    password_str = (char ****REMOVED***calloc(password->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    password->WriteUtf8(password_str***REMOVED***;    
***REMOVED***

  // If we have a domain
  if((args.Length(***REMOVED*** == 4 || args.Length(***REMOVED*** == 5***REMOVED*** && args[3]->IsString(***REMOVED******REMOVED*** {
    Local<String> domain = args[3]->ToString(***REMOVED***;
    domain_str = (char ****REMOVED***calloc(domain->Utf8Length(***REMOVED*** + 1, sizeof(char***REMOVED******REMOVED***;
    domain->WriteUtf8(domain_str***REMOVED***;    
***REMOVED***

  // Create reference object
  Local<Object> security_credentials_value = constructor_template->GetFunction(***REMOVED***->NewInstance(***REMOVED***;
  // Unwrap object
  SecurityCredentials *security_credentials = ObjectWrap::Unwrap<SecurityCredentials>(security_credentials_value***REMOVED***;

  // Allocate call structure
  SecurityCredentialCall *call = (SecurityCredentialCall ****REMOVED***calloc(1, sizeof(SecurityCredentialCall***REMOVED******REMOVED***;
  call->domain_str = domain_str;
  call->package_str = package_str;
  call->password_str = password_str;
  call->username_str = username_str;
  call->credentials = security_credentials;

  // Let's allocate some space
  Worker *worker = new Worker(***REMOVED***;
  worker->error = false;
  worker->request.data = worker;
  worker->callback = Persistent<Function>::New(callback***REMOVED***;
  worker->parameters = call;
  worker->execute = _authSSPIAquire;
  worker->mapper = _map_authSSPIAquire;

  // Schedule the worker with lib_uv
  uv_queue_work(uv_default_loop(***REMOVED***, &worker->request, SecurityCredentials::Process, (uv_after_work_cb***REMOVED***SecurityCredentials::After***REMOVED***;

  // Return the undefined value
  return scope.Close(Undefined(***REMOVED******REMOVED***;
}

void SecurityCredentials::Initialize(Handle<Object> target***REMOVED*** {
  // Grab the scope of the call from Node
  HandleScope scope;
  // Define a new function template
  Local<FunctionTemplate> t = FunctionTemplate::New(New***REMOVED***;
  constructor_template = Persistent<FunctionTemplate>::New(t***REMOVED***;
  constructor_template->InstanceTemplate(***REMOVED***->SetInternalFieldCount(1***REMOVED***;
  constructor_template->SetClassName(String::NewSymbol("SecurityCredentials"***REMOVED******REMOVED***;

  // Class methods
  NODE_SET_METHOD(constructor_template, "aquireSync", AquireSync***REMOVED***;
  NODE_SET_METHOD(constructor_template, "aquire", Aquire***REMOVED***;

  // Set the class on the target module
  target->Set(String::NewSymbol("SecurityCredentials"***REMOVED***, constructor_template->GetFunction(***REMOVED******REMOVED***;  

  // Attempt to load the security.dll library
  load_library(***REMOVED***;
}

static LPSTR DisplaySECError(DWORD ErrCode***REMOVED*** {
  LPSTR pszName = NULL; // WinError.h

  switch(ErrCode***REMOVED*** {
    case SEC_E_BUFFER_TOO_SMALL:
      pszName = "SEC_E_BUFFER_TOO_SMALL - The message buffer is too small. Used with the Digest SSP.";
      break;

    case SEC_E_CRYPTO_SYSTEM_INVALID:
      pszName = "SEC_E_CRYPTO_SYSTEM_INVALID - The cipher chosen for the security context is not supported. Used with the Digest SSP."; 
      break;
    case SEC_E_INCOMPLETE_MESSAGE:
      pszName = "SEC_E_INCOMPLETE_MESSAGE - The data in the input buffer is incomplete. The application needs to read more data from the server and call DecryptMessage (General***REMOVED*** again."; 
      break;

    case SEC_E_INVALID_HANDLE:
      pszName = "SEC_E_INVALID_HANDLE - A context handle that is not valid was specified in the phContext parameter. Used with the Digest and Schannel SSPs."; 
      break;

    case SEC_E_INVALID_TOKEN:
      pszName = "SEC_E_INVALID_TOKEN - The buffers are of the wrong type or no buffer of type SECBUFFER_DATA was found. Used with the Schannel SSP."; 
      break;
        
    case SEC_E_MESSAGE_ALTERED:
      pszName = "SEC_E_MESSAGE_ALTERED - The message has been altered. Used with the Digest and Schannel SSPs."; 
      break;
        
    case SEC_E_OUT_OF_SEQUENCE:
      pszName = "SEC_E_OUT_OF_SEQUENCE - The message was not received in the correct sequence."; 
      break;
        
    case SEC_E_QOP_NOT_SUPPORTED:
      pszName = "SEC_E_QOP_NOT_SUPPORTED - Neither confidentiality nor integrity are supported by the security context. Used with the Digest SSP."; 
      break;
        
    case SEC_I_CONTEXT_EXPIRED:
      pszName = "SEC_I_CONTEXT_EXPIRED - The message sender has finished using the connection and has initiated a shutdown."; 
      break;
        
    case SEC_I_RENEGOTIATE:
      pszName = "SEC_I_RENEGOTIATE - The remote party requires a new handshake sequence or the application has just initiated a shutdown."; 
      break;
        
    case SEC_E_ENCRYPT_FAILURE:
      pszName = "SEC_E_ENCRYPT_FAILURE - The specified data could not be encrypted."; 
      break;
        
    case SEC_E_DECRYPT_FAILURE:
      pszName = "SEC_E_DECRYPT_FAILURE - The specified data could not be decrypted."; 
      break;
    case -1:
      pszName = "Failed to load security.dll library"; 
      break;

***REMOVED***

  return pszName;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// UV Lib callbacks
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void SecurityCredentials::Process(uv_work_t* work_req***REMOVED*** {
  // Grab the worker
  Worker *worker = static_cast<Worker*>(work_req->data***REMOVED***;
  // Execute the worker code
  worker->execute(worker***REMOVED***;
}

void SecurityCredentials::After(uv_work_t* work_req***REMOVED*** {
  // Grab the scope of the call from Node
  v8::HandleScope scope;

  // Get the worker reference
  Worker *worker = static_cast<Worker*>(work_req->data***REMOVED***;

  // If we have an error
  if(worker->error***REMOVED*** {
    v8::Local<v8::Value> err = v8::Exception::Error(v8::String::New(worker->error_message***REMOVED******REMOVED***;
    Local<Object> obj = err->ToObject(***REMOVED***;
    obj->Set(NODE_PSYMBOL("code"***REMOVED***, Int32::New(worker->error_code***REMOVED******REMOVED***;
    v8::Local<v8::Value> args[2] = { err, v8::Local<v8::Value>::New(v8::Null(***REMOVED******REMOVED*** };
    // Execute the error
    v8::TryCatch try_catch;
    // Call the callback
    worker->callback->Call(v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***, ARRAY_SIZE(args***REMOVED***, args***REMOVED***;
    // If we have an exception handle it as a fatalexception
    if (try_catch.HasCaught(***REMOVED******REMOVED*** {
      node::FatalException(try_catch***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    // // Map the data
    v8::Handle<v8::Value> result = worker->mapper(worker***REMOVED***;
    // Set up the callback with a null first
    v8::Handle<v8::Value> args[2] = { v8::Local<v8::Value>::New(v8::Null(***REMOVED******REMOVED***, result};
    // Wrap the callback function call in a TryCatch so that we can call
    // node's FatalException afterwards. This makes it possible to catch
    // the exception from JavaScript land using the
    // process.on('uncaughtException'***REMOVED*** event.
    v8::TryCatch try_catch;
    // Call the callback
    worker->callback->Call(v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***, ARRAY_SIZE(args***REMOVED***, args***REMOVED***;
    // If we have an exception handle it as a fatalexception
    if (try_catch.HasCaught(***REMOVED******REMOVED*** {
      node::FatalException(try_catch***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Clean up the memory
  worker->callback.Dispose(***REMOVED***;
  delete worker;
}

