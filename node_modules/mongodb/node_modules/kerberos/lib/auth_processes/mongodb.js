var format = require('util'***REMOVED***.format;

var MongoAuthProcess = function(host, port, service_name***REMOVED*** {  
  // Check what system we are on
  if(process.platform == 'win32'***REMOVED*** {
    this._processor = new Win32MongoProcessor(host, port, service_name***REMOVED***;
***REMOVED*** else {
    this._processor = new UnixMongoProcessor(host, port, service_name***REMOVED***;
***REMOVED***
}

MongoAuthProcess.prototype.init = function(username, password, callback***REMOVED*** {
  this._processor.init(username, password, callback***REMOVED***;
}

MongoAuthProcess.prototype.transition = function(payload, callback***REMOVED*** {
  this._processor.transition(payload, callback***REMOVED***;
}

/*******************************************************************
 *
 * Win32 SSIP Processor for MongoDB
 *
 *******************************************************************/
var Win32MongoProcessor = function(host, port, service_name***REMOVED*** {
  this.host = host;
  this.port = port  
  // SSIP classes
  this.ssip = require("../kerberos"***REMOVED***.SSIP;
  // Set up first transition
  this._transition = Win32MongoProcessor.first_transition(this***REMOVED***;
  // Set up service name
  service_name = service_name || "mongodb";
  // Set up target
  this.target = format("%s/%s", service_name, host***REMOVED***;
  // Number of retries
  this.retries = 10;
}

Win32MongoProcessor.prototype.init = function(username, password, callback***REMOVED*** {
  var self = this;
  // Save the values used later
  this.username = username;
  this.password = password;
  // Aquire credentials
  this.ssip.SecurityCredentials.aquire_kerberos(username, password, function(err, security_credentials***REMOVED*** {
    if(err***REMOVED*** return callback(err***REMOVED***;
    // Save credentials
    self.security_credentials = security_credentials;
    // Callback with success
    callback(null***REMOVED***;
***REMOVED******REMOVED***;
}

Win32MongoProcessor.prototype.transition = function(payload, callback***REMOVED*** {
  if(this._transition == null***REMOVED*** return callback(new Error("Transition finished"***REMOVED******REMOVED***;
  this._transition(payload, callback***REMOVED***;
}

Win32MongoProcessor.first_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {    
    self.ssip.SecurityContext.initialize(
      self.security_credentials, 
      self.target, 
      payload, function(err, security_context***REMOVED*** {   
        if(err***REMOVED*** return callback(err***REMOVED***;
        
        // If no context try again until we have no more retries
        if(!security_context.hasContext***REMOVED*** {
          if(self.retries == 0***REMOVED*** return callback(new Error("Failed to initialize security context"***REMOVED******REMOVED***;
          // Update the number of retries
          self.retries = self.retries - 1;
          // Set next transition
          return self.transition(payload, callback***REMOVED***;
      ***REMOVED***

        // Set next transition
        self._transition = Win32MongoProcessor.second_transition(self***REMOVED***;
        self.security_context = security_context;
        // Return the payload
        callback(null, security_context.payload***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
}

Win32MongoProcessor.second_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {    
    // Perform a step
    self.security_context.initialize(self.target, payload, function(err, security_context***REMOVED*** {
      if(err***REMOVED*** return callback(err***REMOVED***;

      // If no context try again until we have no more retries
      if(!security_context.hasContext***REMOVED*** {
        if(self.retries == 0***REMOVED*** return callback(new Error("Failed to initialize security context"***REMOVED******REMOVED***;
        // Update the number of retries
        self.retries = self.retries - 1;
        // Set next transition
        self._transition = Win32MongoProcessor.first_transition(self***REMOVED***;
        // Retry
        return self.transition(payload, callback***REMOVED***;
    ***REMOVED***

      // Set next transition
      self._transition = Win32MongoProcessor.third_transition(self***REMOVED***;
      // Return the payload
      callback(null, security_context.payload***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***  
}

Win32MongoProcessor.third_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {   
    var messageLength = 0;
    // Get the raw bytes
    var encryptedBytes = new Buffer(payload, 'base64'***REMOVED***;
    var encryptedMessage = new Buffer(messageLength***REMOVED***;
    // Copy first byte
    encryptedBytes.copy(encryptedMessage, 0, 0, messageLength***REMOVED***;
    // Set up trailer
    var securityTrailerLength = encryptedBytes.length - messageLength;
    var securityTrailer = new Buffer(securityTrailerLength***REMOVED***;
    // Copy the bytes
    encryptedBytes.copy(securityTrailer, 0, messageLength, securityTrailerLength***REMOVED***;

    // Types used
    var SecurityBuffer = self.ssip.SecurityBuffer;
    var SecurityBufferDescriptor = self.ssip.SecurityBufferDescriptor;

    // Set up security buffers
    var buffers = [
        new SecurityBuffer(SecurityBuffer.DATA, encryptedBytes***REMOVED***
      , new SecurityBuffer(SecurityBuffer.STREAM, securityTrailer***REMOVED***
    ];

    // Set up the descriptor
    var descriptor = new SecurityBufferDescriptor(buffers***REMOVED***;

    // Decrypt the data
    self.security_context.decryptMessage(descriptor, function(err, security_context***REMOVED*** {
      if(err***REMOVED*** return callback(err***REMOVED***;

      var length = 4;
      if(self.username != null***REMOVED*** {
        length += self.username.length;          
    ***REMOVED***

      var bytesReceivedFromServer = new Buffer(length***REMOVED***;
      bytesReceivedFromServer[0] = 0x01;  // NO_PROTECTION
      bytesReceivedFromServer[1] = 0x00;  // NO_PROTECTION
      bytesReceivedFromServer[2] = 0x00;  // NO_PROTECTION
      bytesReceivedFromServer[3] = 0x00;  // NO_PROTECTION        

      if(self.username != null***REMOVED*** {
        var authorization_id_bytes = new Buffer(self.username, 'utf8'***REMOVED***;
        authorization_id_bytes.copy(bytesReceivedFromServer, 4, 0***REMOVED***;
    ***REMOVED***

      self.security_context.queryContextAttributes(0x00, function(err, sizes***REMOVED*** {
        if(err***REMOVED*** return callback(err***REMOVED***;

        var buffers = [
            new SecurityBuffer(SecurityBuffer.TOKEN, new Buffer(sizes.securityTrailer***REMOVED******REMOVED***
          , new SecurityBuffer(SecurityBuffer.DATA, bytesReceivedFromServer***REMOVED***
          , new SecurityBuffer(SecurityBuffer.PADDING, new Buffer(sizes.blockSize***REMOVED******REMOVED***
        ]

        var descriptor = new SecurityBufferDescriptor(buffers***REMOVED***;

        self.security_context.encryptMessage(descriptor, 0x80000001, function(err, security_context***REMOVED*** {
          if(err***REMOVED*** return callback(err***REMOVED***;
          callback(null, security_context.payload***REMOVED***;
      ***REMOVED******REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***  
}

/*******************************************************************
 *
 * UNIX MIT Kerberos processor
 *
 *******************************************************************/
var UnixMongoProcessor = function(host, port, service_name***REMOVED*** {
  this.host = host;
  this.port = port  
  // SSIP classes
  this.Kerberos = require("../kerberos"***REMOVED***.Kerberos;
  this.kerberos = new this.Kerberos(***REMOVED***;
  service_name = service_name || "mongodb";
  // Set up first transition
  this._transition = UnixMongoProcessor.first_transition(this***REMOVED***;
  // Set up target
  this.target = format("%s@%s", service_name, host***REMOVED***;
  // Number of retries
  this.retries = 10;
}

UnixMongoProcessor.prototype.init = function(username, password, callback***REMOVED*** {
  var self = this;
  this.username = username;
  this.password = password;
  // Call client initiate
  this.kerberos.authGSSClientInit(
      self.target
    , this.Kerberos.GSS_C_MUTUAL_FLAG, function(err, context***REMOVED*** {
      self.context = context;
      // Return the context
      callback(null, context***REMOVED***;
***REMOVED******REMOVED***;
}

UnixMongoProcessor.prototype.transition = function(payload, callback***REMOVED*** {
  if(this._transition == null***REMOVED*** return callback(new Error("Transition finished"***REMOVED******REMOVED***;
  this._transition(payload, callback***REMOVED***;
}

UnixMongoProcessor.first_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {    
    self.kerberos.authGSSClientStep(self.context, '', function(err, result***REMOVED*** {
      if(err***REMOVED*** return callback(err***REMOVED***;
      // Set up the next step
      self._transition = UnixMongoProcessor.second_transition(self***REMOVED***;
      // Return the payload
      callback(null, self.context.response***REMOVED***;
  ***REMOVED******REMOVED***
***REMOVED***
}

UnixMongoProcessor.second_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {    
    self.kerberos.authGSSClientStep(self.context, payload, function(err, result***REMOVED*** {
      if(err && self.retries == 0***REMOVED*** return callback(err***REMOVED***;
      // Attempt to re-establish a context
      if(err***REMOVED*** {
        // Adjust the number of retries
        self.retries = self.retries - 1;
        // Call same step again
        return self.transition(payload, callback***REMOVED***;
    ***REMOVED***
      
      // Set up the next step
      self._transition = UnixMongoProcessor.third_transition(self***REMOVED***;
      // Return the payload
      callback(null, self.context.response || ''***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
}

UnixMongoProcessor.third_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {    
    // GSS Client Unwrap
    self.kerberos.authGSSClientUnwrap(self.context, payload, function(err, result***REMOVED*** {
      if(err***REMOVED*** return callback(err, false***REMOVED***;
      
      // Wrap the response
      self.kerberos.authGSSClientWrap(self.context, self.context.response, self.username, function(err, result***REMOVED*** {
        if(err***REMOVED*** return callback(err, false***REMOVED***;
        // Set up the next step
        self._transition = UnixMongoProcessor.fourth_transition(self***REMOVED***;
        // Return the payload
        callback(null, self.context.response***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
}

UnixMongoProcessor.fourth_transition = function(self***REMOVED*** {
  return function(payload, callback***REMOVED*** {    
    // Clean up context
    self.kerberos.authGSSClientClean(self.context, function(err, result***REMOVED*** {
      if(err***REMOVED*** return callback(err, false***REMOVED***;
      // Set the transition to null
      self._transition = null;
      // Callback with valid authentication
      callback(null, true***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
}

// Set the process
exports.MongoAuthProcess = MongoAuthProcess;