/**
 * Copyright (c***REMOVED*** 2006-2010 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"***REMOVED***;
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

#include "kerberosgss.h"

#include "base64.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>

static void set_gss_error(OM_uint32 err_maj, OM_uint32 err_min***REMOVED***;

/*extern PyObject *GssException_class;
extern PyObject *KrbException_class;

char* server_principal_details(const char* service, const char* hostname***REMOVED***
{
    char match[1024];
    int match_len = 0;
    char* result = NULL;
    
    int code;
    krb5_context kcontext;
    krb5_keytab kt = NULL;
    krb5_kt_cursor cursor = NULL;
    krb5_keytab_entry entry;
    char* pname = NULL;
    
    // Generate the principal prefix we want to match
    snprintf(match, 1024, "%s/%s@", service, hostname***REMOVED***;
    match_len = strlen(match***REMOVED***;
    
    code = krb5_init_context(&kcontext***REMOVED***;
    if (code***REMOVED***
    {
        PyErr_SetObject(KrbException_class, Py_BuildValue("((s:i***REMOVED******REMOVED***",
                                                          "Cannot initialize Kerberos5 context", code***REMOVED******REMOVED***;
        return NULL;
  ***REMOVED***
    
    if ((code = krb5_kt_default(kcontext, &kt***REMOVED******REMOVED******REMOVED***
    {
        PyErr_SetObject(KrbException_class, Py_BuildValue("((s:i***REMOVED******REMOVED***",
                                                          "Cannot get default keytab", code***REMOVED******REMOVED***;
        goto end;
  ***REMOVED***
    
    if ((code = krb5_kt_start_seq_get(kcontext, kt, &cursor***REMOVED******REMOVED******REMOVED***
    {
        PyErr_SetObject(KrbException_class, Py_BuildValue("((s:i***REMOVED******REMOVED***",
                                                          "Cannot get sequence cursor from keytab", code***REMOVED******REMOVED***;
        goto end;
  ***REMOVED***
    
    while ((code = krb5_kt_next_entry(kcontext, kt, &entry, &cursor***REMOVED******REMOVED*** == 0***REMOVED***
    {
        if ((code = krb5_unparse_name(kcontext, entry.principal, &pname***REMOVED******REMOVED******REMOVED***
        {
            PyErr_SetObject(KrbException_class, Py_BuildValue("((s:i***REMOVED******REMOVED***",
                                                              "Cannot parse principal name from keytab", code***REMOVED******REMOVED***;
            goto end;
      ***REMOVED***
        
        if (strncmp(pname, match, match_len***REMOVED*** == 0***REMOVED***
        {
            result = malloc(strlen(pname***REMOVED*** + 1***REMOVED***;
            strcpy(result, pname***REMOVED***;
            krb5_free_unparsed_name(kcontext, pname***REMOVED***;
            krb5_free_keytab_entry_contents(kcontext, &entry***REMOVED***;
            break;
      ***REMOVED***
        
        krb5_free_unparsed_name(kcontext, pname***REMOVED***;
        krb5_free_keytab_entry_contents(kcontext, &entry***REMOVED***;
  ***REMOVED***
    
    if (result == NULL***REMOVED***
    {
        PyErr_SetObject(KrbException_class, Py_BuildValue("((s:i***REMOVED******REMOVED***",
                                                          "Principal not found in keytab", -1***REMOVED******REMOVED***;
  ***REMOVED***
    
end:
    if (cursor***REMOVED***
        krb5_kt_end_seq_get(kcontext, kt, &cursor***REMOVED***;
    if (kt***REMOVED***
        krb5_kt_close(kcontext, kt***REMOVED***;
    krb5_free_context(kcontext***REMOVED***;
    
    return result;
}
*/
gss_client_response *authenticate_gss_client_init(const char* service, long int gss_flags, gss_client_state* state***REMOVED*** {
  OM_uint32 maj_stat;
  OM_uint32 min_stat;
  gss_buffer_desc name_token = GSS_C_EMPTY_BUFFER;
  gss_client_response *response = NULL;
  int ret = AUTH_GSS_COMPLETE;

  state->server_name = GSS_C_NO_NAME;
  state->context = GSS_C_NO_CONTEXT;
  state->gss_flags = gss_flags;
  state->username = NULL;
  state->response = NULL;
  
  // Import server name first
  name_token.length = strlen(service***REMOVED***;
  name_token.value = (char ****REMOVED***service;
  
  maj_stat = gss_import_name(&min_stat, &name_token, gss_krb5_nt_service_name, &state->server_name***REMOVED***;
  
  if (GSS_ERROR(maj_stat***REMOVED******REMOVED*** {
    response = gss_error(maj_stat, min_stat***REMOVED***;
    response->return_code = AUTH_GSS_ERROR;
    goto end;
***REMOVED***
  
end:
  if(response == NULL***REMOVED*** {
    response = calloc(1, sizeof(gss_client_response***REMOVED******REMOVED***;
    response->return_code = ret;    
***REMOVED***

  return response;
}

gss_client_response *authenticate_gss_client_clean(gss_client_state *state***REMOVED*** {
  OM_uint32 min_stat;
  int ret = AUTH_GSS_COMPLETE;
  gss_client_response *response = NULL;
  
  if(state->context != GSS_C_NO_CONTEXT***REMOVED***
    gss_delete_sec_context(&min_stat, &state->context, GSS_C_NO_BUFFER***REMOVED***;
  
  if(state->server_name != GSS_C_NO_NAME***REMOVED***
    gss_release_name(&min_stat, &state->server_name***REMOVED***;
  
  if(state->username != NULL***REMOVED*** {
    free(state->username***REMOVED***;
    state->username = NULL;
***REMOVED***

  if (state->response != NULL***REMOVED*** {
    free(state->response***REMOVED***;
    state->response = NULL;
***REMOVED***
  
  if(response == NULL***REMOVED*** {
    response = calloc(1, sizeof(gss_client_response***REMOVED******REMOVED***;
    response->return_code = ret;    
***REMOVED***

  return response;
}

gss_client_response *authenticate_gss_client_step(gss_client_state* state, const char* challenge***REMOVED*** {
  OM_uint32 maj_stat;
  OM_uint32 min_stat;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret = AUTH_GSS_CONTINUE;
  gss_client_response *response = NULL;
  
  // Always clear out the old response
  if (state->response != NULL***REMOVED*** {
    free(state->response***REMOVED***;
    state->response = NULL;
***REMOVED***
  
  // If there is a challenge (data from the server***REMOVED*** we need to give it to GSS
  if (challenge && *challenge***REMOVED*** {
    int len;
    input_token.value = base64_decode(challenge, &len***REMOVED***;
    input_token.length = len;
***REMOVED***
  
  // Do GSSAPI step
  maj_stat = gss_init_sec_context(&min_stat,
                                  GSS_C_NO_CREDENTIAL,
                                  &state->context,
                                  state->server_name,
                                  GSS_C_NO_OID,
                                  (OM_uint32***REMOVED***state->gss_flags,
                                  0,
                                  GSS_C_NO_CHANNEL_BINDINGS,
                                  &input_token,
                                  NULL,
                                  &output_token,
                                  NULL,
                                  NULL***REMOVED***;

  if ((maj_stat != GSS_S_COMPLETE***REMOVED*** && (maj_stat != GSS_S_CONTINUE_NEEDED***REMOVED******REMOVED*** {
    response = gss_error(maj_stat, min_stat***REMOVED***;
    response->return_code = AUTH_GSS_ERROR;
    goto end;
***REMOVED***
  
  ret = (maj_stat == GSS_S_COMPLETE***REMOVED*** ? AUTH_GSS_COMPLETE : AUTH_GSS_CONTINUE;
  // Grab the client response to send back to the server
  if(output_token.length***REMOVED*** {
    state->response = base64_encode((const unsigned char ****REMOVED***output_token.value, output_token.length***REMOVED***;
    maj_stat = gss_release_buffer(&min_stat, &output_token***REMOVED***;
***REMOVED***
  
  // Try to get the user name if we have completed all GSS operations
  if (ret == AUTH_GSS_COMPLETE***REMOVED*** {
    gss_name_t gssuser = GSS_C_NO_NAME;
    maj_stat = gss_inquire_context(&min_stat, state->context, &gssuser, NULL, NULL, NULL,  NULL, NULL, NULL***REMOVED***;
    
    if(GSS_ERROR(maj_stat***REMOVED******REMOVED*** {
      response = gss_error(maj_stat, min_stat***REMOVED***;
      response->return_code = AUTH_GSS_ERROR;
      goto end;
  ***REMOVED***
    
    gss_buffer_desc name_token;
    name_token.length = 0;
    maj_stat = gss_display_name(&min_stat, gssuser, &name_token, NULL***REMOVED***;
    
    if(GSS_ERROR(maj_stat***REMOVED******REMOVED*** {
      if(name_token.value***REMOVED***
        gss_release_buffer(&min_stat, &name_token***REMOVED***;
      gss_release_name(&min_stat, &gssuser***REMOVED***;
      
      response = gss_error(maj_stat, min_stat***REMOVED***;
      response->return_code = AUTH_GSS_ERROR;
      goto end;
  ***REMOVED*** else {
      state->username = (char ****REMOVED***malloc(name_token.length + 1***REMOVED***;
      strncpy(state->username, (char****REMOVED*** name_token.value, name_token.length***REMOVED***;
      state->username[name_token.length] = 0;
      gss_release_buffer(&min_stat, &name_token***REMOVED***;
      gss_release_name(&min_stat, &gssuser***REMOVED***;
  ***REMOVED***
***REMOVED***

end:
  if(output_token.value***REMOVED***
    gss_release_buffer(&min_stat, &output_token***REMOVED***;
  if(input_token.value***REMOVED***
    free(input_token.value***REMOVED***;

  if(response == NULL***REMOVED*** {
    response = calloc(1, sizeof(gss_client_response***REMOVED******REMOVED***;
    response->return_code = ret;
***REMOVED***

  // Return the response
  return response;
}

gss_client_response *authenticate_gss_client_unwrap(gss_client_state *state, const char *challenge***REMOVED*** {
  OM_uint32 maj_stat;
  OM_uint32 min_stat;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  gss_client_response *response = NULL;
  int ret = AUTH_GSS_CONTINUE;
    
  // Always clear out the old response
  if(state->response != NULL***REMOVED*** {
    free(state->response***REMOVED***;
    state->response = NULL;
***REMOVED***
    
  // If there is a challenge (data from the server***REMOVED*** we need to give it to GSS
  if(challenge && *challenge***REMOVED*** {
    int len;
    input_token.value = base64_decode(challenge, &len***REMOVED***;
    input_token.length = len;
***REMOVED***
    
  // Do GSSAPI step
  maj_stat = gss_unwrap(&min_stat,
                          state->context,
                          &input_token,
                          &output_token,
                          NULL,
                          NULL***REMOVED***;
    
  if(maj_stat != GSS_S_COMPLETE***REMOVED*** {
    response = gss_error(maj_stat, min_stat***REMOVED***;
    response->return_code = AUTH_GSS_ERROR;
    goto end;
***REMOVED*** else {
    ret = AUTH_GSS_COMPLETE;    
***REMOVED***
    
  // Grab the client response
  if(output_token.length***REMOVED*** {
    state->response = base64_encode((const unsigned char ****REMOVED***output_token.value, output_token.length***REMOVED***;
    maj_stat = gss_release_buffer(&min_stat, &output_token***REMOVED***;
***REMOVED***
end:
  if(output_token.value***REMOVED***
    gss_release_buffer(&min_stat, &output_token***REMOVED***;
  if(input_token.value***REMOVED***
    free(input_token.value***REMOVED***;

  if(response == NULL***REMOVED*** {
    response = calloc(1, sizeof(gss_client_response***REMOVED******REMOVED***;
    response->return_code = ret;
***REMOVED***

  // Return the response
  return response;
}

gss_client_response *authenticate_gss_client_wrap(gss_client_state* state, const char* challenge, const char* user***REMOVED*** {
  OM_uint32 maj_stat;
  OM_uint32 min_stat;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret = AUTH_GSS_CONTINUE;
  gss_client_response *response = NULL;
  char buf[4096], server_conf_flags;
  unsigned long buf_size;
    
  // Always clear out the old response
  if(state->response != NULL***REMOVED*** {
    free(state->response***REMOVED***;
    state->response = NULL;
***REMOVED***
    
  if(challenge && *challenge***REMOVED*** {
    int len;
    input_token.value = base64_decode(challenge, &len***REMOVED***;
    input_token.length = len;
***REMOVED***
    
  if(user***REMOVED*** {
    // get bufsize
    server_conf_flags = ((char****REMOVED*** input_token.value***REMOVED***[0];
    ((char****REMOVED*** input_token.value***REMOVED***[0] = 0;
    buf_size = ntohl(*((long ****REMOVED*** input_token.value***REMOVED******REMOVED***;
    free(input_token.value***REMOVED***;
#ifdef PRINTFS
    printf("User: %s, %c%c%c\n", user,
               server_conf_flags & GSS_AUTH_P_NONE      ? 'N' : '-',
               server_conf_flags & GSS_AUTH_P_INTEGRITY ? 'I' : '-',
               server_conf_flags & GSS_AUTH_P_PRIVACY   ? 'P' : '-'***REMOVED***;
    printf("Maximum GSS token size is %ld\n", buf_size***REMOVED***;
#endif
        
    // agree to terms (hack!***REMOVED***
    buf_size = htonl(buf_size***REMOVED***; // not relevant without integrity/privacy
    memcpy(buf, &buf_size, 4***REMOVED***;
    buf[0] = GSS_AUTH_P_NONE;
    // server decides if principal can log in as user
    strncpy(buf + 4, user, sizeof(buf***REMOVED*** - 4***REMOVED***;
    input_token.value = buf;
    input_token.length = 4 + strlen(user***REMOVED***;
***REMOVED***
    
  // Do GSSAPI wrap
  maj_stat = gss_wrap(&min_stat,
            state->context,
            0,
            GSS_C_QOP_DEFAULT,
            &input_token,
            NULL,
            &output_token***REMOVED***;
    
  if (maj_stat != GSS_S_COMPLETE***REMOVED*** {
    response = gss_error(maj_stat, min_stat***REMOVED***;
    response->return_code = AUTH_GSS_ERROR;
    goto end;
***REMOVED*** else
    ret = AUTH_GSS_COMPLETE;
  // Grab the client response to send back to the server
  if (output_token.length***REMOVED*** {
    state->response = base64_encode((const unsigned char ****REMOVED***output_token.value, output_token.length***REMOVED***;;
    maj_stat = gss_release_buffer(&min_stat, &output_token***REMOVED***;
***REMOVED***
end:
  if (output_token.value***REMOVED***
    gss_release_buffer(&min_stat, &output_token***REMOVED***;

  if(response == NULL***REMOVED*** {
    response = calloc(1, sizeof(gss_client_response***REMOVED******REMOVED***;
    response->return_code = ret;
***REMOVED***

  // Return the response
  return response;
}

int authenticate_gss_server_init(const char *service, gss_server_state *state***REMOVED***
{
    OM_uint32 maj_stat;
    OM_uint32 min_stat;
    gss_buffer_desc name_token = GSS_C_EMPTY_BUFFER;
    int ret = AUTH_GSS_COMPLETE;
    
    state->context = GSS_C_NO_CONTEXT;
    state->server_name = GSS_C_NO_NAME;
    state->client_name = GSS_C_NO_NAME;
    state->server_creds = GSS_C_NO_CREDENTIAL;
    state->client_creds = GSS_C_NO_CREDENTIAL;
    state->username = NULL;
    state->targetname = NULL;
    state->response = NULL;
    
    // Server name may be empty which means we aren't going to create our own creds
    size_t service_len = strlen(service***REMOVED***;
    if (service_len != 0***REMOVED***
    {
        // Import server name first
        name_token.length = strlen(service***REMOVED***;
        name_token.value = (char ****REMOVED***service;
        
        maj_stat = gss_import_name(&min_stat, &name_token, GSS_C_NT_HOSTBASED_SERVICE, &state->server_name***REMOVED***;
        
        if (GSS_ERROR(maj_stat***REMOVED******REMOVED***
        {
            set_gss_error(maj_stat, min_stat***REMOVED***;
            ret = AUTH_GSS_ERROR;
            goto end;
      ***REMOVED***
        
        // Get credentials
        maj_stat = gss_acquire_cred(&min_stat, state->server_name, GSS_C_INDEFINITE,
                                    GSS_C_NO_OID_SET, GSS_C_ACCEPT, &state->server_creds, NULL, NULL***REMOVED***;
        
        if (GSS_ERROR(maj_stat***REMOVED******REMOVED***
        {
            set_gss_error(maj_stat, min_stat***REMOVED***;
            ret = AUTH_GSS_ERROR;
            goto end;
      ***REMOVED***
  ***REMOVED***
    
end:
    return ret;
}

int authenticate_gss_server_clean(gss_server_state *state***REMOVED***
{
    OM_uint32 min_stat;
    int ret = AUTH_GSS_COMPLETE;
    
    if (state->context != GSS_C_NO_CONTEXT***REMOVED***
        gss_delete_sec_context(&min_stat, &state->context, GSS_C_NO_BUFFER***REMOVED***;
    if (state->server_name != GSS_C_NO_NAME***REMOVED***
        gss_release_name(&min_stat, &state->server_name***REMOVED***;
    if (state->client_name != GSS_C_NO_NAME***REMOVED***
        gss_release_name(&min_stat, &state->client_name***REMOVED***;
    if (state->server_creds != GSS_C_NO_CREDENTIAL***REMOVED***
        gss_release_cred(&min_stat, &state->server_creds***REMOVED***;
    if (state->client_creds != GSS_C_NO_CREDENTIAL***REMOVED***
        gss_release_cred(&min_stat, &state->client_creds***REMOVED***;
    if (state->username != NULL***REMOVED***
    {
        free(state->username***REMOVED***;
        state->username = NULL;
  ***REMOVED***
    if (state->targetname != NULL***REMOVED***
    {
        free(state->targetname***REMOVED***;
        state->targetname = NULL;
  ***REMOVED***
    if (state->response != NULL***REMOVED***
    {
        free(state->response***REMOVED***;
        state->response = NULL;
  ***REMOVED***
    
    return ret;
}

/*int authenticate_gss_server_step(gss_server_state *state, const char *challenge***REMOVED***
{
    OM_uint32 maj_stat;
    OM_uint32 min_stat;
    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
    int ret = AUTH_GSS_CONTINUE;
    
    // Always clear out the old response
    if (state->response != NULL***REMOVED***
    {
        free(state->response***REMOVED***;
        state->response = NULL;
  ***REMOVED***
    
    // If there is a challenge (data from the server***REMOVED*** we need to give it to GSS
    if (challenge && *challenge***REMOVED***
    {
        int len;
        input_token.value = base64_decode(challenge, &len***REMOVED***;
        input_token.length = len;
  ***REMOVED***
    else
    {
        PyErr_SetString(KrbException_class, "No challenge parameter in request from client"***REMOVED***;
        ret = AUTH_GSS_ERROR;
        goto end;
  ***REMOVED***
    
    maj_stat = gss_accept_sec_context(&min_stat,
                                      &state->context,
                                      state->server_creds,
                                      &input_token,
                                      GSS_C_NO_CHANNEL_BINDINGS,
                                      &state->client_name,
                                      NULL,
                                      &output_token,
                                      NULL,
                                      NULL,
                                      &state->client_creds***REMOVED***;
    
    if (GSS_ERROR(maj_stat***REMOVED******REMOVED***
    {
        set_gss_error(maj_stat, min_stat***REMOVED***;
        ret = AUTH_GSS_ERROR;
        goto end;
  ***REMOVED***
    
    // Grab the server response to send back to the client
    if (output_token.length***REMOVED***
    {
        state->response = base64_encode((const unsigned char ****REMOVED***output_token.value, output_token.length***REMOVED***;;
        maj_stat = gss_release_buffer(&min_stat, &output_token***REMOVED***;
  ***REMOVED***
    
    // Get the user name
    maj_stat = gss_display_name(&min_stat, state->client_name, &output_token, NULL***REMOVED***;
    if (GSS_ERROR(maj_stat***REMOVED******REMOVED***
    {
        set_gss_error(maj_stat, min_stat***REMOVED***;
        ret = AUTH_GSS_ERROR;
        goto end;
  ***REMOVED***
    state->username = (char ****REMOVED***malloc(output_token.length + 1***REMOVED***;
    strncpy(state->username, (char****REMOVED*** output_token.value, output_token.length***REMOVED***;
    state->username[output_token.length] = 0;
    
    // Get the target name if no server creds were supplied
    if (state->server_creds == GSS_C_NO_CREDENTIAL***REMOVED***
    {
        gss_name_t target_name = GSS_C_NO_NAME;
        maj_stat = gss_inquire_context(&min_stat, state->context, NULL, &target_name, NULL, NULL, NULL, NULL, NULL***REMOVED***;
        if (GSS_ERROR(maj_stat***REMOVED******REMOVED***
        {
            set_gss_error(maj_stat, min_stat***REMOVED***;
            ret = AUTH_GSS_ERROR;
            goto end;
      ***REMOVED***
        maj_stat = gss_display_name(&min_stat, target_name, &output_token, NULL***REMOVED***;
        if (GSS_ERROR(maj_stat***REMOVED******REMOVED***
        {
            set_gss_error(maj_stat, min_stat***REMOVED***;
            ret = AUTH_GSS_ERROR;
            goto end;
      ***REMOVED***
        state->targetname = (char ****REMOVED***malloc(output_token.length + 1***REMOVED***;
        strncpy(state->targetname, (char****REMOVED*** output_token.value, output_token.length***REMOVED***;
        state->targetname[output_token.length] = 0;
  ***REMOVED***

    ret = AUTH_GSS_COMPLETE;
    
end:
    if (output_token.length***REMOVED***
        gss_release_buffer(&min_stat, &output_token***REMOVED***;
    if (input_token.value***REMOVED***
        free(input_token.value***REMOVED***;
    return ret;
}
*/

static void set_gss_error(OM_uint32 err_maj, OM_uint32 err_min***REMOVED*** {
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf_maj[512];
  char buf_min[512];
  
  do {
    maj_stat = gss_display_status (&min_stat,
                                   err_maj,
                                   GSS_C_GSS_CODE,
                                   GSS_C_NO_OID,
                                   &msg_ctx,
                                   &status_string***REMOVED***;
    if(GSS_ERROR(maj_stat***REMOVED******REMOVED***
      break;
    
    strncpy(buf_maj, (char****REMOVED*** status_string.value, sizeof(buf_maj***REMOVED******REMOVED***;
    gss_release_buffer(&min_stat, &status_string***REMOVED***;
    
    maj_stat = gss_display_status (&min_stat,
                                   err_min,
                                   GSS_C_MECH_CODE,
                                   GSS_C_NULL_OID,
                                   &msg_ctx,
                                   &status_string***REMOVED***;
    if (!GSS_ERROR(maj_stat***REMOVED******REMOVED*** {

      strncpy(buf_min, (char****REMOVED*** status_string.value , sizeof(buf_min***REMOVED******REMOVED***;
      gss_release_buffer(&min_stat, &status_string***REMOVED***;
  ***REMOVED***
***REMOVED*** while (!GSS_ERROR(maj_stat***REMOVED*** && msg_ctx != 0***REMOVED***;
}

gss_client_response *gss_error(OM_uint32 err_maj, OM_uint32 err_min***REMOVED*** {
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char *buf_maj = calloc(512, sizeof(char***REMOVED******REMOVED***;
  char *buf_min = calloc(512, sizeof(char***REMOVED******REMOVED***;
  char *message = NULL;
  gss_client_response *response = calloc(1, sizeof(gss_client_response***REMOVED******REMOVED***;
  
  do {
    maj_stat = gss_display_status (&min_stat,
                                   err_maj,
                                   GSS_C_GSS_CODE,
                                   GSS_C_NO_OID,
                                   &msg_ctx,
                                   &status_string***REMOVED***;
    if(GSS_ERROR(maj_stat***REMOVED******REMOVED***
      break;
    
    strncpy(buf_maj, (char****REMOVED*** status_string.value, 512***REMOVED***;
    gss_release_buffer(&min_stat, &status_string***REMOVED***;
    
    maj_stat = gss_display_status (&min_stat,
                                   err_min,
                                   GSS_C_MECH_CODE,
                                   GSS_C_NULL_OID,
                                   &msg_ctx,
                                   &status_string***REMOVED***;
    if(!GSS_ERROR(maj_stat***REMOVED******REMOVED*** {
      strncpy(buf_min, (char****REMOVED*** status_string.value , 512***REMOVED***;
      gss_release_buffer(&min_stat, &status_string***REMOVED***;
  ***REMOVED***
***REMOVED*** while (!GSS_ERROR(maj_stat***REMOVED*** && msg_ctx != 0***REMOVED***;

  // Join the strings
  message = calloc(1026, 1***REMOVED***;
  // Join the two messages
  sprintf(message, "%s, %s", buf_maj, buf_min***REMOVED***;
  // Free data
  free(buf_min***REMOVED***;
  free(buf_maj***REMOVED***;
  // Set the message
  response->message = message;
  // Return the message
  return response;
}
