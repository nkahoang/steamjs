//===========================================================================

#ifndef BSON_H_
#define BSON_H_

//===========================================================================

#ifdef __arm__
#define USE_MISALIGNED_MEMORY_ACCESS 0
#else
#define USE_MISALIGNED_MEMORY_ACCESS 1
#endif

#include <node.h>
#include <node_object_wrap.h>
#include <v8.h>
#include "nan.h"

using namespace v8;
using namespace node;

//===========================================================================

enum BsonType
{
	BSON_TYPE_NUMBER		= 1,
	BSON_TYPE_STRING		= 2,
	BSON_TYPE_OBJECT		= 3,
	BSON_TYPE_ARRAY			= 4,
	BSON_TYPE_BINARY		= 5,
	BSON_TYPE_UNDEFINED		= 6,
	BSON_TYPE_OID			= 7,
	BSON_TYPE_BOOLEAN		= 8,
	BSON_TYPE_DATE			= 9,
	BSON_TYPE_NULL			= 10,
	BSON_TYPE_REGEXP		= 11,
	BSON_TYPE_CODE			= 13,
	BSON_TYPE_SYMBOL		= 14,
	BSON_TYPE_CODE_W_SCOPE	= 15,
	BSON_TYPE_INT			= 16,
	BSON_TYPE_TIMESTAMP		= 17,
	BSON_TYPE_LONG			= 18,
	BSON_TYPE_MAX_KEY		= 0x7f,
	BSON_TYPE_MIN_KEY		= 0xff
};

//===========================================================================

template<typename T> class BSONSerializer;

class BSON : public ObjectWrap {
public:
	BSON(***REMOVED***;
	~BSON(***REMOVED*** {}

	static void Initialize(Handle<Object> target***REMOVED***;
        static NAN_METHOD(BSONDeserializeStream***REMOVED***;

	// JS based objects
	static NAN_METHOD(BSONSerialize***REMOVED***;
	static NAN_METHOD(BSONDeserialize***REMOVED***;

        // Calculate size of function
	static NAN_METHOD(CalculateObjectSize***REMOVED***;
	static NAN_METHOD(SerializeWithBufferAndIndex***REMOVED***;

	// Constructor used for creating new BSON objects from C++
	static Persistent<FunctionTemplate> constructor_template;

private:
	static NAN_METHOD(New***REMOVED***;
	static Handle<Value> deserialize(BSON *bson, char *data, uint32_t dataLength, uint32_t startIndex, bool is_array_item***REMOVED***;

	// BSON type instantiate functions
	Persistent<Function> longConstructor;
	Persistent<Function> objectIDConstructor;
	Persistent<Function> binaryConstructor;
	Persistent<Function> codeConstructor;
	Persistent<Function> dbrefConstructor;
	Persistent<Function> symbolConstructor;
	Persistent<Function> doubleConstructor;
	Persistent<Function> timestampConstructor;
	Persistent<Function> minKeyConstructor;
	Persistent<Function> maxKeyConstructor;

	// Equality Objects
	Persistent<String> longString;
	Persistent<String> objectIDString;
	Persistent<String> binaryString;
	Persistent<String> codeString;
	Persistent<String> dbrefString;
	Persistent<String> symbolString;
	Persistent<String> doubleString;
	Persistent<String> timestampString;
	Persistent<String> minKeyString;
	Persistent<String> maxKeyString;

	// Equality speed up comparison objects
	Persistent<String> _bsontypeString;
	Persistent<String> _longLowString;
	Persistent<String> _longHighString;
	Persistent<String> _objectIDidString;
	Persistent<String> _binaryPositionString;
	Persistent<String> _binarySubTypeString;
	Persistent<String> _binaryBufferString;
	Persistent<String> _doubleValueString;
	Persistent<String> _symbolValueString;

	Persistent<String> _dbRefRefString;
	Persistent<String> _dbRefIdRefString;
	Persistent<String> _dbRefDbRefString;
	Persistent<String> _dbRefNamespaceString;
	Persistent<String> _dbRefDbString;
	Persistent<String> _dbRefOidString;

	Persistent<String> _codeCodeString;
	Persistent<String> _codeScopeString;
	Persistent<String> _toBSONString;

	Local<Object> GetSerializeObject(const Handle<Value>& object***REMOVED***;

	template<typename T> friend class BSONSerializer;
	friend class BSONDeserializer;
};

//===========================================================================

class CountStream
{
public:
	CountStream(***REMOVED*** : count(0***REMOVED*** { }

	void	WriteByte(int value***REMOVED***									{ ++count; }
	void	WriteByte(const Handle<Object>&, const Handle<String>&***REMOVED***	{ ++count; }
	void	WriteBool(const Handle<Value>& value***REMOVED***					{ ++count; }
	void	WriteInt32(int32_t value***REMOVED***								{ count += 4; }
	void	WriteInt32(const Handle<Value>& value***REMOVED***					{ count += 4; }
	void	WriteInt32(const Handle<Object>& object, const Handle<String>& key***REMOVED*** { count += 4; }
	void	WriteInt64(int64_t value***REMOVED***								{ count += 8; }
	void	WriteInt64(const Handle<Value>& value***REMOVED***					{ count += 8; }
	void	WriteDouble(double value***REMOVED***								{ count += 8; }
	void	WriteDouble(const Handle<Value>& value***REMOVED***					{ count += 8; }
	void	WriteDouble(const Handle<Object>&, const Handle<String>&***REMOVED*** { count += 8; }
	void	WriteUInt32String(uint32_t name***REMOVED***						{ char buffer[32]; count += sprintf(buffer, "%u", name***REMOVED*** + 1; }
	void	WriteLengthPrefixedString(const Local<String>& value***REMOVED***	{ count += value->Utf8Length(***REMOVED***+5; }
	void	WriteObjectId(const Handle<Object>& object, const Handle<String>& key***REMOVED***				{ count += 12; }
	void	WriteString(const Local<String>& value***REMOVED***					{ count += value->Utf8Length(***REMOVED*** + 1; }	// This returns the number of bytes exclusive of the NULL terminator
	void	WriteData(const char* data, size_t length***REMOVED***				{ count += length; }

	void*	BeginWriteType(***REMOVED***										{ ++count; return NULL; }
	void	CommitType(void*, BsonType***REMOVED***								{ }
	void*	BeginWriteSize(***REMOVED***										{ count += 4; return NULL; }
	void	CommitSize(void****REMOVED***										{ }

	size_t GetSerializeSize(***REMOVED*** const									{ return count; }

	// Do nothing. CheckKey is implemented for DataStream
	void	CheckKey(const Local<String>&***REMOVED***							{ }

private:
	size_t	count;
};

class DataStream
{
public:
	DataStream(char* aDestinationBuffer***REMOVED*** : destinationBuffer(aDestinationBuffer***REMOVED***, p(aDestinationBuffer***REMOVED*** { }

	void	WriteByte(int value***REMOVED***									{ *p++ = value; }
	void	WriteByte(const Handle<Object>& object, const Handle<String>& key***REMOVED***	{ *p++ = object->Get(key***REMOVED***->Int32Value(***REMOVED***; }
#if USE_MISALIGNED_MEMORY_ACCESS
	void	WriteInt32(int32_t value***REMOVED***								{ *reinterpret_cast<int32_t*>(p***REMOVED*** = value; p += 4; }
	void	WriteInt64(int64_t value***REMOVED***								{ *reinterpret_cast<int64_t*>(p***REMOVED*** = value; p += 8; }
	void	WriteDouble(double value***REMOVED***								{ *reinterpret_cast<double*>(p***REMOVED*** = value; p += 8; }
#else
	void	WriteInt32(int32_t value***REMOVED***								{ memcpy(p, &value, 4***REMOVED***; p += 4; }
	void	WriteInt64(int64_t value***REMOVED***								{ memcpy(p, &value, 8***REMOVED***; p += 8; }
	void	WriteDouble(double value***REMOVED***								{ memcpy(p, &value, 8***REMOVED***; p += 8; }
#endif
	void	WriteBool(const Handle<Value>& value***REMOVED***					{ WriteByte(value->BooleanValue(***REMOVED*** ? 1 : 0***REMOVED***; }
	void	WriteInt32(const Handle<Value>& value***REMOVED***					{ WriteInt32(value->Int32Value(***REMOVED******REMOVED***;			}
	void	WriteInt32(const Handle<Object>& object, const Handle<String>& key***REMOVED*** { WriteInt32(object->Get(key***REMOVED******REMOVED***; }
	void	WriteInt64(const Handle<Value>& value***REMOVED***					{ WriteInt64(value->IntegerValue(***REMOVED******REMOVED***;		}
	void	WriteDouble(const Handle<Value>& value***REMOVED***					{ WriteDouble(value->NumberValue(***REMOVED******REMOVED***;		}
	void	WriteDouble(const Handle<Object>& object, const Handle<String>& key***REMOVED*** { WriteDouble(object->Get(key***REMOVED******REMOVED***; }
	void	WriteUInt32String(uint32_t name***REMOVED***						{ p += sprintf(p, "%u", name***REMOVED*** + 1;			}
	void	WriteLengthPrefixedString(const Local<String>& value***REMOVED***	{ WriteInt32(value->Utf8Length(***REMOVED***+1***REMOVED***; WriteString(value***REMOVED***; }
	void	WriteObjectId(const Handle<Object>& object, const Handle<String>& key***REMOVED***;
	void	WriteString(const Local<String>& value***REMOVED***					{ p += value->WriteUtf8(p***REMOVED***; }		// This returns the number of bytes inclusive of the NULL terminator.
	void	WriteData(const char* data, size_t length***REMOVED***				{ memcpy(p, data, length***REMOVED***; p += length; }

	void*	BeginWriteType(***REMOVED***										{ void* returnValue = p; p++; return returnValue; }
	void	CommitType(void* beginPoint, BsonType value***REMOVED***			{ *reinterpret_cast<unsigned char*>(beginPoint***REMOVED*** = value; }
	void*	BeginWriteSize(***REMOVED***										{ void* returnValue = p; p += 4; return returnValue; }

#if USE_MISALIGNED_MEMORY_ACCESS
	void	CommitSize(void* beginPoint***REMOVED***							{ *reinterpret_cast<int32_t*>(beginPoint***REMOVED*** = (int32_t***REMOVED*** (p - (char****REMOVED*** beginPoint***REMOVED***; }
#else
	void	CommitSize(void* beginPoint***REMOVED***							{ int32_t value = (int32_t***REMOVED*** (p - (char****REMOVED*** beginPoint***REMOVED***; memcpy(beginPoint, &value, 4***REMOVED***; }
#endif

	size_t GetSerializeSize(***REMOVED*** const									{ return p - destinationBuffer; }

	void	CheckKey(const Local<String>& keyName***REMOVED***;

protected:
	char *const	destinationBuffer;		// base, never changes
	char*		p;						// cursor into buffer
};

template<typename T> class BSONSerializer : public T
{
private:
	typedef T Inherited;

public:
	BSONSerializer(BSON* aBson, bool aCheckKeys, bool aSerializeFunctions***REMOVED*** : Inherited(***REMOVED***, checkKeys(aCheckKeys***REMOVED***, serializeFunctions(aSerializeFunctions***REMOVED***, bson(aBson***REMOVED*** { }
	BSONSerializer(BSON* aBson, bool aCheckKeys, bool aSerializeFunctions, char* parentParam***REMOVED*** : Inherited(parentParam***REMOVED***, checkKeys(aCheckKeys***REMOVED***, serializeFunctions(aSerializeFunctions***REMOVED***, bson(aBson***REMOVED*** { }

	void SerializeDocument(const Handle<Value>& value***REMOVED***;
	void SerializeArray(const Handle<Value>& value***REMOVED***;
	void SerializeValue(void* typeLocation, const Handle<Value>& value***REMOVED***;

private:
	bool		checkKeys;
	bool		serializeFunctions;
	BSON*		bson;
};

//===========================================================================

class BSONDeserializer
{
public:
	BSONDeserializer(BSON* aBson, char* data, size_t length***REMOVED***;
	BSONDeserializer(BSONDeserializer& parentSerializer, size_t length***REMOVED***;

	Handle<Value> DeserializeDocument(bool promoteLongs***REMOVED***;

	bool			HasMoreData(***REMOVED*** const { return p < pEnd; }
	Handle<Value>	ReadCString(***REMOVED***;
	uint32_t		ReadIntegerString(***REMOVED***;
	int32_t			ReadRegexOptions(***REMOVED***;
	Local<String>	ReadString(***REMOVED***;
	Local<String>	ReadObjectId(***REMOVED***;

	unsigned char	ReadByte(***REMOVED***			{ return *reinterpret_cast<unsigned char*>(p++***REMOVED***; }
#if USE_MISALIGNED_MEMORY_ACCESS
	int32_t			ReadInt32(***REMOVED***			{ int32_t returnValue = *reinterpret_cast<int32_t*>(p***REMOVED***; p += 4; return returnValue; }
	uint32_t		ReadUInt32(***REMOVED***		{ uint32_t returnValue = *reinterpret_cast<uint32_t*>(p***REMOVED***; p += 4; return returnValue; }
	int64_t			ReadInt64(***REMOVED***			{ int64_t returnValue = *reinterpret_cast<int64_t*>(p***REMOVED***; p += 8; return returnValue; }
	double			ReadDouble(***REMOVED***		{ double returnValue = *reinterpret_cast<double*>(p***REMOVED***; p += 8; return returnValue; }
#else
	int32_t			ReadInt32(***REMOVED***			{ int32_t returnValue; memcpy(&returnValue, p, 4***REMOVED***; p += 4; return returnValue; }
	uint32_t		ReadUInt32(***REMOVED***		{ uint32_t returnValue; memcpy(&returnValue, p, 4***REMOVED***; p += 4; return returnValue; }
	int64_t			ReadInt64(***REMOVED***			{ int64_t returnValue; memcpy(&returnValue, p, 8***REMOVED***; p += 8; return returnValue; }
	double			ReadDouble(***REMOVED***		{ double returnValue; memcpy(&returnValue, p, 8***REMOVED***; p += 8; return returnValue; }
#endif

	size_t			GetSerializeSize(***REMOVED*** const { return p - pStart; }

private:
	Handle<Value> DeserializeArray(bool promoteLongs***REMOVED***;
	Handle<Value> DeserializeValue(BsonType type, bool promoteLongs***REMOVED***;
	Handle<Value> DeserializeDocumentInternal(bool promoteLongs***REMOVED***;
	Handle<Value> DeserializeArrayInternal(bool promoteLongs***REMOVED***;

	BSON*		bson;
	char* const pStart;
	char*		p;
	char* const	pEnd;
};

//===========================================================================

#endif  // BSON_H_

//===========================================================================
