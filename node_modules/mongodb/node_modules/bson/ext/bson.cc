//===========================================================================

#include <stdarg.h>
#include <cstdlib>
#include <cstring>
#include <string.h>
#include <stdlib.h>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif

#include <v8.h>

// this and the above block must be around the v8.h header otherwise
// v8 is not happy
#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include <node.h>
#include <node_version.h>
#include <node_buffer.h>

#include <cmath>
#include <iostream>
#include <limits>
#include <vector>

#ifdef __sun
	#include <alloca.h>
#endif

#include "bson.h"

using namespace v8;
using namespace node;

//===========================================================================

void DataStream::WriteObjectId(const Handle<Object>& object, const Handle<String>& key***REMOVED***
{
	uint16_t buffer[12];
	object->Get(key***REMOVED***->ToString(***REMOVED***->Write(buffer, 0, 12***REMOVED***;
	for(uint32_t i = 0; i < 12; ++i***REMOVED***
	{
		*p++ = (char***REMOVED*** buffer[i];
	}
}

void ThrowAllocatedStringException(size_t allocationSize, const char* format, ...***REMOVED***
{
	va_list args;
	va_start(args, format***REMOVED***;
	char* string = (char****REMOVED*** malloc(allocationSize***REMOVED***;
	vsprintf(string, format, args***REMOVED***;
	va_end(args***REMOVED***;

	throw string;
}

void DataStream::CheckKey(const Local<String>& keyName***REMOVED***
{
	size_t keyLength = keyName->Utf8Length(***REMOVED***;
	if(keyLength == 0***REMOVED*** return;

	// Allocate space for the key, do not need to zero terminate as WriteUtf8 does it
	char* keyStringBuffer = (char****REMOVED*** alloca(keyLength + 1***REMOVED***;
	// Write the key to the allocated buffer
	keyName->WriteUtf8(keyStringBuffer***REMOVED***;
	// Check for the zero terminator
	char* terminator = strchr(keyStringBuffer, 0x00***REMOVED***;

	// If the location is not at the end of the string we've got an illegal 0x00 byte somewhere
	if(terminator != &keyStringBuffer[keyLength]***REMOVED*** {
		ThrowAllocatedStringException(64+keyLength, "key %s must not contain null bytes", keyStringBuffer***REMOVED***;
	}

	if(keyStringBuffer[0] == '$'***REMOVED***
	{
		ThrowAllocatedStringException(64+keyLength, "key %s must not start with '$'", keyStringBuffer***REMOVED***;
	}

	if(strchr(keyStringBuffer, '.'***REMOVED*** != NULL***REMOVED***
	{
		ThrowAllocatedStringException(64+keyLength, "key %s must not contain '.'", keyStringBuffer***REMOVED***;
	}
}

template<typename T> void BSONSerializer<T>::SerializeDocument(const Handle<Value>& value***REMOVED***
{
	void* documentSize = this->BeginWriteSize(***REMOVED***;
	Local<Object> object = bson->GetSerializeObject(value***REMOVED***;

	// Get the object property names
  Local<Array> propertyNames = object->GetPropertyNames(***REMOVED***;

	// Length of the property
	int propertyLength = propertyNames->Length(***REMOVED***;
	for(int i = 0;  i < propertyLength; ++i***REMOVED***
	{
		const Local<String>& propertyName = propertyNames->Get(i***REMOVED***->ToString(***REMOVED***;
		if(checkKeys***REMOVED*** this->CheckKey(propertyName***REMOVED***;

		const Local<Value>& propertyValue = object->Get(propertyName***REMOVED***;

		if(serializeFunctions || !propertyValue->IsFunction(***REMOVED******REMOVED***
		{
			void* typeLocation = this->BeginWriteType(***REMOVED***;
			this->WriteString(propertyName***REMOVED***;
			SerializeValue(typeLocation, propertyValue***REMOVED***;
		}
	}

	this->WriteByte(0***REMOVED***;
	this->CommitSize(documentSize***REMOVED***;
}

template<typename T> void BSONSerializer<T>::SerializeArray(const Handle<Value>& value***REMOVED***
{
	void* documentSize = this->BeginWriteSize(***REMOVED***;

	Local<Array> array = Local<Array>::Cast(value->ToObject(***REMOVED******REMOVED***;
	uint32_t arrayLength = array->Length(***REMOVED***;

	for(uint32_t i = 0;  i < arrayLength; ++i***REMOVED***
	{
		void* typeLocation = this->BeginWriteType(***REMOVED***;
		this->WriteUInt32String(i***REMOVED***;
		SerializeValue(typeLocation, array->Get(i***REMOVED******REMOVED***;
	}

	this->WriteByte(0***REMOVED***;
	this->CommitSize(documentSize***REMOVED***;
}

// This is templated so that we can use this function to both count the number of bytes, and to serialize those bytes.
// The template approach eliminates almost all of the inspection of values unless they're required (eg. string lengths***REMOVED***
// and ensures that there is always consistency between bytes counted and bytes written by design.
template<typename T> void BSONSerializer<T>::SerializeValue(void* typeLocation, const Handle<Value>& value***REMOVED***
{
	if(value->IsNumber(***REMOVED******REMOVED***
	{
		double doubleValue = value->NumberValue(***REMOVED***;
		int intValue = (int***REMOVED*** doubleValue;
		if(intValue == doubleValue***REMOVED***
		{
			this->CommitType(typeLocation, BSON_TYPE_INT***REMOVED***;
			this->WriteInt32(intValue***REMOVED***;
		}
		else
		{
			this->CommitType(typeLocation, BSON_TYPE_NUMBER***REMOVED***;
			this->WriteDouble(doubleValue***REMOVED***;
		}
	}
	else if(value->IsString(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_STRING***REMOVED***;
		this->WriteLengthPrefixedString(value->ToString(***REMOVED******REMOVED***;
	}
	else if(value->IsBoolean(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_BOOLEAN***REMOVED***;
		this->WriteBool(value***REMOVED***;
	}
	else if(value->IsArray(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_ARRAY***REMOVED***;
		SerializeArray(value***REMOVED***;
	}
	else if(value->IsDate(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_DATE***REMOVED***;
		this->WriteInt64(value***REMOVED***;
	}
	else if(value->IsRegExp(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_REGEXP***REMOVED***;
		const Handle<RegExp>& regExp = Handle<RegExp>::Cast(value***REMOVED***;

		this->WriteString(regExp->GetSource(***REMOVED******REMOVED***;

		int flags = regExp->GetFlags(***REMOVED***;
		if(flags & RegExp::kGlobal***REMOVED*** this->WriteByte('s'***REMOVED***;
		if(flags & RegExp::kIgnoreCase***REMOVED*** this->WriteByte('i'***REMOVED***;
		if(flags & RegExp::kMultiline***REMOVED*** this->WriteByte('m'***REMOVED***;
		this->WriteByte(0***REMOVED***;
	}
	else if(value->IsFunction(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_CODE***REMOVED***;
		this->WriteLengthPrefixedString(value->ToString(***REMOVED******REMOVED***;
	}
	else if(value->IsObject(***REMOVED******REMOVED***
	{
		const Local<Object>& object = value->ToObject(***REMOVED***;
		if(object->Has(NanPersistentToLocal(bson->_bsontypeString***REMOVED******REMOVED******REMOVED***
		{
			const Local<String>& constructorString = object->GetConstructorName(***REMOVED***;
			if(NanPersistentToLocal(bson->longString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_LONG***REMOVED***;
				this->WriteInt32(object, NanPersistentToLocal(bson->_longLowString***REMOVED******REMOVED***;
				this->WriteInt32(object, NanPersistentToLocal(bson->_longHighString***REMOVED******REMOVED***;
			}
			else if(NanPersistentToLocal(bson->timestampString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_TIMESTAMP***REMOVED***;
				this->WriteInt32(object, NanPersistentToLocal(bson->_longLowString***REMOVED******REMOVED***;
				this->WriteInt32(object, NanPersistentToLocal(bson->_longHighString***REMOVED******REMOVED***;
			}
			else if(NanPersistentToLocal(bson->objectIDString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_OID***REMOVED***;
				this->WriteObjectId(object, NanPersistentToLocal(bson->_objectIDidString***REMOVED******REMOVED***;
			}
			else if(NanPersistentToLocal(bson->binaryString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_BINARY***REMOVED***;

				uint32_t length = object->Get(NanPersistentToLocal(bson->_binaryPositionString***REMOVED******REMOVED***->Uint32Value(***REMOVED***;
				Local<Object> bufferObj = object->Get(NanPersistentToLocal(bson->_binaryBufferString***REMOVED******REMOVED***->ToObject(***REMOVED***;

				this->WriteInt32(length***REMOVED***;
				this->WriteByte(object, NanPersistentToLocal(bson->_binarySubTypeString***REMOVED******REMOVED***;	// write subtype
				// If type 0x02 write the array length aswell
				if(object->Get(NanPersistentToLocal(bson->_binarySubTypeString***REMOVED******REMOVED***->Int32Value(***REMOVED*** == 0x02***REMOVED*** {
					this->WriteInt32(length***REMOVED***;
				}
				// Write the actual data
				this->WriteData(Buffer::Data(bufferObj***REMOVED***, length***REMOVED***;
			}
			else if(NanPersistentToLocal(bson->doubleString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_NUMBER***REMOVED***;
				this->WriteDouble(object, NanPersistentToLocal(bson->_doubleValueString***REMOVED******REMOVED***;
			}
			else if(NanPersistentToLocal(bson->symbolString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_SYMBOL***REMOVED***;
				this->WriteLengthPrefixedString(object->Get(NanPersistentToLocal(bson->_symbolValueString***REMOVED******REMOVED***->ToString(***REMOVED******REMOVED***;
			}
			else if(NanPersistentToLocal(bson->codeString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				const Local<String>& function = object->Get(NanPersistentToLocal(bson->_codeCodeString***REMOVED******REMOVED***->ToString(***REMOVED***;
				const Local<Object>& scope = object->Get(NanPersistentToLocal(bson->_codeScopeString***REMOVED******REMOVED***->ToObject(***REMOVED***;

				// For Node < 0.6.X use the GetPropertyNames
	      #if NODE_MAJOR_VERSION == 0 && NODE_MINOR_VERSION < 6
	        uint32_t propertyNameLength = scope->GetPropertyNames(***REMOVED***->Length(***REMOVED***;
	      #else
	        uint32_t propertyNameLength = scope->GetOwnPropertyNames(***REMOVED***->Length(***REMOVED***;
	      #endif

				if(propertyNameLength > 0***REMOVED***
				{
					this->CommitType(typeLocation, BSON_TYPE_CODE_W_SCOPE***REMOVED***;
					void* codeWidthScopeSize = this->BeginWriteSize(***REMOVED***;
					this->WriteLengthPrefixedString(function->ToString(***REMOVED******REMOVED***;
					SerializeDocument(scope***REMOVED***;
					this->CommitSize(codeWidthScopeSize***REMOVED***;
				}
				else
				{
					this->CommitType(typeLocation, BSON_TYPE_CODE***REMOVED***;
					this->WriteLengthPrefixedString(function->ToString(***REMOVED******REMOVED***;
				}
			}
			else if(NanPersistentToLocal(bson->dbrefString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_OBJECT***REMOVED***;

				void* dbRefSize = this->BeginWriteSize(***REMOVED***;

				void* refType = this->BeginWriteType(***REMOVED***;
				this->WriteData("$ref", 5***REMOVED***;
				SerializeValue(refType, object->Get(NanPersistentToLocal(bson->_dbRefNamespaceString***REMOVED******REMOVED******REMOVED***;

				void* idType = this->BeginWriteType(***REMOVED***;
				this->WriteData("$id", 4***REMOVED***;
				SerializeValue(idType, object->Get(NanPersistentToLocal(bson->_dbRefOidString***REMOVED******REMOVED******REMOVED***;

				const Local<Value>& refDbValue = object->Get(NanPersistentToLocal(bson->_dbRefDbString***REMOVED******REMOVED***;
				if(!refDbValue->IsUndefined(***REMOVED******REMOVED***
				{
					void* dbType = this->BeginWriteType(***REMOVED***;
					this->WriteData("$db", 4***REMOVED***;
					SerializeValue(dbType, refDbValue***REMOVED***;
				}

				this->WriteByte(0***REMOVED***;
				this->CommitSize(dbRefSize***REMOVED***;
			}
			else if(NanPersistentToLocal(bson->minKeyString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_MIN_KEY***REMOVED***;
			}
			else if(NanPersistentToLocal(bson->maxKeyString***REMOVED***->StrictEquals(constructorString***REMOVED******REMOVED***
			{
				this->CommitType(typeLocation, BSON_TYPE_MAX_KEY***REMOVED***;
			}
		}
		else if(Buffer::HasInstance(value***REMOVED******REMOVED***
		{
			this->CommitType(typeLocation, BSON_TYPE_BINARY***REMOVED***;

	    #if NODE_MAJOR_VERSION == 0 && NODE_MINOR_VERSION < 3
       Local<Object> buffer = ObjectWrap::Unwrap<Buffer>(value->ToObject(***REMOVED******REMOVED***;
			 uint32_t length = object->length(***REMOVED***;
	    #else
			 uint32_t length = Buffer::Length(value->ToObject(***REMOVED******REMOVED***;
	    #endif

			this->WriteInt32(length***REMOVED***;
			this->WriteByte(0***REMOVED***;
			this->WriteData(Buffer::Data(value->ToObject(***REMOVED******REMOVED***, length***REMOVED***;
		}
		else
		{
			this->CommitType(typeLocation, BSON_TYPE_OBJECT***REMOVED***;
			SerializeDocument(value***REMOVED***;
		}
	}
	else if(value->IsNull(***REMOVED*** || value->IsUndefined(***REMOVED******REMOVED***
	{
		this->CommitType(typeLocation, BSON_TYPE_NULL***REMOVED***;
	}
}

// Data points to start of element list, length is length of entire document including '\0' but excluding initial size
BSONDeserializer::BSONDeserializer(BSON* aBson, char* data, size_t length***REMOVED***
: bson(aBson***REMOVED***,
  pStart(data***REMOVED***,
  p(data***REMOVED***,
  pEnd(data + length - 1***REMOVED***
{
	if(*pEnd != '\0'***REMOVED*** ThrowAllocatedStringException(64, "Missing end of document marker '\\0'"***REMOVED***;
}

BSONDeserializer::BSONDeserializer(BSONDeserializer& parentSerializer, size_t length***REMOVED***
: bson(parentSerializer.bson***REMOVED***,
  pStart(parentSerializer.p***REMOVED***,
  p(parentSerializer.p***REMOVED***,
  pEnd(parentSerializer.p + length - 1***REMOVED***
{
	parentSerializer.p += length;
	if(pEnd > parentSerializer.pEnd***REMOVED*** ThrowAllocatedStringException(64, "Child document exceeds parent's bounds"***REMOVED***;
	if(*pEnd != '\0'***REMOVED*** ThrowAllocatedStringException(64, "Missing end of document marker '\\0'"***REMOVED***;
}

Handle<Value> BSONDeserializer::ReadCString(***REMOVED***
{
	char* start = p;
	while(*p++ && (p < pEnd***REMOVED******REMOVED*** { }
	if(p > pEnd***REMOVED*** {
		return Null(***REMOVED***;
	}
	return String::New(start, (int32_t***REMOVED*** (p-start-1***REMOVED*** ***REMOVED***;
}

int32_t BSONDeserializer::ReadRegexOptions(***REMOVED***
{
	int32_t options = 0;
	for(;;***REMOVED***
	{
		switch(*p++***REMOVED***
		{
		case '\0': return options;
		case 's': options |= RegExp::kGlobal; break;
		case 'i': options |= RegExp::kIgnoreCase; break;
		case 'm': options |= RegExp::kMultiline; break;
		}
	}
}

uint32_t BSONDeserializer::ReadIntegerString(***REMOVED***
{
	uint32_t value = 0;
	while(*p***REMOVED***
	{
		if(*p < '0' || *p > '9'***REMOVED*** ThrowAllocatedStringException(64, "Invalid key for array"***REMOVED***;
		value = value * 10 + *p++ - '0';
	}
	++p;
	return value;
}

Local<String> BSONDeserializer::ReadString(***REMOVED***
{
	uint32_t length = ReadUInt32(***REMOVED***;
	char* start = p;
	p += length;
	return String::New(start, length-1***REMOVED***;
}

Local<String> BSONDeserializer::ReadObjectId(***REMOVED***
{
	uint16_t objectId[12];
	for(size_t i = 0; i < 12; ++i***REMOVED***
	{
		objectId[i] = *reinterpret_cast<unsigned char*>(p++***REMOVED***;
	}
	return String::New(objectId, 12***REMOVED***;
}

Handle<Value> BSONDeserializer::DeserializeDocument(bool promoteLongs***REMOVED***
{
	uint32_t length = ReadUInt32(***REMOVED***;
	if(length < 5***REMOVED*** ThrowAllocatedStringException(64, "Bad BSON: Document is less than 5 bytes"***REMOVED***;

	BSONDeserializer documentDeserializer(*this, length-4***REMOVED***;
	return documentDeserializer.DeserializeDocumentInternal(promoteLongs***REMOVED***;
}

Handle<Value> BSONDeserializer::DeserializeDocumentInternal(bool promoteLongs***REMOVED***
{
	Local<Object> returnObject = Object::New(***REMOVED***;

	while(HasMoreData(***REMOVED******REMOVED***
	{
		BsonType type = (BsonType***REMOVED*** ReadByte(***REMOVED***;
		const Handle<Value>& name = ReadCString(***REMOVED***;
		if(name->IsNull(***REMOVED******REMOVED*** ThrowAllocatedStringException(64, "Bad BSON Document: illegal CString"***REMOVED***;
		// name->Is
		const Handle<Value>& value = DeserializeValue(type, promoteLongs***REMOVED***;
		returnObject->ForceSet(name, value***REMOVED***;
	}
	if(p != pEnd***REMOVED*** ThrowAllocatedStringException(64, "Bad BSON Document: Serialize consumed unexpected number of bytes"***REMOVED***;

	// From JavaScript:
	// if(object['$id'] != null***REMOVED*** object = new DBRef(object['$ref'], object['$id'], object['$db']***REMOVED***;
	if(returnObject->Has(NanPersistentToLocal(bson->_dbRefIdRefString***REMOVED******REMOVED******REMOVED***
	{
		Local<Value> argv[] = { returnObject->Get(NanPersistentToLocal(bson->_dbRefRefString***REMOVED******REMOVED***, returnObject->Get(NanPersistentToLocal(bson->_dbRefIdRefString***REMOVED******REMOVED***, returnObject->Get(NanPersistentToLocal(bson->_dbRefDbRefString***REMOVED******REMOVED*** };
		return NanPersistentToLocal(bson->dbrefConstructor***REMOVED***->NewInstance(3, argv***REMOVED***;
	}
	else
	{
		return returnObject;
	}
}

Handle<Value> BSONDeserializer::DeserializeArray(bool promoteLongs***REMOVED***
{
	uint32_t length = ReadUInt32(***REMOVED***;
	if(length < 5***REMOVED*** ThrowAllocatedStringException(64, "Bad BSON: Array Document is less than 5 bytes"***REMOVED***;

	BSONDeserializer documentDeserializer(*this, length-4***REMOVED***;
	return documentDeserializer.DeserializeArrayInternal(promoteLongs***REMOVED***;
}

Handle<Value> BSONDeserializer::DeserializeArrayInternal(bool promoteLongs***REMOVED***
{
	Local<Array> returnArray = Array::New(***REMOVED***;

	while(HasMoreData(***REMOVED******REMOVED***
	{
		BsonType type = (BsonType***REMOVED*** ReadByte(***REMOVED***;
		uint32_t index = ReadIntegerString(***REMOVED***;
		const Handle<Value>& value = DeserializeValue(type, promoteLongs***REMOVED***;
		returnArray->Set(index, value***REMOVED***;
	}
	if(p != pEnd***REMOVED*** ThrowAllocatedStringException(64, "Bad BSON Array: Serialize consumed unexpected number of bytes"***REMOVED***;

	return returnArray;
}

Handle<Value> BSONDeserializer::DeserializeValue(BsonType type, bool promoteLongs***REMOVED***
{
	switch(type***REMOVED***
	{
	case BSON_TYPE_STRING:
		return ReadString(***REMOVED***;

	case BSON_TYPE_INT:
		return Integer::New(ReadInt32(***REMOVED******REMOVED***;

	case BSON_TYPE_NUMBER:
		return Number::New(ReadDouble(***REMOVED******REMOVED***;

	case BSON_TYPE_NULL:
		return Null(***REMOVED***;

	case BSON_TYPE_UNDEFINED:
		return Undefined(***REMOVED***;

	case BSON_TYPE_TIMESTAMP:
		{
			int32_t lowBits = ReadInt32(***REMOVED***;
			int32_t highBits = ReadInt32(***REMOVED***;
			Local<Value> argv[] = { Int32::New(lowBits***REMOVED***, Int32::New(highBits***REMOVED*** };
			return NanPersistentToLocal(bson->timestampConstructor***REMOVED***->NewInstance(2, argv***REMOVED***;
		}

	case BSON_TYPE_BOOLEAN:
		return (ReadByte(***REMOVED*** != 0***REMOVED*** ? True(***REMOVED*** : False(***REMOVED***;

	case BSON_TYPE_REGEXP:
		{
			const Handle<Value>& regex = ReadCString(***REMOVED***;
			if(regex->IsNull(***REMOVED******REMOVED*** ThrowAllocatedStringException(64, "Bad BSON Document: illegal CString"***REMOVED***;
			int32_t options = ReadRegexOptions(***REMOVED***;
			return RegExp::New(regex->ToString(***REMOVED***, (RegExp::Flags***REMOVED*** options***REMOVED***;
		}

	case BSON_TYPE_CODE:
		{
			const Local<Value>& code = ReadString(***REMOVED***;
			const Local<Value>& scope = Object::New(***REMOVED***;
			Local<Value> argv[] = { code, scope };
			return NanPersistentToLocal(bson->codeConstructor***REMOVED***->NewInstance(2, argv***REMOVED***;
		}

	case BSON_TYPE_CODE_W_SCOPE:
		{
			ReadUInt32(***REMOVED***;
			const Local<Value>& code = ReadString(***REMOVED***;
			const Handle<Value>& scope = DeserializeDocument(promoteLongs***REMOVED***;
			Local<Value> argv[] = { code, scope->ToObject(***REMOVED*** };
			return NanPersistentToLocal(bson->codeConstructor***REMOVED***->NewInstance(2, argv***REMOVED***;
		}

	case BSON_TYPE_OID:
		{
			Local<Value> argv[] = { ReadObjectId(***REMOVED*** };
			return NanPersistentToLocal(bson->objectIDConstructor***REMOVED***->NewInstance(1, argv***REMOVED***;
		}

	case BSON_TYPE_BINARY:
		{
			uint32_t length = ReadUInt32(***REMOVED***;
			uint32_t subType = ReadByte(***REMOVED***;
			if(subType == 0x02***REMOVED*** {
				length = ReadInt32(***REMOVED***;
			}

			Local<Object> buffer = NanNewBufferHandle(p, length***REMOVED***;
			p += length;

			Handle<Value> argv[] = { buffer, Uint32::New(subType***REMOVED*** };
			return NanPersistentToLocal(bson->binaryConstructor***REMOVED***->NewInstance(2, argv***REMOVED***;
		}

	case BSON_TYPE_LONG:
		{
			// Read 32 bit integers
			int32_t lowBits = (int32_t***REMOVED*** ReadInt32(***REMOVED***;
			int32_t highBits = (int32_t***REMOVED*** ReadInt32(***REMOVED***;

			// Promote long is enabled
			if(promoteLongs***REMOVED*** {
				// If value is < 2^53 and >-2^53
				if((highBits < 0x200000 || (highBits == 0x200000 && lowBits == 0***REMOVED******REMOVED*** && highBits >= -0x200000***REMOVED*** {
					// Adjust the pointer and read as 64 bit value
					p -= 8;
					// Read the 64 bit value
					int64_t finalValue = (int64_t***REMOVED*** ReadInt64(***REMOVED***;
					return Number::New(finalValue***REMOVED***;
				}
			}

			// Decode the Long value
			Local<Value> argv[] = { Int32::New(lowBits***REMOVED***, Int32::New(highBits***REMOVED*** };
			return NanPersistentToLocal(bson->longConstructor***REMOVED***->NewInstance(2, argv***REMOVED***;
		}

	case BSON_TYPE_DATE:
		return Date::New((double***REMOVED*** ReadInt64(***REMOVED******REMOVED***;

	case BSON_TYPE_ARRAY:
		return DeserializeArray(promoteLongs***REMOVED***;

	case BSON_TYPE_OBJECT:
		return DeserializeDocument(promoteLongs***REMOVED***;

	case BSON_TYPE_SYMBOL:
		{
			const Local<String>& string = ReadString(***REMOVED***;
			Local<Value> argv[] = { string };
			return NanPersistentToLocal(bson->symbolConstructor***REMOVED***->NewInstance(1, argv***REMOVED***;
		}

	case BSON_TYPE_MIN_KEY:
		return NanPersistentToLocal(bson->minKeyConstructor***REMOVED***->NewInstance(***REMOVED***;

	case BSON_TYPE_MAX_KEY:
		return NanPersistentToLocal(bson->maxKeyConstructor***REMOVED***->NewInstance(***REMOVED***;

	default:
		ThrowAllocatedStringException(64, "Unhandled BSON Type: %d", type***REMOVED***;
	}

	return v8::Null(***REMOVED***;
}

Persistent<FunctionTemplate> BSON::constructor_template;

BSON::BSON(***REMOVED*** : ObjectWrap(***REMOVED***
{
	// Setup pre-allocated comparision objects
        NanAssignPersistent(String, _bsontypeString, String::New("_bsontype"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _longLowString, String::New("low_"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _longHighString, String::New("high_"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _objectIDidString, String::New("id"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _binaryPositionString, String::New("position"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _binarySubTypeString, String::New("sub_type"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _binaryBufferString, String::New("buffer"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _doubleValueString, String::New("value"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _symbolValueString, String::New("value"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _dbRefRefString, String::New("$ref"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _dbRefIdRefString, String::New("$id"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _dbRefDbRefString, String::New("$db"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _dbRefNamespaceString, String::New("namespace"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _dbRefDbString, String::New("db"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _dbRefOidString, String::New("oid"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _codeCodeString, String::New("code"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _codeScopeString, String::New("scope"***REMOVED******REMOVED***;
        NanAssignPersistent(String, _toBSONString, String::New("toBSON"***REMOVED******REMOVED***;

        NanAssignPersistent(String, longString, String::New("Long"***REMOVED******REMOVED***;
        NanAssignPersistent(String, objectIDString, String::New("ObjectID"***REMOVED******REMOVED***;
        NanAssignPersistent(String, binaryString, String::New("Binary"***REMOVED******REMOVED***;
        NanAssignPersistent(String, codeString, String::New("Code"***REMOVED******REMOVED***;
        NanAssignPersistent(String, dbrefString, String::New("DBRef"***REMOVED******REMOVED***;
        NanAssignPersistent(String, symbolString, String::New("Symbol"***REMOVED******REMOVED***;
        NanAssignPersistent(String, doubleString, String::New("Double"***REMOVED******REMOVED***;
        NanAssignPersistent(String, timestampString, String::New("Timestamp"***REMOVED******REMOVED***;
        NanAssignPersistent(String, minKeyString, String::New("MinKey"***REMOVED******REMOVED***;
        NanAssignPersistent(String, maxKeyString, String::New("MaxKey"***REMOVED******REMOVED***;
}

void BSON::Initialize(v8::Handle<v8::Object> target***REMOVED***
{
	// Grab the scope of the call from Node
	NanScope(***REMOVED***;
	// Define a new function template
	Local<FunctionTemplate> t = FunctionTemplate::New(New***REMOVED***;
	t->InstanceTemplate(***REMOVED***->SetInternalFieldCount(1***REMOVED***;
	t->SetClassName(String::NewSymbol("BSON"***REMOVED******REMOVED***;

	// Instance methods
	NODE_SET_PROTOTYPE_METHOD(t, "calculateObjectSize", CalculateObjectSize***REMOVED***;
	NODE_SET_PROTOTYPE_METHOD(t, "serialize", BSONSerialize***REMOVED***;
	NODE_SET_PROTOTYPE_METHOD(t, "serializeWithBufferAndIndex", SerializeWithBufferAndIndex***REMOVED***;
	NODE_SET_PROTOTYPE_METHOD(t, "deserialize", BSONDeserialize***REMOVED***;
	NODE_SET_PROTOTYPE_METHOD(t, "deserializeStream", BSONDeserializeStream***REMOVED***;

	NanAssignPersistent(FunctionTemplate, constructor_template, t***REMOVED***;

	target->ForceSet(String::NewSymbol("BSON"***REMOVED***, t->GetFunction(***REMOVED******REMOVED***;
}

// Create a new instance of BSON and passing it the existing context
NAN_METHOD(BSON::New***REMOVED***
{
	NanScope(***REMOVED***;

	// Check that we have an array
	if(args.Length(***REMOVED*** == 1 && args[0]->IsArray(***REMOVED******REMOVED***
	{
		// Cast the array to a local reference
		Local<Array> array = Local<Array>::Cast(args[0]***REMOVED***;

		if(array->Length(***REMOVED*** > 0***REMOVED***
		{
			// Create a bson object instance and return it
			BSON *bson = new BSON(***REMOVED***;

			uint32_t foundClassesMask = 0;

			// Iterate over all entries to save the instantiate funtions
			for(uint32_t i = 0; i < array->Length(***REMOVED***; i++***REMOVED*** {
				// Let's get a reference to the function
				Local<Function> func = Local<Function>::Cast(array->Get(i***REMOVED******REMOVED***;
				Local<String> functionName = func->GetName(***REMOVED***->ToString(***REMOVED***;

				// Save the functions making them persistant handles (they don't get collected***REMOVED***
				if(functionName->StrictEquals(NanPersistentToLocal(bson->longString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->longConstructor, func***REMOVED***;
					foundClassesMask |= 1;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->objectIDString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->objectIDConstructor, func***REMOVED***;
					foundClassesMask |= 2;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->binaryString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->binaryConstructor, func***REMOVED***;
					foundClassesMask |= 4;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->codeString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->codeConstructor, func***REMOVED***;
					foundClassesMask |= 8;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->dbrefString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->dbrefConstructor, func***REMOVED***;
					foundClassesMask |= 0x10;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->symbolString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->symbolConstructor, func***REMOVED***;
					foundClassesMask |= 0x20;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->doubleString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->doubleConstructor, func***REMOVED***;
					foundClassesMask |= 0x40;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->timestampString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->timestampConstructor, func***REMOVED***;
					foundClassesMask |= 0x80;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->minKeyString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->minKeyConstructor, func***REMOVED***;
					foundClassesMask |= 0x100;
				} else if(functionName->StrictEquals(NanPersistentToLocal(bson->maxKeyString***REMOVED******REMOVED******REMOVED*** {
					NanAssignPersistent(Function, bson->maxKeyConstructor, func***REMOVED***;
					foundClassesMask |= 0x200;
				}
			}

			// Check if we have the right number of constructors otherwise throw an error
			if(foundClassesMask != 0x3ff***REMOVED*** {
				delete bson;
				return NanThrowError("Missing function constructor for either [Long/ObjectID/Binary/Code/DbRef/Symbol/Double/Timestamp/MinKey/MaxKey]"***REMOVED***;
			} else {
				bson->Wrap(args.This(***REMOVED******REMOVED***;
				NanReturnValue(args.This(***REMOVED******REMOVED***;
			}
		}
		else
		{
			return NanThrowError("No types passed in"***REMOVED***;
		}
	}
	else
	{
		return NanThrowTypeError("Argument passed in must be an array of types"***REMOVED***;
	}
}

//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------

NAN_METHOD(BSON::BSONDeserialize***REMOVED***
{
	NanScope(***REMOVED***;

	// Fail if the first argument is not a string or a buffer
	if(args.Length(***REMOVED*** > 1 && !args[0]->IsString(***REMOVED*** && !Buffer::HasInstance(args[0]***REMOVED******REMOVED***
		return NanThrowError("First Argument must be a Buffer or String."***REMOVED***;

	// Promote longs
	bool promoteLongs = true;

	// If we have an options object
	if(args.Length(***REMOVED*** == 2 && args[1]->IsObject(***REMOVED******REMOVED*** {
		Local<Object> options = args[1]->ToObject(***REMOVED***;

		if(options->Has(String::New("promoteLongs"***REMOVED******REMOVED******REMOVED*** {
			promoteLongs = options->Get(String::New("promoteLongs"***REMOVED******REMOVED***->ToBoolean(***REMOVED***->Value(***REMOVED***;
		}
	}

	// Define pointer to data
	Local<Object> obj = args[0]->ToObject(***REMOVED***;

	// Unpack the BSON parser instance
	BSON *bson = ObjectWrap::Unwrap<BSON>(args.This(***REMOVED******REMOVED***;

	// If we passed in a buffer, let's unpack it, otherwise let's unpack the string
	if(Buffer::HasInstance(obj***REMOVED******REMOVED***
	{
#if NODE_MAJOR_VERSION == 0 && NODE_MINOR_VERSION < 3
		Local<Object> buffer = ObjectWrap::Unwrap<Buffer>(obj***REMOVED***;
		char* data = buffer->data(***REMOVED***;
		size_t length = buffer->length(***REMOVED***;
#else
		char* data = Buffer::Data(obj***REMOVED***;
		size_t length = Buffer::Length(obj***REMOVED***;
#endif

		// Validate that we have at least 5 bytes
		if(length < 5***REMOVED*** return NanThrowError("corrupt bson message < 5 bytes long"***REMOVED***;

		try
		{
			BSONDeserializer deserializer(bson, data, length***REMOVED***;
			// deserializer.promoteLongs = promoteLongs;
			NanReturnValue(deserializer.DeserializeDocument(promoteLongs***REMOVED******REMOVED***;
		}
		catch(char* exception***REMOVED***
		{
			Local<String> error = String::New(exception***REMOVED***;
			free(exception***REMOVED***;
			return NanThrowError(error***REMOVED***;
		}

	}
	else
	{
		// The length of the data for this encoding
		ssize_t len = DecodeBytes(args[0], BINARY***REMOVED***;

		// Validate that we have at least 5 bytes
		if(len < 5***REMOVED*** return NanThrowError("corrupt bson message < 5 bytes long"***REMOVED***;

		// Let's define the buffer size
		char* data = (char ****REMOVED***malloc(len***REMOVED***;
		DecodeWrite(data, len, args[0], BINARY***REMOVED***;

		try
		{
			BSONDeserializer deserializer(bson, data, len***REMOVED***;
			// deserializer.promoteLongs = promoteLongs;
			Handle<Value> result = deserializer.DeserializeDocument(promoteLongs***REMOVED***;
			free(data***REMOVED***;
			NanReturnValue(result***REMOVED***;

		}
		catch(char* exception***REMOVED***
		{
			Local<String> error = String::New(exception***REMOVED***;
			free(exception***REMOVED***;
			free(data***REMOVED***;
			return NanThrowError(error***REMOVED***;
		}
	}
}

Local<Object> BSON::GetSerializeObject(const Handle<Value>& argValue***REMOVED***
{
	Local<Object> object = argValue->ToObject(***REMOVED***;
	if(object->Has(NanPersistentToLocal(_toBSONString***REMOVED******REMOVED******REMOVED***
	{
		const Local<Value>& toBSON = object->Get(NanPersistentToLocal(_toBSONString***REMOVED******REMOVED***;
		if(!toBSON->IsFunction(***REMOVED******REMOVED*** ThrowAllocatedStringException(64, "toBSON is not a function"***REMOVED***;

		Local<Value> result = Local<Function>::Cast(toBSON***REMOVED***->Call(object, 0, NULL***REMOVED***;
		if(!result->IsObject(***REMOVED******REMOVED*** ThrowAllocatedStringException(64, "toBSON function did not return an object"***REMOVED***;
		return result->ToObject(***REMOVED***;
	}
	else
	{
		return object;
	}
}

NAN_METHOD(BSON::BSONSerialize***REMOVED***
{
	NanScope(***REMOVED***;

	if(args.Length(***REMOVED*** == 1 && !args[0]->IsObject(***REMOVED******REMOVED*** return NanThrowError("One, two or tree arguments required - [object] or [object, boolean] or [object, boolean, boolean]"***REMOVED***;
	if(args.Length(***REMOVED*** == 2 && !args[0]->IsObject(***REMOVED*** && !args[1]->IsBoolean(***REMOVED******REMOVED*** return NanThrowError("One, two or tree arguments required - [object] or [object, boolean] or [object, boolean, boolean]"***REMOVED***;
	if(args.Length(***REMOVED*** == 3 && !args[0]->IsObject(***REMOVED*** && !args[1]->IsBoolean(***REMOVED*** && !args[2]->IsBoolean(***REMOVED******REMOVED*** return NanThrowError("One, two or tree arguments required - [object] or [object, boolean] or [object, boolean, boolean]"***REMOVED***;
	if(args.Length(***REMOVED*** == 4 && !args[0]->IsObject(***REMOVED*** && !args[1]->IsBoolean(***REMOVED*** && !args[2]->IsBoolean(***REMOVED*** && !args[3]->IsBoolean(***REMOVED******REMOVED*** return NanThrowError("One, two or tree arguments required - [object] or [object, boolean] or [object, boolean, boolean] or [object, boolean, boolean, boolean]"***REMOVED***;
	if(args.Length(***REMOVED*** > 4***REMOVED*** return NanThrowError("One, two, tree or four arguments required - [object] or [object, boolean] or [object, boolean, boolean] or [object, boolean, boolean, boolean]"***REMOVED***;

	// Check if we have an array as the object
	if(args[0]->IsArray(***REMOVED******REMOVED*** return NanThrowError("Only javascript objects supported"***REMOVED***;

	// Unpack the BSON parser instance
	BSON *bson = ObjectWrap::Unwrap<BSON>(args.This(***REMOVED******REMOVED***;

	// Calculate the total size of the document in binary form to ensure we only allocate memory once
	// With serialize function
	bool serializeFunctions = (args.Length(***REMOVED*** >= 4***REMOVED*** && args[3]->BooleanValue(***REMOVED***;

	char *serialized_object = NULL;
	size_t object_size;
	try
	{
		Local<Object> object = bson->GetSerializeObject(args[0]***REMOVED***;

		BSONSerializer<CountStream> counter(bson, false, serializeFunctions***REMOVED***;
		counter.SerializeDocument(object***REMOVED***;
		object_size = counter.GetSerializeSize(***REMOVED***;

		// Allocate the memory needed for the serialization
		serialized_object = (char ****REMOVED***malloc(object_size***REMOVED***;

		// Check if we have a boolean value
		bool checkKeys = args.Length(***REMOVED*** >= 3 && args[1]->IsBoolean(***REMOVED*** && args[1]->BooleanValue(***REMOVED***;
		BSONSerializer<DataStream> data(bson, checkKeys, serializeFunctions, serialized_object***REMOVED***;
		data.SerializeDocument(object***REMOVED***;
	}
	catch(char *err_msg***REMOVED***
	{
		free(serialized_object***REMOVED***;
		Local<String> error = String::New(err_msg***REMOVED***;
		free(err_msg***REMOVED***;
		return NanThrowError(error***REMOVED***;
	}

	// If we have 3 arguments
	if(args.Length(***REMOVED*** == 3 || args.Length(***REMOVED*** == 4***REMOVED***
	{
		Local<Object> buffer = NanNewBufferHandle(serialized_object, object_size***REMOVED***;
		free(serialized_object***REMOVED***;
		NanReturnValue(buffer***REMOVED***;
	}
	else
	{
		Local<Value> bin_value = Encode(serialized_object, object_size, BINARY***REMOVED***->ToString(***REMOVED***;
		free(serialized_object***REMOVED***;
		NanReturnValue(bin_value***REMOVED***;
	}
}

NAN_METHOD(BSON::CalculateObjectSize***REMOVED***
{
	NanScope(***REMOVED***;
	// Ensure we have a valid object
	if(args.Length(***REMOVED*** == 1 && !args[0]->IsObject(***REMOVED******REMOVED*** return NanThrowError("One argument required - [object]"***REMOVED***;
	if(args.Length(***REMOVED*** == 2 && !args[0]->IsObject(***REMOVED*** && !args[1]->IsBoolean(***REMOVED******REMOVED***  return NanThrowError("Two arguments required - [object, boolean]"***REMOVED***;
	if(args.Length(***REMOVED*** > 3***REMOVED*** return NanThrowError("One or two arguments required - [object] or [object, boolean]"***REMOVED***;

	// Unpack the BSON parser instance
	BSON *bson = ObjectWrap::Unwrap<BSON>(args.This(***REMOVED******REMOVED***;
	bool serializeFunctions = (args.Length(***REMOVED*** >= 2***REMOVED*** && args[1]->BooleanValue(***REMOVED***;
	BSONSerializer<CountStream> countSerializer(bson, false, serializeFunctions***REMOVED***;
	countSerializer.SerializeDocument(args[0]***REMOVED***;

	// Return the object size
	NanReturnValue(Uint32::New((uint32_t***REMOVED*** countSerializer.GetSerializeSize(***REMOVED******REMOVED******REMOVED***;
}

NAN_METHOD(BSON::SerializeWithBufferAndIndex***REMOVED***
{
	NanScope(***REMOVED***;

	//BSON.serializeWithBufferAndIndex = function serializeWithBufferAndIndex(object, ->, buffer, index***REMOVED*** {
	// Ensure we have the correct values
	if(args.Length(***REMOVED*** > 5***REMOVED*** return NanThrowError("Four or five parameters required [object, boolean, Buffer, int] or [object, boolean, Buffer, int, boolean]"***REMOVED***;
	if(args.Length(***REMOVED*** == 4 && !args[0]->IsObject(***REMOVED*** && !args[1]->IsBoolean(***REMOVED*** && !Buffer::HasInstance(args[2]***REMOVED*** && !args[3]->IsUint32(***REMOVED******REMOVED*** return NanThrowError("Four parameters required [object, boolean, Buffer, int]"***REMOVED***;
	if(args.Length(***REMOVED*** == 5 && !args[0]->IsObject(***REMOVED*** && !args[1]->IsBoolean(***REMOVED*** && !Buffer::HasInstance(args[2]***REMOVED*** && !args[3]->IsUint32(***REMOVED*** && !args[4]->IsBoolean(***REMOVED******REMOVED*** return NanThrowError("Four parameters required [object, boolean, Buffer, int, boolean]"***REMOVED***;

	uint32_t index;
	size_t object_size;

	try
	{
		BSON *bson = ObjectWrap::Unwrap<BSON>(args.This(***REMOVED******REMOVED***;

		Local<Object> obj = args[2]->ToObject(***REMOVED***;
		char* data = Buffer::Data(obj***REMOVED***;
		size_t length = Buffer::Length(obj***REMOVED***;

		index = args[3]->Uint32Value(***REMOVED***;
		bool checkKeys = args.Length(***REMOVED*** >= 4 && args[1]->IsBoolean(***REMOVED*** && args[1]->BooleanValue(***REMOVED***;
		bool serializeFunctions = (args.Length(***REMOVED*** == 5***REMOVED*** && args[4]->BooleanValue(***REMOVED***;

		BSONSerializer<DataStream> dataSerializer(bson, checkKeys, serializeFunctions, data+index***REMOVED***;
		dataSerializer.SerializeDocument(bson->GetSerializeObject(args[0]***REMOVED******REMOVED***;
		object_size = dataSerializer.GetSerializeSize(***REMOVED***;

		if(object_size + index > length***REMOVED*** return NanThrowError("Serious error - overflowed buffer!!"***REMOVED***;
	}
	catch(char *exception***REMOVED***
	{
		Local<String> error = String::New(exception***REMOVED***;
		free(exception***REMOVED***;
                return NanThrowError(error***REMOVED***;
	}

	NanReturnValue(Uint32::New((uint32_t***REMOVED*** (index + object_size - 1***REMOVED******REMOVED******REMOVED***;
}

NAN_METHOD(BSON::BSONDeserializeStream***REMOVED***
{
	NanScope(***REMOVED***;

	// At least 3 arguments required
	if(args.Length(***REMOVED*** < 5***REMOVED*** return NanThrowError("Arguments required (Buffer(data***REMOVED***, Number(index in data***REMOVED***, Number(number of documents to deserialize***REMOVED***, Array(results***REMOVED***, Number(index in the array***REMOVED***, Object(optional***REMOVED******REMOVED***"***REMOVED***;

	// If the number of argumets equals 3
	if(args.Length(***REMOVED*** >= 5***REMOVED***
	{
		if(!Buffer::HasInstance(args[0]***REMOVED******REMOVED*** return NanThrowError("First argument must be Buffer instance"***REMOVED***;
		if(!args[1]->IsUint32(***REMOVED******REMOVED*** return NanThrowError("Second argument must be a positive index number"***REMOVED***;
		if(!args[2]->IsUint32(***REMOVED******REMOVED*** return NanThrowError("Third argument must be a positive number of documents to deserialize"***REMOVED***;
		if(!args[3]->IsArray(***REMOVED******REMOVED*** return NanThrowError("Fourth argument must be an array the size of documents to deserialize"***REMOVED***;
		if(!args[4]->IsUint32(***REMOVED******REMOVED*** return NanThrowError("Sixth argument must be a positive index number"***REMOVED***;
	}

	// If we have 4 arguments
	if(args.Length(***REMOVED*** == 6 && !args[5]->IsObject(***REMOVED******REMOVED*** return NanThrowError("Fifth argument must be an object with options"***REMOVED***;

	// Define pointer to data
	Local<Object> obj = args[0]->ToObject(***REMOVED***;
	uint32_t numberOfDocuments = args[2]->Uint32Value(***REMOVED***;
	uint32_t index = args[1]->Uint32Value(***REMOVED***;
	uint32_t resultIndex = args[4]->Uint32Value(***REMOVED***;
	bool promoteLongs = true;

	// Check for the value promoteLongs in the options object
	if(args.Length(***REMOVED*** == 6***REMOVED*** {
		Local<Object> options = args[5]->ToObject(***REMOVED***;

		// Check if we have the promoteLong variable
		if(options->Has(String::New("promoteLongs"***REMOVED******REMOVED******REMOVED*** {
			promoteLongs = options->Get(String::New("promoteLongs"***REMOVED******REMOVED***->ToBoolean(***REMOVED***->Value(***REMOVED***;
		}
	}

	// Unpack the BSON parser instance
	BSON *bson = ObjectWrap::Unwrap<BSON>(args.This(***REMOVED******REMOVED***;

	// Unpack the buffer variable
#if NODE_MAJOR_VERSION == 0 && NODE_MINOR_VERSION < 3
	Local<Object> buffer = ObjectWrap::Unwrap<Buffer>(obj***REMOVED***;
	char* data = buffer->data(***REMOVED***;
	size_t length = buffer->length(***REMOVED***;
#else
	char* data = Buffer::Data(obj***REMOVED***;
	size_t length = Buffer::Length(obj***REMOVED***;
#endif

	// Fetch the documents
	Local<Object> documents = args[3]->ToObject(***REMOVED***;

	BSONDeserializer deserializer(bson, data+index, length-index***REMOVED***;
	for(uint32_t i = 0; i < numberOfDocuments; i++***REMOVED***
	{
		try
		{
			documents->Set(i + resultIndex, deserializer.DeserializeDocument(promoteLongs***REMOVED******REMOVED***;
		}
		catch (char* exception***REMOVED***
		{
		        Local<String> error = String::New(exception***REMOVED***;
			free(exception***REMOVED***;
			return NanThrowError(error***REMOVED***;
		}
	}

	// Return new index of parsing
	NanReturnValue(Uint32::New((uint32_t***REMOVED*** (index + deserializer.GetSerializeSize(***REMOVED******REMOVED******REMOVED******REMOVED***;
}

// Exporting function
extern "C" void init(Handle<Object> target***REMOVED***
{
	NanScope(***REMOVED***;
	BSON::Initialize(target***REMOVED***;
}

NODE_MODULE(bson, BSON::Initialize***REMOVED***;
