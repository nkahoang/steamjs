var bson = (function(***REMOVED***{

  var pkgmap        = {},
      global        = {},
      nativeRequire = typeof require != 'undefined' && require,
      lib, ties, main, async;

  function exports(***REMOVED***{ return main(***REMOVED***; };

  exports.main     = exports;
  exports.module   = module;
  exports.packages = pkgmap;
  exports.pkg      = pkg;
  exports.require  = function require(uri***REMOVED***{
    return pkgmap.main.index.require(uri***REMOVED***;
***REMOVED***;


  ties             = {};

  aliases          = {};


  return exports;

function join(***REMOVED*** {
  return normalize(Array.prototype.join.call(arguments, "/"***REMOVED******REMOVED***;
};

function normalize(path***REMOVED*** {
  var ret = [], parts = path.split('/'***REMOVED***, cur, prev;

  var i = 0, l = parts.length-1;
  for (; i <= l; i++***REMOVED*** {
    cur = parts[i];

    if (cur === "." && prev !== undefined***REMOVED*** continue;

    if (cur === ".." && ret.length && prev !== ".." && prev !== "." && prev !== undefined***REMOVED*** {
      ret.pop(***REMOVED***;
      prev = ret.slice(-1***REMOVED***[0];
  ***REMOVED*** else {
      if (prev === "."***REMOVED*** ret.pop(***REMOVED***;
      ret.push(cur***REMOVED***;
      prev = cur;
  ***REMOVED***
***REMOVED***

  return ret.join("/"***REMOVED***;
};

function dirname(path***REMOVED*** {
  return path && path.substr(0, path.lastIndexOf("/"***REMOVED******REMOVED*** || ".";
};

function findModule(workingModule, uri***REMOVED***{
  var moduleId      = join(dirname(workingModule.id***REMOVED***, /\.\/$/.test(uri***REMOVED*** ? (uri + 'index'***REMOVED*** : uri ***REMOVED***.replace(/\.js$/, ''***REMOVED***,
      moduleIndexId = join(moduleId, 'index'***REMOVED***,
      pkg           = workingModule.pkg,
      module;

  var i = pkg.modules.length,
      id;

  while(i-->0***REMOVED***{
    id = pkg.modules[i].id;

    if(id==moduleId || id == moduleIndexId***REMOVED***{
      module = pkg.modules[i];
      break;
  ***REMOVED***
***REMOVED***

  return module;
}

function newRequire(callingModule***REMOVED***{
  function require(uri***REMOVED***{
    var module, pkg;

    if(/^\./.test(uri***REMOVED******REMOVED***{
      module = findModule(callingModule, uri***REMOVED***;
  ***REMOVED*** else if ( ties && ties.hasOwnProperty( uri ***REMOVED*** ***REMOVED*** {
      return ties[uri];
  ***REMOVED*** else if ( aliases && aliases.hasOwnProperty( uri ***REMOVED*** ***REMOVED*** {
      return require(aliases[uri]***REMOVED***;
  ***REMOVED*** else {
      pkg = pkgmap[uri];

      if(!pkg && nativeRequire***REMOVED***{
        try {
          pkg = nativeRequire(uri***REMOVED***;
      ***REMOVED*** catch (nativeRequireError***REMOVED*** {}

        if(pkg***REMOVED*** return pkg;
    ***REMOVED***

      if(!pkg***REMOVED***{
        throw new Error('Cannot find module "'+uri+'" @[module: '+callingModule.id+' package: '+callingModule.pkg.name+']'***REMOVED***;
    ***REMOVED***

      module = pkg.index;
  ***REMOVED***

    if(!module***REMOVED***{
      throw new Error('Cannot find module "'+uri+'" @[module: '+callingModule.id+' package: '+callingModule.pkg.name+']'***REMOVED***;
  ***REMOVED***

    module.parent = callingModule;
    return module.call(***REMOVED***;
***REMOVED***;


  return require;
}


function module(parent, id, wrapper***REMOVED***{
  var mod    = { pkg: parent, id: id, wrapper: wrapper },
      cached = false;

  mod.exports = {};
  mod.require = newRequire(mod***REMOVED***;

  mod.call = function(***REMOVED***{
    if(cached***REMOVED*** {
      return mod.exports;
  ***REMOVED***

    cached = true;

    global.require = mod.require;

    mod.wrapper(mod, mod.exports, global, global.require***REMOVED***;
    return mod.exports;
***REMOVED***;

  if(parent.mainModuleId == mod.id***REMOVED***{
    parent.index = mod;
    parent.parents.length === 0 && ( main = mod.call ***REMOVED***;
***REMOVED***

  parent.modules.push(mod***REMOVED***;
}

function pkg(/* [ parentId ...], wrapper */***REMOVED***{
  var wrapper = arguments[ arguments.length - 1 ],
      parents = Array.prototype.slice.call(arguments, 0, arguments.length - 1***REMOVED***,
      ctx     = wrapper(parents***REMOVED***;


  pkgmap[ctx.name] = ctx;

  arguments.length == 1 && ( pkgmap.main = ctx ***REMOVED***;

  return function(modules***REMOVED***{
    var id;
    for(id in modules***REMOVED***{
      module(ctx, id, modules[id]***REMOVED***;
  ***REMOVED***
***REMOVED***;
}


}(this***REMOVED******REMOVED***;

bson.pkg(function(parents***REMOVED***{

  return {
    'name'         : 'bson',
    'mainModuleId' : 'bson',
    'modules'      : [],
    'parents'      : parents
***REMOVED***;

}***REMOVED***({ 'binary': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * Module dependencies.
 */
if(typeof window === 'undefined'***REMOVED*** { 
  var Buffer = require('buffer'***REMOVED***.Buffer; // TODO just use global Buffer
}

// Binary default subtype
var BSON_BINARY_SUBTYPE_DEFAULT = 0;

/**
 * @ignore
 * @api private
 */
var writeStringToArray = function(data***REMOVED*** {
  // Create a buffer
  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length***REMOVED******REMOVED*** : new Array(data.length***REMOVED***;
  // Write the content to the buffer
  for(var i = 0; i < data.length; i++***REMOVED*** {
    buffer[i] = data.charCodeAt(i***REMOVED***;
***REMOVED***  
  // Write the string to the buffer
  return buffer;
}

/**
 * Convert Array ot Uint8Array to Binary String
 *
 * @ignore
 * @api private
 */
var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex***REMOVED*** {
  var result = "";
  for(var i = startIndex; i < endIndex; i++***REMOVED*** {
   result = result + String.fromCharCode(byteArray[i]***REMOVED***;
***REMOVED***
  return result;  
};

/**
 * A class representation of the BSON Binary type.
 * 
 * Sub types
 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
 *
 * @class Represents the Binary BSON type.
 * @param {Buffer} buffer a buffer object containing the binary data.
 * @param {Number} [subType] the option binary type.
 * @return {Grid}
 */
function Binary(buffer, subType***REMOVED*** {
  if(!(this instanceof Binary***REMOVED******REMOVED*** return new Binary(buffer, subType***REMOVED***;
  
  this._bsontype = 'Binary';

  if(buffer instanceof Number***REMOVED*** {
    this.sub_type = buffer;
    this.position = 0;
***REMOVED*** else {    
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
***REMOVED***

  if(buffer != null && !(buffer instanceof Number***REMOVED******REMOVED*** {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string'***REMOVED*** {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined'***REMOVED*** {
        this.buffer = new Buffer(buffer***REMOVED***;
    ***REMOVED*** else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer***REMOVED*** == '[object Array]'***REMOVED******REMOVED*** {
        this.buffer = writeStringToArray(buffer***REMOVED***;
    ***REMOVED*** else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted"***REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      this.buffer = buffer;      
  ***REMOVED***
    this.position = buffer.length;
***REMOVED*** else {
    if(typeof Buffer != 'undefined'***REMOVED*** {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE***REMOVED***;      
  ***REMOVED*** else if(typeof Uint8Array != 'undefined'***REMOVED***{
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE***REMOVED******REMOVED***;
  ***REMOVED*** else {
      this.buffer = new Array(Binary.BUFFER_SIZE***REMOVED***;
  ***REMOVED***
    // Set position to start of buffer
    this.position = 0;
***REMOVED***
};

/**
 * Updates this binary with byte_value.
 *
 * @param {Character} byte_value a single byte we wish to write.
 * @api public
 */
Binary.prototype.put = function put(byte_value***REMOVED*** {
  // If it's a string and a has more than one character throw an error
  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1***REMOVED*** throw new Error("only accepts single character String, Uint8Array or Array"***REMOVED***;
  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255***REMOVED*** throw new Error("only accepts number in a valid unsigned byte range 0-255"***REMOVED***;
  
  // Decode the byte value once
  var decoded_byte = null;
  if(typeof byte_value == 'string'***REMOVED*** {
    decoded_byte = byte_value.charCodeAt(0***REMOVED***;      
***REMOVED*** else if(byte_value['length'] != null***REMOVED*** {
    decoded_byte = byte_value[0];
***REMOVED*** else {
    decoded_byte = byte_value;
***REMOVED***
  
  if(this.buffer.length > this.position***REMOVED*** {
    this.buffer[this.position++] = decoded_byte;
***REMOVED*** else {
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {    
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length***REMOVED***;
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length***REMOVED***;
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
  ***REMOVED*** else {
      var buffer = null;
      // Create a new buffer (typed or normal array***REMOVED***
      if(Object.prototype.toString.call(this.buffer***REMOVED*** == '[object Uint8Array]'***REMOVED*** {
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length***REMOVED******REMOVED***;
    ***REMOVED*** else {
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length***REMOVED***;
    ***REMOVED***      
      
      // We need to copy all the content to the new array
      for(var i = 0; i < this.buffer.length; i++***REMOVED*** {
        buffer[i] = this.buffer[i];
    ***REMOVED***
      
      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
  ***REMOVED***
***REMOVED***
};

/**
 * Writes a buffer or string to the binary.
 *
 * @param {Buffer|String} string a string or buffer to be written to the Binary BSON object.
 * @param {Number} offset specify the binary of where to write the content.
 * @api public
 */
Binary.prototype.write = function write(string, offset***REMOVED*** {
  offset = typeof offset == 'number' ? offset : this.position;

  // If the buffer is to small let's extend the buffer
  if(this.buffer.length < offset + string.length***REMOVED*** {
    var buffer = null;
    // If we are in node.js
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {      
      buffer = new Buffer(this.buffer.length + string.length***REMOVED***;
      this.buffer.copy(buffer, 0, 0, this.buffer.length***REMOVED***;      
  ***REMOVED*** else if(Object.prototype.toString.call(this.buffer***REMOVED*** == '[object Uint8Array]'***REMOVED*** {
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length***REMOVED******REMOVED***
      // Copy the content
      for(var i = 0; i < this.position; i++***REMOVED*** {
        buffer[i] = this.buffer[i];
    ***REMOVED***
  ***REMOVED***
    
    // Assign the new buffer
    this.buffer = buffer;
***REMOVED***

  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string***REMOVED*** && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {
    string.copy(this.buffer, offset, 0, string.length***REMOVED***;
    this.position = (offset + string.length***REMOVED*** > this.position ? (offset + string.length***REMOVED*** : this.position;
    // offset = string.length
***REMOVED*** else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {
    this.buffer.write(string, 'binary', offset***REMOVED***;
    this.position = (offset + string.length***REMOVED*** > this.position ? (offset + string.length***REMOVED*** : this.position;
    // offset = string.length;
***REMOVED*** else if(Object.prototype.toString.call(string***REMOVED*** == '[object Uint8Array]' 
    || Object.prototype.toString.call(string***REMOVED*** == '[object Array]' && typeof string != 'string'***REMOVED*** {      
    for(var i = 0; i < string.length; i++***REMOVED*** {
      this.buffer[offset++] = string[i];
  ***REMOVED***    

    this.position = offset > this.position ? offset : this.position;
***REMOVED*** else if(typeof string == 'string'***REMOVED*** {
    for(var i = 0; i < string.length; i++***REMOVED*** {
      this.buffer[offset++] = string.charCodeAt(i***REMOVED***;
  ***REMOVED***

    this.position = offset > this.position ? offset : this.position;
***REMOVED***
};

/**
 * Reads **length** bytes starting at **position**.
 *
 * @param {Number} position read from the given position in the Binary.
 * @param {Number} length the number of bytes to read.
 * @return {Buffer}
 * @api public
 */
Binary.prototype.read = function read(position, length***REMOVED*** {
  length = length && length > 0
    ? length
    : this.position;
  
  // Let's return the data based on the type we have
  if(this.buffer['slice']***REMOVED*** {
    return this.buffer.slice(position, position + length***REMOVED***;
***REMOVED*** else {
    // Create a buffer to keep the result
    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length***REMOVED******REMOVED*** : new Array(length***REMOVED***;
    for(var i = 0; i < length; i++***REMOVED*** {
      buffer[i] = this.buffer[position++];
  ***REMOVED***
***REMOVED***
  // Return the buffer
  return buffer;
};

/**
 * Returns the value of this binary as a string.
 *
 * @return {String}
 * @api public
 */
Binary.prototype.value = function value(asRaw***REMOVED*** {
  asRaw = asRaw == null ? false : asRaw;  
  
  // If it's a node.js buffer object
  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {
    return asRaw ? this.buffer.slice(0, this.position***REMOVED*** : this.buffer.toString('binary', 0, this.position***REMOVED***;
***REMOVED*** else {
    if(asRaw***REMOVED*** {
      // we support the slice command use it
      if(this.buffer['slice'] != null***REMOVED*** {
        return this.buffer.slice(0, this.position***REMOVED***;
    ***REMOVED*** else {
        // Create a new buffer to copy content to
        var newBuffer = Object.prototype.toString.call(this.buffer***REMOVED*** == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position***REMOVED******REMOVED*** : new Array(this.position***REMOVED***;
        // Copy content
        for(var i = 0; i < this.position; i++***REMOVED*** {
          newBuffer[i] = this.buffer[i];
      ***REMOVED***
        // Return the buffer
        return newBuffer;
    ***REMOVED***
  ***REMOVED*** else {
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Length.
 *
 * @return {Number} the length of the binary.
 * @api public
 */
Binary.prototype.length = function length(***REMOVED*** {
  return this.position;
};

/**
 * @ignore
 * @api private
 */
Binary.prototype.toJSON = function(***REMOVED*** {
  return this.buffer != null ? this.buffer.toString('base64'***REMOVED*** : '';
}

/**
 * @ignore
 * @api private
 */
Binary.prototype.toString = function(format***REMOVED*** {
  return this.buffer != null ? this.buffer.slice(0, this.position***REMOVED***.toString(format***REMOVED*** : '';
}

Binary.BUFFER_SIZE = 256;

/**
 * Default BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_DEFAULT = 0;
/**
 * Function BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_FUNCTION = 1;
/**
 * Byte Array BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_BYTE_ARRAY = 2;
/**
 * OLD UUID BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID_OLD = 3;
/**
 * UUID BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID = 4;
/**
 * MD5 BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_MD5 = 5;
/**
 * User BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_USER_DEFINED = 128;

/**
 * Expose.
 */
exports.Binary = Binary;


}, 



'binary_parser': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * Binary Parser.
 * Jonas Raoni Soares Silva
 * http://jsfromhell.com/classes/binary-parser [v1.0]
 */
var chr = String.fromCharCode;

var maxBits = [];
for (var i = 0; i < 64; i++***REMOVED*** {
	maxBits[i] = Math.pow(2, i***REMOVED***;
}

function BinaryParser (bigEndian, allowExceptions***REMOVED*** {
  if(!(this instanceof BinaryParser***REMOVED******REMOVED*** return new BinaryParser(bigEndian, allowExceptions***REMOVED***;
  
	this.bigEndian = bigEndian;
	this.allowExceptions = allowExceptions;
};

BinaryParser.warn = function warn (msg***REMOVED*** {
	if (this.allowExceptions***REMOVED*** {
		throw new Error(msg***REMOVED***;
***REMOVED***

	return 1;
};

BinaryParser.decodeFloat = function decodeFloat (data, precisionBits, exponentBits***REMOVED*** {
	var b = new this.Buffer(this.bigEndian, data***REMOVED***;

	b.checkBuffer(precisionBits + exponentBits + 1***REMOVED***;

	var bias = maxBits[exponentBits - 1] - 1
    , signal = b.readBits(precisionBits + exponentBits, 1***REMOVED***
    , exponent = b.readBits(precisionBits, exponentBits***REMOVED***
    , significand = 0
    , divisor = 2
    , curByte = b.buffer.length + (-precisionBits >> 3***REMOVED*** - 1;

	do {
		for (var byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; ( byteValue & mask ***REMOVED*** && ( significand += 1 / divisor ***REMOVED***, divisor *= 2 ***REMOVED***;
	} while (precisionBits -= startBit***REMOVED***;

	return exponent == ( bias << 1 ***REMOVED*** + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : ( 1 + signal * -2 ***REMOVED*** * ( exponent || significand ? !exponent ? Math.pow( 2, -bias + 1 ***REMOVED*** * significand : Math.pow( 2, exponent - bias ***REMOVED*** * ( 1 + significand ***REMOVED*** : 0 ***REMOVED***;
};

BinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian***REMOVED*** {
  var b = new this.Buffer(this.bigEndian || forceBigEndian, data***REMOVED***
      , x = b.readBits(0, bits***REMOVED***
      , max = maxBits[bits]; //max = Math.pow( 2, bits ***REMOVED***;
  
  return signed && x >= max / 2
      ? x - max
      : x;
};

BinaryParser.encodeFloat = function encodeFloat (data, precisionBits, exponentBits***REMOVED*** {
	var bias = maxBits[exponentBits - 1] - 1
    , minExp = -bias + 1
    , maxExp = bias
    , minUnnormExp = minExp - precisionBits
    , n = parseFloat(data***REMOVED***
    , status = isNaN(n***REMOVED*** || n == -Infinity || n == +Infinity ? n : 0
    ,	exp = 0
    , len = 2 * bias + 1 + precisionBits + 3
    , bin = new Array(len***REMOVED***
    , signal = (n = status !== 0 ? 0 : n***REMOVED*** < 0
    , intPart = Math.floor(n = Math.abs(n***REMOVED******REMOVED***
    , floatPart = n - intPart
    , lastBit
    , rounded
    , result
    , i
    , j;

	for (i = len; i; bin[--i] = 0***REMOVED***;

	for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2***REMOVED******REMOVED***;

	for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2***REMOVED*** >= 1***REMOVED*** - 0 ***REMOVED*** && --floatPart***REMOVED***;

	for (i = -1; ++i < len && !bin[i];***REMOVED***;

	if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i***REMOVED*** >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1***REMOVED******REMOVED******REMOVED*** + 1]***REMOVED*** {
		if (!(rounded = bin[lastBit]***REMOVED******REMOVED*** {
			for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]***REMOVED***;
		}

		for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0***REMOVED*** && (rounded = 0***REMOVED******REMOVED***;
	}

	for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];***REMOVED***;

	if ((exp = bias + 1 - i***REMOVED*** >= minExp && exp <= maxExp***REMOVED*** {
		++i;
***REMOVED*** else if (exp < minExp***REMOVED*** {
		exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"***REMOVED***;
		i = bias + 1 - (exp = minExp - 1***REMOVED***;
	}

	if (intPart || status !== 0***REMOVED*** {
		this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status***REMOVED***;
		exp = maxExp + 1;
		i = bias + 2;

		if (status == -Infinity***REMOVED*** {
			signal = 1;
  ***REMOVED*** else if (isNaN(status***REMOVED******REMOVED*** {
			bin[i] = 1;
  ***REMOVED***
	}

	for (n = Math.abs(exp + bias***REMOVED***, j = exponentBits + 1, result = ""; --j; result = (n % 2***REMOVED*** + result, n = n >>= 1***REMOVED***;

	for (n = 0, j = 0, i = (result = (signal ? "1" : "0"***REMOVED*** + result + bin.slice(i, i + precisionBits***REMOVED***.join(""***REMOVED******REMOVED***.length, r = []; i; j = (j + 1***REMOVED*** % 8***REMOVED*** {
		n += (1 << j***REMOVED*** * result.charAt(--i***REMOVED***;
		if (j == 7***REMOVED*** {
			r[r.length] = String.fromCharCode(n***REMOVED***;
			n = 0;
		}
	}

	r[r.length] = n
    ? String.fromCharCode(n***REMOVED***
    : "";

	return (this.bigEndian ? r.reverse(***REMOVED*** : r***REMOVED***.join(""***REMOVED***;
};

BinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian***REMOVED*** {
	var max = maxBits[bits];

  if (data >= max || data < -(max / 2***REMOVED******REMOVED*** {
    this.warn("encodeInt::overflow"***REMOVED***;
    data = 0;
***REMOVED***

	if (data < 0***REMOVED*** {
    data += max;
***REMOVED***

	for (var r = []; data; r[r.length] = String.fromCharCode(data % 256***REMOVED***, data = Math.floor(data / 256***REMOVED******REMOVED***;

	for (bits = -(-bits >> 3***REMOVED*** - r.length; bits--; r[r.length] = "\0"***REMOVED***;

  return ((this.bigEndian || forceBigEndian***REMOVED*** ? r.reverse(***REMOVED*** : r***REMOVED***.join(""***REMOVED***;
};

BinaryParser.toSmall    = function( data ***REMOVED***{ return this.decodeInt( data,  8, true  ***REMOVED***; };
BinaryParser.fromSmall  = function( data ***REMOVED***{ return this.encodeInt( data,  8, true  ***REMOVED***; };
BinaryParser.toByte     = function( data ***REMOVED***{ return this.decodeInt( data,  8, false ***REMOVED***; };
BinaryParser.fromByte   = function( data ***REMOVED***{ return this.encodeInt( data,  8, false ***REMOVED***; };
BinaryParser.toShort    = function( data ***REMOVED***{ return this.decodeInt( data, 16, true  ***REMOVED***; };
BinaryParser.fromShort  = function( data ***REMOVED***{ return this.encodeInt( data, 16, true  ***REMOVED***; };
BinaryParser.toWord     = function( data ***REMOVED***{ return this.decodeInt( data, 16, false ***REMOVED***; };
BinaryParser.fromWord   = function( data ***REMOVED***{ return this.encodeInt( data, 16, false ***REMOVED***; };
BinaryParser.toInt      = function( data ***REMOVED***{ return this.decodeInt( data, 32, true  ***REMOVED***; };
BinaryParser.fromInt    = function( data ***REMOVED***{ return this.encodeInt( data, 32, true  ***REMOVED***; };
BinaryParser.toLong     = function( data ***REMOVED***{ return this.decodeInt( data, 64, true  ***REMOVED***; };
BinaryParser.fromLong   = function( data ***REMOVED***{ return this.encodeInt( data, 64, true  ***REMOVED***; };
BinaryParser.toDWord    = function( data ***REMOVED***{ return this.decodeInt( data, 32, false ***REMOVED***; };
BinaryParser.fromDWord  = function( data ***REMOVED***{ return this.encodeInt( data, 32, false ***REMOVED***; };
BinaryParser.toQWord    = function( data ***REMOVED***{ return this.decodeInt( data, 64, true ***REMOVED***; };
BinaryParser.fromQWord  = function( data ***REMOVED***{ return this.encodeInt( data, 64, true ***REMOVED***; };
BinaryParser.toFloat    = function( data ***REMOVED***{ return this.decodeFloat( data, 23, 8   ***REMOVED***; };
BinaryParser.fromFloat  = function( data ***REMOVED***{ return this.encodeFloat( data, 23, 8   ***REMOVED***; };
BinaryParser.toDouble   = function( data ***REMOVED***{ return this.decodeFloat( data, 52, 11  ***REMOVED***; };
BinaryParser.fromDouble = function( data ***REMOVED***{ return this.encodeFloat( data, 52, 11  ***REMOVED***; };

// Factor out the encode so it can be shared by add_header and push_int32
BinaryParser.encode_int32 = function encode_int32 (number, asArray***REMOVED*** {
  var a, b, c, d, unsigned;
  unsigned = (number < 0***REMOVED*** ? (number + 0x100000000***REMOVED*** : number;
  a = Math.floor(unsigned / 0xffffff***REMOVED***;
  unsigned &= 0xffffff;
  b = Math.floor(unsigned / 0xffff***REMOVED***;
  unsigned &= 0xffff;
  c = Math.floor(unsigned / 0xff***REMOVED***;
  unsigned &= 0xff;
  d = Math.floor(unsigned***REMOVED***;
  return asArray ? [chr(a***REMOVED***, chr(b***REMOVED***, chr(c***REMOVED***, chr(d***REMOVED***] : chr(a***REMOVED*** + chr(b***REMOVED*** + chr(c***REMOVED*** + chr(d***REMOVED***;
};

BinaryParser.encode_int64 = function encode_int64 (number***REMOVED*** {
  var a, b, c, d, e, f, g, h, unsigned;
  unsigned = (number < 0***REMOVED*** ? (number + 0x10000000000000000***REMOVED*** : number;
  a = Math.floor(unsigned / 0xffffffffffffff***REMOVED***;
  unsigned &= 0xffffffffffffff;
  b = Math.floor(unsigned / 0xffffffffffff***REMOVED***;
  unsigned &= 0xffffffffffff;
  c = Math.floor(unsigned / 0xffffffffff***REMOVED***;
  unsigned &= 0xffffffffff;
  d = Math.floor(unsigned / 0xffffffff***REMOVED***;
  unsigned &= 0xffffffff;
  e = Math.floor(unsigned / 0xffffff***REMOVED***;
  unsigned &= 0xffffff;
  f = Math.floor(unsigned / 0xffff***REMOVED***;
  unsigned &= 0xffff;
  g = Math.floor(unsigned / 0xff***REMOVED***;
  unsigned &= 0xff;
  h = Math.floor(unsigned***REMOVED***;
  return chr(a***REMOVED*** + chr(b***REMOVED*** + chr(c***REMOVED*** + chr(d***REMOVED*** + chr(e***REMOVED*** + chr(f***REMOVED*** + chr(g***REMOVED*** + chr(h***REMOVED***;
};

/**
 * UTF8 methods
 */

// Take a raw binary string and return a utf8 string
BinaryParser.decode_utf8 = function decode_utf8 (binaryStr***REMOVED*** {
  var len = binaryStr.length
    , decoded = ''
    , i = 0
    , c = 0
    , c1 = 0
    , c2 = 0
    , c3;

  while (i < len***REMOVED*** {
    c = binaryStr.charCodeAt(i***REMOVED***;
    if (c < 128***REMOVED*** {
      decoded += String.fromCharCode(c***REMOVED***;
      i++;
  ***REMOVED*** else if ((c > 191***REMOVED*** && (c < 224***REMOVED******REMOVED*** {
	    c2 = binaryStr.charCodeAt(i+1***REMOVED***;
      decoded += String.fromCharCode(((c & 31***REMOVED*** << 6***REMOVED*** | (c2 & 63***REMOVED******REMOVED***;
      i += 2;
  ***REMOVED*** else {
	    c2 = binaryStr.charCodeAt(i+1***REMOVED***;
	    c3 = binaryStr.charCodeAt(i+2***REMOVED***;
      decoded += String.fromCharCode(((c & 15***REMOVED*** << 12***REMOVED*** | ((c2 & 63***REMOVED*** << 6***REMOVED*** | (c3 & 63***REMOVED******REMOVED***;
      i += 3;
  ***REMOVED***
***REMOVED***

  return decoded;
};

// Encode a cstring
BinaryParser.encode_cstring = function encode_cstring (s***REMOVED*** {
  return unescape(encodeURIComponent(s***REMOVED******REMOVED*** + BinaryParser.fromByte(0***REMOVED***;
};

// Take a utf8 string and return a binary string
BinaryParser.encode_utf8 = function encode_utf8 (s***REMOVED*** {
  var a = ""
    , c;

  for (var n = 0, len = s.length; n < len; n++***REMOVED*** {
    c = s.charCodeAt(n***REMOVED***;

    if (c < 128***REMOVED*** {
	    a += String.fromCharCode(c***REMOVED***;
  ***REMOVED*** else if ((c > 127***REMOVED*** && (c < 2048***REMOVED******REMOVED*** {
	    a += String.fromCharCode((c>>6***REMOVED*** | 192***REMOVED*** ;
	    a += String.fromCharCode((c&63***REMOVED*** | 128***REMOVED***;
  ***REMOVED*** else {
      a += String.fromCharCode((c>>12***REMOVED*** | 224***REMOVED***;
      a += String.fromCharCode(((c>>6***REMOVED*** & 63***REMOVED*** | 128***REMOVED***;
      a += String.fromCharCode((c&63***REMOVED*** | 128***REMOVED***;
  ***REMOVED***
***REMOVED***

  return a;
};

BinaryParser.hprint = function hprint (s***REMOVED*** {
  var number;

  for (var i = 0, len = s.length; i < len; i++***REMOVED*** {
    if (s.charCodeAt(i***REMOVED*** < 32***REMOVED*** {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;        
      process.stdout.write(number + " "***REMOVED***
  ***REMOVED*** else {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;
        process.stdout.write(number + " "***REMOVED***
  ***REMOVED***
***REMOVED***
  
  process.stdout.write("\n\n"***REMOVED***;
};

BinaryParser.ilprint = function hprint (s***REMOVED*** {
  var number;

  for (var i = 0, len = s.length; i < len; i++***REMOVED*** {
    if (s.charCodeAt(i***REMOVED*** < 32***REMOVED*** {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(10***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(10***REMOVED***;

      require('util'***REMOVED***.debug(number+' : '***REMOVED***;
  ***REMOVED*** else {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(10***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(10***REMOVED***;
      require('util'***REMOVED***.debug(number+' : '+ s.charAt(i***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

BinaryParser.hlprint = function hprint (s***REMOVED*** {
  var number;

  for (var i = 0, len = s.length; i < len; i++***REMOVED*** {
    if (s.charCodeAt(i***REMOVED*** < 32***REMOVED*** {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;
      require('util'***REMOVED***.debug(number+' : '***REMOVED***;
  ***REMOVED*** else {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;
      require('util'***REMOVED***.debug(number+' : '+ s.charAt(i***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * BinaryParser buffer constructor.
 */
function BinaryParserBuffer (bigEndian, buffer***REMOVED*** {
  this.bigEndian = bigEndian || 0;
  this.buffer = [];
  this.setBuffer(buffer***REMOVED***;
};

BinaryParserBuffer.prototype.setBuffer = function setBuffer (data***REMOVED*** {
  var l, i, b;

	if (data***REMOVED*** {
    i = l = data.length;
    b = this.buffer = new Array(l***REMOVED***;
		for (; i; b[l - i] = data.charCodeAt(--i***REMOVED******REMOVED***;
		this.bigEndian && b.reverse(***REMOVED***;
	}
};

BinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits***REMOVED*** {
	return this.buffer.length >= -(-neededBits >> 3***REMOVED***;
};

BinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits***REMOVED*** {
	if (!this.hasNeededBits(neededBits***REMOVED******REMOVED*** {
		throw new Error("checkBuffer::missing bytes"***REMOVED***;
***REMOVED***
};

BinaryParserBuffer.prototype.readBits = function readBits (start, length***REMOVED*** {
	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni***REMOVED***

	function shl (a, b***REMOVED*** {
		for (; b--; a = ((a %= 0x7fffffff + 1***REMOVED*** & 0x40000000***REMOVED*** == 0x40000000 ? a * 2 : (a - 0x40000000***REMOVED*** * 2 + 0x7fffffff + 1***REMOVED***;
		return a;
	}

	if (start < 0 || length <= 0***REMOVED*** {
		return 0;
***REMOVED***

	this.checkBuffer(start + length***REMOVED***;

  var offsetLeft
    , offsetRight = start % 8
    , curByte = this.buffer.length - ( start >> 3 ***REMOVED*** - 1
    , lastByte = this.buffer.length + ( -( start + length ***REMOVED*** >> 3 ***REMOVED***
    , diff = curByte - lastByte
    , sum = ((this.buffer[ curByte ] >> offsetRight***REMOVED*** & ((1 << (diff ? 8 - offsetRight : length***REMOVED******REMOVED*** - 1***REMOVED******REMOVED*** + (diff && (offsetLeft = (start + length***REMOVED*** % 8***REMOVED*** ? (this.buffer[lastByte++] & ((1 << offsetLeft***REMOVED*** - 1***REMOVED******REMOVED*** << (diff-- << 3***REMOVED*** - offsetRight : 0***REMOVED***;

	for(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3***REMOVED*** - offsetRight***REMOVED******REMOVED***;

	return sum;
};

/**
 * Expose.
 */
BinaryParser.Buffer = BinaryParserBuffer;

exports.BinaryParser = BinaryParser;

}, 



'bson': function(module, exports, global, require, undefined***REMOVED***{
  var Long = require('./long'***REMOVED***.Long
  , Double = require('./double'***REMOVED***.Double
  , Timestamp = require('./timestamp'***REMOVED***.Timestamp
  , ObjectID = require('./objectid'***REMOVED***.ObjectID
  , Symbol = require('./symbol'***REMOVED***.Symbol
  , Code = require('./code'***REMOVED***.Code
  , MinKey = require('./min_key'***REMOVED***.MinKey
  , MaxKey = require('./max_key'***REMOVED***.MaxKey
  , DBRef = require('./db_ref'***REMOVED***.DBRef
  , Binary = require('./binary'***REMOVED***.Binary
  , BinaryParser = require('./binary_parser'***REMOVED***.BinaryParser
  , writeIEEE754 = require('./float_parser'***REMOVED***.writeIEEE754
  , readIEEE754 = require('./float_parser'***REMOVED***.readIEEE754

// To ensure that 0.4 of node works correctly
var isDate = function isDate(d***REMOVED*** {
  return typeof d === 'object' && Object.prototype.toString.call(d***REMOVED*** === '[object Date]';
}

/**
 * Create a new BSON instance
 *
 * @class Represents the BSON Parser
 * @return {BSON} instance of BSON Parser.
 */
function BSON (***REMOVED*** {};

/**
 * @ignore
 * @api private
 */
// BSON MAX VALUES
BSON.BSON_INT32_MAX = 0x7FFFFFFF;
BSON.BSON_INT32_MIN = -0x80000000;

BSON.BSON_INT64_MAX = Math.pow(2, 63***REMOVED*** - 1;
BSON.BSON_INT64_MIN = -Math.pow(2, 63***REMOVED***;

// JS MAX PRECISE VALUES
BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.

// Internal long versions
var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000***REMOVED***;  // Any integer up to 2^53 can be precisely represented by a double.
var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000***REMOVED***;  // Any integer down to -2^53 can be precisely represented by a double.

/**
 * Number BSON Type
 *
 * @classconstant BSON_DATA_NUMBER
 **/
BSON.BSON_DATA_NUMBER = 1;
/**
 * String BSON Type
 *
 * @classconstant BSON_DATA_STRING
 **/
BSON.BSON_DATA_STRING = 2;
/**
 * Object BSON Type
 *
 * @classconstant BSON_DATA_OBJECT
 **/
BSON.BSON_DATA_OBJECT = 3;
/**
 * Array BSON Type
 *
 * @classconstant BSON_DATA_ARRAY
 **/
BSON.BSON_DATA_ARRAY = 4;
/**
 * Binary BSON Type
 *
 * @classconstant BSON_DATA_BINARY
 **/
BSON.BSON_DATA_BINARY = 5;
/**
 * ObjectID BSON Type
 *
 * @classconstant BSON_DATA_OID
 **/
BSON.BSON_DATA_OID = 7;
/**
 * Boolean BSON Type
 *
 * @classconstant BSON_DATA_BOOLEAN
 **/
BSON.BSON_DATA_BOOLEAN = 8;
/**
 * Date BSON Type
 *
 * @classconstant BSON_DATA_DATE
 **/
BSON.BSON_DATA_DATE = 9;
/**
 * null BSON Type
 *
 * @classconstant BSON_DATA_NULL
 **/
BSON.BSON_DATA_NULL = 10;
/**
 * RegExp BSON Type
 *
 * @classconstant BSON_DATA_REGEXP
 **/
BSON.BSON_DATA_REGEXP = 11;
/**
 * Code BSON Type
 *
 * @classconstant BSON_DATA_CODE
 **/
BSON.BSON_DATA_CODE = 13;
/**
 * Symbol BSON Type
 *
 * @classconstant BSON_DATA_SYMBOL
 **/
BSON.BSON_DATA_SYMBOL = 14;
/**
 * Code with Scope BSON Type
 *
 * @classconstant BSON_DATA_CODE_W_SCOPE
 **/
BSON.BSON_DATA_CODE_W_SCOPE = 15;
/**
 * 32 bit Integer BSON Type
 *
 * @classconstant BSON_DATA_INT
 **/
BSON.BSON_DATA_INT = 16;
/**
 * Timestamp BSON Type
 *
 * @classconstant BSON_DATA_TIMESTAMP
 **/
BSON.BSON_DATA_TIMESTAMP = 17;
/**
 * Long BSON Type
 *
 * @classconstant BSON_DATA_LONG
 **/
BSON.BSON_DATA_LONG = 18;
/**
 * MinKey BSON Type
 *
 * @classconstant BSON_DATA_MIN_KEY
 **/
BSON.BSON_DATA_MIN_KEY = 0xff;
/**
 * MaxKey BSON Type
 *
 * @classconstant BSON_DATA_MAX_KEY
 **/
BSON.BSON_DATA_MAX_KEY = 0x7f;

/**
 * Binary Default Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
 **/
BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
/**
 * Binary Function Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
 **/
BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
/**
 * Binary Byte Array Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
 **/
BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
/**
 * Binary UUID Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_UUID
 **/
BSON.BSON_BINARY_SUBTYPE_UUID = 3;
/**
 * Binary MD5 Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_MD5
 **/
BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
/**
 * Binary User Defined Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
 **/
BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param {Object} object the Javascript object to calculate the BSON byte size for.
 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false***REMOVED*****.
 * @return {Number} returns the number of bytes the BSON object will take up.
 * @api public
 */
BSON.calculateObjectSize = function calculateObjectSize(object, serializeFunctions***REMOVED*** {
  var totalLength = (4 + 1***REMOVED***;

  if(Array.isArray(object***REMOVED******REMOVED*** {
    for(var i = 0; i < object.length; i++***REMOVED*** {
      totalLength += calculateElement(i.toString(***REMOVED***, object[i], serializeFunctions***REMOVED***
  ***REMOVED***
***REMOVED*** else {
		// If we have toBSON defined, override the current object
		if(object.toBSON***REMOVED*** {
			object = object.toBSON(***REMOVED***;
		}

		// Calculate size
    for(var key in object***REMOVED*** {
      totalLength += calculateElement(key, object[key], serializeFunctions***REMOVED***
  ***REMOVED***
***REMOVED***

  return totalLength;
}

/**
 * @ignore
 * @api private
 */
function calculateElement(name, value, serializeFunctions***REMOVED*** {
  var isBuffer = typeof Buffer !== 'undefined';

  switch(typeof value***REMOVED*** {
    case 'string':
      return 1 + (!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1 + 4 + (!isBuffer ? numberOfBytes(value***REMOVED*** : Buffer.byteLength(value, 'utf8'***REMOVED******REMOVED*** + 1;
    case 'number':
      if(Math.floor(value***REMOVED*** === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX***REMOVED*** {
        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX***REMOVED*** { // 32 bit
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (4 + 1***REMOVED***;
      ***REMOVED*** else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else {  // 64 bit
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
    ***REMOVED***
    case 'undefined':
      return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1***REMOVED***;
    case 'boolean':
      return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1 + 1***REMOVED***;
    case 'object':
      if(value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1***REMOVED***;
    ***REMOVED*** else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (12 + 1***REMOVED***;
    ***REMOVED*** else if(value instanceof Date || isDate(value***REMOVED******REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
    ***REMOVED*** else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value***REMOVED******REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1 + 4 + 1***REMOVED*** + value.length;
    ***REMOVED*** else if(value instanceof Long || value instanceof Double || value instanceof Timestamp
          || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
    ***REMOVED*** else if(value instanceof Code || value['_bsontype'] == 'Code'***REMOVED*** {
        // Calculate size depending on the availability of a scope
        if(value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.code.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.code.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
      ***REMOVED*** else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + (!isBuffer ? numberOfBytes(value.code.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.code.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1;
      ***REMOVED***
    ***REMOVED*** else if(value instanceof Binary || value['_bsontype'] == 'Binary'***REMOVED*** {
        // Check what kind of subtype we have
        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (value.position + 1 + 4 + 1 + 4***REMOVED***;
      ***REMOVED*** else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (value.position + 1 + 4 + 1***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else if(value instanceof Symbol || value['_bsontype'] == 'Symbol'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + ((!isBuffer ? numberOfBytes(value.value***REMOVED*** : Buffer.byteLength(value.value, 'utf8'***REMOVED******REMOVED*** + 4 + 1 + 1***REMOVED***;
    ***REMOVED*** else if(value instanceof DBRef || value['_bsontype'] == 'DBRef'***REMOVED*** {
        // Set up correct object for serialization
        var ordered_values = {
            '$ref': value.namespace
          , '$id' : value.oid
      ***REMOVED***;

        // Add db reference if it exists
        if(null != value.db***REMOVED*** {
          ordered_values['$db'] = value.db;
      ***REMOVED***

        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + BSON.calculateObjectSize(ordered_values, serializeFunctions***REMOVED***;
    ***REMOVED*** else if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]'***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + (!isBuffer ? numberOfBytes(value.source***REMOVED*** : Buffer.byteLength(value.source, 'utf8'***REMOVED******REMOVED*** + 1
            + (value.global ? 1 : 0***REMOVED*** + (value.ignoreCase ? 1 : 0***REMOVED*** + (value.multiline ? 1 : 0***REMOVED*** + 1
    ***REMOVED*** else {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + BSON.calculateObjectSize(value, serializeFunctions***REMOVED*** + 1;
    ***REMOVED***
    case 'function':
      // WTF for 0.4.X where typeof /someregexp/ === 'function'
      if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]' || String.call(value***REMOVED*** == '[object RegExp]'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + (!isBuffer ? numberOfBytes(value.source***REMOVED*** : Buffer.byteLength(value.source, 'utf8'***REMOVED******REMOVED*** + 1
          + (value.global ? 1 : 0***REMOVED*** + (value.ignoreCase ? 1 : 0***REMOVED*** + (value.multiline ? 1 : 0***REMOVED*** + 1
    ***REMOVED*** else {
        if(serializeFunctions && value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
      ***REMOVED*** else if(serializeFunctions***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + (!isBuffer ? numberOfBytes(value.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1;
      ***REMOVED***
    ***REMOVED***
***REMOVED***

  return 0;
}

/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
 * @param {Number} index the index in the buffer where we wish to start serializing into.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Number} returns the new write index in the Buffer.
 * @api public
 */
BSON.serializeWithBufferAndIndex = function serializeWithBufferAndIndex(object, checkKeys, buffer, index, serializeFunctions***REMOVED*** {
  // Default setting false
  serializeFunctions = serializeFunctions == null ? false : serializeFunctions;
  // Write end information (length of the object***REMOVED***
  var size = buffer.length;
  // Write the size of the object
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8***REMOVED*** & 0xff;
  buffer[index++] = (size >> 16***REMOVED*** & 0xff;
  buffer[index++] = (size >> 24***REMOVED*** & 0xff;
  return serializeObject(object, checkKeys, buffer, index, serializeFunctions***REMOVED*** - 1;
}

/**
 * @ignore
 * @api private
 */
var serializeObject = function(object, checkKeys, buffer, index, serializeFunctions***REMOVED*** {
  // Process the object
  if(Array.isArray(object***REMOVED******REMOVED*** {
    for(var i = 0; i < object.length; i++***REMOVED*** {
      index = packElement(i.toString(***REMOVED***, object[i], checkKeys, buffer, index, serializeFunctions***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
		// If we have toBSON defined, override the current object
		if(object.toBSON***REMOVED*** {
			object = object.toBSON(***REMOVED***;
		}

		// Serialize the object
    for(var key in object***REMOVED*** {
      // Check the key and throw error if it's illegal
      if (key != '$db' && key != '$ref' && key != '$id'***REMOVED*** {
        // dollars and dots ok
        BSON.checkKey(key, !checkKeys***REMOVED***;
    ***REMOVED***

      // Pack the element
      index = packElement(key, object[key], checkKeys, buffer, index, serializeFunctions***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Write zero
  buffer[index++] = 0;
  return index;
}

var stringToBytes = function(str***REMOVED*** {
  var ch, st, re = [];
  for (var i = 0; i < str.length; i++ ***REMOVED*** {
    ch = str.charCodeAt(i***REMOVED***;  // get char
    st = [];                 // set up "stack"
    do {
      st.push( ch & 0xFF ***REMOVED***;  // push byte to stack
      ch = ch >> 8;          // shift value down by 1 byte
  ***REMOVED***
    while ( ch ***REMOVED***;
    // add stack contents to result
    // done because chars have "wrong" endianness
    re = re.concat( st.reverse(***REMOVED*** ***REMOVED***;
***REMOVED***
  // return an array of bytes
  return re;
}

var numberOfBytes = function(str***REMOVED*** {
  var ch, st, re = 0;
  for (var i = 0; i < str.length; i++ ***REMOVED*** {
    ch = str.charCodeAt(i***REMOVED***;  // get char
    st = [];                 // set up "stack"
    do {
      st.push( ch & 0xFF ***REMOVED***;  // push byte to stack
      ch = ch >> 8;          // shift value down by 1 byte
  ***REMOVED***
    while ( ch ***REMOVED***;
    // add stack contents to result
    // done because chars have "wrong" endianness
    re = re + st.length;
***REMOVED***
  // return an array of bytes
  return re;
}

/**
 * @ignore
 * @api private
 */
var writeToTypedArray = function(buffer, string, index***REMOVED*** {
  var bytes = stringToBytes(string***REMOVED***;
  for(var i = 0; i < bytes.length; i++***REMOVED*** {
    buffer[index + i] = bytes[i];
***REMOVED***
  return bytes.length;
}

/**
 * @ignore
 * @api private
 */
var supportsBuffer = typeof Buffer != 'undefined';

/**
 * @ignore
 * @api private
 */
var packElement = function(name, value, checkKeys, buffer, index, serializeFunctions***REMOVED*** {
  var startIndex = index;

  switch(typeof value***REMOVED*** {
    case 'string':
      // Encode String type
      buffer[index++] = BSON.BSON_DATA_STRING;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;

      // Calculate size
      var size = supportsBuffer ? Buffer.byteLength(value***REMOVED*** + 1 : numberOfBytes(value***REMOVED*** + 1;
      // Write the size of the string to buffer
      buffer[index + 3] = (size >> 24***REMOVED*** & 0xff;
      buffer[index + 2] = (size >> 16***REMOVED*** & 0xff;
      buffer[index + 1] = (size >> 8***REMOVED*** & 0xff;
      buffer[index] = size & 0xff;
      // Ajust the index
      index = index + 4;
      // Write the string
      supportsBuffer ? buffer.write(value, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, value, index***REMOVED***;
      // Update index
      index = index + size - 1;
      // Write zero
      buffer[index++] = 0;
      // Return index
      return index;
    case 'number':
      // We have an integer value
      if(Math.floor(value***REMOVED*** === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX***REMOVED*** {
        // If the value fits in 32 bits encode as int, if it fits in a double
        // encode it as a double, otherwise long
        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX***REMOVED*** {
          // Set int type 32 bits or less
          buffer[index++] = BSON.BSON_DATA_INT;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Write the int value
          buffer[index++] = value & 0xff;
          buffer[index++] = (value >> 8***REMOVED*** & 0xff;
          buffer[index++] = (value >> 16***REMOVED*** & 0xff;
          buffer[index++] = (value >> 24***REMOVED*** & 0xff;
      ***REMOVED*** else if(value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX***REMOVED*** {
          // Encode as double
          buffer[index++] = BSON.BSON_DATA_NUMBER;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Write float
          writeIEEE754(buffer, value, index, 'little', 52, 8***REMOVED***;
          // Ajust index
          index = index + 8;
      ***REMOVED*** else {
          // Set long type
          buffer[index++] = BSON.BSON_DATA_LONG;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          var longVal = Long.fromNumber(value***REMOVED***;
          var lowBits = longVal.getLowBits(***REMOVED***;
          var highBits = longVal.getHighBits(***REMOVED***;
          // Encode low bits
          buffer[index++] = lowBits & 0xff;
          buffer[index++] = (lowBits >> 8***REMOVED*** & 0xff;
          buffer[index++] = (lowBits >> 16***REMOVED*** & 0xff;
          buffer[index++] = (lowBits >> 24***REMOVED*** & 0xff;
          // Encode high bits
          buffer[index++] = highBits & 0xff;
          buffer[index++] = (highBits >> 8***REMOVED*** & 0xff;
          buffer[index++] = (highBits >> 16***REMOVED*** & 0xff;
          buffer[index++] = (highBits >> 24***REMOVED*** & 0xff;
      ***REMOVED***
    ***REMOVED*** else {
        // Encode as double
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write float
        writeIEEE754(buffer, value, index, 'little', 52, 8***REMOVED***;
        // Ajust index
        index = index + 8;
    ***REMOVED***

      return index;
    case 'undefined':
      // Set long type
      buffer[index++] = BSON.BSON_DATA_NULL;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      return index;
    case 'boolean':
      // Write the type
      buffer[index++] = BSON.BSON_DATA_BOOLEAN;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      // Encode the boolean value
      buffer[index++] = value ? 1 : 0;
      return index;
    case 'object':
      if(value === null || value instanceof MinKey || value instanceof MaxKey
          || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey'***REMOVED*** {
        // Write the type of either min or max key
        if(value === null***REMOVED*** {
          buffer[index++] = BSON.BSON_DATA_NULL;
      ***REMOVED*** else if(value instanceof MinKey***REMOVED*** {
          buffer[index++] = BSON.BSON_DATA_MIN_KEY;
      ***REMOVED*** else {
          buffer[index++] = BSON.BSON_DATA_MAX_KEY;
      ***REMOVED***

        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        return index;
    ***REMOVED*** else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_OID;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write objectid
        supportsBuffer ? buffer.write(value.id, index, 'binary'***REMOVED*** : writeToTypedArray(buffer, value.id, index***REMOVED***;
        // Ajust index
        index = index + 12;
        return index;
    ***REMOVED*** else if(value instanceof Date || isDate(value***REMOVED******REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_DATE;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the date
        var dateInMilis = Long.fromNumber(value.getTime(***REMOVED******REMOVED***;
        var lowBits = dateInMilis.getLowBits(***REMOVED***;
        var highBits = dateInMilis.getHighBits(***REMOVED***;
        // Encode low bits
        buffer[index++] = lowBits & 0xff;
        buffer[index++] = (lowBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 24***REMOVED*** & 0xff;
        // Encode high bits
        buffer[index++] = highBits & 0xff;
        buffer[index++] = (highBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 24***REMOVED*** & 0xff;
        return index;
    ***REMOVED*** else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value***REMOVED******REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_BINARY;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Get size of the buffer (current write point***REMOVED***
        var size = value.length;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write the default subtype
        buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
        // Copy the content form the binary field to the buffer
        value.copy(buffer, index, 0, size***REMOVED***;
        // Adjust the index
        index = index + size;
        return index;
    ***REMOVED*** else if(value instanceof Long || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp'***REMOVED*** {
        // Write the type
        buffer[index++] = value instanceof Long ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write the date
        var lowBits = value.getLowBits(***REMOVED***;
        var highBits = value.getHighBits(***REMOVED***;
        // Encode low bits
        buffer[index++] = lowBits & 0xff;
        buffer[index++] = (lowBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 24***REMOVED*** & 0xff;
        // Encode high bits
        buffer[index++] = highBits & 0xff;
        buffer[index++] = (highBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 24***REMOVED*** & 0xff;
        return index;
    ***REMOVED*** else if(value instanceof Double || value['_bsontype'] == 'Double'***REMOVED*** {
        // Encode as double
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write float
        writeIEEE754(buffer, value, index, 'little', 52, 8***REMOVED***;
        // Ajust index
        index = index + 8;
        return index;
    ***REMOVED*** else if(value instanceof Code || value['_bsontype'] == 'Code'***REMOVED*** {
        if(value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          // Write the type
          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Calculate the scope size
          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
          // Function string
          var functionString = value.code.toString(***REMOVED***;
          // Function Size
          var codeSize = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;

          // Calculate full size of the object
          var totalSize = 4 + codeSize + scopeSize + 4;

          // Write the total size of the object
          buffer[index++] = totalSize & 0xff;
          buffer[index++] = (totalSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 24***REMOVED*** & 0xff;

          // Write the size of the string to buffer
          buffer[index++] = codeSize & 0xff;
          buffer[index++] = (codeSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 24***REMOVED*** & 0xff;

          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + codeSize - 1;
          // Write zero
          buffer[index++] = 0;
          // Serialize the scope object
          var scopeObjectBuffer = supportsBuffer ? new Buffer(scopeSize***REMOVED*** : new Uint8Array(new ArrayBuffer(scopeSize***REMOVED******REMOVED***;
          // Execute the serialization into a seperate buffer
          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions***REMOVED***;

          // Adjusted scope Size (removing the header***REMOVED***
          var scopeDocSize = scopeSize;
          // Write scope object size
          buffer[index++] = scopeDocSize & 0xff;
          buffer[index++] = (scopeDocSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 24***REMOVED*** & 0xff;

          // Write the scopeObject into the buffer
          supportsBuffer ? scopeObjectBuffer.copy(buffer, index, 0, scopeSize***REMOVED*** : buffer.set(scopeObjectBuffer, index***REMOVED***;
          // Adjust index, removing the empty size of the doc (5 bytes 0000000005***REMOVED***
          index = index + scopeDocSize - 5;
          // Write trailing zero
          buffer[index++] = 0;
          return index
      ***REMOVED*** else {
          buffer[index++] = BSON.BSON_DATA_CODE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Function string
          var functionString = value.code.toString(***REMOVED***;
          // Function Size
          var size = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;
          // Write the size of the string to buffer
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8***REMOVED*** & 0xff;
          buffer[index++] = (size >> 16***REMOVED*** & 0xff;
          buffer[index++] = (size >> 24***REMOVED*** & 0xff;
          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + size - 1;
          // Write zero
          buffer[index++] = 0;
          return index;
      ***REMOVED***
    ***REMOVED*** else if(value instanceof Binary || value['_bsontype'] == 'Binary'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_BINARY;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Extract the buffer
        var data = value.value(true***REMOVED***;
        // Calculate size
        var size = value.position;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write the subtype to the buffer
        buffer[index++] = value.sub_type;

        // If we have binary type 2 the 4 first bytes are the size
        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8***REMOVED*** & 0xff;
          buffer[index++] = (size >> 16***REMOVED*** & 0xff;
          buffer[index++] = (size >> 24***REMOVED*** & 0xff;
      ***REMOVED***

        // Write the data to the object
        supportsBuffer ? data.copy(buffer, index, 0, value.position***REMOVED*** : buffer.set(data, index***REMOVED***;
        // Ajust index
        index = index + value.position;
        return index;
    ***REMOVED*** else if(value instanceof Symbol || value['_bsontype'] == 'Symbol'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_SYMBOL;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Calculate size
        var size = supportsBuffer ? Buffer.byteLength(value.value***REMOVED*** + 1 : numberOfBytes(value.value***REMOVED*** + 1;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write the string
        buffer.write(value.value, index, 'utf8'***REMOVED***;
        // Update index
        index = index + size - 1;
        // Write zero
        buffer[index++] = 0x00;
        return index;
    ***REMOVED*** else if(value instanceof DBRef || value['_bsontype'] == 'DBRef'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_OBJECT;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Set up correct object for serialization
        var ordered_values = {
            '$ref': value.namespace
          , '$id' : value.oid
      ***REMOVED***;

        // Add db reference if it exists
        if(null != value.db***REMOVED*** {
          ordered_values['$db'] = value.db;
      ***REMOVED***

        // Message size
        var size = BSON.calculateObjectSize(ordered_values, serializeFunctions***REMOVED***;
        // Serialize the object
        var endIndex = BSON.serializeWithBufferAndIndex(ordered_values, checkKeys, buffer, index, serializeFunctions***REMOVED***;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write zero for object
        buffer[endIndex++] = 0x00;
        // Return the end index
        return endIndex;
    ***REMOVED*** else if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_REGEXP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the regular expression string
        supportsBuffer ? buffer.write(value.source, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, value.source, index***REMOVED***;
        // Adjust the index
        index = index + (supportsBuffer ? Buffer.byteLength(value.source***REMOVED*** : numberOfBytes(value.source***REMOVED******REMOVED***;
        // Write zero
        buffer[index++] = 0x00;
        // Write the parameters
        if(value.global***REMOVED*** buffer[index++] = 0x73; // s
        if(value.ignoreCase***REMOVED*** buffer[index++] = 0x69; // i
        if(value.multiline***REMOVED*** buffer[index++] = 0x6d; // m
        // Add ending zero
        buffer[index++] = 0x00;
        return index;
    ***REMOVED*** else {
        // Write the type
        buffer[index++] = Array.isArray(value***REMOVED*** ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Adjust the index
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
	      var endIndex = serializeObject(value, checkKeys, buffer, index + 4, serializeFunctions***REMOVED***;
        // Write size
        var size = endIndex - index;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        return endIndex;
    ***REMOVED***
    case 'function':
      // WTF for 0.4.X where typeof /someregexp/ === 'function'
      if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]' || String.call(value***REMOVED*** == '[object RegExp]'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_REGEXP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the regular expression string
        buffer.write(value.source, index, 'utf8'***REMOVED***;
        // Adjust the index
        index = index + (supportsBuffer ? Buffer.byteLength(value.source***REMOVED*** : numberOfBytes(value.source***REMOVED******REMOVED***;
        // Write zero
        buffer[index++] = 0x00;
        // Write the parameters
        if(value.global***REMOVED*** buffer[index++] = 0x73; // s
        if(value.ignoreCase***REMOVED*** buffer[index++] = 0x69; // i
        if(value.multiline***REMOVED*** buffer[index++] = 0x6d; // m
        // Add ending zero
        buffer[index++] = 0x00;
        return index;
    ***REMOVED*** else {
        if(serializeFunctions && value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          // Write the type
          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Calculate the scope size
          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
          // Function string
          var functionString = value.toString(***REMOVED***;
          // Function Size
          var codeSize = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;

          // Calculate full size of the object
          var totalSize = 4 + codeSize + scopeSize;

          // Write the total size of the object
          buffer[index++] = totalSize & 0xff;
          buffer[index++] = (totalSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 24***REMOVED*** & 0xff;

          // Write the size of the string to buffer
          buffer[index++] = codeSize & 0xff;
          buffer[index++] = (codeSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 24***REMOVED*** & 0xff;

          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + codeSize - 1;
          // Write zero
          buffer[index++] = 0;
          // Serialize the scope object
          var scopeObjectBuffer = new Buffer(scopeSize***REMOVED***;
          // Execute the serialization into a seperate buffer
          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions***REMOVED***;

          // Adjusted scope Size (removing the header***REMOVED***
          var scopeDocSize = scopeSize - 4;
          // Write scope object size
          buffer[index++] = scopeDocSize & 0xff;
          buffer[index++] = (scopeDocSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 24***REMOVED*** & 0xff;

          // Write the scopeObject into the buffer
          scopeObjectBuffer.copy(buffer, index, 0, scopeSize***REMOVED***;

          // Adjust index, removing the empty size of the doc (5 bytes 0000000005***REMOVED***
          index = index + scopeDocSize - 5;
          // Write trailing zero
          buffer[index++] = 0;
          return index
      ***REMOVED*** else if(serializeFunctions***REMOVED*** {
          buffer[index++] = BSON.BSON_DATA_CODE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Function string
          var functionString = value.toString(***REMOVED***;
          // Function Size
          var size = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;
          // Write the size of the string to buffer
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8***REMOVED*** & 0xff;
          buffer[index++] = (size >> 16***REMOVED*** & 0xff;
          buffer[index++] = (size >> 24***REMOVED*** & 0xff;
          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + size - 1;
          // Write zero
          buffer[index++] = 0;
          return index;
      ***REMOVED***
    ***REMOVED***
***REMOVED***

  // If no value to serialize
  return index;
}

/**
 * Serialize a Javascript object.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore***REMOVED*****.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Buffer} returns the Buffer object containing the serialized object.
 * @api public
 */
BSON.serialize = function(object, checkKeys, asBuffer, serializeFunctions***REMOVED*** {
  // Throw error if we are trying serialize an illegal type
  if(object == null || typeof object != 'object' || Array.isArray(object***REMOVED******REMOVED*** 
    throw new Error("Only javascript objects supported"***REMOVED***;
  
  // Emoty target buffer
  var buffer = null;
  // Calculate the size of the object
  var size = BSON.calculateObjectSize(object, serializeFunctions***REMOVED***;
  // Fetch the best available type for storing the binary data
  if(buffer = typeof Buffer != 'undefined'***REMOVED*** {
    buffer = new Buffer(size***REMOVED***;
    asBuffer = true;
***REMOVED*** else if(typeof Uint8Array != 'undefined'***REMOVED*** {
    buffer = new Uint8Array(new ArrayBuffer(size***REMOVED******REMOVED***;
***REMOVED*** else {
    buffer = new Array(size***REMOVED***;
***REMOVED***

  // If asBuffer is false use typed arrays
  BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, 0, serializeFunctions***REMOVED***;
  return buffer;
}

/**
 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
 *
 * @ignore
 * @api private
 */
var functionCache = BSON.functionCache = {};

/**
 * Crc state variables shared by function
 *
 * @ignore
 * @api private
 */
var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

/**
 * CRC32 hash method, Fast and enough versitility for our usage
 *
 * @ignore
 * @api private
 */
var crc32 =  function(string, start, end***REMOVED*** {
  var crc = 0
  var x = 0;
  var y = 0;
  crc = crc ^ (-1***REMOVED***;

  for(var i = start, iTop = end; i < iTop;i++***REMOVED*** {
  	y = (crc ^ string[i]***REMOVED*** & 0xFF;
    x = table[y];
  	crc = (crc >>> 8***REMOVED*** ^ x;
***REMOVED***

  return crc ^ (-1***REMOVED***;
}

/**
 * Deserialize stream data as BSON documents.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
 *
 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
 * @param {Number} numberOfDocuments number of documents to deserialize.
 * @param {Array} documents an array where to store the deserialized documents.
 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
 * @api public
 */
BSON.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options***REMOVED*** {
  // if(numberOfDocuments !== documents.length***REMOVED*** throw new Error("Number of expected results back is less than the number of documents"***REMOVED***;
  options = options != null ? options : {};
  var index = startIndex;
  // Loop over all documents
  for(var i = 0; i < numberOfDocuments; i++***REMOVED*** {
    // Find size of the document
    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
    // Update options with index
    options['index'] = index;
    // Parse the document at this point
    documents[docStartIndex + i] = BSON.deserialize(data, options***REMOVED***;
    // Adjust index by the document size
    index = index + size;
***REMOVED***

  // Return object containing end index of parsing and list of documents
  return index;
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEvalWithHash = function(functionCache, hash, functionString, object***REMOVED*** {
  // Contains the value we are going to set
  var value = null;

  // Check for cache hit, eval if missing and return cached function
  if(functionCache[hash] == null***REMOVED*** {
    eval("value = " + functionString***REMOVED***;
    functionCache[hash] = value;
***REMOVED***
  // Set the object
  return functionCache[hash].bind(object***REMOVED***;
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEval = function(functionString***REMOVED*** {
  // Contains the value we are going to set
  var value = null;
  // Eval the function
  eval("value = " + functionString***REMOVED***;
  return value;
}

/**
 * Convert Uint8Array to String
 *
 * @ignore
 * @api private
 */
var convertUint8ArrayToUtf8String = function(byteArray, startIndex, endIndex***REMOVED*** {
  return BinaryParser.decode_utf8(convertArraytoUtf8BinaryString(byteArray, startIndex, endIndex***REMOVED******REMOVED***;
}

var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex***REMOVED*** {
  var result = "";
  for(var i = startIndex; i < endIndex; i++***REMOVED*** {
    result = result + String.fromCharCode(byteArray[i]***REMOVED***;
***REMOVED***

  return result;
};

/**
 * Deserialize data as BSON.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
 *
 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @param {Boolean} [isArray] ignore used for recursive parsing.
 * @return {Object} returns the deserialized Javascript Object.
 * @api public
 */
BSON.deserialize = function(buffer, options, isArray***REMOVED*** {
  // Options
  options = options == null ? {} : options;
  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
  var promoteLongs = options['promoteLongs'] || true;

  // Validate that we have at least 4 bytes of buffer
  if(buffer.length < 5***REMOVED*** throw new Error("corrupt bson message < 5 bytes long"***REMOVED***;

  // Set up index
  var index = typeof options['index'] == 'number' ? options['index'] : 0;
  // Reads in a C style string
  var readCStyleString = function(***REMOVED*** {
    // Get the start search index
    var i = index;
    // Locate the end of the c string
    while(buffer[i] !== 0x00***REMOVED*** { i++ }
    // Grab utf8 encoded string
    var string = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, i***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, i***REMOVED***;
    // Update index position
    index = i + 1;
    // Return string
    return string;
***REMOVED***

  // Create holding object
  var object = isArray ? [] : {};

  // Read the document size
  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;

  // Ensure buffer is valid size
  if(size < 5 || size > buffer.length***REMOVED*** throw new Error("corrupt bson message"***REMOVED***;

  // While we have more left data left keep parsing
  while(true***REMOVED*** {
    // Read the type
    var elementType = buffer[index++];
    // If we get a zero it's the last byte, exit
    if(elementType == 0***REMOVED*** break;
    // Read the name of the field
    var name = readCStyleString(***REMOVED***;
    // Switch on the type
    switch(elementType***REMOVED*** {
      case BSON.BSON_DATA_OID:
        var string = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('binary', index, index + 12***REMOVED*** : convertArraytoUtf8BinaryString(buffer, index, index + 12***REMOVED***;
        // Decode the oid
        object[name] = new ObjectID(string***REMOVED***;
        // Update index
        index = index + 12;
        break;
      case BSON.BSON_DATA_STRING:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Add string to object
        object[name] = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, index + stringSize - 1***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1***REMOVED***;
        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_INT:
        // Decode the 32bit value
        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        break;
      case BSON.BSON_DATA_NUMBER:
        // Decode the double value
        object[name] = readIEEE754(buffer, index, 'little', 52, 8***REMOVED***;
        // Update the index
        index = index + 8;
        break;
      case BSON.BSON_DATA_DATE:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Set date object
        object[name] = new Date(new Long(lowBits, highBits***REMOVED***.toNumber(***REMOVED******REMOVED***;
        break;
      case BSON.BSON_DATA_BOOLEAN:
        // Parse the boolean value
        object[name] = buffer[index++] == 1;
        break;
      case BSON.BSON_DATA_NULL:
        // Parse the boolean value
        object[name] = null;
        break;
      case BSON.BSON_DATA_BINARY:
        // Decode the size of the binary blob
        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Decode the subtype
        var subType = buffer[index++];
        // Decode as raw Buffer object if options specifies it
        if(buffer['slice'] != null***REMOVED*** {
          // If we have subtype 2 skip the 4 bytes for the size
          if(subType == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        ***REMOVED***
          // Slice the data
          object[name] = new Binary(buffer.slice(index, index + binarySize***REMOVED***, subType***REMOVED***;
      ***REMOVED*** else {
          var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize***REMOVED******REMOVED*** : new Array(binarySize***REMOVED***;
          // If we have subtype 2 skip the 4 bytes for the size
          if(subType == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        ***REMOVED***
          // Copy the data
          for(var i = 0; i < binarySize; i++***REMOVED*** {
            _buffer[i] = buffer[index + i];
        ***REMOVED***
          // Create the binary object
          object[name] = new Binary(_buffer, subType***REMOVED***;
      ***REMOVED***
        // Update the index
        index = index + binarySize;
        break;
      case BSON.BSON_DATA_ARRAY:
        options['index'] = index;
        // Decode the size of the array document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Set the array to the object
        object[name] = BSON.deserialize(buffer, options, true***REMOVED***;
        // Adjust the index
        index = index + objectSize;
        break;
      case BSON.BSON_DATA_OBJECT:
        options['index'] = index;
        // Decode the size of the object document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Set the array to the object
        object[name] = BSON.deserialize(buffer, options, false***REMOVED***;
        // Adjust the index
        index = index + objectSize;
        break;
      case BSON.BSON_DATA_REGEXP:
        // Create the regexp
        var source = readCStyleString(***REMOVED***;
        var regExpOptions = readCStyleString(***REMOVED***;
        // For each option add the corresponding one for javascript
        var optionsArray = new Array(regExpOptions.length***REMOVED***;

        // Parse options
        for(var i = 0; i < regExpOptions.length; i++***REMOVED*** {
          switch(regExpOptions[i]***REMOVED*** {
            case 'm':
              optionsArray[i] = 'm';
              break;
            case 's':
              optionsArray[i] = 'g';
              break;
            case 'i':
              optionsArray[i] = 'i';
              break;
        ***REMOVED***
      ***REMOVED***

        object[name] = new RegExp(source, optionsArray.join(''***REMOVED******REMOVED***;
        break;
      case BSON.BSON_DATA_LONG:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Create long object
        var long = new Long(lowBits, highBits***REMOVED***; 
        // Promote the long if possible
        if(promoteLongs***REMOVED*** {
          object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG***REMOVED*** && long.greaterThanOrEqual(JS_INT_MIN_LONG***REMOVED*** ? long.toNumber(***REMOVED*** : long;
      ***REMOVED*** else {
          object[name] = long;
      ***REMOVED***
        break;
      case BSON.BSON_DATA_SYMBOL:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Add string to object
        object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1***REMOVED******REMOVED***;
        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_TIMESTAMP:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Set the object
        object[name] = new Timestamp(lowBits, highBits***REMOVED***;
        break;
      case BSON.BSON_DATA_MIN_KEY:
        // Parse the object
        object[name] = new MinKey(***REMOVED***;
        break;
      case BSON.BSON_DATA_MAX_KEY:
        // Parse the object
        object[name] = new MaxKey(***REMOVED***;
        break;
      case BSON.BSON_DATA_CODE:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Function string
        var functionString = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, index + stringSize - 1***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1***REMOVED***;

        // If we are evaluating the functions
        if(evalFunctions***REMOVED*** {
          // Contains the value we are going to set
          var value = null;
          // If we have cache enabled let's look for the md5 of the function in the cache
          if(cacheFunctions***REMOVED*** {
            var hash = cacheFunctionsCrc32 ? crc32(functionString***REMOVED*** : functionString;
            // Got to do this to avoid V8 deoptimizing the call due to finding eval
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object***REMOVED***;
        ***REMOVED*** else {
            // Set directly
            object[name] = isolateEval(functionString***REMOVED***;
        ***REMOVED***
      ***REMOVED*** else {
          object[name]  = new Code(functionString, {}***REMOVED***;
      ***REMOVED***

        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_CODE_W_SCOPE:
        // Read the content of the field
        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Javascript function
        var functionString = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, index + stringSize - 1***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1***REMOVED***;
        // Update parse index position
        index = index + stringSize;
        // Parse the element
        options['index'] = index;
        // Decode the size of the object document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Decode the scope object
        var scopeObject = BSON.deserialize(buffer, options, false***REMOVED***;
        // Adjust the index
        index = index + objectSize;

        // If we are evaluating the functions
        if(evalFunctions***REMOVED*** {
          // Contains the value we are going to set
          var value = null;
          // If we have cache enabled let's look for the md5 of the function in the cache
          if(cacheFunctions***REMOVED*** {
            var hash = cacheFunctionsCrc32 ? crc32(functionString***REMOVED*** : functionString;
            // Got to do this to avoid V8 deoptimizing the call due to finding eval
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object***REMOVED***;
        ***REMOVED*** else {
            // Set directly
            object[name] = isolateEval(functionString***REMOVED***;
        ***REMOVED***

          // Set the scope on the object
          object[name].scope = scopeObject;
      ***REMOVED*** else {
          object[name]  = new Code(functionString, scopeObject***REMOVED***;
      ***REMOVED***

        // Add string to object
        break;
  ***REMOVED***
***REMOVED***

  // Check if we have a db ref object
  if(object['$id'] != null***REMOVED*** object = new DBRef(object['$ref'], object['$id'], object['$db']***REMOVED***;

  // Return the final objects
  return object;
}

/**
 * Check if key name is valid.
 *
 * @ignore
 * @api private
 */
BSON.checkKey = function checkKey (key, dollarsAndDotsOk***REMOVED*** {
  if (!key.length***REMOVED*** return;
  // Check if we have a legal key for the object
  if (!!~key.indexOf("\x00"***REMOVED******REMOVED*** {
    // The BSON spec doesn't allow keys with null bytes because keys are
    // null-terminated.
    throw Error("key " + key + " must not contain null bytes"***REMOVED***;
***REMOVED***
  if (!dollarsAndDotsOk***REMOVED*** {
    if('$' == key[0]***REMOVED*** {
      throw Error("key " + key + " must not start with '$'"***REMOVED***;
  ***REMOVED*** else if (!!~key.indexOf('.'***REMOVED******REMOVED*** {
      throw Error("key " + key + " must not contain '.'"***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Deserialize data as BSON.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *
 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @param {Boolean} [isArray] ignore used for recursive parsing.
 * @return {Object} returns the deserialized Javascript Object.
 * @api public
 */
BSON.prototype.deserialize = function(data, options***REMOVED*** {
  return BSON.deserialize(data, options***REMOVED***;
}

/**
 * Deserialize stream data as BSON documents.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *
 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
 * @param {Number} numberOfDocuments number of documents to deserialize.
 * @param {Array} documents an array where to store the deserialized documents.
 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
 * @api public
 */
BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options***REMOVED*** {
  return BSON.deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options***REMOVED***;
}

/**
 * Serialize a Javascript object.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore***REMOVED*****.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Buffer} returns the Buffer object containing the serialized object.
 * @api public
 */
BSON.prototype.serialize = function(object, checkKeys, asBuffer, serializeFunctions***REMOVED*** {
  return BSON.serialize(object, checkKeys, asBuffer, serializeFunctions***REMOVED***;
}

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param {Object} object the Javascript object to calculate the BSON byte size for.
 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false***REMOVED*****.
 * @return {Number} returns the number of bytes the BSON object will take up.
 * @api public
 */
BSON.prototype.calculateObjectSize = function(object, serializeFunctions***REMOVED*** {
  return BSON.calculateObjectSize(object, serializeFunctions***REMOVED***;
}

/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
 * @param {Number} index the index in the buffer where we wish to start serializing into.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Number} returns the new write index in the Buffer.
 * @api public
 */
BSON.prototype.serializeWithBufferAndIndex = function(object, checkKeys, buffer, startIndex, serializeFunctions***REMOVED*** {
  return BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, startIndex, serializeFunctions***REMOVED***;
}

/**
 * @ignore
 * @api private
 */
exports.Code = Code;
exports.Symbol = Symbol;
exports.BSON = BSON;
exports.DBRef = DBRef;
exports.Binary = Binary;
exports.ObjectID = ObjectID;
exports.Long = Long;
exports.Timestamp = Timestamp;
exports.Double = Double;
exports.MinKey = MinKey;
exports.MaxKey = MaxKey;

}, 



'code': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * A class representation of the BSON Code type.
 *
 * @class Represents the BSON Code type.
 * @param {String|Function} code a string or function.
 * @param {Object} [scope] an optional scope for the function.
 * @return {Code}
 */
function Code(code, scope***REMOVED*** {
  if(!(this instanceof Code***REMOVED******REMOVED*** return new Code(code, scope***REMOVED***;
  
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope == null ? {} : scope;
};

/**
 * @ignore
 * @api private
 */
Code.prototype.toJSON = function(***REMOVED*** {
  return {scope:this.scope, code:this.code};
}

exports.Code = Code;
}, 



'db_ref': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * A class representation of the BSON DBRef type.
 *
 * @class Represents the BSON DBRef type.
 * @param {String} namespace the collection name.
 * @param {ObjectID} oid the reference ObjectID.
 * @param {String} [db] optional db name, if omitted the reference is local to the current db.
 * @return {DBRef}
 */
function DBRef(namespace, oid, db***REMOVED*** {
  if(!(this instanceof DBRef***REMOVED******REMOVED*** return new DBRef(namespace, oid, db***REMOVED***;
  
  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
};

/**
 * @ignore
 * @api private
 */
DBRef.prototype.toJSON = function(***REMOVED*** {
  return {
    '$ref':this.namespace,
    '$id':this.oid,
    '$db':this.db == null ? '' : this.db
***REMOVED***;
}

exports.DBRef = DBRef;
}, 



'double': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * A class representation of the BSON Double type.
 *
 * @class Represents the BSON Double type.
 * @param {Number} value the number we want to represent as a double.
 * @return {Double}
 */
function Double(value***REMOVED*** {
  if(!(this instanceof Double***REMOVED******REMOVED*** return new Double(value***REMOVED***;
  
  this._bsontype = 'Double';
  this.value = value;
}

/**
 * Access the number value.
 *
 * @return {Number} returns the wrapped double number.
 * @api public
 */
Double.prototype.valueOf = function(***REMOVED*** {
  return this.value;
};

/**
 * @ignore
 * @api private
 */
Double.prototype.toJSON = function(***REMOVED*** {
  return this.value;
}

exports.Double = Double;
}, 



'float_parser': function(module, exports, global, require, undefined***REMOVED***{
  // Copyright (c***REMOVED*** 2008, Fair Oaks Labs, Inc.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//  * Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
//  * Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 
//  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION***REMOVED*** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE***REMOVED***
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
//
// Modifications to writeIEEE754 to support negative zeroes made by Brian White

var readIEEE754 = function(buffer, offset, endian, mLen, nBytes***REMOVED*** {
  var e, m,
      bBE = (endian === 'big'***REMOVED***,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen***REMOVED*** - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = bBE ? 0 : (nBytes - 1***REMOVED***,
      d = bBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits***REMOVED******REMOVED*** - 1***REMOVED***;
  s >>= (-nBits***REMOVED***;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8***REMOVED***;

  m = e & ((1 << (-nBits***REMOVED******REMOVED*** - 1***REMOVED***;
  e >>= (-nBits***REMOVED***;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8***REMOVED***;

  if (e === 0***REMOVED*** {
    e = 1 - eBias;
***REMOVED*** else if (e === eMax***REMOVED*** {
    return m ? NaN : ((s ? -1 : 1***REMOVED*** * Infinity***REMOVED***;
***REMOVED*** else {
    m = m + Math.pow(2, mLen***REMOVED***;
    e = e - eBias;
***REMOVED***
  return (s ? -1 : 1***REMOVED*** * m * Math.pow(2, e - mLen***REMOVED***;
};

var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes***REMOVED*** {
  var e, m, c,
      bBE = (endian === 'big'***REMOVED***,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen***REMOVED*** - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24***REMOVED*** - Math.pow(2, -77***REMOVED*** : 0***REMOVED***,
      i = bBE ? (nBytes-1***REMOVED*** : 0,
      d = bBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0***REMOVED*** ? 1 : 0;

  value = Math.abs(value***REMOVED***;

  if (isNaN(value***REMOVED*** || value === Infinity***REMOVED*** {
    m = isNaN(value***REMOVED*** ? 1 : 0;
    e = eMax;
***REMOVED*** else {
    e = Math.floor(Math.log(value***REMOVED*** / Math.LN2***REMOVED***;
    if (value * (c = Math.pow(2, -e***REMOVED******REMOVED*** < 1***REMOVED*** {
      e--;
      c *= 2;
  ***REMOVED***
    if (e+eBias >= 1***REMOVED*** {
      value += rt / c;
  ***REMOVED*** else {
      value += rt * Math.pow(2, 1 - eBias***REMOVED***;
  ***REMOVED***
    if (value * c >= 2***REMOVED*** {
      e++;
      c /= 2;
  ***REMOVED***

    if (e + eBias >= eMax***REMOVED*** {
      m = 0;
      e = eMax;
  ***REMOVED*** else if (e + eBias >= 1***REMOVED*** {
      m = (value * c - 1***REMOVED*** * Math.pow(2, mLen***REMOVED***;
      e = e + eBias;
  ***REMOVED*** else {
      m = value * Math.pow(2, eBias - 1***REMOVED*** * Math.pow(2, mLen***REMOVED***;
      e = 0;
  ***REMOVED***
***REMOVED***

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8***REMOVED***;

  e = (e << mLen***REMOVED*** | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8***REMOVED***;

  buffer[offset + i - d] |= s * 128;
};

exports.readIEEE754 = readIEEE754;
exports.writeIEEE754 = writeIEEE754;
}, 



'index': function(module, exports, global, require, undefined***REMOVED***{
  try {
  exports.BSONPure = require('./bson'***REMOVED***;
  exports.BSONNative = require('../../ext'***REMOVED***;
} catch(err***REMOVED*** {
  // do nothing
}

[ './binary_parser'
  , './binary'
  , './code'
  , './db_ref'
  , './double'
  , './max_key'
  , './min_key'
  , './objectid'
  , './symbol'
  , './timestamp'
  , './long'].forEach(function (path***REMOVED*** {
  	var module = require('./' + path***REMOVED***;
  	for (var i in module***REMOVED*** {
  		exports[i] = module[i];
  ***REMOVED***
}***REMOVED***;

// Exports all the classes for the NATIVE JS BSON Parser
exports.native = function(***REMOVED*** {
  var classes = {};
  // Map all the classes
  [ './binary_parser'
    , './binary'
    , './code'
    , './db_ref'
    , './double'
    , './max_key'
    , './min_key'
    , './objectid'
    , './symbol'
    , './timestamp'
    , './long'
    , '../../ext'
].forEach(function (path***REMOVED*** {
    	var module = require('./' + path***REMOVED***;
    	for (var i in module***REMOVED*** {
    		classes[i] = module[i];
    ***REMOVED***
***REMOVED******REMOVED***;
  // Return classes list
  return classes;
}

// Exports all the classes for the PURE JS BSON Parser
exports.pure = function(***REMOVED*** {
  var classes = {};
  // Map all the classes
  [ './binary_parser'
    , './binary'
    , './code'
    , './db_ref'
    , './double'
    , './max_key'
    , './min_key'
    , './objectid'
    , './symbol'
    , './timestamp'
    , './long'
    , '././bson'].forEach(function (path***REMOVED*** {
    	var module = require('./' + path***REMOVED***;
    	for (var i in module***REMOVED*** {
    		classes[i] = module[i];
    ***REMOVED***
***REMOVED******REMOVED***;
  // Return classes list
  return classes;
}

}, 



'long': function(module, exports, global, require, undefined***REMOVED***{
  // Licensed under the Apache License, Version 2.0 (the "License"***REMOVED***;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2009 Google Inc. All Rights Reserved

/**
 * Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "Long". This
 * implementation is derived from LongLib in GWT.
 *
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Longs.
 *
 * The internal representation of a Long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s***REMOVED*** and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63***REMOVED*** because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative***REMOVED***.  Not handling this
 * case would often result in infinite recursion.
 *
 * @class Represents the BSON Long type.
 * @param {Number} low  the low (signed***REMOVED*** 32 bits of the Long.
 * @param {Number} high the high (signed***REMOVED*** 32 bits of the Long.
 */
function Long(low, high***REMOVED*** {
  if(!(this instanceof Long***REMOVED******REMOVED*** return new Long(low, high***REMOVED***;
  
  this._bsontype = 'Long';
  /**
   * @type {number}
   * @api private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * Return the int value.
 *
 * @return {Number} the value, assuming it is a 32-bit integer.
 * @api public
 */
Long.prototype.toInt = function(***REMOVED*** {
  return this.low_;
};

/**
 * Return the Number value.
 *
 * @return {Number} the closest floating-point representation to this value.
 * @api public
 */
Long.prototype.toNumber = function(***REMOVED*** {
  return this.high_ * Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned(***REMOVED***;
};

/**
 * Return the JSON value.
 *
 * @return {String} the JSON representation.
 * @api public
 */
Long.prototype.toJSON = function(***REMOVED*** {
  return this.toString(***REMOVED***;
}

/**
 * Return the String value.
 *
 * @param {Number} [opt_radix] the radix in which the text should be written.
 * @return {String} the textual representation of this value.
 * @api public
 */
Long.prototype.toString = function(opt_radix***REMOVED*** {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix***REMOVED*** {
    throw Error('radix out of range: ' + radix***REMOVED***;
***REMOVED***

  if (this.isZero(***REMOVED******REMOVED*** {
    return '0';
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (this.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = Long.fromNumber(radix***REMOVED***;
      var div = this.div(radixLong***REMOVED***;
      var rem = div.multiply(radixLong***REMOVED***.subtract(this***REMOVED***;
      return div.toString(radix***REMOVED*** + rem.toInt(***REMOVED***.toString(radix***REMOVED***;
  ***REMOVED*** else {
      return '-' + this.negate(***REMOVED***.toString(radix***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Do several (6***REMOVED*** digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Long.fromNumber(Math.pow(radix, 6***REMOVED******REMOVED***;

  var rem = this;
  var result = '';
  while (true***REMOVED*** {
    var remDiv = rem.div(radixToPower***REMOVED***;
    var intval = rem.subtract(remDiv.multiply(radixToPower***REMOVED******REMOVED***.toInt(***REMOVED***;
    var digits = intval.toString(radix***REMOVED***;

    rem = remDiv;
    if (rem.isZero(***REMOVED******REMOVED*** {
      return digits + result;
  ***REMOVED*** else {
      while (digits.length < 6***REMOVED*** {
        digits = '0' + digits;
    ***REMOVED***
      result = '' + digits + result;
  ***REMOVED***
***REMOVED***
};

/**
 * Return the high 32-bits value.
 *
 * @return {Number} the high 32-bits as a signed value.
 * @api public
 */
Long.prototype.getHighBits = function(***REMOVED*** {
  return this.high_;
};

/**
 * Return the low 32-bits value.
 *
 * @return {Number} the low 32-bits as a signed value.
 * @api public
 */
Long.prototype.getLowBits = function(***REMOVED*** {
  return this.low_;
};

/**
 * Return the low unsigned 32-bits value.
 *
 * @return {Number} the low 32-bits as an unsigned value.
 * @api public
 */
Long.prototype.getLowBitsUnsigned = function(***REMOVED*** {
  return (this.low_ >= 0***REMOVED*** ?
      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
};

/**
 * Returns the number of bits needed to represent the absolute value of this Long.
 *
 * @return {Number} Returns the number of bits needed to represent the absolute value of this Long.
 * @api public
 */
Long.prototype.getNumBitsAbs = function(***REMOVED*** {
  if (this.isNegative(***REMOVED******REMOVED*** {
    if (this.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
      return 64;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.getNumBitsAbs(***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--***REMOVED*** {
      if ((val & (1 << bit***REMOVED******REMOVED*** != 0***REMOVED*** {
        break;
    ***REMOVED***
  ***REMOVED***
    return this.high_ != 0 ? bit + 33 : bit + 1;
***REMOVED***
};

/**
 * Return whether this value is zero.
 *
 * @return {Boolean} whether this value is zero.
 * @api public
 */
Long.prototype.isZero = function(***REMOVED*** {
  return this.high_ == 0 && this.low_ == 0;
};

/**
 * Return whether this value is negative.
 *
 * @return {Boolean} whether this value is negative.
 * @api public
 */
Long.prototype.isNegative = function(***REMOVED*** {
  return this.high_ < 0;
};

/**
 * Return whether this value is odd.
 *
 * @return {Boolean} whether this value is odd.
 * @api public
 */
Long.prototype.isOdd = function(***REMOVED*** {
  return (this.low_ & 1***REMOVED*** == 1;
};

/**
 * Return whether this Long equals the other
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long equals the other
 * @api public
 */
Long.prototype.equals = function(other***REMOVED*** {
  return (this.high_ == other.high_***REMOVED*** && (this.low_ == other.low_***REMOVED***;
};

/**
 * Return whether this Long does not equal the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long does not equal the other.
 * @api public
 */
Long.prototype.notEquals = function(other***REMOVED*** {
  return (this.high_ != other.high_***REMOVED*** || (this.low_ != other.low_***REMOVED***;
};

/**
 * Return whether this Long is less than the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is less than the other.
 * @api public
 */
Long.prototype.lessThan = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** < 0;
};

/**
 * Return whether this Long is less than or equal to the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is less than or equal to the other.
 * @api public
 */
Long.prototype.lessThanOrEqual = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** <= 0;
};

/**
 * Return whether this Long is greater than the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is greater than the other.
 * @api public
 */
Long.prototype.greaterThan = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** > 0;
};

/**
 * Return whether this Long is greater than or equal to the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is greater than or equal to the other.
 * @api public
 */
Long.prototype.greaterThanOrEqual = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** >= 0;
};

/**
 * Compares this Long with the given one.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
 * @api public
 */
Long.prototype.compare = function(other***REMOVED*** {
  if (this.equals(other***REMOVED******REMOVED*** {
    return 0;
***REMOVED***

  var thisNeg = this.isNegative(***REMOVED***;
  var otherNeg = other.isNegative(***REMOVED***;
  if (thisNeg && !otherNeg***REMOVED*** {
    return -1;
***REMOVED***
  if (!thisNeg && otherNeg***REMOVED*** {
    return 1;
***REMOVED***

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other***REMOVED***.isNegative(***REMOVED******REMOVED*** {
    return -1;
***REMOVED*** else {
    return 1;
***REMOVED***
};

/**
 * The negation of this value.
 *
 * @return {Long} the negation of this value.
 * @api public
 */
Long.prototype.negate = function(***REMOVED*** {
  if (this.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
    return Long.MIN_VALUE;
***REMOVED*** else {
    return this.not(***REMOVED***.add(Long.ONE***REMOVED***;
***REMOVED***
};

/**
 * Returns the sum of this and the given Long.
 *
 * @param {Long} other Long to add to this one.
 * @return {Long} the sum of this and the given Long.
 * @api public
 */
Long.prototype.add = function(other***REMOVED*** {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16***REMOVED*** | c00, (c48 << 16***REMOVED*** | c32***REMOVED***;
};

/**
 * Returns the difference of this and the given Long.
 *
 * @param {Long} other Long to subtract from this.
 * @return {Long} the difference of this and the given Long.
 * @api public
 */
Long.prototype.subtract = function(other***REMOVED*** {
  return this.add(other.negate(***REMOVED******REMOVED***;
};

/**
 * Returns the product of this and the given Long.
 *
 * @param {Long} other Long to multiply with this.
 * @return {Long} the product of this and the other.
 * @api public
 */
Long.prototype.multiply = function(other***REMOVED*** {
  if (this.isZero(***REMOVED******REMOVED*** {
    return Long.ZERO;
***REMOVED*** else if (other.isZero(***REMOVED******REMOVED*** {
    return Long.ZERO;
***REMOVED***

  if (this.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
    return other.isOdd(***REMOVED*** ? Long.MIN_VALUE : Long.ZERO;
***REMOVED*** else if (other.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
    return this.isOdd(***REMOVED*** ? Long.MIN_VALUE : Long.ZERO;
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (other.isNegative(***REMOVED******REMOVED*** {
      return this.negate(***REMOVED***.multiply(other.negate(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.multiply(other***REMOVED***.negate(***REMOVED***;
  ***REMOVED***
***REMOVED*** else if (other.isNegative(***REMOVED******REMOVED*** {
    return this.multiply(other.negate(***REMOVED******REMOVED***.negate(***REMOVED***;
***REMOVED***

  // If both Longs are small, use float multiplication
  if (this.lessThan(Long.TWO_PWR_24_***REMOVED*** &&
      other.lessThan(Long.TWO_PWR_24_***REMOVED******REMOVED*** {
    return Long.fromNumber(this.toNumber(***REMOVED*** * other.toNumber(***REMOVED******REMOVED***;
***REMOVED***

  // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16***REMOVED*** | c00, (c48 << 16***REMOVED*** | c32***REMOVED***;
};

/**
 * Returns this Long divided by the given one.
 *
 * @param {Long} other Long by which to divide.
 * @return {Long} this Long divided by the given one.
 * @api public
 */
Long.prototype.div = function(other***REMOVED*** {
  if (other.isZero(***REMOVED******REMOVED*** {
    throw Error('division by zero'***REMOVED***;
***REMOVED*** else if (this.isZero(***REMOVED******REMOVED*** {
    return Long.ZERO;
***REMOVED***

  if (this.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
    if (other.equals(Long.ONE***REMOVED*** ||
        other.equals(Long.NEG_ONE***REMOVED******REMOVED*** {
      return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
  ***REMOVED*** else if (other.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
      return Long.ONE;
  ***REMOVED*** else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1***REMOVED***;
      var approx = halfThis.div(other***REMOVED***.shiftLeft(1***REMOVED***;
      if (approx.equals(Long.ZERO***REMOVED******REMOVED*** {
        return other.isNegative(***REMOVED*** ? Long.ONE : Long.NEG_ONE;
    ***REMOVED*** else {
        var rem = this.subtract(other.multiply(approx***REMOVED******REMOVED***;
        var result = approx.add(rem.div(other***REMOVED******REMOVED***;
        return result;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if (other.equals(Long.MIN_VALUE***REMOVED******REMOVED*** {
    return Long.ZERO;
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (other.isNegative(***REMOVED******REMOVED*** {
      return this.negate(***REMOVED***.div(other.negate(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.div(other***REMOVED***.negate(***REMOVED***;
  ***REMOVED***
***REMOVED*** else if (other.isNegative(***REMOVED******REMOVED*** {
    return this.div(other.negate(***REMOVED******REMOVED***.negate(***REMOVED***;
***REMOVED***

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Long.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other***REMOVED******REMOVED*** {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber(***REMOVED*** / other.toNumber(***REMOVED******REMOVED******REMOVED***;

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx***REMOVED*** / Math.LN2***REMOVED***;
    var delta = (log2 <= 48***REMOVED*** ? 1 : Math.pow(2, log2 - 48***REMOVED***;

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Long.fromNumber(approx***REMOVED***;
    var approxRem = approxRes.multiply(other***REMOVED***;
    while (approxRem.isNegative(***REMOVED*** || approxRem.greaterThan(rem***REMOVED******REMOVED*** {
      approx -= delta;
      approxRes = Long.fromNumber(approx***REMOVED***;
      approxRem = approxRes.multiply(other***REMOVED***;
  ***REMOVED***

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero(***REMOVED******REMOVED*** {
      approxRes = Long.ONE;
  ***REMOVED***

    res = res.add(approxRes***REMOVED***;
    rem = rem.subtract(approxRem***REMOVED***;
***REMOVED***
  return res;
};

/**
 * Returns this Long modulo the given one.
 *
 * @param {Long} other Long by which to mod.
 * @return {Long} this Long modulo the given one.
 * @api public
 */
Long.prototype.modulo = function(other***REMOVED*** {
  return this.subtract(this.div(other***REMOVED***.multiply(other***REMOVED******REMOVED***;
};

/**
 * The bitwise-NOT of this value.
 *
 * @return {Long} the bitwise-NOT of this value.
 * @api public
 */
Long.prototype.not = function(***REMOVED*** {
  return Long.fromBits(~this.low_, ~this.high_***REMOVED***;
};

/**
 * Returns the bitwise-AND of this Long and the given one.
 *
 * @param {Long} other the Long with which to AND.
 * @return {Long} the bitwise-AND of this and the other.
 * @api public
 */
Long.prototype.and = function(other***REMOVED*** {
  return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_***REMOVED***;
};

/**
 * Returns the bitwise-OR of this Long and the given one.
 *
 * @param {Long} other the Long with which to OR.
 * @return {Long} the bitwise-OR of this and the other.
 * @api public
 */
Long.prototype.or = function(other***REMOVED*** {
  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_***REMOVED***;
};

/**
 * Returns the bitwise-XOR of this Long and the given one.
 *
 * @param {Long} other the Long with which to XOR.
 * @return {Long} the bitwise-XOR of this and the other.
 * @api public
 */
Long.prototype.xor = function(other***REMOVED*** {
  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_***REMOVED***;
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Long} this shifted to the left by the given amount.
 * @api public
 */
Long.prototype.shiftLeft = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var low = this.low_;
    if (numBits < 32***REMOVED*** {
      var high = this.high_;
      return Long.fromBits(
                 low << numBits,
                 (high << numBits***REMOVED*** | (low >>> (32 - numBits***REMOVED******REMOVED******REMOVED***;
  ***REMOVED*** else {
      return Long.fromBits(0, low << (numBits - 32***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns this Long with bits shifted to the right by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Long} this shifted to the right by the given amount.
 * @api public
 */
Long.prototype.shiftRight = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var high = this.high_;
    if (numBits < 32***REMOVED*** {
      var low = this.low_;
      return Long.fromBits(
                 (low >>> numBits***REMOVED*** | (high << (32 - numBits***REMOVED******REMOVED***,
                 high >> numBits***REMOVED***;
  ***REMOVED*** else {
      return Long.fromBits(
                 high >> (numBits - 32***REMOVED***,
                 high >= 0 ? 0 : -1***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns this Long with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Long} this shifted to the right by the given amount, with zeros placed into the new leading bits.
 * @api public
 */
Long.prototype.shiftRightUnsigned = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var high = this.high_;
    if (numBits < 32***REMOVED*** {
      var low = this.low_;
      return Long.fromBits(
                 (low >>> numBits***REMOVED*** | (high << (32 - numBits***REMOVED******REMOVED***,
                 high >>> numBits***REMOVED***;
  ***REMOVED*** else if (numBits == 32***REMOVED*** {
      return Long.fromBits(high, 0***REMOVED***;
  ***REMOVED*** else {
      return Long.fromBits(high >>> (numBits - 32***REMOVED***, 0***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns a Long representing the given (32-bit***REMOVED*** integer value.
 *
 * @param {Number} value the 32-bit integer in question.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromInt = function(value***REMOVED*** {
  if (-128 <= value && value < 128***REMOVED*** {
    var cachedObj = Long.INT_CACHE_[value];
    if (cachedObj***REMOVED*** {
      return cachedObj;
  ***REMOVED***
***REMOVED***

  var obj = new Long(value | 0, value < 0 ? -1 : 0***REMOVED***;
  if (-128 <= value && value < 128***REMOVED*** {
    Long.INT_CACHE_[value] = obj;
***REMOVED***
  return obj;
};

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 *
 * @param {Number} value the number in question.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromNumber = function(value***REMOVED*** {
  if (isNaN(value***REMOVED*** || !isFinite(value***REMOVED******REMOVED*** {
    return Long.ZERO;
***REMOVED*** else if (value <= -Long.TWO_PWR_63_DBL_***REMOVED*** {
    return Long.MIN_VALUE;
***REMOVED*** else if (value + 1 >= Long.TWO_PWR_63_DBL_***REMOVED*** {
    return Long.MAX_VALUE;
***REMOVED*** else if (value < 0***REMOVED*** {
    return Long.fromNumber(-value***REMOVED***.negate(***REMOVED***;
***REMOVED*** else {
    return new Long(
               (value % Long.TWO_PWR_32_DBL_***REMOVED*** | 0,
               (value / Long.TWO_PWR_32_DBL_***REMOVED*** | 0***REMOVED***;
***REMOVED***
};

/**
 * Returns a Long representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
 *
 * @param {Number} lowBits the low 32-bits.
 * @param {Number} highBits the high 32-bits.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromBits = function(lowBits, highBits***REMOVED*** {
  return new Long(lowBits, highBits***REMOVED***;
};

/**
 * Returns a Long representation of the given string, written using the given radix.
 *
 * @param {String} str the textual representation of the Long.
 * @param {Number} opt_radix the radix in which the text is written.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromString = function(str, opt_radix***REMOVED*** {
  if (str.length == 0***REMOVED*** {
    throw Error('number format error: empty string'***REMOVED***;
***REMOVED***

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix***REMOVED*** {
    throw Error('radix out of range: ' + radix***REMOVED***;
***REMOVED***

  if (str.charAt(0***REMOVED*** == '-'***REMOVED*** {
    return Long.fromString(str.substring(1***REMOVED***, radix***REMOVED***.negate(***REMOVED***;
***REMOVED*** else if (str.indexOf('-'***REMOVED*** >= 0***REMOVED*** {
    throw Error('number format error: interior "-" character: ' + str***REMOVED***;
***REMOVED***

  // Do several (8***REMOVED*** digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Long.fromNumber(Math.pow(radix, 8***REMOVED******REMOVED***;

  var result = Long.ZERO;
  for (var i = 0; i < str.length; i += 8***REMOVED*** {
    var size = Math.min(8, str.length - i***REMOVED***;
    var value = parseInt(str.substring(i, i + size***REMOVED***, radix***REMOVED***;
    if (size < 8***REMOVED*** {
      var power = Long.fromNumber(Math.pow(radix, size***REMOVED******REMOVED***;
      result = result.multiply(power***REMOVED***.add(Long.fromNumber(value***REMOVED******REMOVED***;
  ***REMOVED*** else {
      result = result.multiply(radixToPower***REMOVED***;
      result = result.add(Long.fromNumber(value***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  return result;
};

// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Long representations of small integer values.
 * @type {Object}
 * @api private
 */
Long.INT_CACHE_ = {};

// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @api private
 */
Long.TWO_PWR_16_DBL_ = 1 << 16;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_24_DBL_ = 1 << 24;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

/** @type {Long} */
Long.ZERO = Long.fromInt(0***REMOVED***;

/** @type {Long} */
Long.ONE = Long.fromInt(1***REMOVED***;

/** @type {Long} */
Long.NEG_ONE = Long.fromInt(-1***REMOVED***;

/** @type {Long} */
Long.MAX_VALUE =
    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0***REMOVED***;

/** @type {Long} */
Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0***REMOVED***;

/**
 * @type {Long}
 * @api private
 */
Long.TWO_PWR_24_ = Long.fromInt(1 << 24***REMOVED***;

/**
 * Expose.
 */
exports.Long = Long;
}, 



'max_key': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * A class representation of the BSON MaxKey type.
 *
 * @class Represents the BSON MaxKey type.
 * @return {MaxKey}
 */
function MaxKey(***REMOVED*** {
  if(!(this instanceof MaxKey***REMOVED******REMOVED*** return new MaxKey(***REMOVED***;
  
  this._bsontype = 'MaxKey';  
}

exports.MaxKey = MaxKey;
}, 



'min_key': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * A class representation of the BSON MinKey type.
 *
 * @class Represents the BSON MinKey type.
 * @return {MinKey}
 */
function MinKey(***REMOVED*** {
  if(!(this instanceof MinKey***REMOVED******REMOVED*** return new MinKey(***REMOVED***;
  
  this._bsontype = 'MinKey';
}

exports.MinKey = MinKey;
}, 



'objectid': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * Module dependencies.
 */
var BinaryParser = require('./binary_parser'***REMOVED***.BinaryParser;

/**
 * Machine id.
 *
 * Create a random 3-byte value (i.e. unique for this
 * process***REMOVED***. Other drivers use a md5 of the machine id here, but
 * that would mean an asyc call to gethostname, so we don't bother.
 */
var MACHINE_ID = parseInt(Math.random(***REMOVED*** * 0xFFFFFF, 10***REMOVED***;

// Regular expression that checks for hex value
var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$"***REMOVED***;

/**
* Create a new ObjectID instance
*
* @class Represents the BSON ObjectID type
* @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.
* @return {Object} instance of ObjectID.
*/
var ObjectID = function ObjectID(id, _hex***REMOVED*** {
  if(!(this instanceof ObjectID***REMOVED******REMOVED*** return new ObjectID(id, _hex***REMOVED***;

  this._bsontype = 'ObjectID';
  var __id = null;

  // Throw an error if it's not a valid setup
  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24***REMOVED******REMOVED***
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"***REMOVED***;

  // Generate id based on the input
  if(id == null || typeof id == 'number'***REMOVED*** {
    // convert to 12 byte binary string
    this.id = this.generate(id***REMOVED***;
***REMOVED*** else if(id != null && id.length === 12***REMOVED*** {
    // assume 12 byte string
    this.id = id;
***REMOVED*** else if(checkForHexRegExp.test(id***REMOVED******REMOVED*** {
    return ObjectID.createFromHexString(id***REMOVED***;
***REMOVED*** else {
    throw new Error("Value passed in is not a valid 24 character hex string"***REMOVED***;
***REMOVED***

  if(ObjectID.cacheHexString***REMOVED*** this.__id = this.toHexString(***REMOVED***;
};

// Allow usage of ObjectId aswell as ObjectID
var ObjectId = ObjectID;

/**
* Return the ObjectID id as a 24 byte hex string representation
*
* @return {String} return the 24 byte hex string representation.
* @api public
*/
ObjectID.prototype.toHexString = function(***REMOVED*** {
  if(ObjectID.cacheHexString && this.__id***REMOVED*** return this.__id;

  var hexString = ''
    , number
    , value;

  for (var index = 0, len = this.id.length; index < len; index++***REMOVED*** {
    value = BinaryParser.toByte(this.id[index]***REMOVED***;
    number = value <= 15
      ? '0' + value.toString(16***REMOVED***
      : value.toString(16***REMOVED***;
    hexString = hexString + number;
***REMOVED***

  if(ObjectID.cacheHexString***REMOVED*** this.__id = hexString;
  return hexString;
};

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @return {Number} returns next index value.
* @api private
*/
ObjectID.prototype.get_inc = function(***REMOVED*** {
  return ObjectID.index = (ObjectID.index + 1***REMOVED*** % 0xFFFFFF;
};

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @return {Number} returns next index value.
* @api private
*/
ObjectID.prototype.getInc = function(***REMOVED*** {
  return this.get_inc(***REMOVED***;
};

/**
* Generate a 12 byte id string used in ObjectID's
*
* @param {Number} [time] optional parameter allowing to pass in a second based timestamp.
* @return {String} return the 12 byte id binary string.
* @api private
*/
ObjectID.prototype.generate = function(time***REMOVED*** {
  if ('number' == typeof time***REMOVED*** {
    var time4Bytes = BinaryParser.encodeInt(time, 32, true, true***REMOVED***;
    /* for time-based ObjectID the bytes following the time will be zeroed */
    var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false***REMOVED***;
    var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random(***REMOVED*** * 100000***REMOVED*** : process.pid***REMOVED***;
    var index3Bytes = BinaryParser.encodeInt(this.get_inc(***REMOVED***, 24, false, true***REMOVED***;
***REMOVED*** else {
  	var unixTime = parseInt(Date.now(***REMOVED***/1000,10***REMOVED***;
    var time4Bytes = BinaryParser.encodeInt(unixTime, 32, true, true***REMOVED***;
    var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false***REMOVED***;
    var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random(***REMOVED*** * 100000***REMOVED*** : process.pid***REMOVED***;
    var index3Bytes = BinaryParser.encodeInt(this.get_inc(***REMOVED***, 24, false, true***REMOVED***;
***REMOVED***

  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
};

/**
* Converts the id into a 24 byte hex string for printing
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.toString = function(***REMOVED*** {
  return this.toHexString(***REMOVED***;
};

/**
* Converts to a string representation of this Id.
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.inspect = ObjectID.prototype.toString;

/**
* Converts to its JSON representation.
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.toJSON = function(***REMOVED*** {
  return this.toHexString(***REMOVED***;
};

/**
* Compares the equality of this ObjectID with `otherID`.
*
* @param {Object} otherID ObjectID instance to compare against.
* @return {Bool} the result of comparing two ObjectID's
* @api public
*/
ObjectID.prototype.equals = function equals (otherID***REMOVED*** {
  var id = (otherID instanceof ObjectID || otherID.toHexString***REMOVED***
    ? otherID.id
    : ObjectID.createFromHexString(otherID***REMOVED***.id;

  return this.id === id;
}

/**
* Returns the generation date (accurate up to the second***REMOVED*** that this ID was generated.
*
* @return {Date} the generation date
* @api public
*/
ObjectID.prototype.getTimestamp = function(***REMOVED*** {
  var timestamp = new Date(***REMOVED***;
  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4***REMOVED***, 32, true, true***REMOVED******REMOVED*** * 1000***REMOVED***;
  return timestamp;
}

/**
* @ignore
* @api private
*/
ObjectID.index = parseInt(Math.random(***REMOVED*** * 0xFFFFFF, 10***REMOVED***;

ObjectID.createPk = function createPk (***REMOVED*** {
  return new ObjectID(***REMOVED***;
};

/**
* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
*
* @param {Number} time an integer number representing a number of seconds.
* @return {ObjectID} return the created ObjectID
* @api public
*/
ObjectID.createFromTime = function createFromTime (time***REMOVED*** {
  var id = BinaryParser.encodeInt(time, 32, true, true***REMOVED*** +
           BinaryParser.encodeInt(0, 64, true, true***REMOVED***;
  return new ObjectID(id***REMOVED***;
};

/**
* Creates an ObjectID from a hex string representation of an ObjectID.
*
* @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.
* @return {ObjectID} return the created ObjectID
* @api public
*/
ObjectID.createFromHexString = function createFromHexString (hexString***REMOVED*** {
  // Throw an error if it's not a valid setup
  if(typeof hexString === 'undefined' || hexString != null && hexString.length != 24***REMOVED***
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"***REMOVED***;

  var len = hexString.length;

  if(len > 12*2***REMOVED*** {
    throw new Error('Id cannot be longer than 12 bytes'***REMOVED***;
***REMOVED***

  var result = ''
    , string
    , number;

  for (var index = 0; index < len; index += 2***REMOVED*** {
    string = hexString.substr(index, 2***REMOVED***;
    number = parseInt(string, 16***REMOVED***;
    result += BinaryParser.fromByte(number***REMOVED***;
***REMOVED***

  return new ObjectID(result, hexString***REMOVED***;
};

/**
* @ignore
*/
Object.defineProperty(ObjectID.prototype, "generationTime", {
   enumerable: true
 , get: function (***REMOVED*** {
     return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4***REMOVED***, 32, true, true***REMOVED******REMOVED***;
 ***REMOVED***
 , set: function (value***REMOVED*** {
     var value = BinaryParser.encodeInt(value, 32, true, true***REMOVED***;
     this.id = value + this.id.substr(4***REMOVED***;
     // delete this.__id;
     this.toHexString(***REMOVED***;
 ***REMOVED***
}***REMOVED***;

/**
 * Expose.
 */
exports.ObjectID = ObjectID;
exports.ObjectId = ObjectID;

}, 



'symbol': function(module, exports, global, require, undefined***REMOVED***{
  /**
 * A class representation of the BSON Symbol type.
 *
 * @class Represents the BSON Symbol type.
 * @param {String} value the string representing the symbol.
 * @return {Symbol}
 */
function Symbol(value***REMOVED*** {
  if(!(this instanceof Symbol***REMOVED******REMOVED*** return new Symbol(value***REMOVED***;
  this._bsontype = 'Symbol';
  this.value = value;
}

/**
 * Access the wrapped string value.
 *
 * @return {String} returns the wrapped string.
 * @api public
 */
Symbol.prototype.valueOf = function(***REMOVED*** {
  return this.value;
};

/**
 * @ignore
 * @api private
 */
Symbol.prototype.toString = function(***REMOVED*** {
  return this.value;
}

/**
 * @ignore
 * @api private
 */
Symbol.prototype.inspect = function(***REMOVED*** {
  return this.value;
}

/**
 * @ignore
 * @api private
 */
Symbol.prototype.toJSON = function(***REMOVED*** {
  return this.value;
}

exports.Symbol = Symbol;
}, 



'timestamp': function(module, exports, global, require, undefined***REMOVED***{
  // Licensed under the Apache License, Version 2.0 (the "License"***REMOVED***;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2009 Google Inc. All Rights Reserved

/**
 * Defines a Timestamp class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
 * implementation is derived from TimestampLib in GWT.
 *
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Timestamps.
 *
 * The internal representation of a Timestamp is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s***REMOVED*** and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63***REMOVED*** because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative***REMOVED***.  Not handling this
 * case would often result in infinite recursion.
 *
 * @class Represents the BSON Timestamp type.
 * @param {Number} low  the low (signed***REMOVED*** 32 bits of the Timestamp.
 * @param {Number} high the high (signed***REMOVED*** 32 bits of the Timestamp.
 */
function Timestamp(low, high***REMOVED*** {
  if(!(this instanceof Timestamp***REMOVED******REMOVED*** return new Timestamp(low, high***REMOVED***;
  this._bsontype = 'Timestamp';
  /**
   * @type {number}
   * @api private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * Return the int value.
 *
 * @return {Number} the value, assuming it is a 32-bit integer.
 * @api public
 */
Timestamp.prototype.toInt = function(***REMOVED*** {
  return this.low_;
};

/**
 * Return the Number value.
 *
 * @return {Number} the closest floating-point representation to this value.
 * @api public
 */
Timestamp.prototype.toNumber = function(***REMOVED*** {
  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned(***REMOVED***;
};

/**
 * Return the JSON value.
 *
 * @return {String} the JSON representation.
 * @api public
 */
Timestamp.prototype.toJSON = function(***REMOVED*** {
  return this.toString(***REMOVED***;
}

/**
 * Return the String value.
 *
 * @param {Number} [opt_radix] the radix in which the text should be written.
 * @return {String} the textual representation of this value.
 * @api public
 */
Timestamp.prototype.toString = function(opt_radix***REMOVED*** {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix***REMOVED*** {
    throw Error('radix out of range: ' + radix***REMOVED***;
***REMOVED***

  if (this.isZero(***REMOVED******REMOVED*** {
    return '0';
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
      // We need to change the Timestamp value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixTimestamp = Timestamp.fromNumber(radix***REMOVED***;
      var div = this.div(radixTimestamp***REMOVED***;
      var rem = div.multiply(radixTimestamp***REMOVED***.subtract(this***REMOVED***;
      return div.toString(radix***REMOVED*** + rem.toInt(***REMOVED***.toString(radix***REMOVED***;
  ***REMOVED*** else {
      return '-' + this.negate(***REMOVED***.toString(radix***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Do several (6***REMOVED*** digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6***REMOVED******REMOVED***;

  var rem = this;
  var result = '';
  while (true***REMOVED*** {
    var remDiv = rem.div(radixToPower***REMOVED***;
    var intval = rem.subtract(remDiv.multiply(radixToPower***REMOVED******REMOVED***.toInt(***REMOVED***;
    var digits = intval.toString(radix***REMOVED***;

    rem = remDiv;
    if (rem.isZero(***REMOVED******REMOVED*** {
      return digits + result;
  ***REMOVED*** else {
      while (digits.length < 6***REMOVED*** {
        digits = '0' + digits;
    ***REMOVED***
      result = '' + digits + result;
  ***REMOVED***
***REMOVED***
};

/**
 * Return the high 32-bits value.
 *
 * @return {Number} the high 32-bits as a signed value.
 * @api public
 */
Timestamp.prototype.getHighBits = function(***REMOVED*** {
  return this.high_;
};

/**
 * Return the low 32-bits value.
 *
 * @return {Number} the low 32-bits as a signed value.
 * @api public
 */
Timestamp.prototype.getLowBits = function(***REMOVED*** {
  return this.low_;
};

/**
 * Return the low unsigned 32-bits value.
 *
 * @return {Number} the low 32-bits as an unsigned value.
 * @api public
 */
Timestamp.prototype.getLowBitsUnsigned = function(***REMOVED*** {
  return (this.low_ >= 0***REMOVED*** ?
      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
};

/**
 * Returns the number of bits needed to represent the absolute value of this Timestamp.
 *
 * @return {Number} Returns the number of bits needed to represent the absolute value of this Timestamp.
 * @api public
 */
Timestamp.prototype.getNumBitsAbs = function(***REMOVED*** {
  if (this.isNegative(***REMOVED******REMOVED*** {
    if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
      return 64;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.getNumBitsAbs(***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--***REMOVED*** {
      if ((val & (1 << bit***REMOVED******REMOVED*** != 0***REMOVED*** {
        break;
    ***REMOVED***
  ***REMOVED***
    return this.high_ != 0 ? bit + 33 : bit + 1;
***REMOVED***
};

/**
 * Return whether this value is zero.
 *
 * @return {Boolean} whether this value is zero.
 * @api public
 */
Timestamp.prototype.isZero = function(***REMOVED*** {
  return this.high_ == 0 && this.low_ == 0;
};

/**
 * Return whether this value is negative.
 *
 * @return {Boolean} whether this value is negative.
 * @api public
 */
Timestamp.prototype.isNegative = function(***REMOVED*** {
  return this.high_ < 0;
};

/**
 * Return whether this value is odd.
 *
 * @return {Boolean} whether this value is odd.
 * @api public
 */
Timestamp.prototype.isOdd = function(***REMOVED*** {
  return (this.low_ & 1***REMOVED*** == 1;
};

/**
 * Return whether this Timestamp equals the other
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp equals the other
 * @api public
 */
Timestamp.prototype.equals = function(other***REMOVED*** {
  return (this.high_ == other.high_***REMOVED*** && (this.low_ == other.low_***REMOVED***;
};

/**
 * Return whether this Timestamp does not equal the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp does not equal the other.
 * @api public
 */
Timestamp.prototype.notEquals = function(other***REMOVED*** {
  return (this.high_ != other.high_***REMOVED*** || (this.low_ != other.low_***REMOVED***;
};

/**
 * Return whether this Timestamp is less than the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is less than the other.
 * @api public
 */
Timestamp.prototype.lessThan = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** < 0;
};

/**
 * Return whether this Timestamp is less than or equal to the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is less than or equal to the other.
 * @api public
 */
Timestamp.prototype.lessThanOrEqual = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** <= 0;
};

/**
 * Return whether this Timestamp is greater than the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is greater than the other.
 * @api public
 */
Timestamp.prototype.greaterThan = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** > 0;
};

/**
 * Return whether this Timestamp is greater than or equal to the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is greater than or equal to the other.
 * @api public
 */
Timestamp.prototype.greaterThanOrEqual = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** >= 0;
};

/**
 * Compares this Timestamp with the given one.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
 * @api public
 */
Timestamp.prototype.compare = function(other***REMOVED*** {
  if (this.equals(other***REMOVED******REMOVED*** {
    return 0;
***REMOVED***

  var thisNeg = this.isNegative(***REMOVED***;
  var otherNeg = other.isNegative(***REMOVED***;
  if (thisNeg && !otherNeg***REMOVED*** {
    return -1;
***REMOVED***
  if (!thisNeg && otherNeg***REMOVED*** {
    return 1;
***REMOVED***

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other***REMOVED***.isNegative(***REMOVED******REMOVED*** {
    return -1;
***REMOVED*** else {
    return 1;
***REMOVED***
};

/**
 * The negation of this value.
 *
 * @return {Timestamp} the negation of this value.
 * @api public
 */
Timestamp.prototype.negate = function(***REMOVED*** {
  if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return Timestamp.MIN_VALUE;
***REMOVED*** else {
    return this.not(***REMOVED***.add(Timestamp.ONE***REMOVED***;
***REMOVED***
};

/**
 * Returns the sum of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to add to this one.
 * @return {Timestamp} the sum of this and the given Timestamp.
 * @api public
 */
Timestamp.prototype.add = function(other***REMOVED*** {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Timestamp.fromBits((c16 << 16***REMOVED*** | c00, (c48 << 16***REMOVED*** | c32***REMOVED***;
};

/**
 * Returns the difference of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to subtract from this.
 * @return {Timestamp} the difference of this and the given Timestamp.
 * @api public
 */
Timestamp.prototype.subtract = function(other***REMOVED*** {
  return this.add(other.negate(***REMOVED******REMOVED***;
};

/**
 * Returns the product of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to multiply with this.
 * @return {Timestamp} the product of this and the other.
 * @api public
 */
Timestamp.prototype.multiply = function(other***REMOVED*** {
  if (this.isZero(***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED*** else if (other.isZero(***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED***

  if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return other.isOdd(***REMOVED*** ? Timestamp.MIN_VALUE : Timestamp.ZERO;
***REMOVED*** else if (other.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return this.isOdd(***REMOVED*** ? Timestamp.MIN_VALUE : Timestamp.ZERO;
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (other.isNegative(***REMOVED******REMOVED*** {
      return this.negate(***REMOVED***.multiply(other.negate(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.multiply(other***REMOVED***.negate(***REMOVED***;
  ***REMOVED***
***REMOVED*** else if (other.isNegative(***REMOVED******REMOVED*** {
    return this.multiply(other.negate(***REMOVED******REMOVED***.negate(***REMOVED***;
***REMOVED***

  // If both Timestamps are small, use float multiplication
  if (this.lessThan(Timestamp.TWO_PWR_24_***REMOVED*** &&
      other.lessThan(Timestamp.TWO_PWR_24_***REMOVED******REMOVED*** {
    return Timestamp.fromNumber(this.toNumber(***REMOVED*** * other.toNumber(***REMOVED******REMOVED***;
***REMOVED***

  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Timestamp.fromBits((c16 << 16***REMOVED*** | c00, (c48 << 16***REMOVED*** | c32***REMOVED***;
};

/**
 * Returns this Timestamp divided by the given one.
 *
 * @param {Timestamp} other Timestamp by which to divide.
 * @return {Timestamp} this Timestamp divided by the given one.
 * @api public
 */
Timestamp.prototype.div = function(other***REMOVED*** {
  if (other.isZero(***REMOVED******REMOVED*** {
    throw Error('division by zero'***REMOVED***;
***REMOVED*** else if (this.isZero(***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED***

  if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    if (other.equals(Timestamp.ONE***REMOVED*** ||
        other.equals(Timestamp.NEG_ONE***REMOVED******REMOVED*** {
      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
  ***REMOVED*** else if (other.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
      return Timestamp.ONE;
  ***REMOVED*** else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1***REMOVED***;
      var approx = halfThis.div(other***REMOVED***.shiftLeft(1***REMOVED***;
      if (approx.equals(Timestamp.ZERO***REMOVED******REMOVED*** {
        return other.isNegative(***REMOVED*** ? Timestamp.ONE : Timestamp.NEG_ONE;
    ***REMOVED*** else {
        var rem = this.subtract(other.multiply(approx***REMOVED******REMOVED***;
        var result = approx.add(rem.div(other***REMOVED******REMOVED***;
        return result;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if (other.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (other.isNegative(***REMOVED******REMOVED*** {
      return this.negate(***REMOVED***.div(other.negate(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.div(other***REMOVED***.negate(***REMOVED***;
  ***REMOVED***
***REMOVED*** else if (other.isNegative(***REMOVED******REMOVED*** {
    return this.div(other.negate(***REMOVED******REMOVED***.negate(***REMOVED***;
***REMOVED***

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Timestamp.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other***REMOVED******REMOVED*** {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber(***REMOVED*** / other.toNumber(***REMOVED******REMOVED******REMOVED***;

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx***REMOVED*** / Math.LN2***REMOVED***;
    var delta = (log2 <= 48***REMOVED*** ? 1 : Math.pow(2, log2 - 48***REMOVED***;

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Timestamp.fromNumber(approx***REMOVED***;
    var approxRem = approxRes.multiply(other***REMOVED***;
    while (approxRem.isNegative(***REMOVED*** || approxRem.greaterThan(rem***REMOVED******REMOVED*** {
      approx -= delta;
      approxRes = Timestamp.fromNumber(approx***REMOVED***;
      approxRem = approxRes.multiply(other***REMOVED***;
  ***REMOVED***

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero(***REMOVED******REMOVED*** {
      approxRes = Timestamp.ONE;
  ***REMOVED***

    res = res.add(approxRes***REMOVED***;
    rem = rem.subtract(approxRem***REMOVED***;
***REMOVED***
  return res;
};

/**
 * Returns this Timestamp modulo the given one.
 *
 * @param {Timestamp} other Timestamp by which to mod.
 * @return {Timestamp} this Timestamp modulo the given one.
 * @api public
 */
Timestamp.prototype.modulo = function(other***REMOVED*** {
  return this.subtract(this.div(other***REMOVED***.multiply(other***REMOVED******REMOVED***;
};

/**
 * The bitwise-NOT of this value.
 *
 * @return {Timestamp} the bitwise-NOT of this value.
 * @api public
 */
Timestamp.prototype.not = function(***REMOVED*** {
  return Timestamp.fromBits(~this.low_, ~this.high_***REMOVED***;
};

/**
 * Returns the bitwise-AND of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to AND.
 * @return {Timestamp} the bitwise-AND of this and the other.
 * @api public
 */
Timestamp.prototype.and = function(other***REMOVED*** {
  return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_***REMOVED***;
};

/**
 * Returns the bitwise-OR of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to OR.
 * @return {Timestamp} the bitwise-OR of this and the other.
 * @api public
 */
Timestamp.prototype.or = function(other***REMOVED*** {
  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_***REMOVED***;
};

/**
 * Returns the bitwise-XOR of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to XOR.
 * @return {Timestamp} the bitwise-XOR of this and the other.
 * @api public
 */
Timestamp.prototype.xor = function(other***REMOVED*** {
  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_***REMOVED***;
};

/**
 * Returns this Timestamp with bits shifted to the left by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the left by the given amount.
 * @api public
 */
Timestamp.prototype.shiftLeft = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var low = this.low_;
    if (numBits < 32***REMOVED*** {
      var high = this.high_;
      return Timestamp.fromBits(
                 low << numBits,
                 (high << numBits***REMOVED*** | (low >>> (32 - numBits***REMOVED******REMOVED******REMOVED***;
  ***REMOVED*** else {
      return Timestamp.fromBits(0, low << (numBits - 32***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns this Timestamp with bits shifted to the right by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the right by the given amount.
 * @api public
 */
Timestamp.prototype.shiftRight = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var high = this.high_;
    if (numBits < 32***REMOVED*** {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low >>> numBits***REMOVED*** | (high << (32 - numBits***REMOVED******REMOVED***,
                 high >> numBits***REMOVED***;
  ***REMOVED*** else {
      return Timestamp.fromBits(
                 high >> (numBits - 32***REMOVED***,
                 high >= 0 ? 0 : -1***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
 * @api public
 */
Timestamp.prototype.shiftRightUnsigned = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var high = this.high_;
    if (numBits < 32***REMOVED*** {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low >>> numBits***REMOVED*** | (high << (32 - numBits***REMOVED******REMOVED***,
                 high >>> numBits***REMOVED***;
  ***REMOVED*** else if (numBits == 32***REMOVED*** {
      return Timestamp.fromBits(high, 0***REMOVED***;
  ***REMOVED*** else {
      return Timestamp.fromBits(high >>> (numBits - 32***REMOVED***, 0***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns a Timestamp representing the given (32-bit***REMOVED*** integer value.
 *
 * @param {Number} value the 32-bit integer in question.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromInt = function(value***REMOVED*** {
  if (-128 <= value && value < 128***REMOVED*** {
    var cachedObj = Timestamp.INT_CACHE_[value];
    if (cachedObj***REMOVED*** {
      return cachedObj;
  ***REMOVED***
***REMOVED***

  var obj = new Timestamp(value | 0, value < 0 ? -1 : 0***REMOVED***;
  if (-128 <= value && value < 128***REMOVED*** {
    Timestamp.INT_CACHE_[value] = obj;
***REMOVED***
  return obj;
};

/**
 * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 *
 * @param {Number} value the number in question.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromNumber = function(value***REMOVED*** {
  if (isNaN(value***REMOVED*** || !isFinite(value***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED*** else if (value <= -Timestamp.TWO_PWR_63_DBL_***REMOVED*** {
    return Timestamp.MIN_VALUE;
***REMOVED*** else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_***REMOVED*** {
    return Timestamp.MAX_VALUE;
***REMOVED*** else if (value < 0***REMOVED*** {
    return Timestamp.fromNumber(-value***REMOVED***.negate(***REMOVED***;
***REMOVED*** else {
    return new Timestamp(
               (value % Timestamp.TWO_PWR_32_DBL_***REMOVED*** | 0,
               (value / Timestamp.TWO_PWR_32_DBL_***REMOVED*** | 0***REMOVED***;
***REMOVED***
};

/**
 * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
 *
 * @param {Number} lowBits the low 32-bits.
 * @param {Number} highBits the high 32-bits.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromBits = function(lowBits, highBits***REMOVED*** {
  return new Timestamp(lowBits, highBits***REMOVED***;
};

/**
 * Returns a Timestamp representation of the given string, written using the given radix.
 *
 * @param {String} str the textual representation of the Timestamp.
 * @param {Number} opt_radix the radix in which the text is written.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromString = function(str, opt_radix***REMOVED*** {
  if (str.length == 0***REMOVED*** {
    throw Error('number format error: empty string'***REMOVED***;
***REMOVED***

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix***REMOVED*** {
    throw Error('radix out of range: ' + radix***REMOVED***;
***REMOVED***

  if (str.charAt(0***REMOVED*** == '-'***REMOVED*** {
    return Timestamp.fromString(str.substring(1***REMOVED***, radix***REMOVED***.negate(***REMOVED***;
***REMOVED*** else if (str.indexOf('-'***REMOVED*** >= 0***REMOVED*** {
    throw Error('number format error: interior "-" character: ' + str***REMOVED***;
***REMOVED***

  // Do several (8***REMOVED*** digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8***REMOVED******REMOVED***;

  var result = Timestamp.ZERO;
  for (var i = 0; i < str.length; i += 8***REMOVED*** {
    var size = Math.min(8, str.length - i***REMOVED***;
    var value = parseInt(str.substring(i, i + size***REMOVED***, radix***REMOVED***;
    if (size < 8***REMOVED*** {
      var power = Timestamp.fromNumber(Math.pow(radix, size***REMOVED******REMOVED***;
      result = result.multiply(power***REMOVED***.add(Timestamp.fromNumber(value***REMOVED******REMOVED***;
  ***REMOVED*** else {
      result = result.multiply(radixToPower***REMOVED***;
      result = result.add(Timestamp.fromNumber(value***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  return result;
};

// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Timestamp representations of small integer values.
 * @type {Object}
 * @api private
 */
Timestamp.INT_CACHE_ = {};

// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_16_DBL_ = 1 << 16;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_24_DBL_ = 1 << 24;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;

/** @type {Timestamp} */
Timestamp.ZERO = Timestamp.fromInt(0***REMOVED***;

/** @type {Timestamp} */
Timestamp.ONE = Timestamp.fromInt(1***REMOVED***;

/** @type {Timestamp} */
Timestamp.NEG_ONE = Timestamp.fromInt(-1***REMOVED***;

/** @type {Timestamp} */
Timestamp.MAX_VALUE =
    Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0***REMOVED***;

/** @type {Timestamp} */
Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0***REMOVED***;

/**
 * @type {Timestamp}
 * @api private
 */
Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24***REMOVED***;

/**
 * Expose.
 */
exports.Timestamp = Timestamp;
}, 

 }***REMOVED***;


if(typeof module != 'undefined' && module.exports ***REMOVED***{
  module.exports = bson;

  if( !module.parent ***REMOVED***{
    bson(***REMOVED***;
***REMOVED***
}

if(typeof window != 'undefined' && typeof require == 'undefined'***REMOVED***{
  window.require = bson.require;
}
