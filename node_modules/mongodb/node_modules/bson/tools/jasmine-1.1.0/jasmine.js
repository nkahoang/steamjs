var isCommonJS = typeof window == "undefined";

/**
 * Top level namespace for Jasmine, a lightweight JavaScript BDD/spec/testing framework.
 *
 * @namespace
 */
var jasmine = {};
if (isCommonJS***REMOVED*** exports.jasmine = jasmine;
/**
 * @private
 */
jasmine.unimplementedMethod_ = function(***REMOVED*** {
  throw new Error("unimplemented method"***REMOVED***;
};

/**
 * Use <code>jasmine.undefined</code> instead of <code>undefined</code>, since <code>undefined</code> is just
 * a plain old variable and may be redefined by somebody else.
 *
 * @private
 */
jasmine.undefined = jasmine.___undefined___;

/**
 * Show diagnostic messages in the console if set to true
 *
 */
jasmine.VERBOSE = false;

/**
 * Default interval in milliseconds for event loop yields (e.g. to allow network activity or to refresh the screen with the HTML-based runner***REMOVED***. Small values here may result in slow test running. Zero means no updates until all tests have completed.
 *
 */
jasmine.DEFAULT_UPDATE_INTERVAL = 250;

/**
 * Default timeout interval in milliseconds for waitsFor(***REMOVED*** blocks.
 */
jasmine.DEFAULT_TIMEOUT_INTERVAL = 5000;

jasmine.getGlobal = function(***REMOVED*** {
  function getGlobal(***REMOVED*** {
    return this;
***REMOVED***

  return getGlobal(***REMOVED***;
};

/**
 * Allows for bound functions to be compared.  Internal use only.
 *
 * @ignore
 * @private
 * @param base {Object} bound 'this' for the function
 * @param name {Function} function to find
 */
jasmine.bindOriginal_ = function(base, name***REMOVED*** {
  var original = base[name];
  if (original.apply***REMOVED*** {
    return function(***REMOVED*** {
      return original.apply(base, arguments***REMOVED***;
  ***REMOVED***;
***REMOVED*** else {
    // IE support
    return jasmine.getGlobal(***REMOVED***[name];
***REMOVED***
};

jasmine.setTimeout = jasmine.bindOriginal_(jasmine.getGlobal(***REMOVED***, 'setTimeout'***REMOVED***;
jasmine.clearTimeout = jasmine.bindOriginal_(jasmine.getGlobal(***REMOVED***, 'clearTimeout'***REMOVED***;
jasmine.setInterval = jasmine.bindOriginal_(jasmine.getGlobal(***REMOVED***, 'setInterval'***REMOVED***;
jasmine.clearInterval = jasmine.bindOriginal_(jasmine.getGlobal(***REMOVED***, 'clearInterval'***REMOVED***;

jasmine.MessageResult = function(values***REMOVED*** {
  this.type = 'log';
  this.values = values;
  this.trace = new Error(***REMOVED***; // todo: test better
};

jasmine.MessageResult.prototype.toString = function(***REMOVED*** {
  var text = "";
  for (var i = 0; i < this.values.length; i++***REMOVED*** {
    if (i > 0***REMOVED*** text += " ";
    if (jasmine.isString_(this.values[i]***REMOVED******REMOVED*** {
      text += this.values[i];
  ***REMOVED*** else {
      text += jasmine.pp(this.values[i]***REMOVED***;
  ***REMOVED***
***REMOVED***
  return text;
};

jasmine.ExpectationResult = function(params***REMOVED*** {
  this.type = 'expect';
  this.matcherName = params.matcherName;
  this.passed_ = params.passed;
  this.expected = params.expected;
  this.actual = params.actual;
  this.message = this.passed_ ? 'Passed.' : params.message;

  var trace = (params.trace || new Error(this.message***REMOVED******REMOVED***;
  this.trace = this.passed_ ? '' : trace;
};

jasmine.ExpectationResult.prototype.toString = function (***REMOVED*** {
  return this.message;
};

jasmine.ExpectationResult.prototype.passed = function (***REMOVED*** {
  return this.passed_;
};

/**
 * Getter for the Jasmine environment. Ensures one gets created
 */
jasmine.getEnv = function(***REMOVED*** {
  var env = jasmine.currentEnv_ = jasmine.currentEnv_ || new jasmine.Env(***REMOVED***;
  return env;
};

/**
 * @ignore
 * @private
 * @param value
 * @returns {Boolean}
 */
jasmine.isArray_ = function(value***REMOVED*** {
  return jasmine.isA_("Array", value***REMOVED***;
};

/**
 * @ignore
 * @private
 * @param value
 * @returns {Boolean}
 */
jasmine.isString_ = function(value***REMOVED*** {
  return jasmine.isA_("String", value***REMOVED***;
};

/**
 * @ignore
 * @private
 * @param value
 * @returns {Boolean}
 */
jasmine.isNumber_ = function(value***REMOVED*** {
  return jasmine.isA_("Number", value***REMOVED***;
};

/**
 * @ignore
 * @private
 * @param {String} typeName
 * @param value
 * @returns {Boolean}
 */
jasmine.isA_ = function(typeName, value***REMOVED*** {
  return Object.prototype.toString.apply(value***REMOVED*** === '[object ' + typeName + ']';
};

/**
 * Pretty printer for expecations.  Takes any object and turns it into a human-readable string.
 *
 * @param value {Object} an object to be outputted
 * @returns {String}
 */
jasmine.pp = function(value***REMOVED*** {
  var stringPrettyPrinter = new jasmine.StringPrettyPrinter(***REMOVED***;
  stringPrettyPrinter.format(value***REMOVED***;
  return stringPrettyPrinter.string;
};

/**
 * Returns true if the object is a DOM Node.
 *
 * @param {Object} obj object to check
 * @returns {Boolean}
 */
jasmine.isDomNode = function(obj***REMOVED*** {
  return obj.nodeType > 0;
};

/**
 * Returns a matchable 'generic' object of the class type.  For use in expecations of type when values don't matter.
 *
 * @example
 * // don't care about which function is passed in, as long as it's a function
 * expect(mySpy***REMOVED***.toHaveBeenCalledWith(jasmine.any(Function***REMOVED******REMOVED***;
 *
 * @param {Class} clazz
 * @returns matchable object of the type clazz
 */
jasmine.any = function(clazz***REMOVED*** {
  return new jasmine.Matchers.Any(clazz***REMOVED***;
};

/**
 * Jasmine Spies are test doubles that can act as stubs, spies, fakes or when used in an expecation, mocks.
 *
 * Spies should be created in test setup, before expectations.  They can then be checked, using the standard Jasmine
 * expectation syntax. Spies can be checked if they were called or not and what the calling params were.
 *
 * A Spy has the following fields: wasCalled, callCount, mostRecentCall, and argsForCall (see docs***REMOVED***.
 *
 * Spies are torn down at the end of every spec.
 *
 * Note: Do <b>not</b> call new jasmine.Spy(***REMOVED*** directly - a spy must be created using spyOn, jasmine.createSpy or jasmine.createSpyObj.
 *
 * @example
 * // a stub
 * var myStub = jasmine.createSpy('myStub'***REMOVED***;  // can be used anywhere
 *
 * // spy example
 * var foo = {
 *   not: function(bool***REMOVED*** { return !bool; }
 * }
 *
 * // actual foo.not will not be called, execution stops
 * spyOn(foo, 'not'***REMOVED***;

 // foo.not spied upon, execution will continue to implementation
 * spyOn(foo, 'not'***REMOVED***.andCallThrough(***REMOVED***;
 *
 * // fake example
 * var foo = {
 *   not: function(bool***REMOVED*** { return !bool; }
 * }
 *
 * // foo.not(val***REMOVED*** will return val
 * spyOn(foo, 'not'***REMOVED***.andCallFake(function(value***REMOVED*** {return value;}***REMOVED***;
 *
 * // mock example
 * foo.not(7 == 7***REMOVED***;
 * expect(foo.not***REMOVED***.toHaveBeenCalled(***REMOVED***;
 * expect(foo.not***REMOVED***.toHaveBeenCalledWith(true***REMOVED***;
 *
 * @constructor
 * @see spyOn, jasmine.createSpy, jasmine.createSpyObj
 * @param {String} name
 */
jasmine.Spy = function(name***REMOVED*** {
  /**
   * The name of the spy, if provided.
   */
  this.identity = name || 'unknown';
  /**
   *  Is this Object a spy?
   */
  this.isSpy = true;
  /**
   * The actual function this spy stubs.
   */
  this.plan = function(***REMOVED*** {
***REMOVED***;
  /**
   * Tracking of the most recent call to the spy.
   * @example
   * var mySpy = jasmine.createSpy('foo'***REMOVED***;
   * mySpy(1, 2***REMOVED***;
   * mySpy.mostRecentCall.args = [1, 2];
   */
  this.mostRecentCall = {};

  /**
   * Holds arguments for each call to the spy, indexed by call count
   * @example
   * var mySpy = jasmine.createSpy('foo'***REMOVED***;
   * mySpy(1, 2***REMOVED***;
   * mySpy(7, 8***REMOVED***;
   * mySpy.mostRecentCall.args = [7, 8];
   * mySpy.argsForCall[0] = [1, 2];
   * mySpy.argsForCall[1] = [7, 8];
   */
  this.argsForCall = [];
  this.calls = [];
};

/**
 * Tells a spy to call through to the actual implemenatation.
 *
 * @example
 * var foo = {
 *   bar: function(***REMOVED*** { // do some stuff }
 * }
 *
 * // defining a spy on an existing property: foo.bar
 * spyOn(foo, 'bar'***REMOVED***.andCallThrough(***REMOVED***;
 */
jasmine.Spy.prototype.andCallThrough = function(***REMOVED*** {
  this.plan = this.originalValue;
  return this;
};

/**
 * For setting the return value of a spy.
 *
 * @example
 * // defining a spy from scratch: foo(***REMOVED*** returns 'baz'
 * var foo = jasmine.createSpy('spy on foo'***REMOVED***.andReturn('baz'***REMOVED***;
 *
 * // defining a spy on an existing property: foo.bar(***REMOVED*** returns 'baz'
 * spyOn(foo, 'bar'***REMOVED***.andReturn('baz'***REMOVED***;
 *
 * @param {Object} value
 */
jasmine.Spy.prototype.andReturn = function(value***REMOVED*** {
  this.plan = function(***REMOVED*** {
    return value;
***REMOVED***;
  return this;
};

/**
 * For throwing an exception when a spy is called.
 *
 * @example
 * // defining a spy from scratch: foo(***REMOVED*** throws an exception w/ message 'ouch'
 * var foo = jasmine.createSpy('spy on foo'***REMOVED***.andThrow('baz'***REMOVED***;
 *
 * // defining a spy on an existing property: foo.bar(***REMOVED*** throws an exception w/ message 'ouch'
 * spyOn(foo, 'bar'***REMOVED***.andThrow('baz'***REMOVED***;
 *
 * @param {String} exceptionMsg
 */
jasmine.Spy.prototype.andThrow = function(exceptionMsg***REMOVED*** {
  this.plan = function(***REMOVED*** {
    throw exceptionMsg;
***REMOVED***;
  return this;
};

/**
 * Calls an alternate implementation when a spy is called.
 *
 * @example
 * var baz = function(***REMOVED*** {
 *   // do some stuff, return something
 * }
 * // defining a spy from scratch: foo(***REMOVED*** calls the function baz
 * var foo = jasmine.createSpy('spy on foo'***REMOVED***.andCall(baz***REMOVED***;
 *
 * // defining a spy on an existing property: foo.bar(***REMOVED*** calls an anonymnous function
 * spyOn(foo, 'bar'***REMOVED***.andCall(function(***REMOVED*** { return 'baz';} ***REMOVED***;
 *
 * @param {Function} fakeFunc
 */
jasmine.Spy.prototype.andCallFake = function(fakeFunc***REMOVED*** {
  this.plan = fakeFunc;
  return this;
};

/**
 * Resets all of a spy's the tracking variables so that it can be used again.
 *
 * @example
 * spyOn(foo, 'bar'***REMOVED***;
 *
 * foo.bar(***REMOVED***;
 *
 * expect(foo.bar.callCount***REMOVED***.toEqual(1***REMOVED***;
 *
 * foo.bar.reset(***REMOVED***;
 *
 * expect(foo.bar.callCount***REMOVED***.toEqual(0***REMOVED***;
 */
jasmine.Spy.prototype.reset = function(***REMOVED*** {
  this.wasCalled = false;
  this.callCount = 0;
  this.argsForCall = [];
  this.calls = [];
  this.mostRecentCall = {};
};

jasmine.createSpy = function(name***REMOVED*** {

  var spyObj = function(***REMOVED*** {
    spyObj.wasCalled = true;
    spyObj.callCount++;
    var args = jasmine.util.argsToArray(arguments***REMOVED***;
    spyObj.mostRecentCall.object = this;
    spyObj.mostRecentCall.args = args;
    spyObj.argsForCall.push(args***REMOVED***;
    spyObj.calls.push({object: this, args: args}***REMOVED***;
    return spyObj.plan.apply(this, arguments***REMOVED***;
***REMOVED***;

  var spy = new jasmine.Spy(name***REMOVED***;

  for (var prop in spy***REMOVED*** {
    spyObj[prop] = spy[prop];
***REMOVED***

  spyObj.reset(***REMOVED***;

  return spyObj;
};

/**
 * Determines whether an object is a spy.
 *
 * @param {jasmine.Spy|Object} putativeSpy
 * @returns {Boolean}
 */
jasmine.isSpy = function(putativeSpy***REMOVED*** {
  return putativeSpy && putativeSpy.isSpy;
};

/**
 * Creates a more complicated spy: an Object that has every property a function that is a spy.  Used for stubbing something
 * large in one call.
 *
 * @param {String} baseName name of spy class
 * @param {Array} methodNames array of names of methods to make spies
 */
jasmine.createSpyObj = function(baseName, methodNames***REMOVED*** {
  if (!jasmine.isArray_(methodNames***REMOVED*** || methodNames.length === 0***REMOVED*** {
    throw new Error('createSpyObj requires a non-empty array of method names to create spies for'***REMOVED***;
***REMOVED***
  var obj = {};
  for (var i = 0; i < methodNames.length; i++***REMOVED*** {
    obj[methodNames[i]] = jasmine.createSpy(baseName + '.' + methodNames[i]***REMOVED***;
***REMOVED***
  return obj;
};

/**
 * All parameters are pretty-printed and concatenated together, then written to the current spec's output.
 *
 * Be careful not to leave calls to <code>jasmine.log</code> in production code.
 */
jasmine.log = function(***REMOVED*** {
  var spec = jasmine.getEnv(***REMOVED***.currentSpec;
  spec.log.apply(spec, arguments***REMOVED***;
};

/**
 * Function that installs a spy on an existing object's method name.  Used within a Spec to create a spy.
 *
 * @example
 * // spy example
 * var foo = {
 *   not: function(bool***REMOVED*** { return !bool; }
 * }
 * spyOn(foo, 'not'***REMOVED***; // actual foo.not will not be called, execution stops
 *
 * @see jasmine.createSpy
 * @param obj
 * @param methodName
 * @returns a Jasmine spy that can be chained with all spy methods
 */
var spyOn = function(obj, methodName***REMOVED*** {
  return jasmine.getEnv(***REMOVED***.currentSpec.spyOn(obj, methodName***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.spyOn = spyOn;

/**
 * Creates a Jasmine spec that will be added to the current suite.
 *
 * // TODO: pending tests
 *
 * @example
 * it('should be true', function(***REMOVED*** {
 *   expect(true***REMOVED***.toEqual(true***REMOVED***;
 * }***REMOVED***;
 *
 * @param {String} desc description of this specification
 * @param {Function} func defines the preconditions and expectations of the spec
 */
var it = function(desc, func***REMOVED*** {
  return jasmine.getEnv(***REMOVED***.it(desc, func***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.it = it;

/**
 * Creates a <em>disabled</em> Jasmine spec.
 *
 * A convenience method that allows existing specs to be disabled temporarily during development.
 *
 * @param {String} desc description of this specification
 * @param {Function} func defines the preconditions and expectations of the spec
 */
var xit = function(desc, func***REMOVED*** {
  return jasmine.getEnv(***REMOVED***.xit(desc, func***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.xit = xit;

/**
 * Starts a chain for a Jasmine expectation.
 *
 * It is passed an Object that is the actual value and should chain to one of the many
 * jasmine.Matchers functions.
 *
 * @param {Object} actual Actual value to test against and expected value
 */
var expect = function(actual***REMOVED*** {
  return jasmine.getEnv(***REMOVED***.currentSpec.expect(actual***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.expect = expect;

/**
 * Defines part of a jasmine spec.  Used in cominbination with waits or waitsFor in asynchrnous specs.
 *
 * @param {Function} func Function that defines part of a jasmine spec.
 */
var runs = function(func***REMOVED*** {
  jasmine.getEnv(***REMOVED***.currentSpec.runs(func***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.runs = runs;

/**
 * Waits a fixed time period before moving to the next block.
 *
 * @deprecated Use waitsFor(***REMOVED*** instead
 * @param {Number} timeout milliseconds to wait
 */
var waits = function(timeout***REMOVED*** {
  jasmine.getEnv(***REMOVED***.currentSpec.waits(timeout***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.waits = waits;

/**
 * Waits for the latchFunction to return true before proceeding to the next block.
 *
 * @param {Function} latchFunction
 * @param {String} optional_timeoutMessage
 * @param {Number} optional_timeout
 */
var waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout***REMOVED*** {
  jasmine.getEnv(***REMOVED***.currentSpec.waitsFor.apply(jasmine.getEnv(***REMOVED***.currentSpec, arguments***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.waitsFor = waitsFor;

/**
 * A function that is called before each spec in a suite.
 *
 * Used for spec setup, including validating assumptions.
 *
 * @param {Function} beforeEachFunction
 */
var beforeEach = function(beforeEachFunction***REMOVED*** {
  jasmine.getEnv(***REMOVED***.beforeEach(beforeEachFunction***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.beforeEach = beforeEach;

/**
 * A function that is called after each spec in a suite.
 *
 * Used for restoring any state that is hijacked during spec execution.
 *
 * @param {Function} afterEachFunction
 */
var afterEach = function(afterEachFunction***REMOVED*** {
  jasmine.getEnv(***REMOVED***.afterEach(afterEachFunction***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.afterEach = afterEach;

/**
 * Defines a suite of specifications.
 *
 * Stores the description and all defined specs in the Jasmine environment as one suite of specs. Variables declared
 * are accessible by calls to beforeEach, it, and afterEach. Describe blocks can be nested, allowing for specialization
 * of setup in some tests.
 *
 * @example
 * // TODO: a simple suite
 *
 * // TODO: a simple suite with a nested describe block
 *
 * @param {String} description A string, usually the class under test.
 * @param {Function} specDefinitions function that defines several specs.
 */
var describe = function(description, specDefinitions***REMOVED*** {
  return jasmine.getEnv(***REMOVED***.describe(description, specDefinitions***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.describe = describe;

/**
 * Disables a suite of specifications.  Used to disable some suites in a file, or files, temporarily during development.
 *
 * @param {String} description A string, usually the class under test.
 * @param {Function} specDefinitions function that defines several specs.
 */
var xdescribe = function(description, specDefinitions***REMOVED*** {
  return jasmine.getEnv(***REMOVED***.xdescribe(description, specDefinitions***REMOVED***;
};
if (isCommonJS***REMOVED*** exports.xdescribe = xdescribe;


// Provide the XMLHttpRequest class for IE 5.x-6.x:
jasmine.XmlHttpRequest = (typeof XMLHttpRequest == "undefined"***REMOVED*** ? function(***REMOVED*** {
  function tryIt(f***REMOVED*** {
    try {
      return f(***REMOVED***;
  ***REMOVED*** catch(e***REMOVED*** {
  ***REMOVED***
    return null;
***REMOVED***

  var xhr = tryIt(function(***REMOVED*** {
    return new ActiveXObject("Msxml2.XMLHTTP.6.0"***REMOVED***;
***REMOVED******REMOVED*** ||
    tryIt(function(***REMOVED*** {
      return new ActiveXObject("Msxml2.XMLHTTP.3.0"***REMOVED***;
  ***REMOVED******REMOVED*** ||
    tryIt(function(***REMOVED*** {
      return new ActiveXObject("Msxml2.XMLHTTP"***REMOVED***;
  ***REMOVED******REMOVED*** ||
    tryIt(function(***REMOVED*** {
      return new ActiveXObject("Microsoft.XMLHTTP"***REMOVED***;
  ***REMOVED******REMOVED***;

  if (!xhr***REMOVED*** throw new Error("This browser does not support XMLHttpRequest."***REMOVED***;

  return xhr;
} : XMLHttpRequest;
/**
 * @namespace
 */
jasmine.util = {};

/**
 * Declare that a child class inherit it's prototype from the parent class.
 *
 * @private
 * @param {Function} childClass
 * @param {Function} parentClass
 */
jasmine.util.inherit = function(childClass, parentClass***REMOVED*** {
  /**
   * @private
   */
  var subclass = function(***REMOVED*** {
***REMOVED***;
  subclass.prototype = parentClass.prototype;
  childClass.prototype = new subclass(***REMOVED***;
};

jasmine.util.formatException = function(e***REMOVED*** {
  var lineNumber;
  if (e.line***REMOVED*** {
    lineNumber = e.line;
***REMOVED***
  else if (e.lineNumber***REMOVED*** {
    lineNumber = e.lineNumber;
***REMOVED***

  var file;

  if (e.sourceURL***REMOVED*** {
    file = e.sourceURL;
***REMOVED***
  else if (e.fileName***REMOVED*** {
    file = e.fileName;
***REMOVED***

  var message = (e.name && e.message***REMOVED*** ? (e.name + ': ' + e.message***REMOVED*** : e.toString(***REMOVED***;

  if (file && lineNumber***REMOVED*** {
    message += ' in ' + file + ' (line ' + lineNumber + '***REMOVED***';
***REMOVED***

  return message;
};

jasmine.util.htmlEscape = function(str***REMOVED*** {
  if (!str***REMOVED*** return str;
  return str.replace(/&/g, '&amp;'***REMOVED***
    .replace(/</g, '&lt;'***REMOVED***
    .replace(/>/g, '&gt;'***REMOVED***;
};

jasmine.util.argsToArray = function(args***REMOVED*** {
  var arrayOfArgs = [];
  for (var i = 0; i < args.length; i++***REMOVED*** arrayOfArgs.push(args[i]***REMOVED***;
  return arrayOfArgs;
};

jasmine.util.extend = function(destination, source***REMOVED*** {
  for (var property in source***REMOVED*** destination[property] = source[property];
  return destination;
};

/**
 * Environment for Jasmine
 *
 * @constructor
 */
jasmine.Env = function(***REMOVED*** {
  this.currentSpec = null;
  this.currentSuite = null;
  this.currentRunner_ = new jasmine.Runner(this***REMOVED***;

  this.reporter = new jasmine.MultiReporter(***REMOVED***;

  this.updateInterval = jasmine.DEFAULT_UPDATE_INTERVAL;
  this.defaultTimeoutInterval = jasmine.DEFAULT_TIMEOUT_INTERVAL;
  this.lastUpdate = 0;
  this.specFilter = function(***REMOVED*** {
    return true;
***REMOVED***;

  this.nextSpecId_ = 0;
  this.nextSuiteId_ = 0;
  this.equalityTesters_ = [];

  // wrap matchers
  this.matchersClass = function(***REMOVED*** {
    jasmine.Matchers.apply(this, arguments***REMOVED***;
***REMOVED***;
  jasmine.util.inherit(this.matchersClass, jasmine.Matchers***REMOVED***;

  jasmine.Matchers.wrapInto_(jasmine.Matchers.prototype, this.matchersClass***REMOVED***;
};


jasmine.Env.prototype.setTimeout = jasmine.setTimeout;
jasmine.Env.prototype.clearTimeout = jasmine.clearTimeout;
jasmine.Env.prototype.setInterval = jasmine.setInterval;
jasmine.Env.prototype.clearInterval = jasmine.clearInterval;

/**
 * @returns an object containing jasmine version build info, if set.
 */
jasmine.Env.prototype.version = function (***REMOVED*** {
  if (jasmine.version_***REMOVED*** {
    return jasmine.version_;
***REMOVED*** else {
    throw new Error('Version not set'***REMOVED***;
***REMOVED***
};

/**
 * @returns string containing jasmine version build info, if set.
 */
jasmine.Env.prototype.versionString = function(***REMOVED*** {
  if (!jasmine.version_***REMOVED*** {
    return "version unknown";
***REMOVED***

  var version = this.version(***REMOVED***;
  var versionString = version.major + "." + version.minor + "." + version.build;
  if (version.release_candidate***REMOVED*** {
    versionString += ".rc" + version.release_candidate;
***REMOVED***
  versionString += " revision " + version.revision;
  return versionString;
};

/**
 * @returns a sequential integer starting at 0
 */
jasmine.Env.prototype.nextSpecId = function (***REMOVED*** {
  return this.nextSpecId_++;
};

/**
 * @returns a sequential integer starting at 0
 */
jasmine.Env.prototype.nextSuiteId = function (***REMOVED*** {
  return this.nextSuiteId_++;
};

/**
 * Register a reporter to receive status updates from Jasmine.
 * @param {jasmine.Reporter} reporter An object which will receive status updates.
 */
jasmine.Env.prototype.addReporter = function(reporter***REMOVED*** {
  this.reporter.addReporter(reporter***REMOVED***;
};

jasmine.Env.prototype.execute = function(***REMOVED*** {
  this.currentRunner_.execute(***REMOVED***;
};

jasmine.Env.prototype.describe = function(description, specDefinitions***REMOVED*** {
  var suite = new jasmine.Suite(this, description, specDefinitions, this.currentSuite***REMOVED***;

  var parentSuite = this.currentSuite;
  if (parentSuite***REMOVED*** {
    parentSuite.add(suite***REMOVED***;
***REMOVED*** else {
    this.currentRunner_.add(suite***REMOVED***;
***REMOVED***

  this.currentSuite = suite;

  var declarationError = null;
  try {
    specDefinitions.call(suite***REMOVED***;
***REMOVED*** catch(e***REMOVED*** {
    declarationError = e;
***REMOVED***

  if (declarationError***REMOVED*** {
    this.it("encountered a declaration exception", function(***REMOVED*** {
      throw declarationError;
  ***REMOVED******REMOVED***;
***REMOVED***

  this.currentSuite = parentSuite;

  return suite;
};

jasmine.Env.prototype.beforeEach = function(beforeEachFunction***REMOVED*** {
  if (this.currentSuite***REMOVED*** {
    this.currentSuite.beforeEach(beforeEachFunction***REMOVED***;
***REMOVED*** else {
    this.currentRunner_.beforeEach(beforeEachFunction***REMOVED***;
***REMOVED***
};

jasmine.Env.prototype.currentRunner = function (***REMOVED*** {
  return this.currentRunner_;
};

jasmine.Env.prototype.afterEach = function(afterEachFunction***REMOVED*** {
  if (this.currentSuite***REMOVED*** {
    this.currentSuite.afterEach(afterEachFunction***REMOVED***;
***REMOVED*** else {
    this.currentRunner_.afterEach(afterEachFunction***REMOVED***;
***REMOVED***

};

jasmine.Env.prototype.xdescribe = function(desc, specDefinitions***REMOVED*** {
  return {
    execute: function(***REMOVED*** {
  ***REMOVED***
***REMOVED***;
};

jasmine.Env.prototype.it = function(description, func***REMOVED*** {
  var spec = new jasmine.Spec(this, this.currentSuite, description***REMOVED***;
  this.currentSuite.add(spec***REMOVED***;
  this.currentSpec = spec;

  if (func***REMOVED*** {
    spec.runs(func***REMOVED***;
***REMOVED***

  return spec;
};

jasmine.Env.prototype.xit = function(desc, func***REMOVED*** {
  return {
    id: this.nextSpecId(***REMOVED***,
    runs: function(***REMOVED*** {
  ***REMOVED***
***REMOVED***;
};

jasmine.Env.prototype.compareObjects_ = function(a, b, mismatchKeys, mismatchValues***REMOVED*** {
  if (a.__Jasmine_been_here_before__ === b && b.__Jasmine_been_here_before__ === a***REMOVED*** {
    return true;
***REMOVED***

  a.__Jasmine_been_here_before__ = b;
  b.__Jasmine_been_here_before__ = a;

  var hasKey = function(obj, keyName***REMOVED*** {
    return obj !== null && obj[keyName] !== jasmine.undefined;
***REMOVED***;

  for (var property in b***REMOVED*** {
    if (!hasKey(a, property***REMOVED*** && hasKey(b, property***REMOVED******REMOVED*** {
      mismatchKeys.push("expected has key '" + property + "', but missing from actual."***REMOVED***;
  ***REMOVED***
***REMOVED***
  for (property in a***REMOVED*** {
    if (!hasKey(b, property***REMOVED*** && hasKey(a, property***REMOVED******REMOVED*** {
      mismatchKeys.push("expected missing key '" + property + "', but present in actual."***REMOVED***;
  ***REMOVED***
***REMOVED***
  for (property in b***REMOVED*** {
    if (property == '__Jasmine_been_here_before__'***REMOVED*** continue;
    if (!this.equals_(a[property], b[property], mismatchKeys, mismatchValues***REMOVED******REMOVED*** {
      mismatchValues.push("'" + property + "' was '" + (b[property] ? jasmine.util.htmlEscape(b[property].toString(***REMOVED******REMOVED*** : b[property]***REMOVED*** + "' in expected, but was '" + (a[property] ? jasmine.util.htmlEscape(a[property].toString(***REMOVED******REMOVED*** : a[property]***REMOVED*** + "' in actual."***REMOVED***;
  ***REMOVED***
***REMOVED***

  if (jasmine.isArray_(a***REMOVED*** && jasmine.isArray_(b***REMOVED*** && a.length != b.length***REMOVED*** {
    mismatchValues.push("arrays were not the same length"***REMOVED***;
***REMOVED***

  delete a.__Jasmine_been_here_before__;
  delete b.__Jasmine_been_here_before__;
  return (mismatchKeys.length === 0 && mismatchValues.length === 0***REMOVED***;
};

jasmine.Env.prototype.equals_ = function(a, b, mismatchKeys, mismatchValues***REMOVED*** {
  mismatchKeys = mismatchKeys || [];
  mismatchValues = mismatchValues || [];

  for (var i = 0; i < this.equalityTesters_.length; i++***REMOVED*** {
    var equalityTester = this.equalityTesters_[i];
    var result = equalityTester(a, b, this, mismatchKeys, mismatchValues***REMOVED***;
    if (result !== jasmine.undefined***REMOVED*** return result;
***REMOVED***

  if (a === b***REMOVED*** return true;

  if (a === jasmine.undefined || a === null || b === jasmine.undefined || b === null***REMOVED*** {
    return (a == jasmine.undefined && b == jasmine.undefined***REMOVED***;
***REMOVED***

  if (jasmine.isDomNode(a***REMOVED*** && jasmine.isDomNode(b***REMOVED******REMOVED*** {
    return a === b;
***REMOVED***

  if (a instanceof Date && b instanceof Date***REMOVED*** {
    return a.getTime(***REMOVED*** == b.getTime(***REMOVED***;
***REMOVED***

  if (a instanceof jasmine.Matchers.Any***REMOVED*** {
    return a.matches(b***REMOVED***;
***REMOVED***

  if (b instanceof jasmine.Matchers.Any***REMOVED*** {
    return b.matches(a***REMOVED***;
***REMOVED***

  if (jasmine.isString_(a***REMOVED*** && jasmine.isString_(b***REMOVED******REMOVED*** {
    return (a == b***REMOVED***;
***REMOVED***

  if (jasmine.isNumber_(a***REMOVED*** && jasmine.isNumber_(b***REMOVED******REMOVED*** {
    return (a == b***REMOVED***;
***REMOVED***

  if (typeof a === "object" && typeof b === "object"***REMOVED*** {
    return this.compareObjects_(a, b, mismatchKeys, mismatchValues***REMOVED***;
***REMOVED***

  //Straight check
  return (a === b***REMOVED***;
};

jasmine.Env.prototype.contains_ = function(haystack, needle***REMOVED*** {
  if (jasmine.isArray_(haystack***REMOVED******REMOVED*** {
    for (var i = 0; i < haystack.length; i++***REMOVED*** {
      if (this.equals_(haystack[i], needle***REMOVED******REMOVED*** return true;
  ***REMOVED***
    return false;
***REMOVED***
  return haystack.indexOf(needle***REMOVED*** >= 0;
};

jasmine.Env.prototype.addEqualityTester = function(equalityTester***REMOVED*** {
  this.equalityTesters_.push(equalityTester***REMOVED***;
};
/** No-op base class for Jasmine reporters.
 *
 * @constructor
 */
jasmine.Reporter = function(***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.Reporter.prototype.reportRunnerStarting = function(runner***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.Reporter.prototype.reportRunnerResults = function(runner***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.Reporter.prototype.reportSuiteResults = function(suite***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.Reporter.prototype.reportSpecStarting = function(spec***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.Reporter.prototype.reportSpecResults = function(spec***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.Reporter.prototype.log = function(str***REMOVED*** {
};

/**
 * Blocks are functions with executable code that make up a spec.
 *
 * @constructor
 * @param {jasmine.Env} env
 * @param {Function} func
 * @param {jasmine.Spec} spec
 */
jasmine.Block = function(env, func, spec***REMOVED*** {
  this.env = env;
  this.func = func;
  this.spec = spec;
};

jasmine.Block.prototype.execute = function(onComplete***REMOVED*** {  
  try {
    this.func.apply(this.spec***REMOVED***;
***REMOVED*** catch (e***REMOVED*** {
    this.spec.fail(e***REMOVED***;
***REMOVED***
  onComplete(***REMOVED***;
};
/** JavaScript API reporter.
 *
 * @constructor
 */
jasmine.JsApiReporter = function(***REMOVED*** {
  this.started = false;
  this.finished = false;
  this.suites_ = [];
  this.results_ = {};
};

jasmine.JsApiReporter.prototype.reportRunnerStarting = function(runner***REMOVED*** {
  this.started = true;
  var suites = runner.topLevelSuites(***REMOVED***;
  for (var i = 0; i < suites.length; i++***REMOVED*** {
    var suite = suites[i];
    this.suites_.push(this.summarize_(suite***REMOVED******REMOVED***;
***REMOVED***
};

jasmine.JsApiReporter.prototype.suites = function(***REMOVED*** {
  return this.suites_;
};

jasmine.JsApiReporter.prototype.summarize_ = function(suiteOrSpec***REMOVED*** {
  var isSuite = suiteOrSpec instanceof jasmine.Suite;
  var summary = {
    id: suiteOrSpec.id,
    name: suiteOrSpec.description,
    type: isSuite ? 'suite' : 'spec',
    children: []
***REMOVED***;
  
  if (isSuite***REMOVED*** {
    var children = suiteOrSpec.children(***REMOVED***;
    for (var i = 0; i < children.length; i++***REMOVED*** {
      summary.children.push(this.summarize_(children[i]***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  return summary;
};

jasmine.JsApiReporter.prototype.results = function(***REMOVED*** {
  return this.results_;
};

jasmine.JsApiReporter.prototype.resultsForSpec = function(specId***REMOVED*** {
  return this.results_[specId];
};

//noinspection JSUnusedLocalSymbols
jasmine.JsApiReporter.prototype.reportRunnerResults = function(runner***REMOVED*** {
  this.finished = true;
};

//noinspection JSUnusedLocalSymbols
jasmine.JsApiReporter.prototype.reportSuiteResults = function(suite***REMOVED*** {
};

//noinspection JSUnusedLocalSymbols
jasmine.JsApiReporter.prototype.reportSpecResults = function(spec***REMOVED*** {
  this.results_[spec.id] = {
    messages: spec.results(***REMOVED***.getItems(***REMOVED***,
    result: spec.results(***REMOVED***.failedCount > 0 ? "failed" : "passed"
***REMOVED***;
};

//noinspection JSUnusedLocalSymbols
jasmine.JsApiReporter.prototype.log = function(str***REMOVED*** {
};

jasmine.JsApiReporter.prototype.resultsForSpecs = function(specIds***REMOVED***{
  var results = {};
  for (var i = 0; i < specIds.length; i++***REMOVED*** {
    var specId = specIds[i];
    results[specId] = this.summarizeResult_(this.results_[specId]***REMOVED***;
***REMOVED***
  return results;
};

jasmine.JsApiReporter.prototype.summarizeResult_ = function(result***REMOVED***{
  var summaryMessages = [];
  var messagesLength = result.messages.length;
  for (var messageIndex = 0; messageIndex < messagesLength; messageIndex++***REMOVED*** {
    var resultMessage = result.messages[messageIndex];
    summaryMessages.push({
      text: resultMessage.type == 'log' ? resultMessage.toString(***REMOVED*** : jasmine.undefined,
      passed: resultMessage.passed ? resultMessage.passed(***REMOVED*** : true,
      type: resultMessage.type,
      message: resultMessage.message,
      trace: {
        stack: resultMessage.passed && !resultMessage.passed(***REMOVED*** ? resultMessage.trace.stack : jasmine.undefined
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***

  return {
    result : result.result,
    messages : summaryMessages
***REMOVED***;
};

/**
 * @constructor
 * @param {jasmine.Env} env
 * @param actual
 * @param {jasmine.Spec} spec
 */
jasmine.Matchers = function(env, actual, spec, opt_isNot***REMOVED*** {
  this.env = env;
  this.actual = actual;
  this.spec = spec;
  this.isNot = opt_isNot || false;
  this.reportWasCalled_ = false;
};

// todo: @deprecated as of Jasmine 0.11, remove soon [xw]
jasmine.Matchers.pp = function(str***REMOVED*** {
  throw new Error("jasmine.Matchers.pp(***REMOVED*** is no longer supported, please use jasmine.pp(***REMOVED*** instead!"***REMOVED***;
};

// todo: @deprecated Deprecated as of Jasmine 0.10. Rewrite your custom matchers to return true or false. [xw]
jasmine.Matchers.prototype.report = function(result, failing_message, details***REMOVED*** {
  throw new Error("As of jasmine 0.11, custom matchers must be implemented differently -- please see jasmine docs"***REMOVED***;
};

jasmine.Matchers.wrapInto_ = function(prototype, matchersClass***REMOVED*** {
  for (var methodName in prototype***REMOVED*** {
    if (methodName == 'report'***REMOVED*** continue;
    var orig = prototype[methodName];
    matchersClass.prototype[methodName] = jasmine.Matchers.matcherFn_(methodName, orig***REMOVED***;
***REMOVED***
};

jasmine.Matchers.matcherFn_ = function(matcherName, matcherFunction***REMOVED*** {
  return function(***REMOVED*** {
    var matcherArgs = jasmine.util.argsToArray(arguments***REMOVED***;
    var result = matcherFunction.apply(this, arguments***REMOVED***;

    if (this.isNot***REMOVED*** {
      result = !result;
  ***REMOVED***

    if (this.reportWasCalled_***REMOVED*** return result;

    var message;
    if (!result***REMOVED*** {
      if (this.message***REMOVED*** {
        message = this.message.apply(this, arguments***REMOVED***;
        if (jasmine.isArray_(message***REMOVED******REMOVED*** {
          message = message[this.isNot ? 1 : 0];
      ***REMOVED***
    ***REMOVED*** else {
        var englishyPredicate = matcherName.replace(/[A-Z]/g, function(s***REMOVED*** { return ' ' + s.toLowerCase(***REMOVED***; }***REMOVED***;
        message = "Expected " + jasmine.pp(this.actual***REMOVED*** + (this.isNot ? " not " : " "***REMOVED*** + englishyPredicate;
        if (matcherArgs.length > 0***REMOVED*** {
          for (var i = 0; i < matcherArgs.length; i++***REMOVED*** {
            if (i > 0***REMOVED*** message += ",";
            message += " " + jasmine.pp(matcherArgs[i]***REMOVED***;
        ***REMOVED***
      ***REMOVED***
        message += ".";
    ***REMOVED***
  ***REMOVED***
    var expectationResult = new jasmine.ExpectationResult({
      matcherName: matcherName,
      passed: result,
      expected: matcherArgs.length > 1 ? matcherArgs : matcherArgs[0],
      actual: this.actual,
      message: message
  ***REMOVED******REMOVED***;
    this.spec.addMatcherResult(expectationResult***REMOVED***;
    return jasmine.undefined;
***REMOVED***;
};




/**
 * toBe: compares the actual to the expected using ===
 * @param expected
 */
jasmine.Matchers.prototype.toBe = function(expected***REMOVED*** {
  return this.actual === expected;
};

/**
 * toNotBe: compares the actual to the expected using !==
 * @param expected
 * @deprecated as of 1.0. Use not.toBe(***REMOVED*** instead.
 */
jasmine.Matchers.prototype.toNotBe = function(expected***REMOVED*** {
  return this.actual !== expected;
};

/**
 * toEqual: compares the actual to the expected using common sense equality. Handles Objects, Arrays, etc.
 *
 * @param expected
 */
jasmine.Matchers.prototype.toEqual = function(expected***REMOVED*** {
  return this.env.equals_(this.actual, expected***REMOVED***;
};

/**
 * toNotEqual: compares the actual to the expected using the ! of jasmine.Matchers.toEqual
 * @param expected
 * @deprecated as of 1.0. Use not.toNotEqual(***REMOVED*** instead.
 */
jasmine.Matchers.prototype.toNotEqual = function(expected***REMOVED*** {
  return !this.env.equals_(this.actual, expected***REMOVED***;
};

/**
 * Matcher that compares the actual to the expected using a regular expression.  Constructs a RegExp, so takes
 * a pattern or a String.
 *
 * @param expected
 */
jasmine.Matchers.prototype.toMatch = function(expected***REMOVED*** {
  return new RegExp(expected***REMOVED***.test(this.actual***REMOVED***;
};

/**
 * Matcher that compares the actual to the expected using the boolean inverse of jasmine.Matchers.toMatch
 * @param expected
 * @deprecated as of 1.0. Use not.toMatch(***REMOVED*** instead.
 */
jasmine.Matchers.prototype.toNotMatch = function(expected***REMOVED*** {
  return !(new RegExp(expected***REMOVED***.test(this.actual***REMOVED******REMOVED***;
};

/**
 * Matcher that compares the actual to jasmine.undefined.
 */
jasmine.Matchers.prototype.toBeDefined = function(***REMOVED*** {
  return (this.actual !== jasmine.undefined***REMOVED***;
};

/**
 * Matcher that compares the actual to jasmine.undefined.
 */
jasmine.Matchers.prototype.toBeUndefined = function(***REMOVED*** {
  return (this.actual === jasmine.undefined***REMOVED***;
};

/**
 * Matcher that compares the actual to null.
 */
jasmine.Matchers.prototype.toBeNull = function(***REMOVED*** {
  return (this.actual === null***REMOVED***;
};

/**
 * Matcher that boolean not-nots the actual.
 */
jasmine.Matchers.prototype.toBeTruthy = function(***REMOVED*** {
  return !!this.actual;
};


/**
 * Matcher that boolean nots the actual.
 */
jasmine.Matchers.prototype.toBeFalsy = function(***REMOVED*** {
  return !this.actual;
};


/**
 * Matcher that checks to see if the actual, a Jasmine spy, was called.
 */
jasmine.Matchers.prototype.toHaveBeenCalled = function(***REMOVED*** {
  if (arguments.length > 0***REMOVED*** {
    throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith'***REMOVED***;
***REMOVED***

  if (!jasmine.isSpy(this.actual***REMOVED******REMOVED*** {
    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual***REMOVED*** + '.'***REMOVED***;
***REMOVED***

  this.message = function(***REMOVED*** {
    return [
      "Expected spy " + this.actual.identity + " to have been called.",
      "Expected spy " + this.actual.identity + " not to have been called."
    ];
***REMOVED***;

  return this.actual.wasCalled;
};

/** @deprecated Use expect(xxx***REMOVED***.toHaveBeenCalled(***REMOVED*** instead */
jasmine.Matchers.prototype.wasCalled = jasmine.Matchers.prototype.toHaveBeenCalled;

/**
 * Matcher that checks to see if the actual, a Jasmine spy, was not called.
 *
 * @deprecated Use expect(xxx***REMOVED***.not.toHaveBeenCalled(***REMOVED*** instead
 */
jasmine.Matchers.prototype.wasNotCalled = function(***REMOVED*** {
  if (arguments.length > 0***REMOVED*** {
    throw new Error('wasNotCalled does not take arguments'***REMOVED***;
***REMOVED***

  if (!jasmine.isSpy(this.actual***REMOVED******REMOVED*** {
    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual***REMOVED*** + '.'***REMOVED***;
***REMOVED***

  this.message = function(***REMOVED*** {
    return [
      "Expected spy " + this.actual.identity + " to not have been called.",
      "Expected spy " + this.actual.identity + " to have been called."
    ];
***REMOVED***;

  return !this.actual.wasCalled;
};

/**
 * Matcher that checks to see if the actual, a Jasmine spy, was called with a set of parameters.
 *
 * @example
 *
 */
jasmine.Matchers.prototype.toHaveBeenCalledWith = function(***REMOVED*** {
  var expectedArgs = jasmine.util.argsToArray(arguments***REMOVED***;
  if (!jasmine.isSpy(this.actual***REMOVED******REMOVED*** {
    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual***REMOVED*** + '.'***REMOVED***;
***REMOVED***
  this.message = function(***REMOVED*** {
    if (this.actual.callCount === 0***REMOVED*** {
      // todo: what should the failure message for .not.toHaveBeenCalledWith(***REMOVED*** be? is this right? test better. [xw]
      return [
        "Expected spy " + this.actual.identity + " to have been called with " + jasmine.pp(expectedArgs***REMOVED*** + " but it was never called.",
        "Expected spy " + this.actual.identity + " not to have been called with " + jasmine.pp(expectedArgs***REMOVED*** + " but it was."
      ];
  ***REMOVED*** else {
      return [
        "Expected spy " + this.actual.identity + " to have been called with " + jasmine.pp(expectedArgs***REMOVED*** + " but was called with " + jasmine.pp(this.actual.argsForCall***REMOVED***,
        "Expected spy " + this.actual.identity + " not to have been called with " + jasmine.pp(expectedArgs***REMOVED*** + " but was called with " + jasmine.pp(this.actual.argsForCall***REMOVED***
      ];
  ***REMOVED***
***REMOVED***;

  return this.env.contains_(this.actual.argsForCall, expectedArgs***REMOVED***;
};

/** @deprecated Use expect(xxx***REMOVED***.toHaveBeenCalledWith(***REMOVED*** instead */
jasmine.Matchers.prototype.wasCalledWith = jasmine.Matchers.prototype.toHaveBeenCalledWith;

/** @deprecated Use expect(xxx***REMOVED***.not.toHaveBeenCalledWith(***REMOVED*** instead */
jasmine.Matchers.prototype.wasNotCalledWith = function(***REMOVED*** {
  var expectedArgs = jasmine.util.argsToArray(arguments***REMOVED***;
  if (!jasmine.isSpy(this.actual***REMOVED******REMOVED*** {
    throw new Error('Expected a spy, but got ' + jasmine.pp(this.actual***REMOVED*** + '.'***REMOVED***;
***REMOVED***

  this.message = function(***REMOVED*** {
    return [
      "Expected spy not to have been called with " + jasmine.pp(expectedArgs***REMOVED*** + " but it was",
      "Expected spy to have been called with " + jasmine.pp(expectedArgs***REMOVED*** + " but it was"
    ];
***REMOVED***;

  return !this.env.contains_(this.actual.argsForCall, expectedArgs***REMOVED***;
};

/**
 * Matcher that checks that the expected item is an element in the actual Array.
 *
 * @param {Object} expected
 */
jasmine.Matchers.prototype.toContain = function(expected***REMOVED*** {
  return this.env.contains_(this.actual, expected***REMOVED***;
};

/**
 * Matcher that checks that the expected item is NOT an element in the actual Array.
 *
 * @param {Object} expected
 * @deprecated as of 1.0. Use not.toNotContain(***REMOVED*** instead.
 */
jasmine.Matchers.prototype.toNotContain = function(expected***REMOVED*** {
  return !this.env.contains_(this.actual, expected***REMOVED***;
};

jasmine.Matchers.prototype.toBeLessThan = function(expected***REMOVED*** {
  return this.actual < expected;
};

jasmine.Matchers.prototype.toBeGreaterThan = function(expected***REMOVED*** {
  return this.actual > expected;
};

/**
 * Matcher that checks that the expected item is equal to the actual item
 * up to a given level of decimal precision (default 2***REMOVED***.
 *
 * @param {Number} expected
 * @param {Number} precision
 */
jasmine.Matchers.prototype.toBeCloseTo = function(expected, precision***REMOVED*** {
  if (!(precision === 0***REMOVED******REMOVED*** {
    precision = precision || 2;
***REMOVED***
  var multiplier = Math.pow(10, precision***REMOVED***;
  var actual = Math.round(this.actual * multiplier***REMOVED***;
  expected = Math.round(expected * multiplier***REMOVED***;
  return expected == actual;
};

/**
 * Matcher that checks that the expected exception was thrown by the actual.
 *
 * @param {String} expected
 */
jasmine.Matchers.prototype.toThrow = function(expected***REMOVED*** {
  var result = false;
  var exception;
  if (typeof this.actual != 'function'***REMOVED*** {
    throw new Error('Actual is not a function'***REMOVED***;
***REMOVED***
  try {
    this.actual(***REMOVED***;
***REMOVED*** catch (e***REMOVED*** {
    exception = e;
***REMOVED***
  if (exception***REMOVED*** {
    result = (expected === jasmine.undefined || this.env.equals_(exception.message || exception, expected.message || expected***REMOVED******REMOVED***;
***REMOVED***

  var not = this.isNot ? "not " : "";

  this.message = function(***REMOVED*** {
    if (exception && (expected === jasmine.undefined || !this.env.equals_(exception.message || exception, expected.message || expected***REMOVED******REMOVED******REMOVED*** {
      return ["Expected function " + not + "to throw", expected ? expected.message || expected : "an exception", ", but it threw", exception.message || exception].join(' '***REMOVED***;
  ***REMOVED*** else {
      return "Expected function to throw an exception.";
  ***REMOVED***
***REMOVED***;

  return result;
};

jasmine.Matchers.Any = function(expectedClass***REMOVED*** {
  this.expectedClass = expectedClass;
};

jasmine.Matchers.Any.prototype.matches = function(other***REMOVED*** {
  if (this.expectedClass == String***REMOVED*** {
    return typeof other == 'string' || other instanceof String;
***REMOVED***

  if (this.expectedClass == Number***REMOVED*** {
    return typeof other == 'number' || other instanceof Number;
***REMOVED***

  if (this.expectedClass == Function***REMOVED*** {
    return typeof other == 'function' || other instanceof Function;
***REMOVED***

  if (this.expectedClass == Object***REMOVED*** {
    return typeof other == 'object';
***REMOVED***

  return other instanceof this.expectedClass;
};

jasmine.Matchers.Any.prototype.toString = function(***REMOVED*** {
  return '<jasmine.any(' + this.expectedClass + '***REMOVED***>';
};

/**
 * @constructor
 */
jasmine.MultiReporter = function(***REMOVED*** {
  this.subReporters_ = [];
};
jasmine.util.inherit(jasmine.MultiReporter, jasmine.Reporter***REMOVED***;

jasmine.MultiReporter.prototype.addReporter = function(reporter***REMOVED*** {
  this.subReporters_.push(reporter***REMOVED***;
};

(function(***REMOVED*** {
  var functionNames = [
    "reportRunnerStarting",
    "reportRunnerResults",
    "reportSuiteResults",
    "reportSpecStarting",
    "reportSpecResults",
    "log"
  ];
  for (var i = 0; i < functionNames.length; i++***REMOVED*** {
    var functionName = functionNames[i];
    jasmine.MultiReporter.prototype[functionName] = (function(functionName***REMOVED*** {
      return function(***REMOVED*** {
        for (var j = 0; j < this.subReporters_.length; j++***REMOVED*** {
          var subReporter = this.subReporters_[j];
          if (subReporter[functionName]***REMOVED*** {
            subReporter[functionName].apply(subReporter, arguments***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED******REMOVED***(functionName***REMOVED***;
***REMOVED***
}***REMOVED***(***REMOVED***;
/**
 * Holds results for a set of Jasmine spec. Allows for the results array to hold another jasmine.NestedResults
 *
 * @constructor
 */
jasmine.NestedResults = function(***REMOVED*** {
  /**
   * The total count of results
   */
  this.totalCount = 0;
  /**
   * Number of passed results
   */
  this.passedCount = 0;
  /**
   * Number of failed results
   */
  this.failedCount = 0;
  /**
   * Was this suite/spec skipped?
   */
  this.skipped = false;
  /**
   * @ignore
   */
  this.items_ = [];
};

/**
 * Roll up the result counts.
 *
 * @param result
 */
jasmine.NestedResults.prototype.rollupCounts = function(result***REMOVED*** {
  this.totalCount += result.totalCount;
  this.passedCount += result.passedCount;
  this.failedCount += result.failedCount;
};

/**
 * Adds a log message.
 * @param values Array of message parts which will be concatenated later.
 */
jasmine.NestedResults.prototype.log = function(values***REMOVED*** {
  this.items_.push(new jasmine.MessageResult(values***REMOVED******REMOVED***;
};

/**
 * Getter for the results: message & results.
 */
jasmine.NestedResults.prototype.getItems = function(***REMOVED*** {
  return this.items_;
};

/**
 * Adds a result, tracking counts (total, passed, & failed***REMOVED***
 * @param {jasmine.ExpectationResult|jasmine.NestedResults} result
 */
jasmine.NestedResults.prototype.addResult = function(result***REMOVED*** {
  if (result.type != 'log'***REMOVED*** {
    if (result.items_***REMOVED*** {
      this.rollupCounts(result***REMOVED***;
  ***REMOVED*** else {
      this.totalCount++;
      if (result.passed(***REMOVED******REMOVED*** {
        this.passedCount++;
    ***REMOVED*** else {
        this.failedCount++;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  this.items_.push(result***REMOVED***;
};

/**
 * @returns {Boolean} True if <b>everything</b> below passed
 */
jasmine.NestedResults.prototype.passed = function(***REMOVED*** {
  return this.passedCount === this.totalCount;
};
/**
 * Base class for pretty printing for expectation results.
 */
jasmine.PrettyPrinter = function(***REMOVED*** {
  this.ppNestLevel_ = 0;
};

/**
 * Formats a value in a nice, human-readable string.
 *
 * @param value
 */
jasmine.PrettyPrinter.prototype.format = function(value***REMOVED*** {
  if (this.ppNestLevel_ > 40***REMOVED*** {
    throw new Error('jasmine.PrettyPrinter: format(***REMOVED*** nested too deeply!'***REMOVED***;
***REMOVED***

  this.ppNestLevel_++;
  try {
    if (value === jasmine.undefined***REMOVED*** {
      this.emitScalar('undefined'***REMOVED***;
  ***REMOVED*** else if (value === null***REMOVED*** {
      this.emitScalar('null'***REMOVED***;
  ***REMOVED*** else if (value === jasmine.getGlobal(***REMOVED******REMOVED*** {
      this.emitScalar('<global>'***REMOVED***;
  ***REMOVED*** else if (value instanceof jasmine.Matchers.Any***REMOVED*** {
      this.emitScalar(value.toString(***REMOVED******REMOVED***;
  ***REMOVED*** else if (typeof value === 'string'***REMOVED*** {
      this.emitString(value***REMOVED***;
  ***REMOVED*** else if (jasmine.isSpy(value***REMOVED******REMOVED*** {
      this.emitScalar("spy on " + value.identity***REMOVED***;
  ***REMOVED*** else if (value instanceof RegExp***REMOVED*** {
      this.emitScalar(value.toString(***REMOVED******REMOVED***;
  ***REMOVED*** else if (typeof value === 'function'***REMOVED*** {
      this.emitScalar('Function'***REMOVED***;
  ***REMOVED*** else if (typeof value.nodeType === 'number'***REMOVED*** {
      this.emitScalar('HTMLNode'***REMOVED***;
  ***REMOVED*** else if (value instanceof Date***REMOVED*** {
      this.emitScalar('Date(' + value + '***REMOVED***'***REMOVED***;
  ***REMOVED*** else if (value.__Jasmine_been_here_before__***REMOVED*** {
      this.emitScalar('<circular reference: ' + (jasmine.isArray_(value***REMOVED*** ? 'Array' : 'Object'***REMOVED*** + '>'***REMOVED***;
  ***REMOVED*** else if (jasmine.isArray_(value***REMOVED*** || typeof value == 'object'***REMOVED*** {
      value.__Jasmine_been_here_before__ = true;
      if (jasmine.isArray_(value***REMOVED******REMOVED*** {
        this.emitArray(value***REMOVED***;
    ***REMOVED*** else {
        this.emitObject(value***REMOVED***;
    ***REMOVED***
      delete value.__Jasmine_been_here_before__;
  ***REMOVED*** else {
      this.emitScalar(value.toString(***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED*** finally {
    this.ppNestLevel_--;
***REMOVED***
};

jasmine.PrettyPrinter.prototype.iterateObject = function(obj, fn***REMOVED*** {
  for (var property in obj***REMOVED*** {
    if (property == '__Jasmine_been_here_before__'***REMOVED*** continue;
    fn(property, obj.__lookupGetter__ ? (obj.__lookupGetter__(property***REMOVED*** !== jasmine.undefined && 
                                         obj.__lookupGetter__(property***REMOVED*** !== null***REMOVED*** : false***REMOVED***;
***REMOVED***
};

jasmine.PrettyPrinter.prototype.emitArray = jasmine.unimplementedMethod_;
jasmine.PrettyPrinter.prototype.emitObject = jasmine.unimplementedMethod_;
jasmine.PrettyPrinter.prototype.emitScalar = jasmine.unimplementedMethod_;
jasmine.PrettyPrinter.prototype.emitString = jasmine.unimplementedMethod_;

jasmine.StringPrettyPrinter = function(***REMOVED*** {
  jasmine.PrettyPrinter.call(this***REMOVED***;

  this.string = '';
};
jasmine.util.inherit(jasmine.StringPrettyPrinter, jasmine.PrettyPrinter***REMOVED***;

jasmine.StringPrettyPrinter.prototype.emitScalar = function(value***REMOVED*** {
  this.append(value***REMOVED***;
};

jasmine.StringPrettyPrinter.prototype.emitString = function(value***REMOVED*** {
  this.append("'" + value + "'"***REMOVED***;
};

jasmine.StringPrettyPrinter.prototype.emitArray = function(array***REMOVED*** {
  this.append('[ '***REMOVED***;
  for (var i = 0; i < array.length; i++***REMOVED*** {
    if (i > 0***REMOVED*** {
      this.append(', '***REMOVED***;
  ***REMOVED***
    this.format(array[i]***REMOVED***;
***REMOVED***
  this.append(' ]'***REMOVED***;
};

jasmine.StringPrettyPrinter.prototype.emitObject = function(obj***REMOVED*** {
  var self = this;
  this.append('{ '***REMOVED***;
  var first = true;

  this.iterateObject(obj, function(property, isGetter***REMOVED*** {
    if (first***REMOVED*** {
      first = false;
  ***REMOVED*** else {
      self.append(', '***REMOVED***;
  ***REMOVED***

    self.append(property***REMOVED***;
    self.append(' : '***REMOVED***;
    if (isGetter***REMOVED*** {
      self.append('<getter>'***REMOVED***;
  ***REMOVED*** else {
      self.format(obj[property]***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;

  this.append(' }'***REMOVED***;
};

jasmine.StringPrettyPrinter.prototype.append = function(value***REMOVED*** {
  this.string += value;
};
jasmine.Queue = function(env***REMOVED*** {
  this.env = env;
  this.blocks = [];
  this.running = false;
  this.index = 0;
  this.offset = 0;
  this.abort = false;
};

jasmine.Queue.prototype.addBefore = function(block***REMOVED*** {
  this.blocks.unshift(block***REMOVED***;
};

jasmine.Queue.prototype.add = function(block***REMOVED*** {
  this.blocks.push(block***REMOVED***;
};

jasmine.Queue.prototype.insertNext = function(block***REMOVED*** {
  this.blocks.splice((this.index + this.offset + 1***REMOVED***, 0, block***REMOVED***;
  this.offset++;
};

jasmine.Queue.prototype.start = function(onComplete***REMOVED*** {
  this.running = true;
  this.onComplete = onComplete;
  this.next_(***REMOVED***;
};

jasmine.Queue.prototype.isRunning = function(***REMOVED*** {
  return this.running;
};

jasmine.Queue.LOOP_DONT_RECURSE = true;

jasmine.Queue.prototype.next_ = function(***REMOVED*** {
  var self = this;
  var goAgain = true;

  while (goAgain***REMOVED*** {
    goAgain = false;
    
    if (self.index < self.blocks.length && !this.abort***REMOVED*** {
      var calledSynchronously = true;
      var completedSynchronously = false;

      var onComplete = function (***REMOVED*** {
        if (jasmine.Queue.LOOP_DONT_RECURSE && calledSynchronously***REMOVED*** {
          completedSynchronously = true;
          return;
      ***REMOVED***

        if (self.blocks[self.index].abort***REMOVED*** {
          self.abort = true;
      ***REMOVED***

        self.offset = 0;
        self.index++;

        var now = new Date(***REMOVED***.getTime(***REMOVED***;
        if (self.env.updateInterval && now - self.env.lastUpdate > self.env.updateInterval***REMOVED*** {
          self.env.lastUpdate = now;
          self.env.setTimeout(function(***REMOVED*** {
            self.next_(***REMOVED***;
        ***REMOVED***, 0***REMOVED***;
      ***REMOVED*** else {
          if (jasmine.Queue.LOOP_DONT_RECURSE && completedSynchronously***REMOVED*** {
            goAgain = true;
        ***REMOVED*** else {
            self.next_(***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
      self.blocks[self.index].execute(onComplete***REMOVED***;

      calledSynchronously = false;
      if (completedSynchronously***REMOVED*** {
        onComplete(***REMOVED***;
    ***REMOVED***
      
  ***REMOVED*** else {
      self.running = false;
      if (self.onComplete***REMOVED*** {
        self.onComplete(***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
};

jasmine.Queue.prototype.results = function(***REMOVED*** {
  var results = new jasmine.NestedResults(***REMOVED***;
  for (var i = 0; i < this.blocks.length; i++***REMOVED*** {
    if (this.blocks[i].results***REMOVED*** {
      results.addResult(this.blocks[i].results(***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  return results;
};


/**
 * Runner
 *
 * @constructor
 * @param {jasmine.Env} env
 */
jasmine.Runner = function(env***REMOVED*** {
  var self = this;
  self.env = env;
  self.queue = new jasmine.Queue(env***REMOVED***;
  self.before_ = [];
  self.after_ = [];
  self.suites_ = [];
};

jasmine.Runner.prototype.execute = function(***REMOVED*** {
  var self = this;
  if (self.env.reporter.reportRunnerStarting***REMOVED*** {
    self.env.reporter.reportRunnerStarting(this***REMOVED***;
***REMOVED***
  self.queue.start(function (***REMOVED*** {
    self.finishCallback(***REMOVED***;
***REMOVED******REMOVED***;
};

jasmine.Runner.prototype.beforeEach = function(beforeEachFunction***REMOVED*** {
  beforeEachFunction.typeName = 'beforeEach';
  this.before_.splice(0,0,beforeEachFunction***REMOVED***;
};

jasmine.Runner.prototype.afterEach = function(afterEachFunction***REMOVED*** {
  afterEachFunction.typeName = 'afterEach';
  this.after_.splice(0,0,afterEachFunction***REMOVED***;
};


jasmine.Runner.prototype.finishCallback = function(***REMOVED*** {
  this.env.reporter.reportRunnerResults(this***REMOVED***;
};

jasmine.Runner.prototype.addSuite = function(suite***REMOVED*** {
  this.suites_.push(suite***REMOVED***;
};

jasmine.Runner.prototype.add = function(block***REMOVED*** {
  if (block instanceof jasmine.Suite***REMOVED*** {
    this.addSuite(block***REMOVED***;
***REMOVED***
  this.queue.add(block***REMOVED***;
};

jasmine.Runner.prototype.specs = function (***REMOVED*** {
  var suites = this.suites(***REMOVED***;
  var specs = [];
  for (var i = 0; i < suites.length; i++***REMOVED*** {
    specs = specs.concat(suites[i].specs(***REMOVED******REMOVED***;
***REMOVED***
  return specs;
};

jasmine.Runner.prototype.suites = function(***REMOVED*** {
  return this.suites_;
};

jasmine.Runner.prototype.topLevelSuites = function(***REMOVED*** {
  var topLevelSuites = [];
  for (var i = 0; i < this.suites_.length; i++***REMOVED*** {
    if (!this.suites_[i].parentSuite***REMOVED*** {
      topLevelSuites.push(this.suites_[i]***REMOVED***;
  ***REMOVED***
***REMOVED***
  return topLevelSuites;
};

jasmine.Runner.prototype.results = function(***REMOVED*** {
  return this.queue.results(***REMOVED***;
};
/**
 * Internal representation of a Jasmine specification, or test.
 *
 * @constructor
 * @param {jasmine.Env} env
 * @param {jasmine.Suite} suite
 * @param {String} description
 */
jasmine.Spec = function(env, suite, description***REMOVED*** {
  if (!env***REMOVED*** {
    throw new Error('jasmine.Env(***REMOVED*** required'***REMOVED***;
***REMOVED***
  if (!suite***REMOVED*** {
    throw new Error('jasmine.Suite(***REMOVED*** required'***REMOVED***;
***REMOVED***
  var spec = this;
  spec.id = env.nextSpecId ? env.nextSpecId(***REMOVED*** : null;
  spec.env = env;
  spec.suite = suite;
  spec.description = description;
  spec.queue = new jasmine.Queue(env***REMOVED***;

  spec.afterCallbacks = [];
  spec.spies_ = [];

  spec.results_ = new jasmine.NestedResults(***REMOVED***;
  spec.results_.description = description;
  spec.matchersClass = null;
};

jasmine.Spec.prototype.getFullName = function(***REMOVED*** {
  return this.suite.getFullName(***REMOVED*** + ' ' + this.description + '.';
};


jasmine.Spec.prototype.results = function(***REMOVED*** {
  return this.results_;
};

/**
 * All parameters are pretty-printed and concatenated together, then written to the spec's output.
 *
 * Be careful not to leave calls to <code>jasmine.log</code> in production code.
 */
jasmine.Spec.prototype.log = function(***REMOVED*** {
  return this.results_.log(arguments***REMOVED***;
};

jasmine.Spec.prototype.runs = function (func***REMOVED*** {
  var block = new jasmine.Block(this.env, func, this***REMOVED***;
  this.addToQueue(block***REMOVED***;
  return this;
};

jasmine.Spec.prototype.addToQueue = function (block***REMOVED*** {
  if (this.queue.isRunning(***REMOVED******REMOVED*** {
    this.queue.insertNext(block***REMOVED***;
***REMOVED*** else {
    this.queue.add(block***REMOVED***;
***REMOVED***
};

/**
 * @param {jasmine.ExpectationResult} result
 */
jasmine.Spec.prototype.addMatcherResult = function(result***REMOVED*** {
  this.results_.addResult(result***REMOVED***;
};

jasmine.Spec.prototype.expect = function(actual***REMOVED*** {
  var positive = new (this.getMatchersClass_(***REMOVED******REMOVED***(this.env, actual, this***REMOVED***;
  positive.not = new (this.getMatchersClass_(***REMOVED******REMOVED***(this.env, actual, this, true***REMOVED***;
  return positive;
};

/**
 * Waits a fixed time period before moving to the next block.
 *
 * @deprecated Use waitsFor(***REMOVED*** instead
 * @param {Number} timeout milliseconds to wait
 */
jasmine.Spec.prototype.waits = function(timeout***REMOVED*** {
  var waitsFunc = new jasmine.WaitsBlock(this.env, timeout, this***REMOVED***;
  this.addToQueue(waitsFunc***REMOVED***;
  return this;
};

/**
 * Waits for the latchFunction to return true before proceeding to the next block.
 *
 * @param {Function} latchFunction
 * @param {String} optional_timeoutMessage
 * @param {Number} optional_timeout
 */
jasmine.Spec.prototype.waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout***REMOVED*** {
  var latchFunction_ = null;
  var optional_timeoutMessage_ = null;
  var optional_timeout_ = null;

  for (var i = 0; i < arguments.length; i++***REMOVED*** {
    var arg = arguments[i];
    switch (typeof arg***REMOVED*** {
      case 'function':
        latchFunction_ = arg;
        break;
      case 'string':
        optional_timeoutMessage_ = arg;
        break;
      case 'number':
        optional_timeout_ = arg;
        break;
  ***REMOVED***
***REMOVED***

  var waitsForFunc = new jasmine.WaitsForBlock(this.env, optional_timeout_, latchFunction_, optional_timeoutMessage_, this***REMOVED***;
  this.addToQueue(waitsForFunc***REMOVED***;
  return this;
};

jasmine.Spec.prototype.fail = function (e***REMOVED*** {
  var expectationResult = new jasmine.ExpectationResult({
    passed: false,
    message: e ? jasmine.util.formatException(e***REMOVED*** : 'Exception',
    trace: { stack: e.stack }
***REMOVED******REMOVED***;
  this.results_.addResult(expectationResult***REMOVED***;
};

jasmine.Spec.prototype.getMatchersClass_ = function(***REMOVED*** {
  return this.matchersClass || this.env.matchersClass;
};

jasmine.Spec.prototype.addMatchers = function(matchersPrototype***REMOVED*** {
  var parent = this.getMatchersClass_(***REMOVED***;
  var newMatchersClass = function(***REMOVED*** {
    parent.apply(this, arguments***REMOVED***;
***REMOVED***;
  jasmine.util.inherit(newMatchersClass, parent***REMOVED***;
  jasmine.Matchers.wrapInto_(matchersPrototype, newMatchersClass***REMOVED***;
  this.matchersClass = newMatchersClass;
};

jasmine.Spec.prototype.finishCallback = function(***REMOVED*** {
  this.env.reporter.reportSpecResults(this***REMOVED***;
};

jasmine.Spec.prototype.finish = function(onComplete***REMOVED*** {
  this.removeAllSpies(***REMOVED***;
  this.finishCallback(***REMOVED***;
  if (onComplete***REMOVED*** {
    onComplete(***REMOVED***;
***REMOVED***
};

jasmine.Spec.prototype.after = function(doAfter***REMOVED*** {
  if (this.queue.isRunning(***REMOVED******REMOVED*** {
    this.queue.add(new jasmine.Block(this.env, doAfter, this***REMOVED******REMOVED***;
***REMOVED*** else {
    this.afterCallbacks.unshift(doAfter***REMOVED***;
***REMOVED***
};

jasmine.Spec.prototype.execute = function(onComplete***REMOVED*** {
  var spec = this;
  if (!spec.env.specFilter(spec***REMOVED******REMOVED*** {
    spec.results_.skipped = true;
    spec.finish(onComplete***REMOVED***;
    return;
***REMOVED***

  this.env.reporter.reportSpecStarting(this***REMOVED***;

  spec.env.currentSpec = spec;

  spec.addBeforesAndAftersToQueue(***REMOVED***;

  spec.queue.start(function (***REMOVED*** {
    spec.finish(onComplete***REMOVED***;
***REMOVED******REMOVED***;
};

jasmine.Spec.prototype.addBeforesAndAftersToQueue = function(***REMOVED*** {
  var runner = this.env.currentRunner(***REMOVED***;
  var i;

  for (var suite = this.suite; suite; suite = suite.parentSuite***REMOVED*** {
    for (i = 0; i < suite.before_.length; i++***REMOVED*** {
      this.queue.addBefore(new jasmine.Block(this.env, suite.before_[i], this***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  for (i = 0; i < runner.before_.length; i++***REMOVED*** {
    this.queue.addBefore(new jasmine.Block(this.env, runner.before_[i], this***REMOVED******REMOVED***;
***REMOVED***
  for (i = 0; i < this.afterCallbacks.length; i++***REMOVED*** {
    this.queue.add(new jasmine.Block(this.env, this.afterCallbacks[i], this***REMOVED******REMOVED***;
***REMOVED***
  for (suite = this.suite; suite; suite = suite.parentSuite***REMOVED*** {
    for (i = 0; i < suite.after_.length; i++***REMOVED*** {
      this.queue.add(new jasmine.Block(this.env, suite.after_[i], this***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  for (i = 0; i < runner.after_.length; i++***REMOVED*** {
    this.queue.add(new jasmine.Block(this.env, runner.after_[i], this***REMOVED******REMOVED***;
***REMOVED***
};

jasmine.Spec.prototype.explodes = function(***REMOVED*** {
  throw 'explodes function should not have been called';
};

jasmine.Spec.prototype.spyOn = function(obj, methodName, ignoreMethodDoesntExist***REMOVED*** {
  if (obj == jasmine.undefined***REMOVED*** {
    throw "spyOn could not find an object to spy upon for " + methodName + "(***REMOVED***";
***REMOVED***

  if (!ignoreMethodDoesntExist && obj[methodName] === jasmine.undefined***REMOVED*** {
    throw methodName + '(***REMOVED*** method does not exist';
***REMOVED***

  if (!ignoreMethodDoesntExist && obj[methodName] && obj[methodName].isSpy***REMOVED*** {
    throw new Error(methodName + ' has already been spied upon'***REMOVED***;
***REMOVED***

  var spyObj = jasmine.createSpy(methodName***REMOVED***;

  this.spies_.push(spyObj***REMOVED***;
  spyObj.baseObj = obj;
  spyObj.methodName = methodName;
  spyObj.originalValue = obj[methodName];

  obj[methodName] = spyObj;

  return spyObj;
};

jasmine.Spec.prototype.removeAllSpies = function(***REMOVED*** {
  for (var i = 0; i < this.spies_.length; i++***REMOVED*** {
    var spy = this.spies_[i];
    spy.baseObj[spy.methodName] = spy.originalValue;
***REMOVED***
  this.spies_ = [];
};

/**
 * Internal representation of a Jasmine suite.
 *
 * @constructor
 * @param {jasmine.Env} env
 * @param {String} description
 * @param {Function} specDefinitions
 * @param {jasmine.Suite} parentSuite
 */
jasmine.Suite = function(env, description, specDefinitions, parentSuite***REMOVED*** {
  var self = this;
  self.id = env.nextSuiteId ? env.nextSuiteId(***REMOVED*** : null;
  self.description = description;
  self.queue = new jasmine.Queue(env***REMOVED***;
  self.parentSuite = parentSuite;
  self.env = env;
  self.before_ = [];
  self.after_ = [];
  self.children_ = [];
  self.suites_ = [];
  self.specs_ = [];
};

jasmine.Suite.prototype.getFullName = function(***REMOVED*** {
  var fullName = this.description;
  for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite***REMOVED*** {
    fullName = parentSuite.description + ' ' + fullName;
***REMOVED***
  return fullName;
};

jasmine.Suite.prototype.finish = function(onComplete***REMOVED*** {
  this.env.reporter.reportSuiteResults(this***REMOVED***;
  this.finished = true;
  if (typeof(onComplete***REMOVED*** == 'function'***REMOVED*** {
    onComplete(***REMOVED***;
***REMOVED***
};

jasmine.Suite.prototype.beforeEach = function(beforeEachFunction***REMOVED*** {
  beforeEachFunction.typeName = 'beforeEach';
  this.before_.unshift(beforeEachFunction***REMOVED***;
};

jasmine.Suite.prototype.afterEach = function(afterEachFunction***REMOVED*** {
  afterEachFunction.typeName = 'afterEach';
  this.after_.unshift(afterEachFunction***REMOVED***;
};

jasmine.Suite.prototype.results = function(***REMOVED*** {
  return this.queue.results(***REMOVED***;
};

jasmine.Suite.prototype.add = function(suiteOrSpec***REMOVED*** {
  this.children_.push(suiteOrSpec***REMOVED***;
  if (suiteOrSpec instanceof jasmine.Suite***REMOVED*** {
    this.suites_.push(suiteOrSpec***REMOVED***;
    this.env.currentRunner(***REMOVED***.addSuite(suiteOrSpec***REMOVED***;
***REMOVED*** else {
    this.specs_.push(suiteOrSpec***REMOVED***;
***REMOVED***
  this.queue.add(suiteOrSpec***REMOVED***;
};

jasmine.Suite.prototype.specs = function(***REMOVED*** {
  return this.specs_;
};

jasmine.Suite.prototype.suites = function(***REMOVED*** {
  return this.suites_;
};

jasmine.Suite.prototype.children = function(***REMOVED*** {
  return this.children_;
};

jasmine.Suite.prototype.execute = function(onComplete***REMOVED*** {
  var self = this;
  this.queue.start(function (***REMOVED*** {
    self.finish(onComplete***REMOVED***;
***REMOVED******REMOVED***;
};
jasmine.WaitsBlock = function(env, timeout, spec***REMOVED*** {
  this.timeout = timeout;
  jasmine.Block.call(this, env, null, spec***REMOVED***;
};

jasmine.util.inherit(jasmine.WaitsBlock, jasmine.Block***REMOVED***;

jasmine.WaitsBlock.prototype.execute = function (onComplete***REMOVED*** {
  if (jasmine.VERBOSE***REMOVED*** {
    this.env.reporter.log('>> Jasmine waiting for ' + this.timeout + ' ms...'***REMOVED***;
***REMOVED***
  this.env.setTimeout(function (***REMOVED*** {
    onComplete(***REMOVED***;
***REMOVED***, this.timeout***REMOVED***;
};
/**
 * A block which waits for some condition to become true, with timeout.
 *
 * @constructor
 * @extends jasmine.Block
 * @param {jasmine.Env} env The Jasmine environment.
 * @param {Number} timeout The maximum time in milliseconds to wait for the condition to become true.
 * @param {Function} latchFunction A function which returns true when the desired condition has been met.
 * @param {String} message The message to display if the desired condition hasn't been met within the given time period.
 * @param {jasmine.Spec} spec The Jasmine spec.
 */
jasmine.WaitsForBlock = function(env, timeout, latchFunction, message, spec***REMOVED*** {
  this.timeout = timeout || env.defaultTimeoutInterval;
  this.latchFunction = latchFunction;
  this.message = message;
  this.totalTimeSpentWaitingForLatch = 0;
  jasmine.Block.call(this, env, null, spec***REMOVED***;
};
jasmine.util.inherit(jasmine.WaitsForBlock, jasmine.Block***REMOVED***;

jasmine.WaitsForBlock.TIMEOUT_INCREMENT = 10;

jasmine.WaitsForBlock.prototype.execute = function(onComplete***REMOVED*** {
  if (jasmine.VERBOSE***REMOVED*** {
    this.env.reporter.log('>> Jasmine waiting for ' + (this.message || 'something to happen'***REMOVED******REMOVED***;
***REMOVED***
  var latchFunctionResult;
  try {
    latchFunctionResult = this.latchFunction.apply(this.spec***REMOVED***;
***REMOVED*** catch (e***REMOVED*** {
    this.spec.fail(e***REMOVED***;
    onComplete(***REMOVED***;
    return;
***REMOVED***

  if (latchFunctionResult***REMOVED*** {
    onComplete(***REMOVED***;
***REMOVED*** else if (this.totalTimeSpentWaitingForLatch >= this.timeout***REMOVED*** {
    var message = 'timed out after ' + this.timeout + ' msec waiting for ' + (this.message || 'something to happen'***REMOVED***;
    this.spec.fail({
      name: 'timeout',
      message: message
  ***REMOVED******REMOVED***;

    this.abort = true;
    onComplete(***REMOVED***;
***REMOVED*** else {
    this.totalTimeSpentWaitingForLatch += jasmine.WaitsForBlock.TIMEOUT_INCREMENT;
    var self = this;
    this.env.setTimeout(function(***REMOVED*** {
      self.execute(onComplete***REMOVED***;
  ***REMOVED***, jasmine.WaitsForBlock.TIMEOUT_INCREMENT***REMOVED***;
***REMOVED***
};
// Mock setTimeout, clearTimeout
// Contributed by Pivotal Computer Systems, www.pivotalsf.com

jasmine.FakeTimer = function(***REMOVED*** {
  this.reset(***REMOVED***;

  var self = this;
  self.setTimeout = function(funcToCall, millis***REMOVED*** {
    self.timeoutsMade++;
    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, false***REMOVED***;
    return self.timeoutsMade;
***REMOVED***;

  self.setInterval = function(funcToCall, millis***REMOVED*** {
    self.timeoutsMade++;
    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, true***REMOVED***;
    return self.timeoutsMade;
***REMOVED***;

  self.clearTimeout = function(timeoutKey***REMOVED*** {
    self.scheduledFunctions[timeoutKey] = jasmine.undefined;
***REMOVED***;

  self.clearInterval = function(timeoutKey***REMOVED*** {
    self.scheduledFunctions[timeoutKey] = jasmine.undefined;
***REMOVED***;

};

jasmine.FakeTimer.prototype.reset = function(***REMOVED*** {
  this.timeoutsMade = 0;
  this.scheduledFunctions = {};
  this.nowMillis = 0;
};

jasmine.FakeTimer.prototype.tick = function(millis***REMOVED*** {
  var oldMillis = this.nowMillis;
  var newMillis = oldMillis + millis;
  this.runFunctionsWithinRange(oldMillis, newMillis***REMOVED***;
  this.nowMillis = newMillis;
};

jasmine.FakeTimer.prototype.runFunctionsWithinRange = function(oldMillis, nowMillis***REMOVED*** {
  var scheduledFunc;
  var funcsToRun = [];
  for (var timeoutKey in this.scheduledFunctions***REMOVED*** {
    scheduledFunc = this.scheduledFunctions[timeoutKey];
    if (scheduledFunc != jasmine.undefined &&
        scheduledFunc.runAtMillis >= oldMillis &&
        scheduledFunc.runAtMillis <= nowMillis***REMOVED*** {
      funcsToRun.push(scheduledFunc***REMOVED***;
      this.scheduledFunctions[timeoutKey] = jasmine.undefined;
  ***REMOVED***
***REMOVED***

  if (funcsToRun.length > 0***REMOVED*** {
    funcsToRun.sort(function(a, b***REMOVED*** {
      return a.runAtMillis - b.runAtMillis;
  ***REMOVED******REMOVED***;
    for (var i = 0; i < funcsToRun.length; ++i***REMOVED*** {
      try {
        var funcToRun = funcsToRun[i];
        this.nowMillis = funcToRun.runAtMillis;
        funcToRun.funcToCall(***REMOVED***;
        if (funcToRun.recurring***REMOVED*** {
          this.scheduleFunction(funcToRun.timeoutKey,
              funcToRun.funcToCall,
              funcToRun.millis,
              true***REMOVED***;
      ***REMOVED***
    ***REMOVED*** catch(e***REMOVED*** {
    ***REMOVED***
  ***REMOVED***
    this.runFunctionsWithinRange(oldMillis, nowMillis***REMOVED***;
***REMOVED***
};

jasmine.FakeTimer.prototype.scheduleFunction = function(timeoutKey, funcToCall, millis, recurring***REMOVED*** {
  this.scheduledFunctions[timeoutKey] = {
    runAtMillis: this.nowMillis + millis,
    funcToCall: funcToCall,
    recurring: recurring,
    timeoutKey: timeoutKey,
    millis: millis
***REMOVED***;
};

/**
 * @namespace
 */
jasmine.Clock = {
  defaultFakeTimer: new jasmine.FakeTimer(***REMOVED***,

  reset: function(***REMOVED*** {
    jasmine.Clock.assertInstalled(***REMOVED***;
    jasmine.Clock.defaultFakeTimer.reset(***REMOVED***;
***REMOVED***,

  tick: function(millis***REMOVED*** {
    jasmine.Clock.assertInstalled(***REMOVED***;
    jasmine.Clock.defaultFakeTimer.tick(millis***REMOVED***;
***REMOVED***,

  runFunctionsWithinRange: function(oldMillis, nowMillis***REMOVED*** {
    jasmine.Clock.defaultFakeTimer.runFunctionsWithinRange(oldMillis, nowMillis***REMOVED***;
***REMOVED***,

  scheduleFunction: function(timeoutKey, funcToCall, millis, recurring***REMOVED*** {
    jasmine.Clock.defaultFakeTimer.scheduleFunction(timeoutKey, funcToCall, millis, recurring***REMOVED***;
***REMOVED***,

  useMock: function(***REMOVED*** {
    if (!jasmine.Clock.isInstalled(***REMOVED******REMOVED*** {
      var spec = jasmine.getEnv(***REMOVED***.currentSpec;
      spec.after(jasmine.Clock.uninstallMock***REMOVED***;

      jasmine.Clock.installMock(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  installMock: function(***REMOVED*** {
    jasmine.Clock.installed = jasmine.Clock.defaultFakeTimer;
***REMOVED***,

  uninstallMock: function(***REMOVED*** {
    jasmine.Clock.assertInstalled(***REMOVED***;
    jasmine.Clock.installed = jasmine.Clock.real;
***REMOVED***,

  real: {
    setTimeout: jasmine.getGlobal(***REMOVED***.setTimeout,
    clearTimeout: jasmine.getGlobal(***REMOVED***.clearTimeout,
    setInterval: jasmine.getGlobal(***REMOVED***.setInterval,
    clearInterval: jasmine.getGlobal(***REMOVED***.clearInterval
***REMOVED***,

  assertInstalled: function(***REMOVED*** {
    if (!jasmine.Clock.isInstalled(***REMOVED******REMOVED*** {
      throw new Error("Mock clock is not installed, use jasmine.Clock.useMock(***REMOVED***"***REMOVED***;
  ***REMOVED***
***REMOVED***,

  isInstalled: function(***REMOVED*** {
    return jasmine.Clock.installed == jasmine.Clock.defaultFakeTimer;
***REMOVED***,

  installed: null
};
jasmine.Clock.installed = jasmine.Clock.real;

//else for IE support
jasmine.getGlobal(***REMOVED***.setTimeout = function(funcToCall, millis***REMOVED*** {
  if (jasmine.Clock.installed.setTimeout.apply***REMOVED*** {
    return jasmine.Clock.installed.setTimeout.apply(this, arguments***REMOVED***;
***REMOVED*** else {
    return jasmine.Clock.installed.setTimeout(funcToCall, millis***REMOVED***;
***REMOVED***
};

jasmine.getGlobal(***REMOVED***.setInterval = function(funcToCall, millis***REMOVED*** {
  if (jasmine.Clock.installed.setInterval.apply***REMOVED*** {
    return jasmine.Clock.installed.setInterval.apply(this, arguments***REMOVED***;
***REMOVED*** else {
    return jasmine.Clock.installed.setInterval(funcToCall, millis***REMOVED***;
***REMOVED***
};

jasmine.getGlobal(***REMOVED***.clearTimeout = function(timeoutKey***REMOVED*** {
  if (jasmine.Clock.installed.clearTimeout.apply***REMOVED*** {
    return jasmine.Clock.installed.clearTimeout.apply(this, arguments***REMOVED***;
***REMOVED*** else {
    return jasmine.Clock.installed.clearTimeout(timeoutKey***REMOVED***;
***REMOVED***
};

jasmine.getGlobal(***REMOVED***.clearInterval = function(timeoutKey***REMOVED*** {
  if (jasmine.Clock.installed.clearTimeout.apply***REMOVED*** {
    return jasmine.Clock.installed.clearInterval.apply(this, arguments***REMOVED***;
***REMOVED*** else {
    return jasmine.Clock.installed.clearInterval(timeoutKey***REMOVED***;
***REMOVED***
};

jasmine.version_= {
  "major": 1,
  "minor": 1,
  "build": 0,
  "revision": 1315677058
};
