// Licensed under the Apache License, Version 2.0 (the "License"***REMOVED***;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2009 Google Inc. All Rights Reserved

/**
 * Defines a Timestamp class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
 * implementation is derived from TimestampLib in GWT.
 *
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Timestamps.
 *
 * The internal representation of a Timestamp is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s***REMOVED*** and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63***REMOVED*** because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative***REMOVED***.  Not handling this
 * case would often result in infinite recursion.
 *
 * @class Represents the BSON Timestamp type.
 * @param {Number} low  the low (signed***REMOVED*** 32 bits of the Timestamp.
 * @param {Number} high the high (signed***REMOVED*** 32 bits of the Timestamp.
 */
function Timestamp(low, high***REMOVED*** {
  if(!(this instanceof Timestamp***REMOVED******REMOVED*** return new Timestamp(low, high***REMOVED***;
  this._bsontype = 'Timestamp';
  /**
   * @type {number}
   * @api private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * Return the int value.
 *
 * @return {Number} the value, assuming it is a 32-bit integer.
 * @api public
 */
Timestamp.prototype.toInt = function(***REMOVED*** {
  return this.low_;
};

/**
 * Return the Number value.
 *
 * @return {Number} the closest floating-point representation to this value.
 * @api public
 */
Timestamp.prototype.toNumber = function(***REMOVED*** {
  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned(***REMOVED***;
};

/**
 * Return the JSON value.
 *
 * @return {String} the JSON representation.
 * @api public
 */
Timestamp.prototype.toJSON = function(***REMOVED*** {
  return this.toString(***REMOVED***;
}

/**
 * Return the String value.
 *
 * @param {Number} [opt_radix] the radix in which the text should be written.
 * @return {String} the textual representation of this value.
 * @api public
 */
Timestamp.prototype.toString = function(opt_radix***REMOVED*** {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix***REMOVED*** {
    throw Error('radix out of range: ' + radix***REMOVED***;
***REMOVED***

  if (this.isZero(***REMOVED******REMOVED*** {
    return '0';
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
      // We need to change the Timestamp value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixTimestamp = Timestamp.fromNumber(radix***REMOVED***;
      var div = this.div(radixTimestamp***REMOVED***;
      var rem = div.multiply(radixTimestamp***REMOVED***.subtract(this***REMOVED***;
      return div.toString(radix***REMOVED*** + rem.toInt(***REMOVED***.toString(radix***REMOVED***;
  ***REMOVED*** else {
      return '-' + this.negate(***REMOVED***.toString(radix***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Do several (6***REMOVED*** digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6***REMOVED******REMOVED***;

  var rem = this;
  var result = '';
  while (true***REMOVED*** {
    var remDiv = rem.div(radixToPower***REMOVED***;
    var intval = rem.subtract(remDiv.multiply(radixToPower***REMOVED******REMOVED***.toInt(***REMOVED***;
    var digits = intval.toString(radix***REMOVED***;

    rem = remDiv;
    if (rem.isZero(***REMOVED******REMOVED*** {
      return digits + result;
  ***REMOVED*** else {
      while (digits.length < 6***REMOVED*** {
        digits = '0' + digits;
    ***REMOVED***
      result = '' + digits + result;
  ***REMOVED***
***REMOVED***
};

/**
 * Return the high 32-bits value.
 *
 * @return {Number} the high 32-bits as a signed value.
 * @api public
 */
Timestamp.prototype.getHighBits = function(***REMOVED*** {
  return this.high_;
};

/**
 * Return the low 32-bits value.
 *
 * @return {Number} the low 32-bits as a signed value.
 * @api public
 */
Timestamp.prototype.getLowBits = function(***REMOVED*** {
  return this.low_;
};

/**
 * Return the low unsigned 32-bits value.
 *
 * @return {Number} the low 32-bits as an unsigned value.
 * @api public
 */
Timestamp.prototype.getLowBitsUnsigned = function(***REMOVED*** {
  return (this.low_ >= 0***REMOVED*** ?
      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
};

/**
 * Returns the number of bits needed to represent the absolute value of this Timestamp.
 *
 * @return {Number} Returns the number of bits needed to represent the absolute value of this Timestamp.
 * @api public
 */
Timestamp.prototype.getNumBitsAbs = function(***REMOVED*** {
  if (this.isNegative(***REMOVED******REMOVED*** {
    if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
      return 64;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.getNumBitsAbs(***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--***REMOVED*** {
      if ((val & (1 << bit***REMOVED******REMOVED*** != 0***REMOVED*** {
        break;
    ***REMOVED***
  ***REMOVED***
    return this.high_ != 0 ? bit + 33 : bit + 1;
***REMOVED***
};

/**
 * Return whether this value is zero.
 *
 * @return {Boolean} whether this value is zero.
 * @api public
 */
Timestamp.prototype.isZero = function(***REMOVED*** {
  return this.high_ == 0 && this.low_ == 0;
};

/**
 * Return whether this value is negative.
 *
 * @return {Boolean} whether this value is negative.
 * @api public
 */
Timestamp.prototype.isNegative = function(***REMOVED*** {
  return this.high_ < 0;
};

/**
 * Return whether this value is odd.
 *
 * @return {Boolean} whether this value is odd.
 * @api public
 */
Timestamp.prototype.isOdd = function(***REMOVED*** {
  return (this.low_ & 1***REMOVED*** == 1;
};

/**
 * Return whether this Timestamp equals the other
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp equals the other
 * @api public
 */
Timestamp.prototype.equals = function(other***REMOVED*** {
  return (this.high_ == other.high_***REMOVED*** && (this.low_ == other.low_***REMOVED***;
};

/**
 * Return whether this Timestamp does not equal the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp does not equal the other.
 * @api public
 */
Timestamp.prototype.notEquals = function(other***REMOVED*** {
  return (this.high_ != other.high_***REMOVED*** || (this.low_ != other.low_***REMOVED***;
};

/**
 * Return whether this Timestamp is less than the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is less than the other.
 * @api public
 */
Timestamp.prototype.lessThan = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** < 0;
};

/**
 * Return whether this Timestamp is less than or equal to the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is less than or equal to the other.
 * @api public
 */
Timestamp.prototype.lessThanOrEqual = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** <= 0;
};

/**
 * Return whether this Timestamp is greater than the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is greater than the other.
 * @api public
 */
Timestamp.prototype.greaterThan = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** > 0;
};

/**
 * Return whether this Timestamp is greater than or equal to the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is greater than or equal to the other.
 * @api public
 */
Timestamp.prototype.greaterThanOrEqual = function(other***REMOVED*** {
  return this.compare(other***REMOVED*** >= 0;
};

/**
 * Compares this Timestamp with the given one.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
 * @api public
 */
Timestamp.prototype.compare = function(other***REMOVED*** {
  if (this.equals(other***REMOVED******REMOVED*** {
    return 0;
***REMOVED***

  var thisNeg = this.isNegative(***REMOVED***;
  var otherNeg = other.isNegative(***REMOVED***;
  if (thisNeg && !otherNeg***REMOVED*** {
    return -1;
***REMOVED***
  if (!thisNeg && otherNeg***REMOVED*** {
    return 1;
***REMOVED***

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other***REMOVED***.isNegative(***REMOVED******REMOVED*** {
    return -1;
***REMOVED*** else {
    return 1;
***REMOVED***
};

/**
 * The negation of this value.
 *
 * @return {Timestamp} the negation of this value.
 * @api public
 */
Timestamp.prototype.negate = function(***REMOVED*** {
  if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return Timestamp.MIN_VALUE;
***REMOVED*** else {
    return this.not(***REMOVED***.add(Timestamp.ONE***REMOVED***;
***REMOVED***
};

/**
 * Returns the sum of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to add to this one.
 * @return {Timestamp} the sum of this and the given Timestamp.
 * @api public
 */
Timestamp.prototype.add = function(other***REMOVED*** {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Timestamp.fromBits((c16 << 16***REMOVED*** | c00, (c48 << 16***REMOVED*** | c32***REMOVED***;
};

/**
 * Returns the difference of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to subtract from this.
 * @return {Timestamp} the difference of this and the given Timestamp.
 * @api public
 */
Timestamp.prototype.subtract = function(other***REMOVED*** {
  return this.add(other.negate(***REMOVED******REMOVED***;
};

/**
 * Returns the product of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to multiply with this.
 * @return {Timestamp} the product of this and the other.
 * @api public
 */
Timestamp.prototype.multiply = function(other***REMOVED*** {
  if (this.isZero(***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED*** else if (other.isZero(***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED***

  if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return other.isOdd(***REMOVED*** ? Timestamp.MIN_VALUE : Timestamp.ZERO;
***REMOVED*** else if (other.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return this.isOdd(***REMOVED*** ? Timestamp.MIN_VALUE : Timestamp.ZERO;
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (other.isNegative(***REMOVED******REMOVED*** {
      return this.negate(***REMOVED***.multiply(other.negate(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.multiply(other***REMOVED***.negate(***REMOVED***;
  ***REMOVED***
***REMOVED*** else if (other.isNegative(***REMOVED******REMOVED*** {
    return this.multiply(other.negate(***REMOVED******REMOVED***.negate(***REMOVED***;
***REMOVED***

  // If both Timestamps are small, use float multiplication
  if (this.lessThan(Timestamp.TWO_PWR_24_***REMOVED*** &&
      other.lessThan(Timestamp.TWO_PWR_24_***REMOVED******REMOVED*** {
    return Timestamp.fromNumber(this.toNumber(***REMOVED*** * other.toNumber(***REMOVED******REMOVED***;
***REMOVED***

  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Timestamp.fromBits((c16 << 16***REMOVED*** | c00, (c48 << 16***REMOVED*** | c32***REMOVED***;
};

/**
 * Returns this Timestamp divided by the given one.
 *
 * @param {Timestamp} other Timestamp by which to divide.
 * @return {Timestamp} this Timestamp divided by the given one.
 * @api public
 */
Timestamp.prototype.div = function(other***REMOVED*** {
  if (other.isZero(***REMOVED******REMOVED*** {
    throw Error('division by zero'***REMOVED***;
***REMOVED*** else if (this.isZero(***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED***

  if (this.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    if (other.equals(Timestamp.ONE***REMOVED*** ||
        other.equals(Timestamp.NEG_ONE***REMOVED******REMOVED*** {
      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
  ***REMOVED*** else if (other.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
      return Timestamp.ONE;
  ***REMOVED*** else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1***REMOVED***;
      var approx = halfThis.div(other***REMOVED***.shiftLeft(1***REMOVED***;
      if (approx.equals(Timestamp.ZERO***REMOVED******REMOVED*** {
        return other.isNegative(***REMOVED*** ? Timestamp.ONE : Timestamp.NEG_ONE;
    ***REMOVED*** else {
        var rem = this.subtract(other.multiply(approx***REMOVED******REMOVED***;
        var result = approx.add(rem.div(other***REMOVED******REMOVED***;
        return result;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if (other.equals(Timestamp.MIN_VALUE***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED***

  if (this.isNegative(***REMOVED******REMOVED*** {
    if (other.isNegative(***REMOVED******REMOVED*** {
      return this.negate(***REMOVED***.div(other.negate(***REMOVED******REMOVED***;
  ***REMOVED*** else {
      return this.negate(***REMOVED***.div(other***REMOVED***.negate(***REMOVED***;
  ***REMOVED***
***REMOVED*** else if (other.isNegative(***REMOVED******REMOVED*** {
    return this.div(other.negate(***REMOVED******REMOVED***.negate(***REMOVED***;
***REMOVED***

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Timestamp.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other***REMOVED******REMOVED*** {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber(***REMOVED*** / other.toNumber(***REMOVED******REMOVED******REMOVED***;

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx***REMOVED*** / Math.LN2***REMOVED***;
    var delta = (log2 <= 48***REMOVED*** ? 1 : Math.pow(2, log2 - 48***REMOVED***;

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Timestamp.fromNumber(approx***REMOVED***;
    var approxRem = approxRes.multiply(other***REMOVED***;
    while (approxRem.isNegative(***REMOVED*** || approxRem.greaterThan(rem***REMOVED******REMOVED*** {
      approx -= delta;
      approxRes = Timestamp.fromNumber(approx***REMOVED***;
      approxRem = approxRes.multiply(other***REMOVED***;
  ***REMOVED***

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero(***REMOVED******REMOVED*** {
      approxRes = Timestamp.ONE;
  ***REMOVED***

    res = res.add(approxRes***REMOVED***;
    rem = rem.subtract(approxRem***REMOVED***;
***REMOVED***
  return res;
};

/**
 * Returns this Timestamp modulo the given one.
 *
 * @param {Timestamp} other Timestamp by which to mod.
 * @return {Timestamp} this Timestamp modulo the given one.
 * @api public
 */
Timestamp.prototype.modulo = function(other***REMOVED*** {
  return this.subtract(this.div(other***REMOVED***.multiply(other***REMOVED******REMOVED***;
};

/**
 * The bitwise-NOT of this value.
 *
 * @return {Timestamp} the bitwise-NOT of this value.
 * @api public
 */
Timestamp.prototype.not = function(***REMOVED*** {
  return Timestamp.fromBits(~this.low_, ~this.high_***REMOVED***;
};

/**
 * Returns the bitwise-AND of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to AND.
 * @return {Timestamp} the bitwise-AND of this and the other.
 * @api public
 */
Timestamp.prototype.and = function(other***REMOVED*** {
  return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_***REMOVED***;
};

/**
 * Returns the bitwise-OR of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to OR.
 * @return {Timestamp} the bitwise-OR of this and the other.
 * @api public
 */
Timestamp.prototype.or = function(other***REMOVED*** {
  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_***REMOVED***;
};

/**
 * Returns the bitwise-XOR of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to XOR.
 * @return {Timestamp} the bitwise-XOR of this and the other.
 * @api public
 */
Timestamp.prototype.xor = function(other***REMOVED*** {
  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_***REMOVED***;
};

/**
 * Returns this Timestamp with bits shifted to the left by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the left by the given amount.
 * @api public
 */
Timestamp.prototype.shiftLeft = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var low = this.low_;
    if (numBits < 32***REMOVED*** {
      var high = this.high_;
      return Timestamp.fromBits(
                 low << numBits,
                 (high << numBits***REMOVED*** | (low >>> (32 - numBits***REMOVED******REMOVED******REMOVED***;
  ***REMOVED*** else {
      return Timestamp.fromBits(0, low << (numBits - 32***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns this Timestamp with bits shifted to the right by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the right by the given amount.
 * @api public
 */
Timestamp.prototype.shiftRight = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var high = this.high_;
    if (numBits < 32***REMOVED*** {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low >>> numBits***REMOVED*** | (high << (32 - numBits***REMOVED******REMOVED***,
                 high >> numBits***REMOVED***;
  ***REMOVED*** else {
      return Timestamp.fromBits(
                 high >> (numBits - 32***REMOVED***,
                 high >= 0 ? 0 : -1***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
 * @api public
 */
Timestamp.prototype.shiftRightUnsigned = function(numBits***REMOVED*** {
  numBits &= 63;
  if (numBits == 0***REMOVED*** {
    return this;
***REMOVED*** else {
    var high = this.high_;
    if (numBits < 32***REMOVED*** {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low >>> numBits***REMOVED*** | (high << (32 - numBits***REMOVED******REMOVED***,
                 high >>> numBits***REMOVED***;
  ***REMOVED*** else if (numBits == 32***REMOVED*** {
      return Timestamp.fromBits(high, 0***REMOVED***;
  ***REMOVED*** else {
      return Timestamp.fromBits(high >>> (numBits - 32***REMOVED***, 0***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Returns a Timestamp representing the given (32-bit***REMOVED*** integer value.
 *
 * @param {Number} value the 32-bit integer in question.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromInt = function(value***REMOVED*** {
  if (-128 <= value && value < 128***REMOVED*** {
    var cachedObj = Timestamp.INT_CACHE_[value];
    if (cachedObj***REMOVED*** {
      return cachedObj;
  ***REMOVED***
***REMOVED***

  var obj = new Timestamp(value | 0, value < 0 ? -1 : 0***REMOVED***;
  if (-128 <= value && value < 128***REMOVED*** {
    Timestamp.INT_CACHE_[value] = obj;
***REMOVED***
  return obj;
};

/**
 * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 *
 * @param {Number} value the number in question.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromNumber = function(value***REMOVED*** {
  if (isNaN(value***REMOVED*** || !isFinite(value***REMOVED******REMOVED*** {
    return Timestamp.ZERO;
***REMOVED*** else if (value <= -Timestamp.TWO_PWR_63_DBL_***REMOVED*** {
    return Timestamp.MIN_VALUE;
***REMOVED*** else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_***REMOVED*** {
    return Timestamp.MAX_VALUE;
***REMOVED*** else if (value < 0***REMOVED*** {
    return Timestamp.fromNumber(-value***REMOVED***.negate(***REMOVED***;
***REMOVED*** else {
    return new Timestamp(
               (value % Timestamp.TWO_PWR_32_DBL_***REMOVED*** | 0,
               (value / Timestamp.TWO_PWR_32_DBL_***REMOVED*** | 0***REMOVED***;
***REMOVED***
};

/**
 * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
 *
 * @param {Number} lowBits the low 32-bits.
 * @param {Number} highBits the high 32-bits.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromBits = function(lowBits, highBits***REMOVED*** {
  return new Timestamp(lowBits, highBits***REMOVED***;
};

/**
 * Returns a Timestamp representation of the given string, written using the given radix.
 *
 * @param {String} str the textual representation of the Timestamp.
 * @param {Number} opt_radix the radix in which the text is written.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromString = function(str, opt_radix***REMOVED*** {
  if (str.length == 0***REMOVED*** {
    throw Error('number format error: empty string'***REMOVED***;
***REMOVED***

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix***REMOVED*** {
    throw Error('radix out of range: ' + radix***REMOVED***;
***REMOVED***

  if (str.charAt(0***REMOVED*** == '-'***REMOVED*** {
    return Timestamp.fromString(str.substring(1***REMOVED***, radix***REMOVED***.negate(***REMOVED***;
***REMOVED*** else if (str.indexOf('-'***REMOVED*** >= 0***REMOVED*** {
    throw Error('number format error: interior "-" character: ' + str***REMOVED***;
***REMOVED***

  // Do several (8***REMOVED*** digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8***REMOVED******REMOVED***;

  var result = Timestamp.ZERO;
  for (var i = 0; i < str.length; i += 8***REMOVED*** {
    var size = Math.min(8, str.length - i***REMOVED***;
    var value = parseInt(str.substring(i, i + size***REMOVED***, radix***REMOVED***;
    if (size < 8***REMOVED*** {
      var power = Timestamp.fromNumber(Math.pow(radix, size***REMOVED******REMOVED***;
      result = result.multiply(power***REMOVED***.add(Timestamp.fromNumber(value***REMOVED******REMOVED***;
  ***REMOVED*** else {
      result = result.multiply(radixToPower***REMOVED***;
      result = result.add(Timestamp.fromNumber(value***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  return result;
};

// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Timestamp representations of small integer values.
 * @type {Object}
 * @api private
 */
Timestamp.INT_CACHE_ = {};

// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_16_DBL_ = 1 << 16;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_24_DBL_ = 1 << 24;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;

/** @type {Timestamp} */
Timestamp.ZERO = Timestamp.fromInt(0***REMOVED***;

/** @type {Timestamp} */
Timestamp.ONE = Timestamp.fromInt(1***REMOVED***;

/** @type {Timestamp} */
Timestamp.NEG_ONE = Timestamp.fromInt(-1***REMOVED***;

/** @type {Timestamp} */
Timestamp.MAX_VALUE =
    Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0***REMOVED***;

/** @type {Timestamp} */
Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0***REMOVED***;

/**
 * @type {Timestamp}
 * @api private
 */
Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24***REMOVED***;

/**
 * Expose.
 */
exports.Timestamp = Timestamp;