/**
 * Module dependencies.
 */
var BinaryParser = require('./binary_parser'***REMOVED***.BinaryParser;

/**
 * Machine id.
 *
 * Create a random 3-byte value (i.e. unique for this
 * process***REMOVED***. Other drivers use a md5 of the machine id here, but
 * that would mean an asyc call to gethostname, so we don't bother.
 */
var MACHINE_ID = parseInt(Math.random(***REMOVED*** * 0xFFFFFF, 10***REMOVED***;

// Regular expression that checks for hex value
var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$"***REMOVED***;

/**
* Create a new ObjectID instance
*
* @class Represents the BSON ObjectID type
* @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.
* @return {Object} instance of ObjectID.
*/
var ObjectID = function ObjectID(id***REMOVED*** {
  if(!(this instanceof ObjectID***REMOVED******REMOVED*** return new ObjectID(id***REMOVED***;
  if((id instanceof ObjectID***REMOVED******REMOVED*** return id;

  this._bsontype = 'ObjectID';
  var __id = null;
  var valid = ObjectID.isValid(id***REMOVED***;

  // Throw an error if it's not a valid setup
  if(!valid***REMOVED***{
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"***REMOVED***;
***REMOVED*** else if(valid && typeof id == 'string' && id.length == 24***REMOVED*** {
    return ObjectID.createFromHexString(id***REMOVED***;
***REMOVED*** else if(id == null || typeof id == 'number'***REMOVED*** {
    // convert to 12 byte binary string
    this.id = this.generate(id***REMOVED***;
***REMOVED*** else if(id != null && id.length === 12***REMOVED*** {
    // assume 12 byte string
    this.id = id;
***REMOVED***

  this.binId = new Buffer(this.id, 'binary'***REMOVED***;
  if(ObjectID.cacheHexString***REMOVED*** this.__id = this.toHexString(***REMOVED***;
};

// Allow usage of ObjectId aswell as ObjectID
var ObjectId = ObjectID;

/**
* Return the ObjectID id as a 24 byte hex string representation
*
* @return {String} return the 24 byte hex string representation.
* @api public
*/
ObjectID.prototype.toHexString = function(***REMOVED*** {
  if(ObjectID.cacheHexString && this.__id***REMOVED*** return this.__id;

  var hexString = ''
    , number
    , value;

  for (var index = 0, len = this.id.length; index < len; index++***REMOVED*** {
    value = BinaryParser.toByte(this.id[index]***REMOVED***;
    number = value <= 15
      ? '0' + value.toString(16***REMOVED***
      : value.toString(16***REMOVED***;
    hexString = hexString + number;
***REMOVED***

  if(ObjectID.cacheHexString***REMOVED*** this.__id = hexString;
  return hexString;
};

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @return {Number} returns next index value.
* @api private
*/
ObjectID.prototype.get_inc = function(***REMOVED*** {
  return ObjectID.index = (ObjectID.index + 1***REMOVED*** % 0xFFFFFF;
};

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @return {Number} returns next index value.
* @api private
*/
ObjectID.prototype.getInc = function(***REMOVED*** {
  return this.get_inc(***REMOVED***;
};

/**
* Generate a 12 byte id string used in ObjectID's
*
* @param {Number} [time] optional parameter allowing to pass in a second based timestamp.
* @return {String} return the 12 byte id binary string.
* @api private
*/
ObjectID.prototype.generate = function(time***REMOVED*** {
  if ('number' != typeof time***REMOVED*** {
    time = parseInt(Date.now(***REMOVED***/1000,10***REMOVED***;
***REMOVED***
  
  var time4Bytes = BinaryParser.encodeInt(time, 32, true, true***REMOVED***;
  /* for time-based ObjectID the bytes following the time will be zeroed */
  var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false***REMOVED***;
  var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random(***REMOVED*** * 100000***REMOVED*** : process.pid***REMOVED***;
  var index3Bytes = BinaryParser.encodeInt(this.get_inc(***REMOVED***, 24, false, true***REMOVED***;

  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
};

/**
* Converts the id into a 24 byte hex string for printing
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.toString = function(***REMOVED*** {
  return this.toHexString(***REMOVED***;
};

/**
* Converts to a string representation of this Id.
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.inspect = ObjectID.prototype.toString;

/**
* Converts to its JSON representation.
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.toJSON = function(***REMOVED*** {
  return this.toHexString(***REMOVED***;
};

/**
* Compares the equality of this ObjectID with `otherID`.
*
* @param {Object} otherID ObjectID instance to compare against.
* @return {Bool} the result of comparing two ObjectID's
* @api public
*/
ObjectID.prototype.equals = function equals (otherID***REMOVED*** {
  if(otherID == null***REMOVED*** return false;
  var id = (otherID instanceof ObjectID || otherID.toHexString***REMOVED***
    ? otherID.id
    : ObjectID.createFromHexString(otherID***REMOVED***.id;

  return this.id === id;
}

/**
* Returns the generation date (accurate up to the second***REMOVED*** that this ID was generated.
*
* @return {Date} the generation date
* @api public
*/
ObjectID.prototype.getTimestamp = function(***REMOVED*** {
  var timestamp = new Date(***REMOVED***;
  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4***REMOVED***, 32, true, true***REMOVED******REMOVED*** * 1000***REMOVED***;
  return timestamp;
}

/**
* @ignore
* @api private
*/
ObjectID.index = parseInt(Math.random(***REMOVED*** * 0xFFFFFF, 10***REMOVED***;

ObjectID.createPk = function createPk (***REMOVED*** {
  return new ObjectID(***REMOVED***;
};

/**
* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
*
* @param {Number} time an integer number representing a number of seconds.
* @return {ObjectID} return the created ObjectID
* @api public
*/
ObjectID.createFromTime = function createFromTime (time***REMOVED*** {
  var id = BinaryParser.encodeInt(time, 32, true, true***REMOVED*** +
           BinaryParser.encodeInt(0, 64, true, true***REMOVED***;
  return new ObjectID(id***REMOVED***;
};

/**
* Creates an ObjectID from a hex string representation of an ObjectID.
*
* @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.
* @return {ObjectID} return the created ObjectID
* @api public
*/
ObjectID.createFromHexString = function createFromHexString (hexString***REMOVED*** {
  // Throw an error if it's not a valid setup
  if(typeof hexString === 'undefined' || hexString != null && hexString.length != 24***REMOVED***
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"***REMOVED***;

  var len = hexString.length;

  if(len > 12*2***REMOVED*** {
    throw new Error('Id cannot be longer than 12 bytes'***REMOVED***;
***REMOVED***

  var result = ''
    , string
    , number;

  for (var index = 0; index < len; index += 2***REMOVED*** {
    string = hexString.substr(index, 2***REMOVED***;
    number = parseInt(string, 16***REMOVED***;
    result += BinaryParser.fromByte(number***REMOVED***;
***REMOVED***

  return new ObjectID(result, hexString***REMOVED***;
};

/**
* Checks if a value is a valid bson ObjectId
*
* @return {Boolean} return true if the value is a valid bson ObjectId, return false otherwise.
* @api public
*/
ObjectID.isValid = function isValid(id***REMOVED*** {
  if (id != null && 'number' != typeof id && (id.length != 12 && id.length != 24***REMOVED******REMOVED*** {
    return false;
***REMOVED*** else {
    // Check specifically for hex correctness
    if(typeof id == 'string' && id.length == 24***REMOVED*** return checkForHexRegExp.test(id***REMOVED***;
    return true;
***REMOVED***
};

/**
* @ignore
*/
Object.defineProperty(ObjectID.prototype, "generationTime", {
   enumerable: true
 , get: function (***REMOVED*** {
     return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4***REMOVED***, 32, true, true***REMOVED******REMOVED***;
 ***REMOVED***
 , set: function (value***REMOVED*** {
     var value = BinaryParser.encodeInt(value, 32, true, true***REMOVED***;
     this.id = value + this.id.substr(4***REMOVED***;
     // delete this.__id;
     this.toHexString(***REMOVED***;
 ***REMOVED***
}***REMOVED***;

/**
 * Expose.
 */
exports.ObjectID = ObjectID;
exports.ObjectId = ObjectID;
