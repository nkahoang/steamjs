/**
 * Module dependencies.
 */
if(typeof window === 'undefined'***REMOVED*** { 
  var Buffer = require('buffer'***REMOVED***.Buffer; // TODO just use global Buffer
}

// Binary default subtype
var BSON_BINARY_SUBTYPE_DEFAULT = 0;

/**
 * @ignore
 * @api private
 */
var writeStringToArray = function(data***REMOVED*** {
  // Create a buffer
  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length***REMOVED******REMOVED*** : new Array(data.length***REMOVED***;
  // Write the content to the buffer
  for(var i = 0; i < data.length; i++***REMOVED*** {
    buffer[i] = data.charCodeAt(i***REMOVED***;
***REMOVED***  
  // Write the string to the buffer
  return buffer;
}

/**
 * Convert Array ot Uint8Array to Binary String
 *
 * @ignore
 * @api private
 */
var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex***REMOVED*** {
  var result = "";
  for(var i = startIndex; i < endIndex; i++***REMOVED*** {
   result = result + String.fromCharCode(byteArray[i]***REMOVED***;
***REMOVED***
  return result;  
};

/**
 * A class representation of the BSON Binary type.
 * 
 * Sub types
 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
 *
 * @class Represents the Binary BSON type.
 * @param {Buffer} buffer a buffer object containing the binary data.
 * @param {Number} [subType] the option binary type.
 * @return {Grid}
 */
function Binary(buffer, subType***REMOVED*** {
  if(!(this instanceof Binary***REMOVED******REMOVED*** return new Binary(buffer, subType***REMOVED***;
  
  this._bsontype = 'Binary';

  if(buffer instanceof Number***REMOVED*** {
    this.sub_type = buffer;
    this.position = 0;
***REMOVED*** else {    
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
***REMOVED***

  if(buffer != null && !(buffer instanceof Number***REMOVED******REMOVED*** {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string'***REMOVED*** {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined'***REMOVED*** {
        this.buffer = new Buffer(buffer***REMOVED***;
    ***REMOVED*** else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer***REMOVED*** == '[object Array]'***REMOVED******REMOVED*** {
        this.buffer = writeStringToArray(buffer***REMOVED***;
    ***REMOVED*** else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted"***REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      this.buffer = buffer;      
  ***REMOVED***
    this.position = buffer.length;
***REMOVED*** else {
    if(typeof Buffer != 'undefined'***REMOVED*** {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE***REMOVED***;      
  ***REMOVED*** else if(typeof Uint8Array != 'undefined'***REMOVED***{
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE***REMOVED******REMOVED***;
  ***REMOVED*** else {
      this.buffer = new Array(Binary.BUFFER_SIZE***REMOVED***;
  ***REMOVED***
    // Set position to start of buffer
    this.position = 0;
***REMOVED***
};

/**
 * Updates this binary with byte_value.
 *
 * @param {Character} byte_value a single byte we wish to write.
 * @api public
 */
Binary.prototype.put = function put(byte_value***REMOVED*** {
  // If it's a string and a has more than one character throw an error
  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1***REMOVED*** throw new Error("only accepts single character String, Uint8Array or Array"***REMOVED***;
  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255***REMOVED*** throw new Error("only accepts number in a valid unsigned byte range 0-255"***REMOVED***;
  
  // Decode the byte value once
  var decoded_byte = null;
  if(typeof byte_value == 'string'***REMOVED*** {
    decoded_byte = byte_value.charCodeAt(0***REMOVED***;      
***REMOVED*** else if(byte_value['length'] != null***REMOVED*** {
    decoded_byte = byte_value[0];
***REMOVED*** else {
    decoded_byte = byte_value;
***REMOVED***
  
  if(this.buffer.length > this.position***REMOVED*** {
    this.buffer[this.position++] = decoded_byte;
***REMOVED*** else {
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {    
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length***REMOVED***;
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length***REMOVED***;
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
  ***REMOVED*** else {
      var buffer = null;
      // Create a new buffer (typed or normal array***REMOVED***
      if(Object.prototype.toString.call(this.buffer***REMOVED*** == '[object Uint8Array]'***REMOVED*** {
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length***REMOVED******REMOVED***;
    ***REMOVED*** else {
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length***REMOVED***;
    ***REMOVED***      
      
      // We need to copy all the content to the new array
      for(var i = 0; i < this.buffer.length; i++***REMOVED*** {
        buffer[i] = this.buffer[i];
    ***REMOVED***
      
      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
  ***REMOVED***
***REMOVED***
};

/**
 * Writes a buffer or string to the binary.
 *
 * @param {Buffer|String} string a string or buffer to be written to the Binary BSON object.
 * @param {Number} offset specify the binary of where to write the content.
 * @api public
 */
Binary.prototype.write = function write(string, offset***REMOVED*** {
  offset = typeof offset == 'number' ? offset : this.position;

  // If the buffer is to small let's extend the buffer
  if(this.buffer.length < offset + string.length***REMOVED*** {
    var buffer = null;
    // If we are in node.js
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {      
      buffer = new Buffer(this.buffer.length + string.length***REMOVED***;
      this.buffer.copy(buffer, 0, 0, this.buffer.length***REMOVED***;      
  ***REMOVED*** else if(Object.prototype.toString.call(this.buffer***REMOVED*** == '[object Uint8Array]'***REMOVED*** {
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length***REMOVED******REMOVED***
      // Copy the content
      for(var i = 0; i < this.position; i++***REMOVED*** {
        buffer[i] = this.buffer[i];
    ***REMOVED***
  ***REMOVED***
    
    // Assign the new buffer
    this.buffer = buffer;
***REMOVED***

  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string***REMOVED*** && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {
    string.copy(this.buffer, offset, 0, string.length***REMOVED***;
    this.position = (offset + string.length***REMOVED*** > this.position ? (offset + string.length***REMOVED*** : this.position;
    // offset = string.length
***REMOVED*** else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {
    this.buffer.write(string, 'binary', offset***REMOVED***;
    this.position = (offset + string.length***REMOVED*** > this.position ? (offset + string.length***REMOVED*** : this.position;
    // offset = string.length;
***REMOVED*** else if(Object.prototype.toString.call(string***REMOVED*** == '[object Uint8Array]' 
    || Object.prototype.toString.call(string***REMOVED*** == '[object Array]' && typeof string != 'string'***REMOVED*** {      
    for(var i = 0; i < string.length; i++***REMOVED*** {
      this.buffer[offset++] = string[i];
  ***REMOVED***    

    this.position = offset > this.position ? offset : this.position;
***REMOVED*** else if(typeof string == 'string'***REMOVED*** {
    for(var i = 0; i < string.length; i++***REMOVED*** {
      this.buffer[offset++] = string.charCodeAt(i***REMOVED***;
  ***REMOVED***

    this.position = offset > this.position ? offset : this.position;
***REMOVED***
};

/**
 * Reads **length** bytes starting at **position**.
 *
 * @param {Number} position read from the given position in the Binary.
 * @param {Number} length the number of bytes to read.
 * @return {Buffer}
 * @api public
 */
Binary.prototype.read = function read(position, length***REMOVED*** {
  length = length && length > 0
    ? length
    : this.position;
  
  // Let's return the data based on the type we have
  if(this.buffer['slice']***REMOVED*** {
    return this.buffer.slice(position, position + length***REMOVED***;
***REMOVED*** else {
    // Create a buffer to keep the result
    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length***REMOVED******REMOVED*** : new Array(length***REMOVED***;
    for(var i = 0; i < length; i++***REMOVED*** {
      buffer[i] = this.buffer[position++];
  ***REMOVED***
***REMOVED***
  // Return the buffer
  return buffer;
};

/**
 * Returns the value of this binary as a string.
 *
 * @return {String}
 * @api public
 */
Binary.prototype.value = function value(asRaw***REMOVED*** {
  asRaw = asRaw == null ? false : asRaw;  

  // Optimize to serialize for the situation where the data == size of buffer
  if(asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED*** && this.buffer.length == this.position***REMOVED***
    return this.buffer;
  
  // If it's a node.js buffer object
  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer***REMOVED******REMOVED*** {
    return asRaw ? this.buffer.slice(0, this.position***REMOVED*** : this.buffer.toString('binary', 0, this.position***REMOVED***;
***REMOVED*** else {
    if(asRaw***REMOVED*** {
      // we support the slice command use it
      if(this.buffer['slice'] != null***REMOVED*** {
        return this.buffer.slice(0, this.position***REMOVED***;
    ***REMOVED*** else {
        // Create a new buffer to copy content to
        var newBuffer = Object.prototype.toString.call(this.buffer***REMOVED*** == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position***REMOVED******REMOVED*** : new Array(this.position***REMOVED***;
        // Copy content
        for(var i = 0; i < this.position; i++***REMOVED*** {
          newBuffer[i] = this.buffer[i];
      ***REMOVED***
        // Return the buffer
        return newBuffer;
    ***REMOVED***
  ***REMOVED*** else {
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Length.
 *
 * @return {Number} the length of the binary.
 * @api public
 */
Binary.prototype.length = function length(***REMOVED*** {
  return this.position;
};

/**
 * @ignore
 * @api private
 */
Binary.prototype.toJSON = function(***REMOVED*** {
  return this.buffer != null ? this.buffer.toString('base64'***REMOVED*** : '';
}

/**
 * @ignore
 * @api private
 */
Binary.prototype.toString = function(format***REMOVED*** {
  return this.buffer != null ? this.buffer.slice(0, this.position***REMOVED***.toString(format***REMOVED*** : '';
}

Binary.BUFFER_SIZE = 256;

/**
 * Default BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_DEFAULT = 0;
/**
 * Function BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_FUNCTION = 1;
/**
 * Byte Array BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_BYTE_ARRAY = 2;
/**
 * OLD UUID BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID_OLD = 3;
/**
 * UUID BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID = 4;
/**
 * MD5 BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_MD5 = 5;
/**
 * User BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_USER_DEFINED = 128;

/**
 * Expose.
 */
exports.Binary = Binary;

