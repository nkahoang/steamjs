/**
 * Binary Parser.
 * Jonas Raoni Soares Silva
 * http://jsfromhell.com/classes/binary-parser [v1.0]
 */
var chr = String.fromCharCode;

var maxBits = [];
for (var i = 0; i < 64; i++***REMOVED*** {
	maxBits[i] = Math.pow(2, i***REMOVED***;
}

function BinaryParser (bigEndian, allowExceptions***REMOVED*** {
  if(!(this instanceof BinaryParser***REMOVED******REMOVED*** return new BinaryParser(bigEndian, allowExceptions***REMOVED***;
  
	this.bigEndian = bigEndian;
	this.allowExceptions = allowExceptions;
};

BinaryParser.warn = function warn (msg***REMOVED*** {
	if (this.allowExceptions***REMOVED*** {
		throw new Error(msg***REMOVED***;
***REMOVED***

	return 1;
};

BinaryParser.decodeFloat = function decodeFloat (data, precisionBits, exponentBits***REMOVED*** {
	var b = new this.Buffer(this.bigEndian, data***REMOVED***;

	b.checkBuffer(precisionBits + exponentBits + 1***REMOVED***;

	var bias = maxBits[exponentBits - 1] - 1
    , signal = b.readBits(precisionBits + exponentBits, 1***REMOVED***
    , exponent = b.readBits(precisionBits, exponentBits***REMOVED***
    , significand = 0
    , divisor = 2
    , curByte = b.buffer.length + (-precisionBits >> 3***REMOVED*** - 1;

	do {
		for (var byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; ( byteValue & mask ***REMOVED*** && ( significand += 1 / divisor ***REMOVED***, divisor *= 2 ***REMOVED***;
	} while (precisionBits -= startBit***REMOVED***;

	return exponent == ( bias << 1 ***REMOVED*** + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : ( 1 + signal * -2 ***REMOVED*** * ( exponent || significand ? !exponent ? Math.pow( 2, -bias + 1 ***REMOVED*** * significand : Math.pow( 2, exponent - bias ***REMOVED*** * ( 1 + significand ***REMOVED*** : 0 ***REMOVED***;
};

BinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian***REMOVED*** {
  var b = new this.Buffer(this.bigEndian || forceBigEndian, data***REMOVED***
      , x = b.readBits(0, bits***REMOVED***
      , max = maxBits[bits]; //max = Math.pow( 2, bits ***REMOVED***;
  
  return signed && x >= max / 2
      ? x - max
      : x;
};

BinaryParser.encodeFloat = function encodeFloat (data, precisionBits, exponentBits***REMOVED*** {
	var bias = maxBits[exponentBits - 1] - 1
    , minExp = -bias + 1
    , maxExp = bias
    , minUnnormExp = minExp - precisionBits
    , n = parseFloat(data***REMOVED***
    , status = isNaN(n***REMOVED*** || n == -Infinity || n == +Infinity ? n : 0
    ,	exp = 0
    , len = 2 * bias + 1 + precisionBits + 3
    , bin = new Array(len***REMOVED***
    , signal = (n = status !== 0 ? 0 : n***REMOVED*** < 0
    , intPart = Math.floor(n = Math.abs(n***REMOVED******REMOVED***
    , floatPart = n - intPart
    , lastBit
    , rounded
    , result
    , i
    , j;

	for (i = len; i; bin[--i] = 0***REMOVED***;

	for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2***REMOVED******REMOVED***;

	for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2***REMOVED*** >= 1***REMOVED*** - 0 ***REMOVED*** && --floatPart***REMOVED***;

	for (i = -1; ++i < len && !bin[i];***REMOVED***;

	if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i***REMOVED*** >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1***REMOVED******REMOVED******REMOVED*** + 1]***REMOVED*** {
		if (!(rounded = bin[lastBit]***REMOVED******REMOVED*** {
			for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]***REMOVED***;
		}

		for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0***REMOVED*** && (rounded = 0***REMOVED******REMOVED***;
	}

	for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];***REMOVED***;

	if ((exp = bias + 1 - i***REMOVED*** >= minExp && exp <= maxExp***REMOVED*** {
		++i;
***REMOVED*** else if (exp < minExp***REMOVED*** {
		exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"***REMOVED***;
		i = bias + 1 - (exp = minExp - 1***REMOVED***;
	}

	if (intPart || status !== 0***REMOVED*** {
		this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status***REMOVED***;
		exp = maxExp + 1;
		i = bias + 2;

		if (status == -Infinity***REMOVED*** {
			signal = 1;
  ***REMOVED*** else if (isNaN(status***REMOVED******REMOVED*** {
			bin[i] = 1;
  ***REMOVED***
	}

	for (n = Math.abs(exp + bias***REMOVED***, j = exponentBits + 1, result = ""; --j; result = (n % 2***REMOVED*** + result, n = n >>= 1***REMOVED***;

	for (n = 0, j = 0, i = (result = (signal ? "1" : "0"***REMOVED*** + result + bin.slice(i, i + precisionBits***REMOVED***.join(""***REMOVED******REMOVED***.length, r = []; i; j = (j + 1***REMOVED*** % 8***REMOVED*** {
		n += (1 << j***REMOVED*** * result.charAt(--i***REMOVED***;
		if (j == 7***REMOVED*** {
			r[r.length] = String.fromCharCode(n***REMOVED***;
			n = 0;
		}
	}

	r[r.length] = n
    ? String.fromCharCode(n***REMOVED***
    : "";

	return (this.bigEndian ? r.reverse(***REMOVED*** : r***REMOVED***.join(""***REMOVED***;
};

BinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian***REMOVED*** {
	var max = maxBits[bits];

  if (data >= max || data < -(max / 2***REMOVED******REMOVED*** {
    this.warn("encodeInt::overflow"***REMOVED***;
    data = 0;
***REMOVED***

	if (data < 0***REMOVED*** {
    data += max;
***REMOVED***

	for (var r = []; data; r[r.length] = String.fromCharCode(data % 256***REMOVED***, data = Math.floor(data / 256***REMOVED******REMOVED***;

	for (bits = -(-bits >> 3***REMOVED*** - r.length; bits--; r[r.length] = "\0"***REMOVED***;

  return ((this.bigEndian || forceBigEndian***REMOVED*** ? r.reverse(***REMOVED*** : r***REMOVED***.join(""***REMOVED***;
};

BinaryParser.toSmall    = function( data ***REMOVED***{ return this.decodeInt( data,  8, true  ***REMOVED***; };
BinaryParser.fromSmall  = function( data ***REMOVED***{ return this.encodeInt( data,  8, true  ***REMOVED***; };
BinaryParser.toByte     = function( data ***REMOVED***{ return this.decodeInt( data,  8, false ***REMOVED***; };
BinaryParser.fromByte   = function( data ***REMOVED***{ return this.encodeInt( data,  8, false ***REMOVED***; };
BinaryParser.toShort    = function( data ***REMOVED***{ return this.decodeInt( data, 16, true  ***REMOVED***; };
BinaryParser.fromShort  = function( data ***REMOVED***{ return this.encodeInt( data, 16, true  ***REMOVED***; };
BinaryParser.toWord     = function( data ***REMOVED***{ return this.decodeInt( data, 16, false ***REMOVED***; };
BinaryParser.fromWord   = function( data ***REMOVED***{ return this.encodeInt( data, 16, false ***REMOVED***; };
BinaryParser.toInt      = function( data ***REMOVED***{ return this.decodeInt( data, 32, true  ***REMOVED***; };
BinaryParser.fromInt    = function( data ***REMOVED***{ return this.encodeInt( data, 32, true  ***REMOVED***; };
BinaryParser.toLong     = function( data ***REMOVED***{ return this.decodeInt( data, 64, true  ***REMOVED***; };
BinaryParser.fromLong   = function( data ***REMOVED***{ return this.encodeInt( data, 64, true  ***REMOVED***; };
BinaryParser.toDWord    = function( data ***REMOVED***{ return this.decodeInt( data, 32, false ***REMOVED***; };
BinaryParser.fromDWord  = function( data ***REMOVED***{ return this.encodeInt( data, 32, false ***REMOVED***; };
BinaryParser.toQWord    = function( data ***REMOVED***{ return this.decodeInt( data, 64, true ***REMOVED***; };
BinaryParser.fromQWord  = function( data ***REMOVED***{ return this.encodeInt( data, 64, true ***REMOVED***; };
BinaryParser.toFloat    = function( data ***REMOVED***{ return this.decodeFloat( data, 23, 8   ***REMOVED***; };
BinaryParser.fromFloat  = function( data ***REMOVED***{ return this.encodeFloat( data, 23, 8   ***REMOVED***; };
BinaryParser.toDouble   = function( data ***REMOVED***{ return this.decodeFloat( data, 52, 11  ***REMOVED***; };
BinaryParser.fromDouble = function( data ***REMOVED***{ return this.encodeFloat( data, 52, 11  ***REMOVED***; };

// Factor out the encode so it can be shared by add_header and push_int32
BinaryParser.encode_int32 = function encode_int32 (number, asArray***REMOVED*** {
  var a, b, c, d, unsigned;
  unsigned = (number < 0***REMOVED*** ? (number + 0x100000000***REMOVED*** : number;
  a = Math.floor(unsigned / 0xffffff***REMOVED***;
  unsigned &= 0xffffff;
  b = Math.floor(unsigned / 0xffff***REMOVED***;
  unsigned &= 0xffff;
  c = Math.floor(unsigned / 0xff***REMOVED***;
  unsigned &= 0xff;
  d = Math.floor(unsigned***REMOVED***;
  return asArray ? [chr(a***REMOVED***, chr(b***REMOVED***, chr(c***REMOVED***, chr(d***REMOVED***] : chr(a***REMOVED*** + chr(b***REMOVED*** + chr(c***REMOVED*** + chr(d***REMOVED***;
};

BinaryParser.encode_int64 = function encode_int64 (number***REMOVED*** {
  var a, b, c, d, e, f, g, h, unsigned;
  unsigned = (number < 0***REMOVED*** ? (number + 0x10000000000000000***REMOVED*** : number;
  a = Math.floor(unsigned / 0xffffffffffffff***REMOVED***;
  unsigned &= 0xffffffffffffff;
  b = Math.floor(unsigned / 0xffffffffffff***REMOVED***;
  unsigned &= 0xffffffffffff;
  c = Math.floor(unsigned / 0xffffffffff***REMOVED***;
  unsigned &= 0xffffffffff;
  d = Math.floor(unsigned / 0xffffffff***REMOVED***;
  unsigned &= 0xffffffff;
  e = Math.floor(unsigned / 0xffffff***REMOVED***;
  unsigned &= 0xffffff;
  f = Math.floor(unsigned / 0xffff***REMOVED***;
  unsigned &= 0xffff;
  g = Math.floor(unsigned / 0xff***REMOVED***;
  unsigned &= 0xff;
  h = Math.floor(unsigned***REMOVED***;
  return chr(a***REMOVED*** + chr(b***REMOVED*** + chr(c***REMOVED*** + chr(d***REMOVED*** + chr(e***REMOVED*** + chr(f***REMOVED*** + chr(g***REMOVED*** + chr(h***REMOVED***;
};

/**
 * UTF8 methods
 */

// Take a raw binary string and return a utf8 string
BinaryParser.decode_utf8 = function decode_utf8 (binaryStr***REMOVED*** {
  var len = binaryStr.length
    , decoded = ''
    , i = 0
    , c = 0
    , c1 = 0
    , c2 = 0
    , c3;

  while (i < len***REMOVED*** {
    c = binaryStr.charCodeAt(i***REMOVED***;
    if (c < 128***REMOVED*** {
      decoded += String.fromCharCode(c***REMOVED***;
      i++;
  ***REMOVED*** else if ((c > 191***REMOVED*** && (c < 224***REMOVED******REMOVED*** {
	    c2 = binaryStr.charCodeAt(i+1***REMOVED***;
      decoded += String.fromCharCode(((c & 31***REMOVED*** << 6***REMOVED*** | (c2 & 63***REMOVED******REMOVED***;
      i += 2;
  ***REMOVED*** else {
	    c2 = binaryStr.charCodeAt(i+1***REMOVED***;
	    c3 = binaryStr.charCodeAt(i+2***REMOVED***;
      decoded += String.fromCharCode(((c & 15***REMOVED*** << 12***REMOVED*** | ((c2 & 63***REMOVED*** << 6***REMOVED*** | (c3 & 63***REMOVED******REMOVED***;
      i += 3;
  ***REMOVED***
***REMOVED***

  return decoded;
};

// Encode a cstring
BinaryParser.encode_cstring = function encode_cstring (s***REMOVED*** {
  return unescape(encodeURIComponent(s***REMOVED******REMOVED*** + BinaryParser.fromByte(0***REMOVED***;
};

// Take a utf8 string and return a binary string
BinaryParser.encode_utf8 = function encode_utf8 (s***REMOVED*** {
  var a = ""
    , c;

  for (var n = 0, len = s.length; n < len; n++***REMOVED*** {
    c = s.charCodeAt(n***REMOVED***;

    if (c < 128***REMOVED*** {
	    a += String.fromCharCode(c***REMOVED***;
  ***REMOVED*** else if ((c > 127***REMOVED*** && (c < 2048***REMOVED******REMOVED*** {
	    a += String.fromCharCode((c>>6***REMOVED*** | 192***REMOVED*** ;
	    a += String.fromCharCode((c&63***REMOVED*** | 128***REMOVED***;
  ***REMOVED*** else {
      a += String.fromCharCode((c>>12***REMOVED*** | 224***REMOVED***;
      a += String.fromCharCode(((c>>6***REMOVED*** & 63***REMOVED*** | 128***REMOVED***;
      a += String.fromCharCode((c&63***REMOVED*** | 128***REMOVED***;
  ***REMOVED***
***REMOVED***

  return a;
};

BinaryParser.hprint = function hprint (s***REMOVED*** {
  var number;

  for (var i = 0, len = s.length; i < len; i++***REMOVED*** {
    if (s.charCodeAt(i***REMOVED*** < 32***REMOVED*** {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;        
      process.stdout.write(number + " "***REMOVED***
  ***REMOVED*** else {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;
        process.stdout.write(number + " "***REMOVED***
  ***REMOVED***
***REMOVED***
  
  process.stdout.write("\n\n"***REMOVED***;
};

BinaryParser.ilprint = function hprint (s***REMOVED*** {
  var number;

  for (var i = 0, len = s.length; i < len; i++***REMOVED*** {
    if (s.charCodeAt(i***REMOVED*** < 32***REMOVED*** {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(10***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(10***REMOVED***;

      require('util'***REMOVED***.debug(number+' : '***REMOVED***;
  ***REMOVED*** else {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(10***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(10***REMOVED***;
      require('util'***REMOVED***.debug(number+' : '+ s.charAt(i***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

BinaryParser.hlprint = function hprint (s***REMOVED*** {
  var number;

  for (var i = 0, len = s.length; i < len; i++***REMOVED*** {
    if (s.charCodeAt(i***REMOVED*** < 32***REMOVED*** {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;
      require('util'***REMOVED***.debug(number+' : '***REMOVED***;
  ***REMOVED*** else {
      number = s.charCodeAt(i***REMOVED*** <= 15
        ? "0" + s.charCodeAt(i***REMOVED***.toString(16***REMOVED***
        : s.charCodeAt(i***REMOVED***.toString(16***REMOVED***;
      require('util'***REMOVED***.debug(number+' : '+ s.charAt(i***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * BinaryParser buffer constructor.
 */
function BinaryParserBuffer (bigEndian, buffer***REMOVED*** {
  this.bigEndian = bigEndian || 0;
  this.buffer = [];
  this.setBuffer(buffer***REMOVED***;
};

BinaryParserBuffer.prototype.setBuffer = function setBuffer (data***REMOVED*** {
  var l, i, b;

	if (data***REMOVED*** {
    i = l = data.length;
    b = this.buffer = new Array(l***REMOVED***;
		for (; i; b[l - i] = data.charCodeAt(--i***REMOVED******REMOVED***;
		this.bigEndian && b.reverse(***REMOVED***;
	}
};

BinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits***REMOVED*** {
	return this.buffer.length >= -(-neededBits >> 3***REMOVED***;
};

BinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits***REMOVED*** {
	if (!this.hasNeededBits(neededBits***REMOVED******REMOVED*** {
		throw new Error("checkBuffer::missing bytes"***REMOVED***;
***REMOVED***
};

BinaryParserBuffer.prototype.readBits = function readBits (start, length***REMOVED*** {
	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni***REMOVED***

	function shl (a, b***REMOVED*** {
		for (; b--; a = ((a %= 0x7fffffff + 1***REMOVED*** & 0x40000000***REMOVED*** == 0x40000000 ? a * 2 : (a - 0x40000000***REMOVED*** * 2 + 0x7fffffff + 1***REMOVED***;
		return a;
	}

	if (start < 0 || length <= 0***REMOVED*** {
		return 0;
***REMOVED***

	this.checkBuffer(start + length***REMOVED***;

  var offsetLeft
    , offsetRight = start % 8
    , curByte = this.buffer.length - ( start >> 3 ***REMOVED*** - 1
    , lastByte = this.buffer.length + ( -( start + length ***REMOVED*** >> 3 ***REMOVED***
    , diff = curByte - lastByte
    , sum = ((this.buffer[ curByte ] >> offsetRight***REMOVED*** & ((1 << (diff ? 8 - offsetRight : length***REMOVED******REMOVED*** - 1***REMOVED******REMOVED*** + (diff && (offsetLeft = (start + length***REMOVED*** % 8***REMOVED*** ? (this.buffer[lastByte++] & ((1 << offsetLeft***REMOVED*** - 1***REMOVED******REMOVED*** << (diff-- << 3***REMOVED*** - offsetRight : 0***REMOVED***;

	for(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3***REMOVED*** - offsetRight***REMOVED******REMOVED***;

	return sum;
};

/**
 * Expose.
 */
BinaryParser.Buffer = BinaryParserBuffer;

exports.BinaryParser = BinaryParser;
