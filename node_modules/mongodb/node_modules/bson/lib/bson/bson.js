var Long = require('./long'***REMOVED***.Long
  , Double = require('./double'***REMOVED***.Double
  , Timestamp = require('./timestamp'***REMOVED***.Timestamp
  , ObjectID = require('./objectid'***REMOVED***.ObjectID
  , Symbol = require('./symbol'***REMOVED***.Symbol
  , Code = require('./code'***REMOVED***.Code
  , MinKey = require('./min_key'***REMOVED***.MinKey
  , MaxKey = require('./max_key'***REMOVED***.MaxKey
  , DBRef = require('./db_ref'***REMOVED***.DBRef
  , Binary = require('./binary'***REMOVED***.Binary
  , BinaryParser = require('./binary_parser'***REMOVED***.BinaryParser
  , writeIEEE754 = require('./float_parser'***REMOVED***.writeIEEE754
  , readIEEE754 = require('./float_parser'***REMOVED***.readIEEE754

// To ensure that 0.4 of node works correctly
var isDate = function isDate(d***REMOVED*** {
  return typeof d === 'object' && Object.prototype.toString.call(d***REMOVED*** === '[object Date]';
}

/**
 * Create a new BSON instance
 *
 * @class Represents the BSON Parser
 * @return {BSON} instance of BSON Parser.
 */
function BSON (***REMOVED*** {};

/**
 * @ignore
 * @api private
 */
// BSON MAX VALUES
BSON.BSON_INT32_MAX = 0x7FFFFFFF;
BSON.BSON_INT32_MIN = -0x80000000;

BSON.BSON_INT64_MAX = Math.pow(2, 63***REMOVED*** - 1;
BSON.BSON_INT64_MIN = -Math.pow(2, 63***REMOVED***;

// JS MAX PRECISE VALUES
BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.

// Internal long versions
var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000***REMOVED***;  // Any integer up to 2^53 can be precisely represented by a double.
var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000***REMOVED***;  // Any integer down to -2^53 can be precisely represented by a double.

/**
 * Number BSON Type
 *
 * @classconstant BSON_DATA_NUMBER
 **/
BSON.BSON_DATA_NUMBER = 1;
/**
 * String BSON Type
 *
 * @classconstant BSON_DATA_STRING
 **/
BSON.BSON_DATA_STRING = 2;
/**
 * Object BSON Type
 *
 * @classconstant BSON_DATA_OBJECT
 **/
BSON.BSON_DATA_OBJECT = 3;
/**
 * Array BSON Type
 *
 * @classconstant BSON_DATA_ARRAY
 **/
BSON.BSON_DATA_ARRAY = 4;
/**
 * Binary BSON Type
 *
 * @classconstant BSON_DATA_BINARY
 **/
BSON.BSON_DATA_BINARY = 5;
/**
 * ObjectID BSON Type
 *
 * @classconstant BSON_DATA_OID
 **/
BSON.BSON_DATA_OID = 7;
/**
 * Boolean BSON Type
 *
 * @classconstant BSON_DATA_BOOLEAN
 **/
BSON.BSON_DATA_BOOLEAN = 8;
/**
 * Date BSON Type
 *
 * @classconstant BSON_DATA_DATE
 **/
BSON.BSON_DATA_DATE = 9;
/**
 * null BSON Type
 *
 * @classconstant BSON_DATA_NULL
 **/
BSON.BSON_DATA_NULL = 10;
/**
 * RegExp BSON Type
 *
 * @classconstant BSON_DATA_REGEXP
 **/
BSON.BSON_DATA_REGEXP = 11;
/**
 * Code BSON Type
 *
 * @classconstant BSON_DATA_CODE
 **/
BSON.BSON_DATA_CODE = 13;
/**
 * Symbol BSON Type
 *
 * @classconstant BSON_DATA_SYMBOL
 **/
BSON.BSON_DATA_SYMBOL = 14;
/**
 * Code with Scope BSON Type
 *
 * @classconstant BSON_DATA_CODE_W_SCOPE
 **/
BSON.BSON_DATA_CODE_W_SCOPE = 15;
/**
 * 32 bit Integer BSON Type
 *
 * @classconstant BSON_DATA_INT
 **/
BSON.BSON_DATA_INT = 16;
/**
 * Timestamp BSON Type
 *
 * @classconstant BSON_DATA_TIMESTAMP
 **/
BSON.BSON_DATA_TIMESTAMP = 17;
/**
 * Long BSON Type
 *
 * @classconstant BSON_DATA_LONG
 **/
BSON.BSON_DATA_LONG = 18;
/**
 * MinKey BSON Type
 *
 * @classconstant BSON_DATA_MIN_KEY
 **/
BSON.BSON_DATA_MIN_KEY = 0xff;
/**
 * MaxKey BSON Type
 *
 * @classconstant BSON_DATA_MAX_KEY
 **/
BSON.BSON_DATA_MAX_KEY = 0x7f;

/**
 * Binary Default Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
 **/
BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
/**
 * Binary Function Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
 **/
BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
/**
 * Binary Byte Array Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
 **/
BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
/**
 * Binary UUID Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_UUID
 **/
BSON.BSON_BINARY_SUBTYPE_UUID = 3;
/**
 * Binary MD5 Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_MD5
 **/
BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
/**
 * Binary User Defined Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
 **/
BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param {Object} object the Javascript object to calculate the BSON byte size for.
 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false***REMOVED*****.
 * @return {Number} returns the number of bytes the BSON object will take up.
 * @api public
 */
BSON.calculateObjectSize = function calculateObjectSize(object, serializeFunctions***REMOVED*** {
  var totalLength = (4 + 1***REMOVED***;

  if(Array.isArray(object***REMOVED******REMOVED*** {
    for(var i = 0; i < object.length; i++***REMOVED*** {
      totalLength += calculateElement(i.toString(***REMOVED***, object[i], serializeFunctions***REMOVED***
  ***REMOVED***
***REMOVED*** else {
		// If we have toBSON defined, override the current object
		if(object.toBSON***REMOVED*** {
			object = object.toBSON(***REMOVED***;
		}

		// Calculate size
    for(var key in object***REMOVED*** {
      totalLength += calculateElement(key, object[key], serializeFunctions***REMOVED***
  ***REMOVED***
***REMOVED***

  return totalLength;
}

/**
 * @ignore
 * @api private
 */
function calculateElement(name, value, serializeFunctions***REMOVED*** {
  var isBuffer = typeof Buffer !== 'undefined';

  switch(typeof value***REMOVED*** {
    case 'string':
      return 1 + (!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1 + 4 + (!isBuffer ? numberOfBytes(value***REMOVED*** : Buffer.byteLength(value, 'utf8'***REMOVED******REMOVED*** + 1;
    case 'number':
      if(Math.floor(value***REMOVED*** === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX***REMOVED*** {
        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX***REMOVED*** { // 32 bit
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (4 + 1***REMOVED***;
      ***REMOVED*** else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else {  // 64 bit
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
    ***REMOVED***
    case 'undefined':
      return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1***REMOVED***;
    case 'boolean':
      return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1 + 1***REMOVED***;
    case 'object':
      if(value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1***REMOVED***;
    ***REMOVED*** else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (12 + 1***REMOVED***;
    ***REMOVED*** else if(value instanceof Date || isDate(value***REMOVED******REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
    ***REMOVED*** else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value***REMOVED******REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (1 + 4 + 1***REMOVED*** + value.length;
    ***REMOVED*** else if(value instanceof Long || value instanceof Double || value instanceof Timestamp
          || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (8 + 1***REMOVED***;
    ***REMOVED*** else if(value instanceof Code || value['_bsontype'] == 'Code'***REMOVED*** {
        // Calculate size depending on the availability of a scope
        if(value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.code.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.code.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
      ***REMOVED*** else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + (!isBuffer ? numberOfBytes(value.code.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.code.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1;
      ***REMOVED***
    ***REMOVED*** else if(value instanceof Binary || value['_bsontype'] == 'Binary'***REMOVED*** {
        // Check what kind of subtype we have
        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (value.position + 1 + 4 + 1 + 4***REMOVED***;
      ***REMOVED*** else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + (value.position + 1 + 4 + 1***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else if(value instanceof Symbol || value['_bsontype'] == 'Symbol'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + ((!isBuffer ? numberOfBytes(value.value***REMOVED*** : Buffer.byteLength(value.value, 'utf8'***REMOVED******REMOVED*** + 4 + 1 + 1***REMOVED***;
    ***REMOVED*** else if(value instanceof DBRef || value['_bsontype'] == 'DBRef'***REMOVED*** {
        // Set up correct object for serialization
        var ordered_values = {
            '$ref': value.namespace
          , '$id' : value.oid
      ***REMOVED***;

        // Add db reference if it exists
        if(null != value.db***REMOVED*** {
          ordered_values['$db'] = value.db;
      ***REMOVED***

        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + BSON.calculateObjectSize(ordered_values, serializeFunctions***REMOVED***;
    ***REMOVED*** else if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]'***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + (!isBuffer ? numberOfBytes(value.source***REMOVED*** : Buffer.byteLength(value.source, 'utf8'***REMOVED******REMOVED*** + 1
            + (value.global ? 1 : 0***REMOVED*** + (value.ignoreCase ? 1 : 0***REMOVED*** + (value.multiline ? 1 : 0***REMOVED*** + 1
    ***REMOVED*** else {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + BSON.calculateObjectSize(value, serializeFunctions***REMOVED*** + 1;
    ***REMOVED***
    case 'function':
      // WTF for 0.4.X where typeof /someregexp/ === 'function'
      if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]' || String.call(value***REMOVED*** == '[object RegExp]'***REMOVED*** {
        return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + (!isBuffer ? numberOfBytes(value.source***REMOVED*** : Buffer.byteLength(value.source, 'utf8'***REMOVED******REMOVED*** + 1
          + (value.global ? 1 : 0***REMOVED*** + (value.ignoreCase ? 1 : 0***REMOVED*** + (value.multiline ? 1 : 0***REMOVED*** + 1
    ***REMOVED*** else {
        if(serializeFunctions && value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
      ***REMOVED*** else if(serializeFunctions***REMOVED*** {
          return (name != null ? ((!isBuffer ? numberOfBytes(name***REMOVED*** : Buffer.byteLength(name, 'utf8'***REMOVED******REMOVED*** + 1***REMOVED*** : 0***REMOVED*** + 1 + 4 + (!isBuffer ? numberOfBytes(value.toString(***REMOVED******REMOVED*** : Buffer.byteLength(value.toString(***REMOVED***, 'utf8'***REMOVED******REMOVED*** + 1;
      ***REMOVED***
    ***REMOVED***
***REMOVED***

  return 0;
}

/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
 * @param {Number} index the index in the buffer where we wish to start serializing into.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Number} returns the new write index in the Buffer.
 * @api public
 */
BSON.serializeWithBufferAndIndex = function serializeWithBufferAndIndex(object, checkKeys, buffer, index, serializeFunctions***REMOVED*** {
  // Default setting false
  serializeFunctions = serializeFunctions == null ? false : serializeFunctions;
  // Write end information (length of the object***REMOVED***
  var size = buffer.length;
  // Write the size of the object
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8***REMOVED*** & 0xff;
  buffer[index++] = (size >> 16***REMOVED*** & 0xff;
  buffer[index++] = (size >> 24***REMOVED*** & 0xff;
  return serializeObject(object, checkKeys, buffer, index, serializeFunctions***REMOVED*** - 1;
}

/**
 * @ignore
 * @api private
 */
var serializeObject = function(object, checkKeys, buffer, index, serializeFunctions***REMOVED*** {
  // Process the object
  if(Array.isArray(object***REMOVED******REMOVED*** {
    for(var i = 0; i < object.length; i++***REMOVED*** {
      index = packElement(i.toString(***REMOVED***, object[i], checkKeys, buffer, index, serializeFunctions***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
		// If we have toBSON defined, override the current object
		if(object.toBSON***REMOVED*** {
			object = object.toBSON(***REMOVED***;
		}

		// Serialize the object
    for(var key in object***REMOVED*** {
      // Check the key and throw error if it's illegal
      if (key != '$db' && key != '$ref' && key != '$id'***REMOVED*** {
        // dollars and dots ok
        BSON.checkKey(key, !checkKeys***REMOVED***;
    ***REMOVED***

      // Pack the element
      index = packElement(key, object[key], checkKeys, buffer, index, serializeFunctions***REMOVED***;
  ***REMOVED***
***REMOVED***

  // Write zero
  buffer[index++] = 0;
  return index;
}

var stringToBytes = function(str***REMOVED*** {
  var ch, st, re = [];
  for (var i = 0; i < str.length; i++ ***REMOVED*** {
    ch = str.charCodeAt(i***REMOVED***;  // get char
    st = [];                 // set up "stack"
    do {
      st.push( ch & 0xFF ***REMOVED***;  // push byte to stack
      ch = ch >> 8;          // shift value down by 1 byte
  ***REMOVED***
    while ( ch ***REMOVED***;
    // add stack contents to result
    // done because chars have "wrong" endianness
    re = re.concat( st.reverse(***REMOVED*** ***REMOVED***;
***REMOVED***
  // return an array of bytes
  return re;
}

var numberOfBytes = function(str***REMOVED*** {
  var ch, st, re = 0;
  for (var i = 0; i < str.length; i++ ***REMOVED*** {
    ch = str.charCodeAt(i***REMOVED***;  // get char
    st = [];                 // set up "stack"
    do {
      st.push( ch & 0xFF ***REMOVED***;  // push byte to stack
      ch = ch >> 8;          // shift value down by 1 byte
  ***REMOVED***
    while ( ch ***REMOVED***;
    // add stack contents to result
    // done because chars have "wrong" endianness
    re = re + st.length;
***REMOVED***
  // return an array of bytes
  return re;
}

/**
 * @ignore
 * @api private
 */
var writeToTypedArray = function(buffer, string, index***REMOVED*** {
  var bytes = stringToBytes(string***REMOVED***;
  for(var i = 0; i < bytes.length; i++***REMOVED*** {
    buffer[index + i] = bytes[i];
***REMOVED***
  return bytes.length;
}

/**
 * @ignore
 * @api private
 */
var supportsBuffer = typeof Buffer != 'undefined';

/**
 * @ignore
 * @api private
 */
var packElement = function(name, value, checkKeys, buffer, index, serializeFunctions***REMOVED*** {
  var startIndex = index;

  switch(typeof value***REMOVED*** {
    case 'string':
      // console.log("+++++++++++ index string:: " + index***REMOVED***
      // Encode String type
      buffer[index++] = BSON.BSON_DATA_STRING;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;

      // Calculate size
      var size = supportsBuffer ? Buffer.byteLength(value***REMOVED*** + 1 : numberOfBytes(value***REMOVED*** + 1;
      // console.log("====== key :: " + name + " size ::" + size***REMOVED***
      // Write the size of the string to buffer
      buffer[index + 3] = (size >> 24***REMOVED*** & 0xff;
      buffer[index + 2] = (size >> 16***REMOVED*** & 0xff;
      buffer[index + 1] = (size >> 8***REMOVED*** & 0xff;
      buffer[index] = size & 0xff;
      // Ajust the index
      index = index + 4;
      // Write the string
      supportsBuffer ? buffer.write(value, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, value, index***REMOVED***;
      // Update index
      index = index + size - 1;
      // Write zero
      buffer[index++] = 0;
      // Return index
      return index;
    case 'number':
      // We have an integer value
      if(Math.floor(value***REMOVED*** === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX***REMOVED*** {
        // If the value fits in 32 bits encode as int, if it fits in a double
        // encode it as a double, otherwise long
        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX***REMOVED*** {
          // Set int type 32 bits or less
          buffer[index++] = BSON.BSON_DATA_INT;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Write the int value
          buffer[index++] = value & 0xff;
          buffer[index++] = (value >> 8***REMOVED*** & 0xff;
          buffer[index++] = (value >> 16***REMOVED*** & 0xff;
          buffer[index++] = (value >> 24***REMOVED*** & 0xff;
      ***REMOVED*** else if(value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX***REMOVED*** {
          // Encode as double
          buffer[index++] = BSON.BSON_DATA_NUMBER;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Write float
          writeIEEE754(buffer, value, index, 'little', 52, 8***REMOVED***;
          // Ajust index
          index = index + 8;
      ***REMOVED*** else {
          // Set long type
          buffer[index++] = BSON.BSON_DATA_LONG;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          var longVal = Long.fromNumber(value***REMOVED***;
          var lowBits = longVal.getLowBits(***REMOVED***;
          var highBits = longVal.getHighBits(***REMOVED***;
          // Encode low bits
          buffer[index++] = lowBits & 0xff;
          buffer[index++] = (lowBits >> 8***REMOVED*** & 0xff;
          buffer[index++] = (lowBits >> 16***REMOVED*** & 0xff;
          buffer[index++] = (lowBits >> 24***REMOVED*** & 0xff;
          // Encode high bits
          buffer[index++] = highBits & 0xff;
          buffer[index++] = (highBits >> 8***REMOVED*** & 0xff;
          buffer[index++] = (highBits >> 16***REMOVED*** & 0xff;
          buffer[index++] = (highBits >> 24***REMOVED*** & 0xff;
      ***REMOVED***
    ***REMOVED*** else {
        // Encode as double
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write float
        writeIEEE754(buffer, value, index, 'little', 52, 8***REMOVED***;
        // Ajust index
        index = index + 8;
    ***REMOVED***

      return index;
    case 'undefined':
      // Set long type
      buffer[index++] = BSON.BSON_DATA_NULL;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      return index;
    case 'boolean':
      // Write the type
      buffer[index++] = BSON.BSON_DATA_BOOLEAN;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      // Encode the boolean value
      buffer[index++] = value ? 1 : 0;
      return index;
    case 'object':
      if(value === null || value instanceof MinKey || value instanceof MaxKey
          || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey'***REMOVED*** {
        // Write the type of either min or max key
        if(value === null***REMOVED*** {
          buffer[index++] = BSON.BSON_DATA_NULL;
      ***REMOVED*** else if(value instanceof MinKey***REMOVED*** {
          buffer[index++] = BSON.BSON_DATA_MIN_KEY;
      ***REMOVED*** else {
          buffer[index++] = BSON.BSON_DATA_MAX_KEY;
      ***REMOVED***

        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        return index;
    ***REMOVED*** else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID'***REMOVED*** {
        // console.log("+++++++++++ index OBJECTID:: " + index***REMOVED***
        // Write the type
        buffer[index++] = BSON.BSON_DATA_OID;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write objectid
        supportsBuffer ? buffer.write(value.id, index, 'binary'***REMOVED*** : writeToTypedArray(buffer, value.id, index***REMOVED***;
        // Ajust index
        index = index + 12;
        return index;
    ***REMOVED*** else if(value instanceof Date || isDate(value***REMOVED******REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_DATE;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the date
        var dateInMilis = Long.fromNumber(value.getTime(***REMOVED******REMOVED***;
        var lowBits = dateInMilis.getLowBits(***REMOVED***;
        var highBits = dateInMilis.getHighBits(***REMOVED***;
        // Encode low bits
        buffer[index++] = lowBits & 0xff;
        buffer[index++] = (lowBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 24***REMOVED*** & 0xff;
        // Encode high bits
        buffer[index++] = highBits & 0xff;
        buffer[index++] = (highBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 24***REMOVED*** & 0xff;
        return index;
    ***REMOVED*** else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value***REMOVED******REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_BINARY;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Get size of the buffer (current write point***REMOVED***
        var size = value.length;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write the default subtype
        buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
        // Copy the content form the binary field to the buffer
        value.copy(buffer, index, 0, size***REMOVED***;
        // Adjust the index
        index = index + size;
        return index;
    ***REMOVED*** else if(value instanceof Long || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp'***REMOVED*** {
        // Write the type
        buffer[index++] = value instanceof Long ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write the date
        var lowBits = value.getLowBits(***REMOVED***;
        var highBits = value.getHighBits(***REMOVED***;
        // Encode low bits
        buffer[index++] = lowBits & 0xff;
        buffer[index++] = (lowBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (lowBits >> 24***REMOVED*** & 0xff;
        // Encode high bits
        buffer[index++] = highBits & 0xff;
        buffer[index++] = (highBits >> 8***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 16***REMOVED*** & 0xff;
        buffer[index++] = (highBits >> 24***REMOVED*** & 0xff;
        return index;
    ***REMOVED*** else if(value instanceof Double || value['_bsontype'] == 'Double'***REMOVED*** {
        // Encode as double
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write float
        writeIEEE754(buffer, value, index, 'little', 52, 8***REMOVED***;
        // Ajust index
        index = index + 8;
        return index;
    ***REMOVED*** else if(value instanceof Code || value['_bsontype'] == 'Code'***REMOVED*** {
        if(value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          // Write the type
          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Calculate the scope size
          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
          // Function string
          var functionString = value.code.toString(***REMOVED***;
          // Function Size
          var codeSize = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;

          // Calculate full size of the object
          var totalSize = 4 + codeSize + scopeSize + 4;

          // Write the total size of the object
          buffer[index++] = totalSize & 0xff;
          buffer[index++] = (totalSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 24***REMOVED*** & 0xff;

          // Write the size of the string to buffer
          buffer[index++] = codeSize & 0xff;
          buffer[index++] = (codeSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 24***REMOVED*** & 0xff;

          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + codeSize - 1;
          // Write zero
          buffer[index++] = 0;
          // Serialize the scope object
          var scopeObjectBuffer = supportsBuffer ? new Buffer(scopeSize***REMOVED*** : new Uint8Array(new ArrayBuffer(scopeSize***REMOVED******REMOVED***;
          // Execute the serialization into a seperate buffer
          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions***REMOVED***;

          // Adjusted scope Size (removing the header***REMOVED***
          var scopeDocSize = scopeSize;
          // Write scope object size
          buffer[index++] = scopeDocSize & 0xff;
          buffer[index++] = (scopeDocSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 24***REMOVED*** & 0xff;

          // Write the scopeObject into the buffer
          supportsBuffer ? scopeObjectBuffer.copy(buffer, index, 0, scopeSize***REMOVED*** : buffer.set(scopeObjectBuffer, index***REMOVED***;
          // Adjust index, removing the empty size of the doc (5 bytes 0000000005***REMOVED***
          index = index + scopeDocSize - 5;
          // Write trailing zero
          buffer[index++] = 0;
          return index
      ***REMOVED*** else {
          buffer[index++] = BSON.BSON_DATA_CODE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Function string
          var functionString = value.code.toString(***REMOVED***;
          // Function Size
          var size = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;
          // Write the size of the string to buffer
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8***REMOVED*** & 0xff;
          buffer[index++] = (size >> 16***REMOVED*** & 0xff;
          buffer[index++] = (size >> 24***REMOVED*** & 0xff;
          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + size - 1;
          // Write zero
          buffer[index++] = 0;
          return index;
      ***REMOVED***
    ***REMOVED*** else if(value instanceof Binary || value['_bsontype'] == 'Binary'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_BINARY;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Extract the buffer
        var data = value.value(true***REMOVED***;
        // Calculate size
        var size = value.position;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write the subtype to the buffer
        buffer[index++] = value.sub_type;

        // If we have binary type 2 the 4 first bytes are the size
        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8***REMOVED*** & 0xff;
          buffer[index++] = (size >> 16***REMOVED*** & 0xff;
          buffer[index++] = (size >> 24***REMOVED*** & 0xff;
      ***REMOVED***

        // Write the data to the object
        supportsBuffer ? data.copy(buffer, index, 0, value.position***REMOVED*** : buffer.set(data, index***REMOVED***;
        // Ajust index
        index = index + value.position;
        return index;
    ***REMOVED*** else if(value instanceof Symbol || value['_bsontype'] == 'Symbol'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_SYMBOL;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Calculate size
        var size = supportsBuffer ? Buffer.byteLength(value.value***REMOVED*** + 1 : numberOfBytes(value.value***REMOVED*** + 1;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write the string
        buffer.write(value.value, index, 'utf8'***REMOVED***;
        // Update index
        index = index + size - 1;
        // Write zero
        buffer[index++] = 0x00;
        return index;
    ***REMOVED*** else if(value instanceof DBRef || value['_bsontype'] == 'DBRef'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_OBJECT;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Set up correct object for serialization
        var ordered_values = {
            '$ref': value.namespace
          , '$id' : value.oid
      ***REMOVED***;

        // Add db reference if it exists
        if(null != value.db***REMOVED*** {
          ordered_values['$db'] = value.db;
      ***REMOVED***

        // Message size
        var size = BSON.calculateObjectSize(ordered_values, serializeFunctions***REMOVED***;
        // Serialize the object
        var endIndex = BSON.serializeWithBufferAndIndex(ordered_values, checkKeys, buffer, index, serializeFunctions***REMOVED***;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        // Write zero for object
        buffer[endIndex++] = 0x00;
        // Return the end index
        return endIndex;
    ***REMOVED*** else if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_REGEXP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the regular expression string
        supportsBuffer ? buffer.write(value.source, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, value.source, index***REMOVED***;
        // Adjust the index
        index = index + (supportsBuffer ? Buffer.byteLength(value.source***REMOVED*** : numberOfBytes(value.source***REMOVED******REMOVED***;
        // Write zero
        buffer[index++] = 0x00;
        // Write the parameters
        if(value.global***REMOVED*** buffer[index++] = 0x73; // s
        if(value.ignoreCase***REMOVED*** buffer[index++] = 0x69; // i
        if(value.multiline***REMOVED*** buffer[index++] = 0x6d; // m
        // Add ending zero
        buffer[index++] = 0x00;
        return index;
    ***REMOVED*** else {
        // Write the type
        buffer[index++] = Array.isArray(value***REMOVED*** ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Adjust the index
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
	      var endIndex = serializeObject(value, checkKeys, buffer, index + 4, serializeFunctions***REMOVED***;
        // Write size
        var size = endIndex - index;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8***REMOVED*** & 0xff;
        buffer[index++] = (size >> 16***REMOVED*** & 0xff;
        buffer[index++] = (size >> 24***REMOVED*** & 0xff;
        return endIndex;
    ***REMOVED***
    case 'function':
      // WTF for 0.4.X where typeof /someregexp/ === 'function'
      if(value instanceof RegExp || Object.prototype.toString.call(value***REMOVED*** === '[object RegExp]' || String.call(value***REMOVED*** == '[object RegExp]'***REMOVED*** {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_REGEXP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the regular expression string
        buffer.write(value.source, index, 'utf8'***REMOVED***;
        // Adjust the index
        index = index + (supportsBuffer ? Buffer.byteLength(value.source***REMOVED*** : numberOfBytes(value.source***REMOVED******REMOVED***;
        // Write zero
        buffer[index++] = 0x00;
        // Write the parameters
        if(value.global***REMOVED*** buffer[index++] = 0x73; // s
        if(value.ignoreCase***REMOVED*** buffer[index++] = 0x69; // i
        if(value.multiline***REMOVED*** buffer[index++] = 0x6d; // m
        // Add ending zero
        buffer[index++] = 0x00;
        return index;
    ***REMOVED*** else {
        if(serializeFunctions && value.scope != null && Object.keys(value.scope***REMOVED***.length > 0***REMOVED*** {
          // Write the type
          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Calculate the scope size
          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions***REMOVED***;
          // Function string
          var functionString = value.toString(***REMOVED***;
          // Function Size
          var codeSize = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;

          // Calculate full size of the object
          var totalSize = 4 + codeSize + scopeSize;

          // Write the total size of the object
          buffer[index++] = totalSize & 0xff;
          buffer[index++] = (totalSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (totalSize >> 24***REMOVED*** & 0xff;

          // Write the size of the string to buffer
          buffer[index++] = codeSize & 0xff;
          buffer[index++] = (codeSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (codeSize >> 24***REMOVED*** & 0xff;

          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + codeSize - 1;
          // Write zero
          buffer[index++] = 0;
          // Serialize the scope object
          var scopeObjectBuffer = new Buffer(scopeSize***REMOVED***;
          // Execute the serialization into a seperate buffer
          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions***REMOVED***;

          // Adjusted scope Size (removing the header***REMOVED***
          var scopeDocSize = scopeSize - 4;
          // Write scope object size
          buffer[index++] = scopeDocSize & 0xff;
          buffer[index++] = (scopeDocSize >> 8***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 16***REMOVED*** & 0xff;
          buffer[index++] = (scopeDocSize >> 24***REMOVED*** & 0xff;

          // Write the scopeObject into the buffer
          scopeObjectBuffer.copy(buffer, index, 0, scopeSize***REMOVED***;

          // Adjust index, removing the empty size of the doc (5 bytes 0000000005***REMOVED***
          index = index + scopeDocSize - 5;
          // Write trailing zero
          buffer[index++] = 0;
          return index
      ***REMOVED*** else if(serializeFunctions***REMOVED*** {
          buffer[index++] = BSON.BSON_DATA_CODE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, name, index***REMOVED***;
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Function string
          var functionString = value.toString(***REMOVED***;
          // Function Size
          var size = supportsBuffer ? Buffer.byteLength(functionString***REMOVED*** + 1 : numberOfBytes(functionString***REMOVED*** + 1;
          // Write the size of the string to buffer
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8***REMOVED*** & 0xff;
          buffer[index++] = (size >> 16***REMOVED*** & 0xff;
          buffer[index++] = (size >> 24***REMOVED*** & 0xff;
          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8'***REMOVED*** : writeToTypedArray(buffer, functionString, index***REMOVED***;
          // Update index
          index = index + size - 1;
          // Write zero
          buffer[index++] = 0;
          return index;
      ***REMOVED***
    ***REMOVED***
***REMOVED***

  // If no value to serialize
  return index;
}

/**
 * Serialize a Javascript object.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore***REMOVED*****.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Buffer} returns the Buffer object containing the serialized object.
 * @api public
 */
BSON.serialize = function(object, checkKeys, asBuffer, serializeFunctions***REMOVED*** {
  // Throw error if we are trying serialize an illegal type
  if(object == null || typeof object != 'object' || Array.isArray(object***REMOVED******REMOVED*** 
    throw new Error("Only javascript objects supported"***REMOVED***;
  
  // Emoty target buffer
  var buffer = null;
  // Calculate the size of the object
  var size = BSON.calculateObjectSize(object, serializeFunctions***REMOVED***;
  // Fetch the best available type for storing the binary data
  if(buffer = typeof Buffer != 'undefined'***REMOVED*** {
    buffer = new Buffer(size***REMOVED***;
    asBuffer = true;
***REMOVED*** else if(typeof Uint8Array != 'undefined'***REMOVED*** {
    buffer = new Uint8Array(new ArrayBuffer(size***REMOVED******REMOVED***;
***REMOVED*** else {
    buffer = new Array(size***REMOVED***;
***REMOVED***

  // If asBuffer is false use typed arrays
  BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, 0, serializeFunctions***REMOVED***;
  // console.log("++++++++++++++++++++++++++++++++++++ OLDJS :: " + buffer.length***REMOVED***  
  // console.log(buffer.toString('hex'***REMOVED******REMOVED***
  // console.log(buffer.toString('ascii'***REMOVED******REMOVED***
  return buffer;
}

/**
 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
 *
 * @ignore
 * @api private
 */
var functionCache = BSON.functionCache = {};

/**
 * Crc state variables shared by function
 *
 * @ignore
 * @api private
 */
var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

/**
 * CRC32 hash method, Fast and enough versitility for our usage
 *
 * @ignore
 * @api private
 */
var crc32 =  function(string, start, end***REMOVED*** {
  var crc = 0
  var x = 0;
  var y = 0;
  crc = crc ^ (-1***REMOVED***;

  for(var i = start, iTop = end; i < iTop;i++***REMOVED*** {
  	y = (crc ^ string[i]***REMOVED*** & 0xFF;
    x = table[y];
  	crc = (crc >>> 8***REMOVED*** ^ x;
***REMOVED***

  return crc ^ (-1***REMOVED***;
}

/**
 * Deserialize stream data as BSON documents.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
 *
 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
 * @param {Number} numberOfDocuments number of documents to deserialize.
 * @param {Array} documents an array where to store the deserialized documents.
 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
 * @api public
 */
BSON.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options***REMOVED*** {
  // if(numberOfDocuments !== documents.length***REMOVED*** throw new Error("Number of expected results back is less than the number of documents"***REMOVED***;
  options = options != null ? options : {};
  var index = startIndex;
  // Loop over all documents
  for(var i = 0; i < numberOfDocuments; i++***REMOVED*** {
    // Find size of the document
    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
    // Update options with index
    options['index'] = index;
    // Parse the document at this point
    documents[docStartIndex + i] = BSON.deserialize(data, options***REMOVED***;
    // Adjust index by the document size
    index = index + size;
***REMOVED***

  // Return object containing end index of parsing and list of documents
  return index;
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEvalWithHash = function(functionCache, hash, functionString, object***REMOVED*** {
  // Contains the value we are going to set
  var value = null;

  // Check for cache hit, eval if missing and return cached function
  if(functionCache[hash] == null***REMOVED*** {
    eval("value = " + functionString***REMOVED***;
    functionCache[hash] = value;
***REMOVED***
  // Set the object
  return functionCache[hash].bind(object***REMOVED***;
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEval = function(functionString***REMOVED*** {
  // Contains the value we are going to set
  var value = null;
  // Eval the function
  eval("value = " + functionString***REMOVED***;
  return value;
}

/**
 * Convert Uint8Array to String
 *
 * @ignore
 * @api private
 */
var convertUint8ArrayToUtf8String = function(byteArray, startIndex, endIndex***REMOVED*** {
  return BinaryParser.decode_utf8(convertArraytoUtf8BinaryString(byteArray, startIndex, endIndex***REMOVED******REMOVED***;
}

var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex***REMOVED*** {
  var result = "";
  for(var i = startIndex; i < endIndex; i++***REMOVED*** {
    result = result + String.fromCharCode(byteArray[i]***REMOVED***;
***REMOVED***

  return result;
};

/**
 * Deserialize data as BSON.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
 *
 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @param {Boolean} [isArray] ignore used for recursive parsing.
 * @return {Object} returns the deserialized Javascript Object.
 * @api public
 */
BSON.deserialize = function(buffer, options, isArray***REMOVED*** {
  // Options
  options = options == null ? {} : options;
  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];

  // Validate that we have at least 4 bytes of buffer
  if(buffer.length < 5***REMOVED*** throw new Error("corrupt bson message < 5 bytes long"***REMOVED***;

  // Set up index
  var index = typeof options['index'] == 'number' ? options['index'] : 0;
  // Reads in a C style string
  var readCStyleString = function(***REMOVED*** {
    // Get the start search index
    var i = index;
    // Locate the end of the c string
    while(buffer[i] !== 0x00 && i < buffer.length***REMOVED*** { 
      i++ 
  ***REMOVED***
    // If are at the end of the buffer there is a problem with the document
    if(i >= buffer.length***REMOVED*** throw new Error("Bad BSON Document: illegal CString"***REMOVED***
    // Grab utf8 encoded string
    var string = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, i***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, i***REMOVED***;
    // Update index position
    index = i + 1;
    // Return string
    return string;
***REMOVED***

  // Create holding object
  var object = isArray ? [] : {};

  // Read the document size
  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;

  // Ensure buffer is valid size
  if(size < 5 || size > buffer.length***REMOVED*** throw new Error("corrupt bson message"***REMOVED***;

  // While we have more left data left keep parsing
  while(true***REMOVED*** {
    // Read the type
    var elementType = buffer[index++];
    // If we get a zero it's the last byte, exit
    if(elementType == 0***REMOVED*** break;
    // Read the name of the field
    var name = readCStyleString(***REMOVED***;
    // Switch on the type
    switch(elementType***REMOVED*** {
      case BSON.BSON_DATA_OID:
        var string = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('binary', index, index + 12***REMOVED*** : convertArraytoUtf8BinaryString(buffer, index, index + 12***REMOVED***;
        // Decode the oid
        object[name] = new ObjectID(string***REMOVED***;
        // Update index
        index = index + 12;
        break;
      case BSON.BSON_DATA_STRING:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Add string to object
        object[name] = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, index + stringSize - 1***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1***REMOVED***;
        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_INT:
        // Decode the 32bit value
        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        break;
      case BSON.BSON_DATA_NUMBER:
        // Decode the double value
        object[name] = readIEEE754(buffer, index, 'little', 52, 8***REMOVED***;
        // Update the index
        index = index + 8;
        break;
      case BSON.BSON_DATA_DATE:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Set date object
        object[name] = new Date(new Long(lowBits, highBits***REMOVED***.toNumber(***REMOVED******REMOVED***;
        break;
      case BSON.BSON_DATA_BOOLEAN:
        // Parse the boolean value
        object[name] = buffer[index++] == 1;
        break;
      case BSON.BSON_DATA_NULL:
        // Parse the boolean value
        object[name] = null;
        break;
      case BSON.BSON_DATA_BINARY:
        // Decode the size of the binary blob
        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Decode the subtype
        var subType = buffer[index++];
        // Decode as raw Buffer object if options specifies it
        if(buffer['slice'] != null***REMOVED*** {
          // If we have subtype 2 skip the 4 bytes for the size
          if(subType == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        ***REMOVED***
          // Slice the data
          object[name] = new Binary(buffer.slice(index, index + binarySize***REMOVED***, subType***REMOVED***;
      ***REMOVED*** else {
          var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize***REMOVED******REMOVED*** : new Array(binarySize***REMOVED***;
          // If we have subtype 2 skip the 4 bytes for the size
          if(subType == Binary.SUBTYPE_BYTE_ARRAY***REMOVED*** {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        ***REMOVED***
          // Copy the data
          for(var i = 0; i < binarySize; i++***REMOVED*** {
            _buffer[i] = buffer[index + i];
        ***REMOVED***
          // Create the binary object
          object[name] = new Binary(_buffer, subType***REMOVED***;
      ***REMOVED***
        // Update the index
        index = index + binarySize;
        break;
      case BSON.BSON_DATA_ARRAY:
        options['index'] = index;
        // Decode the size of the array document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Set the array to the object
        object[name] = BSON.deserialize(buffer, options, true***REMOVED***;
        // Adjust the index
        index = index + objectSize;
        break;
      case BSON.BSON_DATA_OBJECT:
        options['index'] = index;
        // Decode the size of the object document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Set the array to the object
        object[name] = BSON.deserialize(buffer, options, false***REMOVED***;
        // Adjust the index
        index = index + objectSize;
        break;
      case BSON.BSON_DATA_REGEXP:
        // Create the regexp
        var source = readCStyleString(***REMOVED***;
        var regExpOptions = readCStyleString(***REMOVED***;
        // For each option add the corresponding one for javascript
        var optionsArray = new Array(regExpOptions.length***REMOVED***;

        // Parse options
        for(var i = 0; i < regExpOptions.length; i++***REMOVED*** {
          switch(regExpOptions[i]***REMOVED*** {
            case 'm':
              optionsArray[i] = 'm';
              break;
            case 's':
              optionsArray[i] = 'g';
              break;
            case 'i':
              optionsArray[i] = 'i';
              break;
        ***REMOVED***
      ***REMOVED***

        object[name] = new RegExp(source, optionsArray.join(''***REMOVED******REMOVED***;
        break;
      case BSON.BSON_DATA_LONG:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Create long object
        var long = new Long(lowBits, highBits***REMOVED***; 
        // Promote the long if possible
        if(promoteLongs***REMOVED*** {
          object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG***REMOVED*** && long.greaterThanOrEqual(JS_INT_MIN_LONG***REMOVED*** ? long.toNumber(***REMOVED*** : long;
      ***REMOVED*** else {
          object[name] = long;
      ***REMOVED***
        break;
      case BSON.BSON_DATA_SYMBOL:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Add string to object
        object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1***REMOVED******REMOVED***;
        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_TIMESTAMP:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Set the object
        object[name] = new Timestamp(lowBits, highBits***REMOVED***;
        break;
      case BSON.BSON_DATA_MIN_KEY:
        // Parse the object
        object[name] = new MinKey(***REMOVED***;
        break;
      case BSON.BSON_DATA_MAX_KEY:
        // Parse the object
        object[name] = new MaxKey(***REMOVED***;
        break;
      case BSON.BSON_DATA_CODE:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Function string
        var functionString = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, index + stringSize - 1***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1***REMOVED***;

        // If we are evaluating the functions
        if(evalFunctions***REMOVED*** {
          // Contains the value we are going to set
          var value = null;
          // If we have cache enabled let's look for the md5 of the function in the cache
          if(cacheFunctions***REMOVED*** {
            var hash = cacheFunctionsCrc32 ? crc32(functionString***REMOVED*** : functionString;
            // Got to do this to avoid V8 deoptimizing the call due to finding eval
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object***REMOVED***;
        ***REMOVED*** else {
            // Set directly
            object[name] = isolateEval(functionString***REMOVED***;
        ***REMOVED***
      ***REMOVED*** else {
          object[name]  = new Code(functionString, {}***REMOVED***;
      ***REMOVED***

        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_CODE_W_SCOPE:
        // Read the content of the field
        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Javascript function
        var functionString = supportsBuffer && Buffer.isBuffer(buffer***REMOVED*** ? buffer.toString('utf8', index, index + stringSize - 1***REMOVED*** : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1***REMOVED***;
        // Update parse index position
        index = index + stringSize;
        // Parse the element
        options['index'] = index;
        // Decode the size of the object document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Decode the scope object
        var scopeObject = BSON.deserialize(buffer, options, false***REMOVED***;
        // Adjust the index
        index = index + objectSize;

        // If we are evaluating the functions
        if(evalFunctions***REMOVED*** {
          // Contains the value we are going to set
          var value = null;
          // If we have cache enabled let's look for the md5 of the function in the cache
          if(cacheFunctions***REMOVED*** {
            var hash = cacheFunctionsCrc32 ? crc32(functionString***REMOVED*** : functionString;
            // Got to do this to avoid V8 deoptimizing the call due to finding eval
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object***REMOVED***;
        ***REMOVED*** else {
            // Set directly
            object[name] = isolateEval(functionString***REMOVED***;
        ***REMOVED***

          // Set the scope on the object
          object[name].scope = scopeObject;
      ***REMOVED*** else {
          object[name]  = new Code(functionString, scopeObject***REMOVED***;
      ***REMOVED***

        // Add string to object
        break;
  ***REMOVED***
***REMOVED***

  // Check if we have a db ref object
  if(object['$id'] != null***REMOVED*** object = new DBRef(object['$ref'], object['$id'], object['$db']***REMOVED***;

  // Return the final objects
  return object;
}

/**
 * Check if key name is valid.
 *
 * @ignore
 * @api private
 */
BSON.checkKey = function checkKey (key, dollarsAndDotsOk***REMOVED*** {
  if (!key.length***REMOVED*** return;
  // Check if we have a legal key for the object
  if (!!~key.indexOf("\x00"***REMOVED******REMOVED*** {
    // The BSON spec doesn't allow keys with null bytes because keys are
    // null-terminated.
    throw Error("key " + key + " must not contain null bytes"***REMOVED***;
***REMOVED***
  if (!dollarsAndDotsOk***REMOVED*** {
    if('$' == key[0]***REMOVED*** {
      throw Error("key " + key + " must not start with '$'"***REMOVED***;
  ***REMOVED*** else if (!!~key.indexOf('.'***REMOVED******REMOVED*** {
      throw Error("key " + key + " must not contain '.'"***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Deserialize data as BSON.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *
 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @param {Boolean} [isArray] ignore used for recursive parsing.
 * @return {Object} returns the deserialized Javascript Object.
 * @api public
 */
BSON.prototype.deserialize = function(data, options***REMOVED*** {
  return BSON.deserialize(data, options***REMOVED***;
}

/**
 * Deserialize stream data as BSON documents.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *
 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
 * @param {Number} numberOfDocuments number of documents to deserialize.
 * @param {Array} documents an array where to store the deserialized documents.
 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
 * @api public
 */
BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options***REMOVED*** {
  return BSON.deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options***REMOVED***;
}

/**
 * Serialize a Javascript object.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore***REMOVED*****.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Buffer} returns the Buffer object containing the serialized object.
 * @api public
 */
BSON.prototype.serialize = function(object, checkKeys, asBuffer, serializeFunctions***REMOVED*** {
  return BSON.serialize(object, checkKeys, asBuffer, serializeFunctions***REMOVED***;
}

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param {Object} object the Javascript object to calculate the BSON byte size for.
 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false***REMOVED*****.
 * @return {Number} returns the number of bytes the BSON object will take up.
 * @api public
 */
BSON.prototype.calculateObjectSize = function(object, serializeFunctions***REMOVED*** {
  return BSON.calculateObjectSize(object, serializeFunctions***REMOVED***;
}

/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
 * @param {Number} index the index in the buffer where we wish to start serializing into.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false***REMOVED*****.
 * @return {Number} returns the new write index in the Buffer.
 * @api public
 */
BSON.prototype.serializeWithBufferAndIndex = function(object, checkKeys, buffer, startIndex, serializeFunctions***REMOVED*** {
  return BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, startIndex, serializeFunctions***REMOVED***;
}

/**
 * @ignore
 * @api private
 */
exports.Code = Code;
exports.Symbol = Symbol;
exports.BSON = BSON;
exports.DBRef = DBRef;
exports.Binary = Binary;
exports.ObjectID = ObjectID;
exports.Long = Long;
exports.Timestamp = Timestamp;
exports.Double = Double;
exports.MinKey = MinKey;
exports.MaxKey = MaxKey;
