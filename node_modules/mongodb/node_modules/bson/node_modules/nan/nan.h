/**********************************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c***REMOVED*** 2014 NAN contributors:
 *   - Rod Vagg <https://github.com/rvagg>
 *   - Benjamin Byholm <https://github.com/kkoopa>
 *   - Trevor Norris <https://github.com/trevnorris>
 *   - Nathan Rajlich <https://github.com/TooTallNate>
 *   - Brett Lawson <https://github.com/brett19>
 *   - Ben Noordhuis <https://github.com/bnoordhuis>
 *
 * MIT +no-false-attribs License <https://github.com/rvagg/nan/blob/master/LICENSE>
 *
 * Version 0.8.0 (current Node unstable: 0.11.10, Node stable: 0.10.24***REMOVED***
 *
 * ChangeLog:
 *  * 0.8.0 Jan 9 2014
 *    - NanDispose -> NanDisposePersistent, deprecate NanDispose
 *    - Extract _NAN_*_RETURN_TYPE, pull up NAN_*(***REMOVED***
 *
 *  * 0.7.1 Jan 9 2014
 *    - Fixes to work against debug builds of Node
 *    - Safer NanPersistentToLocal (avoid reinterpret_cast***REMOVED***
 *    - Speed up common NanRawString case by only extracting flattened string when necessary
 *
 *  * 0.7.0 Dec 17 2013
 *    - New no-arg form of NanCallback(***REMOVED*** constructor.
 *    - NanCallback#Call takes Handle rather than Local
 *    - Removed deprecated NanCallback#Run method, use NanCallback#Call instead
 *    - Split off _NAN_*_ARGS_TYPE from _NAN_*_ARGS
 *    - Restore (unofficial***REMOVED*** Node 0.6 compatibility at NanCallback#Call(***REMOVED***
 *    - Introduce NanRawString(***REMOVED*** for char* (or appropriate void****REMOVED*** from v8::String
 *      (replacement for NanFromV8String***REMOVED***
 *    - Introduce NanCString(***REMOVED*** for null-terminated char* from v8::String
 *
 *  * 0.6.0 Nov 21 2013
 *    - Introduce NanNewLocal<T>(v8::Handle<T> value***REMOVED*** for use in place of
 *      v8::Local<T>::New(...***REMOVED*** since v8 started requiring isolate in Node 0.11.9
 *
 *  * 0.5.2 Nov 16 2013
 *    - Convert SavePersistent and GetFromPersistent in NanAsyncWorker from protected and public
 *
 *  * 0.5.1 Nov 12 2013
 *    - Use node::MakeCallback(***REMOVED*** instead of direct v8::Function::Call(***REMOVED***
 *
 *  * 0.5.0 Nov 11 2013
 *    - Added @TooTallNate as collaborator
 *    - New, much simpler, "include_dirs" for binding.gyp
 *    - Added full range of NAN_INDEX_* macros to match NAN_PROPERTY_* macros
 *
 *  * 0.4.4 Nov 2 2013
 *    - Isolate argument from v8::Persistent::MakeWeak removed for 0.11.8+
 *
 *  * 0.4.3 Nov 2 2013
 *    - Include node_object_wrap.h, removed from node.h for Node 0.11.8.
 *
 *  * 0.4.2 Nov 2 2013
 *    - Handle deprecation of v8::Persistent::Dispose(v8::Isolate* isolate***REMOVED******REMOVED*** for
 *      Node 0.11.8 release.
 *
 *  * 0.4.1 Sep 16 2013
 *    - Added explicit `#include <uv.h>` as it was removed from node.h for v0.11.8
 *
 *  * 0.4.0 Sep 2 2013
 *    - Added NAN_INLINE and NAN_DEPRECATED and made use of them
 *    - Added NanError, NanTypeError and NanRangeError
 *    - Cleaned up code
 *
 *  * 0.3.2 Aug 30 2013
 *    - Fix missing scope declaration in GetFromPersistent(***REMOVED*** and SaveToPersistent
 *      in NanAsyncWorker
 *
 *  * 0.3.1 Aug 20 2013
 *    - fix "not all control paths return a value" compile warning on some platforms
 *
 *  * 0.3.0 Aug 19 2013
 *    - Made NAN work with NPM
 *    - Lots of fixes to NanFromV8String, pulling in features from new Node core
 *    - Changed node::encoding to Nan::Encoding in NanFromV8String to unify the API
 *    - Added optional error number argument for NanThrowError(***REMOVED***
 *    - Added NanInitPersistent(***REMOVED***
 *    - Added NanReturnNull(***REMOVED*** and NanReturnEmptyString(***REMOVED***
 *    - Added NanLocker and NanUnlocker
 *    - Added missing scopes
 *    - Made sure to clear disposed Persistent handles
 *    - Changed NanAsyncWorker to allocate error messages on the heap
 *    - Changed NanThrowError(Local<Value>***REMOVED*** to NanThrowError(Handle<Value>***REMOVED***
 *    - Fixed leak in NanAsyncWorker when errmsg is used
 *
 *  * 0.2.2 Aug 5 2013
 *    - Fixed usage of undefined variable with node::BASE64 in NanFromV8String(***REMOVED***
 *
 *  * 0.2.1 Aug 5 2013
 *    - Fixed 0.8 breakage, node::BUFFER encoding type not available in 0.8 for
 *      NanFromV8String(***REMOVED***
 *
 *  * 0.2.0 Aug 5 2013
 *    - Added NAN_PROPERTY_GETTER, NAN_PROPERTY_SETTER, NAN_PROPERTY_ENUMERATOR,
 *      NAN_PROPERTY_DELETER, NAN_PROPERTY_QUERY
 *    - Extracted _NAN_METHOD_ARGS, _NAN_GETTER_ARGS, _NAN_SETTER_ARGS,
 *      _NAN_PROPERTY_GETTER_ARGS, _NAN_PROPERTY_SETTER_ARGS,
 *      _NAN_PROPERTY_ENUMERATOR_ARGS, _NAN_PROPERTY_DELETER_ARGS,
 *      _NAN_PROPERTY_QUERY_ARGS
 *    - Added NanGetInternalFieldPointer, NanSetInternalFieldPointer
 *    - Added NAN_WEAK_CALLBACK, NAN_WEAK_CALLBACK_OBJECT,
 *      NAN_WEAK_CALLBACK_DATA, NanMakeWeak
 *    - Renamed THROW_ERROR to _NAN_THROW_ERROR
 *    - Added NanNewBufferHandle(char*, size_t, node::smalloc::FreeCallback, void****REMOVED***
 *    - Added NanBufferUse(char*, uint32_t***REMOVED***
 *    - Added NanNewContextHandle(v8::ExtensionConfiguration*,
 *        v8::Handle<v8::ObjectTemplate>, v8::Handle<v8::Value>***REMOVED***
 *    - Fixed broken NanCallback#GetFunction(***REMOVED***
 *    - Added optional encoding and size arguments to NanFromV8String(***REMOVED***
 *    - Added NanGetPointerSafe(***REMOVED*** and NanSetPointerSafe(***REMOVED***
 *    - Added initial test suite (to be expanded***REMOVED***
 *    - Allow NanUInt32OptionValue to convert any Number object
 *
 *  * 0.1.0 Jul 21 2013
 *    - Added `NAN_GETTER`, `NAN_SETTER`
 *    - Added `NanThrowError` with single Local<Value> argument
 *    - Added `NanNewBufferHandle` with single uint32_t argument
 *    - Added `NanHasInstance(Persistent<FunctionTemplate>&, Handle<Value>***REMOVED***`
 *    - Added `Local<Function> NanCallback#GetFunction(***REMOVED***`
 *    - Added `NanCallback#Call(int, Local<Value>[]***REMOVED***`
 *    - Deprecated `NanCallback#Run(int, Local<Value>[]***REMOVED***` in favour of Call
 *
 * See https://github.com/rvagg/nan for the latest update to this file
 **********************************************************************************/

#ifndef NAN_H
#define NAN_H

#include <uv.h>
#include <node.h>
#include <node_buffer.h>
#include <node_version.h>
#include <node_object_wrap.h>
#include <string.h>

#if defined(__GNUC__***REMOVED*** && !defined(DEBUG***REMOVED***
# define NAN_INLINE(declarator***REMOVED*** inline __attribute__((always_inline***REMOVED******REMOVED*** declarator
#elif defined(_MSC_VER***REMOVED*** && !defined(DEBUG***REMOVED***
# define NAN_INLINE(declarator***REMOVED*** __forceinline declarator
#else
# define NAN_INLINE(declarator***REMOVED*** inline declarator
#endif

#if defined(__GNUC__***REMOVED*** && !V8_DISABLE_DEPRECATIONS
# define NAN_DEPRECATED(declarator***REMOVED*** __attribute__((deprecated***REMOVED******REMOVED*** declarator
#elif defined(_MSC_VER***REMOVED*** && !V8_DISABLE_DEPRECATIONS
# define NAN_DEPRECATED(declarator***REMOVED*** __declspec(deprecated***REMOVED*** declarator
#else
# define NAN_DEPRECATED(declarator***REMOVED*** declarator
#endif

// some generic helpers

template<class T> static NAN_INLINE(bool NanSetPointerSafe(
    T *var
  , T val
***REMOVED******REMOVED*** {
  if (var***REMOVED*** {
    *var = val;
    return true;
***REMOVED*** else {
    return false;
***REMOVED***
}

template<class T> static NAN_INLINE(T NanGetPointerSafe(
    T *var
  , T fallback = reinterpret_cast<T>(0***REMOVED***
***REMOVED******REMOVED*** {
  if (var***REMOVED*** {
    return *var;
***REMOVED*** else {
    return fallback;
***REMOVED***
}

#define NanSymbol(value***REMOVED*** v8::String::NewSymbol(value***REMOVED***

static NAN_INLINE(bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt, bool def
***REMOVED******REMOVED*** {
  if (def***REMOVED*** {
    return optionsObj.IsEmpty(***REMOVED***
      || !optionsObj->Has(opt***REMOVED***
      || optionsObj->Get(opt***REMOVED***->BooleanValue(***REMOVED***;
***REMOVED*** else {
    return !optionsObj.IsEmpty(***REMOVED***
      && optionsObj->Has(opt***REMOVED***
      && optionsObj->Get(opt***REMOVED***->BooleanValue(***REMOVED***;
***REMOVED***
}

static NAN_INLINE(bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
***REMOVED******REMOVED*** {
  return NanBooleanOptionValue(optionsObj, opt, false***REMOVED***;
}

static NAN_INLINE(uint32_t NanUInt32OptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
  , uint32_t def
***REMOVED******REMOVED*** {
  return !optionsObj.IsEmpty(***REMOVED***
    && optionsObj->Has(opt***REMOVED***
    && optionsObj->Get(opt***REMOVED***->IsNumber(***REMOVED***
      ? optionsObj->Get(opt***REMOVED***->Uint32Value(***REMOVED***
      : def;
}

#if (NODE_MODULE_VERSION > 0x000B***REMOVED***
// Node 0.11+ (0.11.3 and below won't compile with these***REMOVED***

static v8::Isolate* nan_isolate = v8::Isolate::GetCurrent(***REMOVED***;

# define _NAN_METHOD_ARGS_TYPE const v8::FunctionCallbackInfo<v8::Value>&
# define _NAN_METHOD_ARGS _NAN_METHOD_ARGS_TYPE args
# define _NAN_METHOD_RETURN_TYPE void

# define _NAN_GETTER_ARGS_TYPE const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_GETTER_ARGS _NAN_GETTER_ARGS_TYPE args
# define _NAN_GETTER_RETURN_TYPE void

# define _NAN_SETTER_ARGS_TYPE const v8::PropertyCallbackInfo<void>&
# define _NAN_SETTER_ARGS _NAN_SETTER_ARGS_TYPE args
# define _NAN_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_GETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_GETTER_ARGS _NAN_PROPERTY_GETTER_ARGS_TYPE args
# define _NAN_PROPERTY_GETTER_RETURN_TYPE void

# define _NAN_PROPERTY_SETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_SETTER_ARGS _NAN_PROPERTY_SETTER_ARGS_TYPE args
# define _NAN_PROPERTY_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE                                    \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_PROPERTY_ENUMERATOR_ARGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE args
# define _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE void

# define _NAN_PROPERTY_DELETER_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_PROPERTY_DELETER_ARGS                                            \
    _NAN_PROPERTY_DELETER_ARGS_TYPE args
# define _NAN_PROPERTY_DELETER_RETURN_TYPE void

# define _NAN_PROPERTY_QUERY_ARGS_TYPE                                         \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_PROPERTY_QUERY_ARGS _NAN_PROPERTY_QUERY_ARGS_TYPE args
# define _NAN_PROPERTY_QUERY_RETURN_TYPE void

# define _NAN_INDEX_GETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_GETTER_ARGS _NAN_INDEX_GETTER_ARGS_TYPE args
# define _NAN_INDEX_GETTER_RETURN_TYPE void

# define _NAN_INDEX_SETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_SETTER_ARGS _NAN_INDEX_SETTER_ARGS_TYPE args
# define _NAN_INDEX_SETTER_RETURN_TYPE void

# define _NAN_INDEX_ENUMERATOR_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_INDEX_ENUMERATOR_ARGS _NAN_INDEX_ENUMERATOR_ARGS_TYPE args
# define _NAN_INDEX_ENUMERATOR_RETURN_TYPE void

# define _NAN_INDEX_DELETER_ARGS_TYPE                                          \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_INDEX_DELETER_ARGS _NAN_INDEX_DELETER_ARGS_TYPE args
# define _NAN_INDEX_DELETER_RETURN_TYPE void

# define _NAN_INDEX_QUERY_ARGS_TYPE                                            \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_INDEX_QUERY_ARGS _NAN_INDEX_QUERY_ARGS_TYPE args
# define _NAN_INDEX_QUERY_RETURN_TYPE void

# define NanGetInternalFieldPointer(object, index***REMOVED***                             \
    object->GetAlignedPointerFromInternalField(index***REMOVED***
# define NanSetInternalFieldPointer(object, index, value***REMOVED***                      \
    object->SetAlignedPointerInInternalField(index, value***REMOVED***

# define NAN_WEAK_CALLBACK(type, name***REMOVED***                                         \
    void name(                                                                 \
        v8::Isolate* isolate                                                   \
      , v8::Persistent<v8::Object>* object                                     \
      , type data***REMOVED***
# define NAN_WEAK_CALLBACK_OBJECT (*object***REMOVED***
# define NAN_WEAK_CALLBACK_DATA(type***REMOVED*** ((type***REMOVED*** data***REMOVED***

# define NanScope(***REMOVED*** v8::HandleScope scope(nan_isolate***REMOVED***
# define NanLocker(***REMOVED*** v8::Locker locker(nan_isolate***REMOVED***
# define NanUnlocker(***REMOVED*** v8::Unlocker unlocker(nan_isolate***REMOVED***
# define NanReturnValue(value***REMOVED*** return args.GetReturnValue(***REMOVED***.Set(value***REMOVED***
# define NanReturnUndefined(***REMOVED*** return
# define NanReturnNull(***REMOVED*** return args.GetReturnValue(***REMOVED***.SetNull(***REMOVED***
# define NanReturnEmptyString(***REMOVED*** return args.GetReturnValue(***REMOVED***.SetEmptyString(***REMOVED***
# define NanAssignPersistent(type, handle, obj***REMOVED*** handle.Reset(nan_isolate, obj***REMOVED***
# define NanInitPersistent(type, name, obj***REMOVED***                                    \
    v8::Persistent<type> name(nan_isolate, obj***REMOVED***
# define NanObjectWrapHandle(obj***REMOVED*** obj->handle(***REMOVED***

//TODO: remove <0.11.8 support when 0.12 is released
#if NODE_VERSION_AT_LEAST(0, 11, 8***REMOVED***
# define NanMakeWeak(handle, parameter, callback***REMOVED***                              \
    handle.MakeWeak(parameter, callback***REMOVED***
#else
# define NanMakeWeak(handle, parameter, callback***REMOVED***                              \
    handle.MakeWeak(nan_isolate, parameter, callback***REMOVED***
#endif

# define _NAN_ERROR(fun, errmsg***REMOVED*** fun(v8::String::New(errmsg***REMOVED******REMOVED***

# define _NAN_THROW_ERROR(fun, errmsg***REMOVED***                                         \
    do {                                                                       \
      NanScope(***REMOVED***;                                                              \
      v8::ThrowException(_NAN_ERROR(fun, errmsg***REMOVED******REMOVED***;                             \
  ***REMOVED*** while (0***REMOVED***;

  template<class T> static NAN_INLINE(v8::Local<T> NanNewLocal(
      v8::Handle<T> val
  ***REMOVED******REMOVED*** {
//TODO: remove <0.11.9 support when 0.12 is released
#if NODE_VERSION_AT_LEAST(0, 11, 9***REMOVED***
    return v8::Local<T>::New(nan_isolate, val***REMOVED***;
#else
    return v8::Local<T>::New(val***REMOVED***;
#endif
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanError(const char* errmsg***REMOVED******REMOVED*** {
    return  _NAN_ERROR(v8::Exception::Error, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(void NanThrowError(const char* errmsg***REMOVED******REMOVED*** {
    _NAN_THROW_ERROR(v8::Exception::Error, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(void NanThrowError(v8::Handle<v8::Value> error***REMOVED******REMOVED*** {
    NanScope(***REMOVED***;
    v8::ThrowException(error***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanError(
      const char *msg
    , const int errorNumber
  ***REMOVED******REMOVED*** {
    v8::Local<v8::Value> err = v8::Exception::Error(v8::String::New(msg***REMOVED******REMOVED***;
    v8::Local<v8::Object> obj = err.As<v8::Object>(***REMOVED***;
    obj->Set(v8::String::New("code"***REMOVED***, v8::Int32::New(errorNumber***REMOVED******REMOVED***;
    return err;
***REMOVED***

  static NAN_INLINE(void NanThrowError(
      const char *msg
    , const int errorNumber
  ***REMOVED******REMOVED*** {
    NanThrowError(NanError(msg, errorNumber***REMOVED******REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanTypeError(const char* errmsg***REMOVED******REMOVED*** {
    return _NAN_ERROR(v8::Exception::TypeError, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(void NanThrowTypeError(const char* errmsg***REMOVED******REMOVED*** {
    _NAN_THROW_ERROR(v8::Exception::TypeError, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanRangeError(const char* errmsg***REMOVED******REMOVED*** {
    return _NAN_ERROR(v8::Exception::RangeError, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(void NanThrowRangeError(const char* errmsg***REMOVED******REMOVED*** {
    _NAN_THROW_ERROR(v8::Exception::RangeError, errmsg***REMOVED***;
***REMOVED***

  template<class T> static NAN_INLINE(void NanDisposePersistent(
      v8::Persistent<T> &handle
  ***REMOVED******REMOVED*** {

//TODO: remove <0.11.8 support when 0.12 is released
# if NODE_VERSION_AT_LEAST(0, 11, 8***REMOVED***
    handle.Reset(***REMOVED***;
# else
    handle.Dispose(nan_isolate***REMOVED***;
# endif
    handle.Clear(***REMOVED***;
***REMOVED***

  template<class T> static NAN_DEPRECATED(void NanDispose(
      v8::Persistent<T> &handle
  ***REMOVED******REMOVED*** {
    NanDisposePersistent(handle***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanNewBufferHandle (
      char *data
    , size_t length
    , node::smalloc::FreeCallback callback
    , void *hint
  ***REMOVED******REMOVED*** {
    return node::Buffer::New(data, length, callback, hint***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanNewBufferHandle (
      char *data
    , uint32_t size
  ***REMOVED******REMOVED*** {
    return node::Buffer::New(data, size***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanNewBufferHandle (uint32_t size***REMOVED******REMOVED*** {
    return node::Buffer::New(size***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanBufferUse(
      char* data
    , uint32_t size
  ***REMOVED******REMOVED*** {
    return node::Buffer::Use(data, size***REMOVED***;
***REMOVED***

  template <class TypeName>
  static NAN_INLINE(v8::Local<TypeName> NanPersistentToLocal(
     const v8::Persistent<TypeName>& persistent
  ***REMOVED******REMOVED*** {
    return v8::Local<TypeName>::New(nan_isolate, persistent***REMOVED***;
***REMOVED***

  static NAN_INLINE(bool NanHasInstance(
      v8::Persistent<v8::FunctionTemplate>& function_template
    , v8::Handle<v8::Value> value
  ***REMOVED******REMOVED*** {
    return NanPersistentToLocal(function_template***REMOVED***->HasInstance(value***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Context> NanNewContextHandle(
      v8::ExtensionConfiguration* extensions = NULL
    , v8::Handle<v8::ObjectTemplate> tmpl = v8::Handle<v8::ObjectTemplate>(***REMOVED***
    , v8::Handle<v8::Value> obj = v8::Handle<v8::Value>(***REMOVED***
  ***REMOVED******REMOVED*** {
    return v8::Local<v8::Context>::New(
        nan_isolate
      , v8::Context::New(nan_isolate, extensions, tmpl, obj***REMOVED***
    ***REMOVED***;
***REMOVED***

#else
// Node 0.8 and 0.10

# define _NAN_METHOD_ARGS_TYPE const v8::Arguments&
# define _NAN_METHOD_ARGS _NAN_METHOD_ARGS_TYPE args
# define _NAN_METHOD_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_GETTER_ARGS_TYPE const v8::AccessorInfo &
# define _NAN_GETTER_ARGS _NAN_GETTER_ARGS_TYPE args
# define _NAN_GETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_SETTER_ARGS_TYPE const v8::AccessorInfo &
# define _NAN_SETTER_ARGS _NAN_SETTER_ARGS_TYPE args
# define _NAN_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_GETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_GETTER_ARGS _NAN_PROPERTY_GETTER_ARGS_TYPE args
# define _NAN_PROPERTY_GETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_PROPERTY_SETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_SETTER_ARGS _NAN_PROPERTY_SETTER_ARGS_TYPE args
# define _NAN_PROPERTY_SETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_ENUMERATOR_ARGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE args
# define _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE v8::Handle<v8::Array>

# define _NAN_PROPERTY_DELETER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_DELETER_ARGS _NAN_PROPERTY_DELETER_ARGS_TYPE args
# define _NAN_PROPERTY_DELETER_RETURN_TYPE v8::Handle<v8::Boolean>

# define _NAN_PROPERTY_QUERY_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_QUERY_ARGS _NAN_PROPERTY_QUERY_ARGS_TYPE args
# define _NAN_PROPERTY_QUERY_RETURN_TYPE v8::Handle<v8::Integer>

# define _NAN_INDEX_GETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_GETTER_ARGS _NAN_INDEX_GETTER_ARGS_TYPE args
# define _NAN_INDEX_GETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_INDEX_SETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_SETTER_ARGS _NAN_INDEX_SETTER_ARGS_TYPE args
# define _NAN_INDEX_SETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_INDEX_ENUMERATOR_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_ENUMERATOR_ARGS _NAN_INDEX_ENUMERATOR_ARGS_TYPE args
# define _NAN_INDEX_ENUMERATOR_RETURN_TYPE v8::Handle<v8::Array>

# define _NAN_INDEX_DELETER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_DELETER_ARGS _NAN_INDEX_DELETER_ARGS_TYPE args
# define _NAN_INDEX_DELETER_RETURN_TYPE v8::Handle<v8::Boolean>

# define _NAN_INDEX_QUERY_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_QUERY_ARGS _NAN_INDEX_QUERY_ARGS_TYPE args
# define _NAN_INDEX_QUERY_RETURN_TYPE v8::Handle<v8::Integer>

# define NanGetInternalFieldPointer(object, index***REMOVED***                             \
    object->GetPointerFromInternalField(index***REMOVED***
# define NanSetInternalFieldPointer(object, index, value***REMOVED***                      \
    object->SetPointerInInternalField(index, value***REMOVED***
# define NAN_WEAK_CALLBACK(type, name***REMOVED***                                         \
    void name(                                                                 \
        v8::Persistent<v8::Value> object                                       \
      , void *data***REMOVED***
# define NAN_WEAK_CALLBACK_OBJECT object
# define NAN_WEAK_CALLBACK_DATA(type***REMOVED*** ((type***REMOVED*** data***REMOVED***

# define NanScope(***REMOVED*** v8::HandleScope scope
# define NanLocker(***REMOVED*** v8::Locker locker
# define NanUnlocker(***REMOVED*** v8::Unlocker unlocker
# define NanReturnValue(value***REMOVED*** return scope.Close(value***REMOVED***
# define NanReturnUndefined(***REMOVED*** return v8::Undefined(***REMOVED***
# define NanReturnNull(***REMOVED*** return v8::Null(***REMOVED***
# define NanReturnEmptyString(***REMOVED*** return v8::String::Empty(***REMOVED***
# define NanInitPersistent(type, name, obj***REMOVED***                                    \
    v8::Persistent<type> name = v8::Persistent<type>::New(obj***REMOVED***
# define NanAssignPersistent(type, handle, obj***REMOVED***                                \
    handle = v8::Persistent<type>::New(obj***REMOVED***
# define NanObjectWrapHandle(obj***REMOVED*** obj->handle_
# define NanMakeWeak(handle, parameters, callback***REMOVED***                             \
    handle.MakeWeak(parameters, callback***REMOVED***

# define _NAN_ERROR(fun, errmsg***REMOVED***                                               \
    fun(v8::String::New(errmsg***REMOVED******REMOVED***

# define _NAN_THROW_ERROR(fun, errmsg***REMOVED***                                         \
    do {                                                                       \
      NanScope(***REMOVED***;                                                              \
      return v8::ThrowException(_NAN_ERROR(fun, errmsg***REMOVED******REMOVED***;                      \
  ***REMOVED*** while (0***REMOVED***;

  template<class T> static NAN_INLINE(v8::Local<T> NanNewLocal(
      v8::Handle<T> val
  ***REMOVED******REMOVED*** {
    return v8::Local<T>::New(val***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanError(const char* errmsg***REMOVED******REMOVED*** {
    return _NAN_ERROR(v8::Exception::Error, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanThrowError(const char* errmsg***REMOVED******REMOVED*** {
    _NAN_THROW_ERROR(v8::Exception::Error, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanThrowError(
      v8::Handle<v8::Value> error
  ***REMOVED******REMOVED*** {
    NanScope(***REMOVED***;
    return v8::ThrowException(error***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanError(
      const char *msg
    , const int errorNumber
  ***REMOVED******REMOVED*** {
    v8::Local<v8::Value> err = v8::Exception::Error(v8::String::New(msg***REMOVED******REMOVED***;
    v8::Local<v8::Object> obj = err.As<v8::Object>(***REMOVED***;
    obj->Set(v8::String::New("code"***REMOVED***, v8::Int32::New(errorNumber***REMOVED******REMOVED***;
    return err;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanThrowError(
      const char *msg
    , const int errorNumber
  ***REMOVED******REMOVED*** {
    return NanThrowError(NanError(msg, errorNumber***REMOVED******REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanTypeError(const char* errmsg***REMOVED******REMOVED*** {
    return _NAN_ERROR(v8::Exception::TypeError, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanThrowTypeError(
      const char* errmsg
  ***REMOVED******REMOVED*** {
    _NAN_THROW_ERROR(v8::Exception::TypeError, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanRangeError(
      const char* errmsg
  ***REMOVED******REMOVED*** {
    return _NAN_ERROR(v8::Exception::RangeError, errmsg***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Handle<v8::Value> NanThrowRangeError(
      const char* errmsg
  ***REMOVED******REMOVED*** {
    _NAN_THROW_ERROR(v8::Exception::RangeError, errmsg***REMOVED***;
***REMOVED***

  template<class T> static NAN_INLINE(void NanDisposePersistent(
      v8::Persistent<T> &handle
  ***REMOVED******REMOVED*** {
    handle.Dispose(***REMOVED***;
    handle.Clear(***REMOVED***;
***REMOVED***

  template<class T> static NAN_DEPRECATED(void NanDispose(
      v8::Persistent<T> &handle
  ***REMOVED******REMOVED*** {
    NanDisposePersistent(handle***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanNewBufferHandle (
      char *data
    , size_t length
    , node::Buffer::free_callback callback
    , void *hint
  ***REMOVED******REMOVED*** {
    return NanNewLocal<v8::Object>(
        node::Buffer::New(data, length, callback, hint***REMOVED***->handle_***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanNewBufferHandle (
      char *data
    , uint32_t size
  ***REMOVED******REMOVED*** {
    return NanNewLocal<v8::Object>(node::Buffer::New(data, size***REMOVED***->handle_***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanNewBufferHandle (uint32_t size***REMOVED******REMOVED*** {
    return NanNewLocal<v8::Object>(node::Buffer::New(size***REMOVED***->handle_***REMOVED***;
***REMOVED***

  static NAN_INLINE(void FreeData(char *data, void *hint***REMOVED******REMOVED*** {
    delete[] data;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Object> NanBufferUse(
      char* data
    , uint32_t size
  ***REMOVED******REMOVED*** {
    return NanNewLocal<v8::Object>(
        node::Buffer::New(data, size, FreeData, NULL***REMOVED***->handle_***REMOVED***;
***REMOVED***

  template <class TypeName>
  static NAN_INLINE(v8::Local<TypeName> NanPersistentToLocal(
     const v8::Persistent<TypeName>& persistent
  ***REMOVED******REMOVED*** {
    return NanNewLocal<TypeName>(persistent***REMOVED***;
***REMOVED***

  static NAN_INLINE(bool NanHasInstance(
      v8::Persistent<v8::FunctionTemplate>& function_template
    , v8::Handle<v8::Value> value
  ***REMOVED******REMOVED*** {
    return function_template->HasInstance(value***REMOVED***;
***REMOVED***

  static NAN_INLINE(v8::Local<v8::Context> NanNewContextHandle(
      v8::ExtensionConfiguration* extensions = NULL
    , v8::Handle<v8::ObjectTemplate> tmpl = v8::Handle<v8::ObjectTemplate>(***REMOVED***
    , v8::Handle<v8::Value> obj = v8::Handle<v8::Value>(***REMOVED***
  ***REMOVED******REMOVED*** {
    v8::Persistent<v8::Context> ctx = v8::Context::New(extensions, tmpl, obj***REMOVED***;
    v8::Local<v8::Context> lctx = NanNewLocal<v8::Context>(ctx***REMOVED***;
    ctx.Dispose(***REMOVED***;
    return lctx;
***REMOVED***

#endif // node version

#define NAN_METHOD(name***REMOVED*** _NAN_METHOD_RETURN_TYPE name(_NAN_METHOD_ARGS***REMOVED***
#define NAN_GETTER(name***REMOVED***                                                       \
    _NAN_GETTER_RETURN_TYPE name(                                              \
        v8::Local<v8::String> property                                         \
      , _NAN_GETTER_ARGS***REMOVED***
#define NAN_SETTER(name***REMOVED***                                                       \
    _NAN_SETTER_RETURN_TYPE name(                                              \
        v8::Local<v8::String> property                                         \
      , v8::Local<v8::Value> value                                             \
      , _NAN_SETTER_ARGS***REMOVED***
#define NAN_PROPERTY_GETTER(name***REMOVED***                                              \
    _NAN_PROPERTY_GETTER_RETURN_TYPE name(                                     \
        v8::Local<v8::String> property                                         \
      , _NAN_PROPERTY_GETTER_ARGS***REMOVED***
#define NAN_PROPERTY_SETTER(name***REMOVED***                                              \
    _NAN_PROPERTY_SETTER_RETURN_TYPE name(                                     \
        v8::Local<v8::String> property                                         \
      , v8::Local<v8::Value> value                                             \
      , _NAN_PROPERTY_SETTER_ARGS***REMOVED***
#define NAN_PROPERTY_ENUMERATOR(name***REMOVED***                                          \
    _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE name(_NAN_PROPERTY_ENUMERATOR_ARGS***REMOVED***
#define NAN_PROPERTY_DELETER(name***REMOVED***                                             \
    _NAN_PROPERTY_DELETER_RETURN_TYPE name(                                    \
        v8::Local<v8::String> property                                         \
      , _NAN_PROPERTY_DELETER_ARGS***REMOVED***
#define NAN_PROPERTY_QUERY(name***REMOVED***                                               \
    _NAN_PROPERTY_QUERY_RETURN_TYPE name(                                      \
        v8::Local<v8::String> property                                         \
      , _NAN_PROPERTY_QUERY_ARGS***REMOVED***
# define NAN_INDEX_GETTER(name***REMOVED***                                                \
    _NAN_INDEX_GETTER_RETURN_TYPE name(uint32_t index, _NAN_INDEX_GETTER_ARGS***REMOVED***
#define NAN_INDEX_SETTER(name***REMOVED***                                                 \
    _NAN_INDEX_SETTER_RETURN_TYPE name(                                        \
        uint32_t index                                                         \
      , v8::Local<v8::Value> value                                             \
      , _NAN_INDEX_SETTER_ARGS***REMOVED***
#define NAN_INDEX_ENUMERATOR(name***REMOVED***                                             \
    _NAN_INDEX_ENUMERATOR_RETURN_TYPE name(_NAN_INDEX_ENUMERATOR_ARGS***REMOVED***
#define NAN_INDEX_DELETER(name***REMOVED***                                                \
    _NAN_INDEX_DELETER_RETURN_TYPE name(                                       \
        uint32_t index                                                         \
      , _NAN_INDEX_DELETER_ARGS***REMOVED***
#define NAN_INDEX_QUERY(name***REMOVED***                                                  \
    _NAN_INDEX_QUERY_RETURN_TYPE name(uint32_t index, _NAN_INDEX_QUERY_ARGS***REMOVED***

class NanCallback {
 public:
  NanCallback(***REMOVED*** {
    NanScope(***REMOVED***;
    v8::Local<v8::Object> obj = v8::Object::New(***REMOVED***;
    NanAssignPersistent(v8::Object, handle, obj***REMOVED***;
***REMOVED***

  NanCallback(const v8::Handle<v8::Function> &fn***REMOVED*** {
    NanScope(***REMOVED***;
    v8::Local<v8::Object> obj = v8::Object::New(***REMOVED***;
    NanAssignPersistent(v8::Object, handle, obj***REMOVED***;
    SetFunction(fn***REMOVED***;
***REMOVED***

  ~NanCallback(***REMOVED*** {
    if (handle.IsEmpty(***REMOVED******REMOVED*** return;
    handle.Dispose(***REMOVED***;
    handle.Clear(***REMOVED***;
***REMOVED***

  NAN_INLINE(void SetFunction(const v8::Handle<v8::Function> &fn***REMOVED******REMOVED*** {
    NanScope(***REMOVED***;
    NanPersistentToLocal(handle***REMOVED***->Set(NanSymbol("callback"***REMOVED***, fn***REMOVED***;
***REMOVED***

  NAN_INLINE(v8::Local<v8::Function> GetFunction (***REMOVED******REMOVED*** {
    return NanPersistentToLocal(handle***REMOVED***->Get(NanSymbol("callback"***REMOVED******REMOVED***
        .As<v8::Function>(***REMOVED***;
***REMOVED***

  void Call(int argc, v8::Handle<v8::Value> argv[]***REMOVED*** {
    NanScope(***REMOVED***;

#if NODE_VERSION_AT_LEAST(0, 8, 0***REMOVED***
    v8::Local<v8::Function> callback = NanPersistentToLocal(handle***REMOVED***->
        Get(NanSymbol("callback"***REMOVED******REMOVED***.As<v8::Function>(***REMOVED***;
    node::MakeCallback(
        v8::Context::GetCurrent(***REMOVED***->Global(***REMOVED***
      , callback
      , argc
      , argv
    ***REMOVED***;
#else
    node::MakeCallback(handle, "callback", argc, argv***REMOVED***;
#endif
***REMOVED***

 private:
  v8::Persistent<v8::Object> handle;
};

/* abstract */ class NanAsyncWorker {
public:
  NanAsyncWorker (NanCallback *callback***REMOVED*** : callback(callback***REMOVED*** {
    request.data = this;
    errmsg = NULL;
***REMOVED***

  virtual ~NanAsyncWorker (***REMOVED*** {
    NanScope(***REMOVED***;

    if (!persistentHandle.IsEmpty(***REMOVED******REMOVED***
      NanDisposePersistent(persistentHandle***REMOVED***;
    if (callback***REMOVED***
      delete callback;
    if (errmsg***REMOVED***
      delete errmsg;
***REMOVED***

  virtual void WorkComplete (***REMOVED*** {
    NanScope(***REMOVED***;

    if (errmsg == NULL***REMOVED***
      HandleOKCallback(***REMOVED***;
    else
      HandleErrorCallback(***REMOVED***;
    delete callback;
    callback = NULL;
***REMOVED***

  void SavePersistent(const char *key, v8::Local<v8::Object> &obj***REMOVED*** {
    NanScope(***REMOVED***;

    v8::Local<v8::Object> handle = NanPersistentToLocal(persistentHandle***REMOVED***;
    handle->Set(NanSymbol(key***REMOVED***, obj***REMOVED***;
***REMOVED***

  v8::Local<v8::Object> GetFromPersistent(const char *key***REMOVED*** {
    NanScope(***REMOVED***;

    v8::Local<v8::Object> handle = NanPersistentToLocal(persistentHandle***REMOVED***;
    return handle->Get(NanSymbol(key***REMOVED******REMOVED***.As<v8::Object>(***REMOVED***;
***REMOVED***

  virtual void Execute (***REMOVED*** =0;

  uv_work_t request;

protected:
  v8::Persistent<v8::Object> persistentHandle;
  NanCallback *callback;
  const char *errmsg;

  virtual void HandleOKCallback (***REMOVED*** {
    NanScope(***REMOVED***;

    callback->Call(0, NULL***REMOVED***;
***REMOVED***;

  virtual void HandleErrorCallback (***REMOVED*** {
    NanScope(***REMOVED***;

    v8::Local<v8::Value> argv[] = {
        v8::Exception::Error(v8::String::New(errmsg***REMOVED******REMOVED***
  ***REMOVED***;
    callback->Call(1, argv***REMOVED***;
***REMOVED***
};

NAN_INLINE(void NanAsyncExecute (uv_work_t* req***REMOVED******REMOVED*** {
  NanAsyncWorker *worker = static_cast<NanAsyncWorker*>(req->data***REMOVED***;
  worker->Execute(***REMOVED***;
}

NAN_INLINE(void NanAsyncExecuteComplete (uv_work_t* req***REMOVED******REMOVED*** {
  NanAsyncWorker* worker = static_cast<NanAsyncWorker*>(req->data***REMOVED***;
  worker->WorkComplete(***REMOVED***;
  delete worker;
}

NAN_INLINE(void NanAsyncQueueWorker (NanAsyncWorker* worker***REMOVED******REMOVED*** {
  uv_queue_work(
      uv_default_loop(***REMOVED***
    , &worker->request
    , NanAsyncExecute
    , (uv_after_work_cb***REMOVED***NanAsyncExecuteComplete
  ***REMOVED***;
}

//// Base 64 ////

#define _nan_base64_encoded_size(size***REMOVED*** ((size + 2 - ((size + 2***REMOVED*** % 3***REMOVED******REMOVED*** / 3 * 4***REMOVED***

// Doesn't check for padding at the end.  Can be 1-2 bytes over.
static NAN_INLINE(size_t _nan_base64_decoded_size_fast(size_t size***REMOVED******REMOVED*** {
  size_t remainder = size % 4;

  size = (size / 4***REMOVED*** * 3;
  if (remainder***REMOVED*** {
    if (size == 0 && remainder == 1***REMOVED*** {
      // special case: 1-byte input cannot be decoded
      size = 0;
  ***REMOVED*** else {
      // non-padded input, add 1 or 2 extra bytes
      size += 1 + (remainder == 3***REMOVED***;
  ***REMOVED***
***REMOVED***

  return size;
}

template <typename TypeName>
static NAN_INLINE(size_t _nan_base64_decoded_size(
    const TypeName* src
  , size_t size
***REMOVED******REMOVED*** {
  if (size == 0***REMOVED***
    return 0;

  if (src[size - 1] == '='***REMOVED***
    size--;
  if (size > 0 && src[size - 1] == '='***REMOVED***
    size--;

  return _nan_base64_decoded_size_fast(size***REMOVED***;
}

// supports regular and URL-safe base64
static const int _nan_unbase64_table[] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -2, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, 62, -1, 63
  , 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1
  , -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14
  , 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63
  , -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40
  , 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
  , -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};

#define _nan_unbase64(x***REMOVED*** _nan_unbase64_table[(uint8_t***REMOVED***(x***REMOVED***]

template <typename TypeName> static size_t _nan_base64_decode(
    char* buf
  , size_t len
  , const TypeName* src
  , const size_t srcLen
***REMOVED*** {
  char* dst = buf;
  char* dstEnd = buf + len;
  const TypeName* srcEnd = src + srcLen;

  while (src < srcEnd && dst < dstEnd***REMOVED*** {
    int remaining = srcEnd - src;
    char a, b, c, d;

    while (_nan_unbase64(*src***REMOVED*** < 0 && src < srcEnd***REMOVED*** src++, remaining--;
    if (remaining == 0 || *src == '='***REMOVED*** break;
    a = _nan_unbase64(*src++***REMOVED***;

    while (_nan_unbase64(*src***REMOVED*** < 0 && src < srcEnd***REMOVED*** src++, remaining--;
    if (remaining <= 1 || *src == '='***REMOVED*** break;
    b = _nan_unbase64(*src++***REMOVED***;

    *dst++ = (a << 2***REMOVED*** | ((b & 0x30***REMOVED*** >> 4***REMOVED***;
    if (dst == dstEnd***REMOVED*** break;

    while (_nan_unbase64(*src***REMOVED*** < 0 && src < srcEnd***REMOVED*** src++, remaining--;
    if (remaining <= 2 || *src == '='***REMOVED*** break;
    c = _nan_unbase64(*src++***REMOVED***;

    *dst++ = ((b & 0x0F***REMOVED*** << 4***REMOVED*** | ((c & 0x3C***REMOVED*** >> 2***REMOVED***;
    if (dst == dstEnd***REMOVED*** break;

    while (_nan_unbase64(*src***REMOVED*** < 0 && src < srcEnd***REMOVED*** src++, remaining--;
    if (remaining <= 3 || *src == '='***REMOVED*** break;
    d = _nan_unbase64(*src++***REMOVED***;

    *dst++ = ((c & 0x03***REMOVED*** << 6***REMOVED*** | (d & 0x3F***REMOVED***;
***REMOVED***

  return dst - buf;
}

//// HEX ////

template <typename TypeName> unsigned _nan_hex2bin(TypeName c***REMOVED*** {
  if (c >= '0' && c <= '9'***REMOVED*** return c - '0';
  if (c >= 'A' && c <= 'F'***REMOVED*** return 10 + (c - 'A'***REMOVED***;
  if (c >= 'a' && c <= 'f'***REMOVED*** return 10 + (c - 'a'***REMOVED***;
  return static_cast<unsigned>(-1***REMOVED***;
}

template <typename TypeName> static size_t _nan_hex_decode(
    char* buf
  , size_t len
  , const TypeName* src
  , const size_t srcLen
***REMOVED*** {
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i***REMOVED*** {
    unsigned a = _nan_hex2bin(src[i * 2 + 0]***REMOVED***;
    unsigned b = _nan_hex2bin(src[i * 2 + 1]***REMOVED***;
    if (!~a || !~b***REMOVED*** return i;
    buf[i] = a * 16 + b;
***REMOVED***

  return i;
}

static bool _NanGetExternalParts(
    v8::Handle<v8::Value> val
  , const char** data
  , size_t* len
***REMOVED*** {
  if (node::Buffer::HasInstance(val***REMOVED******REMOVED*** {
    *data = node::Buffer::Data(val.As<v8::Object>(***REMOVED******REMOVED***;
    *len = node::Buffer::Length(val.As<v8::Object>(***REMOVED******REMOVED***;
    return true;
***REMOVED***

  assert(val->IsString(***REMOVED******REMOVED***;
  v8::Local<v8::String> str = NanNewLocal(val.As<v8::String>(***REMOVED******REMOVED***;

  if (str->IsExternalAscii(***REMOVED******REMOVED*** {
    const v8::String::ExternalAsciiStringResource* ext;
    ext = str->GetExternalAsciiStringResource(***REMOVED***;
    *data = ext->data(***REMOVED***;
    *len = ext->length(***REMOVED***;
    return true;

***REMOVED*** else if (str->IsExternal(***REMOVED******REMOVED*** {
    const v8::String::ExternalStringResource* ext;
    ext = str->GetExternalStringResource(***REMOVED***;
    *data = reinterpret_cast<const char*>(ext->data(***REMOVED******REMOVED***;
    *len = ext->length(***REMOVED***;
    return true;
***REMOVED***

  return false;
}

namespace Nan {
  enum Encoding {ASCII, UTF8, BASE64, UCS2, BINARY, HEX, BUFFER};
}

static NAN_INLINE(void* NanRawString(
    v8::Handle<v8::Value> from
  , enum Nan::Encoding encoding
  , size_t *datalen
  , void *buf
  , size_t buflen
  , int flags
***REMOVED******REMOVED*** {
  NanScope(***REMOVED***;

  size_t sz_;
  size_t term_len = !(flags & v8::String::NO_NULL_TERMINATION***REMOVED***;
  char *data = NULL;
  size_t len;
  bool is_extern = _NanGetExternalParts(
      from
    , const_cast<const char**>(&data***REMOVED***
    , &len***REMOVED***;

  if (is_extern && !term_len***REMOVED*** {
    NanSetPointerSafe(datalen, len***REMOVED***;
    return data;
***REMOVED***

  v8::Local<v8::String> toStr = from->ToString(***REMOVED***;

  char *to = (char****REMOVED***buf;

  switch(encoding***REMOVED*** {
    case Nan::ASCII:
#if NODE_MODULE_VERSION < 0x0C
      sz_ = toStr->Length(***REMOVED***;
      if (to == NULL***REMOVED*** {
        to = new char[sz_ + term_len];
    ***REMOVED*** else {
        assert(buflen >= sz_ + term_len && "too small buffer"***REMOVED***;
    ***REMOVED***
      NanSetPointerSafe<size_t>(
          datalen
        , toStr->WriteAscii(to, 0, sz_ + term_len, flags***REMOVED******REMOVED***;
      return to;
#endif
    case Nan::BINARY:
    case Nan::BUFFER:
      sz_ = toStr->Length(***REMOVED***;
      if (to == NULL***REMOVED*** {
        to = new char[sz_ + term_len];
    ***REMOVED*** else {
        assert(buflen >= sz_ + term_len && "too small buffer"***REMOVED***;
    ***REMOVED***
#if NODE_MODULE_VERSION < 0x0C
      // TODO(isaacs***REMOVED***: THIS IS AWFUL!!!
      // AGREE(kkoopa***REMOVED***
      {
        uint16_t* twobytebuf = new uint16_t[sz_ + term_len];

        size_t len = toStr->Write(twobytebuf, 0, sz_ + term_len, flags***REMOVED***;

        for (size_t i = 0; i < sz_ + term_len && i < len + term_len; i++***REMOVED*** {
          unsigned char *b = reinterpret_cast<unsigned char*>(&twobytebuf[i]***REMOVED***;
          to[i] = *b;
      ***REMOVED***

        NanSetPointerSafe<size_t>(datalen, len***REMOVED***;

        delete[] twobytebuf;
        return to;
    ***REMOVED***
#else
      NanSetPointerSafe<size_t>(
        datalen,
        toStr->WriteOneByte(
            reinterpret_cast<uint8_t *>(to***REMOVED***
          , 0
          , sz_ + term_len
          , flags***REMOVED******REMOVED***;
      return to;
#endif
    case Nan::UTF8:
      sz_ = toStr->Utf8Length(***REMOVED***;
      if (to == NULL***REMOVED*** {
        to = new char[sz_ + term_len];
    ***REMOVED*** else {
        assert(buflen >= sz_ + term_len && "too small buffer"***REMOVED***;
    ***REMOVED***
      NanSetPointerSafe<size_t>(
          datalen
        , toStr->WriteUtf8(to, sz_ + term_len, NULL, flags***REMOVED*** - term_len***REMOVED***;
      return to;
    case Nan::BASE64:
      {
        v8::String::Value value(toStr***REMOVED***;
        sz_ = _nan_base64_decoded_size(*value, value.length(***REMOVED******REMOVED***;
        if (to == NULL***REMOVED*** {
          to = new char[sz_ + term_len];
      ***REMOVED*** else {
          assert(buflen >= sz_ + term_len***REMOVED***;
      ***REMOVED***
        NanSetPointerSafe<size_t>(
            datalen
          , _nan_base64_decode(to, sz_, *value, value.length(***REMOVED******REMOVED******REMOVED***;
        if (term_len***REMOVED*** {
          to[sz_] = '\0';
      ***REMOVED***
        return to;
    ***REMOVED***
    case Nan::UCS2:
      {
        sz_ = toStr->Length(***REMOVED***;
        if (to == NULL***REMOVED*** {
          to = new char[(sz_ + term_len***REMOVED*** * 2];
      ***REMOVED*** else {
          assert(buflen >= (sz_ + term_len***REMOVED*** * 2 && "too small buffer"***REMOVED***;
      ***REMOVED***

        int bc = 2 * toStr->Write(
            reinterpret_cast<uint16_t *>(to***REMOVED***
          , 0
          , sz_ + term_len
          , flags***REMOVED***;
        NanSetPointerSafe<size_t>(datalen, bc***REMOVED***;
        return to;
    ***REMOVED***
    case Nan::HEX:
      {
        v8::String::Value value(toStr***REMOVED***;
        sz_ = value.length(***REMOVED***;
        assert(!(sz_ & 1***REMOVED*** && "bad hex data"***REMOVED***;
        if (to == NULL***REMOVED*** {
          to = new char[sz_ / 2 + term_len];
      ***REMOVED*** else {
          assert(buflen >= sz_ / 2 + term_len && "too small buffer"***REMOVED***;
      ***REMOVED***
        NanSetPointerSafe<size_t>(
            datalen
          , _nan_hex_decode(to, sz_ / 2, *value, value.length(***REMOVED******REMOVED******REMOVED***;
    ***REMOVED***
      if (term_len***REMOVED*** {
        to[sz_ / 2] = '\0';
    ***REMOVED***
      return to;
    default:
      assert(0 && "unknown encoding"***REMOVED***;
***REMOVED***
  return to;
}

static NAN_INLINE(char* NanFromV8String(
    v8::Handle<v8::Value> from
  , enum Nan::Encoding encoding = Nan::UTF8
  , size_t *datalen = NULL
  , char *buf = NULL
  , size_t buflen = 0
  , int flags =
        v8::String::NO_NULL_TERMINATION | v8::String::HINT_MANY_WRITES_EXPECTED
***REMOVED******REMOVED*** {
    return (char ****REMOVED*** NanRawString(from, encoding, datalen, buf, buflen, flags***REMOVED***;
}

static NAN_INLINE(char* NanCString(
    v8::Handle<v8::Value> from
  , size_t *datalen
  , char *buf = NULL
  , size_t buflen = 0
  , int flags = v8::String::NO_OPTIONS
***REMOVED******REMOVED*** {
    return (char ****REMOVED*** NanRawString(from, Nan::UTF8, datalen, buf, buflen, flags***REMOVED***;
}

#endif
