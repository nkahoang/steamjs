/*
 Copyright (c***REMOVED*** 2013, Rodrigo Gonz√°lez, Sapienlab All Rights Reserved.
 Available via MIT LICENSE. See https://github.com/roro89/jsonpack/blob/master/LICENSE.md for details.
 */
(function(define***REMOVED*** {

	define([], function(***REMOVED*** {

		var TOKEN_TRUE = -1;
		var TOKEN_FALSE = -2;
		var TOKEN_NULL = -3;
		var TOKEN_EMPTY_STRING = -4;

		var pack = function(json, options***REMOVED*** {

			// Canonizes the options
			options = options || {};

			// A shorthand for debugging
			var verbose = options.verbose || false;

			verbose && console.log('Normalize the JSON Object'***REMOVED***;

			// JSON as Javascript Object (Not string representation***REMOVED***
			json = typeof json === 'string' ? this.JSON.parse(json***REMOVED*** : json;

			verbose && console.log('Creating a empty dictionary'***REMOVED***;

			// The dictionary
			var dictionary = {
				strings : [],
				integers : [],
				floats : []
			};

			verbose && console.log('Creating the AST'***REMOVED***;

			// The AST
			var ast = (function recursiveAstBuilder(item***REMOVED*** {

				verbose && console.log('Calling recursiveAstBuilder with ' + this.JSON.stringify(item***REMOVED******REMOVED***;

				// The type of the item
				var type = typeof item;

				// Case 7: The item is null
				if (item === null***REMOVED*** {
					return {
						type : 'null',
						index : TOKEN_NULL
					};
				}

				// Case 1: The item is Array Object
				if ( item instanceof Array***REMOVED*** {

					// Create a new sub-AST of type Array (@***REMOVED***
					var ast = ['@'];

					// Add each items
					for (var i in item***REMOVED*** {
						ast.push(recursiveAstBuilder(item[i]***REMOVED******REMOVED***;
					}

					// And return
					return ast;

				}

				// Case 2: The item is Object
				if (type === 'object'***REMOVED*** {

					// Create a new sub-AST of type Object ($***REMOVED***
					var ast = ['$'];

					// Add each items
					for (var key in item***REMOVED*** {
						if (!item.hasOwnProperty(key***REMOVED******REMOVED***
							continue;
						ast.push(recursiveAstBuilder(key***REMOVED******REMOVED***;
						ast.push(recursiveAstBuilder(item[key]***REMOVED******REMOVED***;
					}

					// And return
					return ast;

				}

				// Case 3: The item empty string
				if (item === ''***REMOVED*** {
					return {
						type : 'empty',
						index : TOKEN_EMPTY_STRING
					};
				}

				// Case 4: The item is String
				if (type === 'string'***REMOVED*** {

					// The index of that word in the dictionary
					var index = _indexOf.call(dictionary.strings, item***REMOVED***;

					// If not, add to the dictionary and actualize the index
					if (index == -1***REMOVED*** {
						dictionary.strings.push(_encode(item***REMOVED******REMOVED***;
						index = dictionary.strings.length - 1;
					}

					// Return the token
					return {
						type : 'strings',
						index : index
					};
				}

				// Case 5: The item is integer
				if (type === 'number' && item % 1 === 0***REMOVED*** {

					// The index of that number in the dictionary
					var index = _indexOf.call(dictionary.integers, item***REMOVED***;

					// If not, add to the dictionary and actualize the index
					if (index == -1***REMOVED*** {
						dictionary.integers.push(_base10To36(item***REMOVED******REMOVED***;
						index = dictionary.integers.length - 1;
					}

					// Return the token
					return {
						type : 'integers',
						index : index
					};
				}

				// Case 6: The item is float
				if (type === 'number'***REMOVED*** {
					// The index of that number in the dictionary
					var index = _indexOf.call(dictionary.floats, item***REMOVED***;

					// If not, add to the dictionary and actualize the index
					if (index == -1***REMOVED*** {
						// Float not use base 36
						dictionary.floats.push(item***REMOVED***;
						index = dictionary.floats.length - 1;
					}

					// Return the token
					return {
						type : 'floats',
						index : index
					};
				}

				// Case 7: The item is boolean
				if (type === 'boolean'***REMOVED*** {
					return {
						type : 'boolean',
						index : item ? TOKEN_TRUE : TOKEN_FALSE
					};
				}

				// Default
				throw new Error('Unexpected argument of type ' + typeof (item***REMOVED******REMOVED***;

			}***REMOVED***(json***REMOVED***;

			// A set of shorthands proxies for the length of the dictionaries
			var stringLength = dictionary.strings.length;
			var integerLength = dictionary.integers.length;
			var floatLength = dictionary.floats.length;

			verbose && console.log('Parsing the dictionary'***REMOVED***;

			// Create a raw dictionary
			var packed = dictionary.strings.join('|'***REMOVED***;
			packed += '^' + dictionary.integers.join('|'***REMOVED***;
			packed += '^' + dictionary.floats.join('|'***REMOVED***;

			verbose && console.log('Parsing the structure'***REMOVED***;

			// And add the structure
			packed += '^' + (function recursiveParser(item***REMOVED*** {

				verbose && console.log('Calling a recursiveParser with ' + this.JSON.stringify(item***REMOVED******REMOVED***;

				// If the item is Array, then is a object of
				// type [object Object] or [object Array]
				if ( item instanceof Array***REMOVED*** {

					// The packed resulting
					var packed = item.shift(***REMOVED***;

					for (var i in item***REMOVED*** {
						packed += recursiveParser(item[i]***REMOVED*** + '|';
					}

					return (packed[packed.length - 1] === '|' ? packed.slice(0, -1***REMOVED*** : packed***REMOVED*** + ']';

				}

				// A shorthand proxies
				var type = item.type, index = item.index;

				if (type === 'strings'***REMOVED*** {
					// Just return the base 36 of index
					return _base10To36(index***REMOVED***;
				}

				if (type === 'integers'***REMOVED*** {
					// Return a base 36 of index plus stringLength offset
					return _base10To36(stringLength + index***REMOVED***;
				}

				if (type === 'floats'***REMOVED*** {
					// Return a base 36 of index plus stringLength and integerLength offset
					return _base10To36(stringLength + integerLength + index***REMOVED***;
				}

				if (type === 'boolean'***REMOVED*** {
					return item.index;
				}

				if (type === 'null'***REMOVED*** {
					return TOKEN_NULL;
				}

				if (type === 'empty'***REMOVED*** {
					return TOKEN_EMPTY_STRING;
				}

				throw new TypeError('The item is alien!'***REMOVED***;

			}***REMOVED***(ast***REMOVED***;

			verbose && console.log('Ending parser'***REMOVED***;

			// If debug, return a internal representation of dictionary and stuff
			if (options.debug***REMOVED***
				return {
					dictionary : dictionary,
					ast : ast,
					packed : packed
				};

			return packed;

		};

		var unpack = function(packed, options***REMOVED*** {

			// Canonizes the options
			options = options || {};

			// A raw buffer
			var rawBuffers = packed.split('^'***REMOVED***;

			// Create a dictionary
			options.verbose && console.log('Building dictionary'***REMOVED***;
			var dictionary = [];

			// Add the strings values
			var buffer = rawBuffers[0];
			if (buffer !== ''***REMOVED*** {
				buffer = buffer.split('|'***REMOVED***;
				options.verbose && console.log('Parse the strings dictionary'***REMOVED***;
				for (var i in buffer***REMOVED*** {
					dictionary.push(_decode(buffer[i]***REMOVED******REMOVED***;
				}
			}

			// Add the integers values
			buffer = rawBuffers[1];
			if (buffer !== ''***REMOVED*** {
				buffer = buffer.split('|'***REMOVED***;
				options.verbose && console.log('Parse the integers dictionary'***REMOVED***;
				for (var i in buffer***REMOVED*** {
					dictionary.push(_base36To10(buffer[i]***REMOVED******REMOVED***;
				}
			}

			// Add the floats values
			buffer = rawBuffers[2];
			if (buffer !== ''***REMOVED*** {
				buffer = buffer.split('|'***REMOVED***
				options.verbose && console.log('Parse the floats dictionary'***REMOVED***;
				for (var i in buffer***REMOVED*** {
					dictionary.push(parseFloat(buffer[i]***REMOVED******REMOVED***;
				}
			}
			// Free memory
			delete buffer;

			options.verbose && console.log('Tokenizing the structure'***REMOVED***;

			// Tokenizer the structure
			var number36 = '';
			var tokens = [];
			for (var i in rawBuffers[3]***REMOVED*** {
				var symbol = rawBuffers[3][i];
				if (symbol === '|' || symbol === '$' || symbol === '@' || symbol === ']'***REMOVED*** {
					if (number36***REMOVED*** {
						tokens.push(_base36To10(number36***REMOVED******REMOVED***;
						number36 = '';
					}
					symbol !== '|' && tokens.push(symbol***REMOVED***;
				} else {
					number36 += symbol;
				}
			}

			// A shorthand proxy for tokens.length
			var tokensLength = tokens.length;

			// The index of the next token to read
			var tokensIndex = 0;

			options.verbose && console.log('Starting recursive parser'***REMOVED***;

			return (function recursiveUnpackerParser(***REMOVED*** {

				// Maybe '$' (object***REMOVED*** or '@' (array***REMOVED***
				var type = tokens[tokensIndex++];

				options.verbose && console.log('Reading collection type ' + (type === '$' ? 'object' : 'Array'***REMOVED******REMOVED***;

				// Parse an array
				if (type === '@'***REMOVED*** {

					var node = [];

					for (; tokensIndex < tokensLength; tokensIndex++***REMOVED*** {
						var value = tokens[tokensIndex];
						options.verbose && console.log('Read ' + value + ' symbol'***REMOVED***;
						if (value === ']'***REMOVED***
							return node;
						if (value === '@' || value === '$'***REMOVED*** {
							node.push(recursiveUnpackerParser(***REMOVED******REMOVED***;
						} else {
							switch(value***REMOVED*** {
								case TOKEN_TRUE:
									node.push(true***REMOVED***;
									break;
								case TOKEN_FALSE:
									node.push(false***REMOVED***;
									break;
								case TOKEN_NULL:
									node.push(null***REMOVED***;
									break;
								case TOKEN_EMPTY_STRING:
									node.push(''***REMOVED***;
									break;
								default:
									node.push(dictionary[value]***REMOVED***;
							}

						}
					}

					options.verbose && console.log('Parsed ' + this.JSON.stringify(node***REMOVED******REMOVED***;

					return node;

				}

				// Parse a object
				if (type === '$'***REMOVED*** {
					var node = {};

					for (; tokensIndex < tokensLength; tokensIndex++***REMOVED*** {

						var key = tokens[tokensIndex];

						if (key === ']'***REMOVED***
							return node;

						if (key === TOKEN_EMPTY_STRING***REMOVED***
							key = '';
						else
							key = dictionary[key];

						var value = tokens[++tokensIndex];

						if (value === '@' || value === '$'***REMOVED*** {
							node[key] = recursiveUnpackerParser(***REMOVED***;
						} else {
							switch(value***REMOVED*** {
								case TOKEN_TRUE:
									node[key] = true;
									break;
								case TOKEN_FALSE:
									node[key] = false;
									break;
								case TOKEN_NULL:
									node[key] = null;
									break;
								case TOKEN_EMPTY_STRING:
									node[key] = '';
									break;
								default:
									node[key] = dictionary[value];
							}

						}
					}

					options.verbose && console.log('Parsed ' + this.JSON.stringify(node***REMOVED******REMOVED***;

					return node;
				}

				throw new TypeError('Bad token ' + type + ' isn\'t a type'***REMOVED***;

			}***REMOVED***(***REMOVED***;

		}
		/**
		 * Get the index value of the dictionary
		 * @param {Object} dictionary a object that have two array attributes: 'string' and 'number'
		 * @param {Object} data
		 */
		var _indexOfDictionary = function(dictionary, value***REMOVED*** {

			// The type of the value
			var type = typeof value;

			// If is boolean, return a boolean token
			if (type === 'boolean'***REMOVED***
				return value ? TOKEN_TRUE : TOKEN_FALSE;

			// If is null, return a... yes! the null token
			if (value === null***REMOVED***
				return TOKEN_NULL;

			if (value === ''***REMOVED*** {
				return TOKEN_EMPTY_STRING;
			}

			if (type === 'string'***REMOVED*** {
				value = _encode(value***REMOVED***;
				var index = _indexOf.call(dictionary.strings, value***REMOVED***;
				if (index === -1***REMOVED*** {
					dictionary.strings.push(value***REMOVED***;
					index = dictionary.strings.length - 1;
				}
			}

			// If has an invalid JSON type (example a function***REMOVED***
			if (type !== 'string' && type !== 'number'***REMOVED*** {
				throw new Error('The type is not a JSON type'***REMOVED***;
			};

			if (type === 'string'***REMOVED*** {// string
				value = _encode(value***REMOVED***;
			} else if (value % 1 === 0***REMOVED*** {// integer
				value = _base10To36(value***REMOVED***;
			} else {// float

			}

			// If is number, "serialize" the value
			value = type === 'number' ? _base10To36(value***REMOVED*** : _encode(value***REMOVED***;

			// Retrieve the index of that value in the dictionary
			var index = _indexOf.call(dictionary[type], value***REMOVED***;

			// If that value is not in the dictionary
			if (index === -1***REMOVED*** {
				// Push the value
				dictionary[type].push(value***REMOVED***;
				// And return their index
				index = dictionary[type].length - 1;
			}

			// If the type is a number, then add the '+'  prefix character
			// to differentiate that they is a number index. If not, then
			// just return a 36-based representation of the index
			return type === 'number' ? '+' + index : index;

		};

		var _encode = function(str***REMOVED*** {
			if ( typeof str !== 'string'***REMOVED***
				return str;

			return str.replace(/[\+ \|\^\%]/g, function(a***REMOVED*** {
				return ({
				' ' : '+',
				'+' : '%2B',
				'|' : '%7C',
				'^' : '%5E',
				'%' : '%25'
				}***REMOVED***[a]
			}***REMOVED***;
		};

		var _decode = function(str***REMOVED*** {
			if ( typeof str !== 'string'***REMOVED***
				return str;

			return str.replace(/\+|%2B|%7C|%5E|%25/g, function(a***REMOVED*** {
				return ({
				'+' : ' ',
				'%2B' : '+',
				'%7C' : '|',
				'%5E' : '^',
				'%25' : '%'
				}***REMOVED***[a]
			}***REMOVED***
		};

		var _base10To36 = function(number***REMOVED*** {
			return Number.prototype.toString.call(number, 36***REMOVED***.toUpperCase(***REMOVED***;
		};

		var _base36To10 = function(number***REMOVED*** {
			return parseInt(number, 36***REMOVED***;
		};

		var _indexOf = Array.prototype.indexOf ||
		function(obj, start***REMOVED*** {
			for (var i = (start || 0***REMOVED***, j = this.length; i < j; i++***REMOVED*** {
				if (this[i] === obj***REMOVED*** {
					return i;
				}
			}
			return -1;
		};

		return {
			JSON : JSON,
			pack : pack,
			unpack : unpack
		};

	}***REMOVED***;

}***REMOVED***( typeof define == 'undefined' || !define.amd ? function(deps, factory***REMOVED*** {
	var jsonpack = factory(***REMOVED***;
	if ( typeof exports != 'undefined'***REMOVED***
		for (var key in jsonpack***REMOVED***
		exports[key] = jsonpack[key];
	else
		window.jsonpack = jsonpack;
} : define***REMOVED***;
