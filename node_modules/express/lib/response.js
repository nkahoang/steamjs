/**
 * Module dependencies.
 */

var ***REMOVED***
  , ***REMOVED***
  , connect = require('connect'***REMOVED***
  , utils = connect.utils
  , sign = require('cookie-signature'***REMOVED***.sign
  , normalizeType = require('./utils'***REMOVED***.normalizeType
  , normalizeTypes = require('./utils'***REMOVED***.normalizeTypes
  , etag = require('./utils'***REMOVED***.etag
  , statusCodes = http.STATUS_CODES
  , cookie = require('cookie'***REMOVED***
  , send = require('send'***REMOVED***
  , mime = connect.mime
  , resolve = require('url'***REMOVED***.resolve
  , basename = path.basename
  , extname = path.extname;

/**
 * Response prototype.
 */

var res = module.exports = {
  __proto__: http.ServerResponse.prototype
};

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @api public
 */

res.status = function(code***REMOVED***{
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *  ***REMOVED******REMOVED***;
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @api public
 */

res.links = function(links***REMOVED***{
  var link = this.get('Link'***REMOVED*** || '';
  if (link***REMOVED*** link += ', ';
  return this.set('Link', link + Object.keys(links***REMOVED***.map(function(rel***REMOVED***{
    return '<' + links[rel] + '>; rel="' + rel + '"';
***REMOVED******REMOVED***.join(', '***REMOVED******REMOVED***;
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(new Buffer('wahoo'***REMOVED******REMOVED***;
 *     res.send({ some: 'json' }***REMOVED***;
 *     res.send('<p>some html</p>'***REMOVED***;
 *     res.send(404, 'Sorry, cant find that'***REMOVED***;
 *     res.send(404***REMOVED***;
 *
 * @param {Mixed} body or status
 * @param {Mixed} body
 * @return {ServerResponse}
 * @api public
 */

res.send = function(body***REMOVED***{
  var req = this.req;
  var head = 'HEAD' == req.method;
  var len;

  // settings
  var app = this.app;

  // allow status / body
  if (2 == arguments.length***REMOVED*** {
    // res.send(body, status***REMOVED*** backwards compat
    if ('number' != typeof body && 'number' == typeof arguments[1]***REMOVED*** {
      this.statusCode = arguments[1];
  ***REMOVED*** else {
      this.statusCode = body;
      body = arguments[1];
  ***REMOVED***
***REMOVED***

  switch (typeof body***REMOVED*** {
    // response status
    case 'number':
      this.get('Content-Type'***REMOVED*** || this.type('txt'***REMOVED***;
      this.statusCode = body;
      body = http.STATUS_CODES[body];
      break;
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type'***REMOVED******REMOVED*** {
        this.charset = this.charset || 'utf-8';
        this.type('html'***REMOVED***;
    ***REMOVED***
      break;
    case 'boolean':
    case 'object':
      if (null == body***REMOVED*** {
        body = '';
    ***REMOVED*** else if (Buffer.isBuffer(body***REMOVED******REMOVED*** {
        this.get('Content-Type'***REMOVED*** || this.type('bin'***REMOVED***;
    ***REMOVED*** else {
        return this.json(body***REMOVED***;
    ***REMOVED***
      break;
***REMOVED***

  // populate Content-Length
  if (undefined !== body && !this.get('Content-Length'***REMOVED******REMOVED*** {
    this.set('Content-Length', len = Buffer.isBuffer(body***REMOVED***
      ? body.length
      : Buffer.byteLength(body***REMOVED******REMOVED***;
***REMOVED***

  // ETag support
  // TODO: W/ support
  if (app.settings.etag && len && 'GET' == req.method***REMOVED*** {
    if (!this.get('ETag'***REMOVED******REMOVED*** {
      this.set('ETag', etag(body***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***

  // freshness
  if (req.fresh***REMOVED*** this.statusCode = 304;

  // strip irrelevant headers
  if (204 == this.statusCode || 304 == this.statusCode***REMOVED*** {
    this.removeHeader('Content-Type'***REMOVED***;
    this.removeHeader('Content-Length'***REMOVED***;
    this.removeHeader('Transfer-Encoding'***REMOVED***;
    body = '';
***REMOVED***

  // respond
  this.end(head ? null : body***REMOVED***;
  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null***REMOVED***;
 *     res.json({ user: 'tj' }***REMOVED***;
 *     res.json(500, 'oh noes!'***REMOVED***;
 *     res.json(404, 'I dont have that'***REMOVED***;
 *
 * @param {Mixed} obj or status
 * @param {Mixed} obj
 * @return {ServerResponse}
 * @api public
 */

res.json = function(obj***REMOVED***{
  // allow status / body
  if (2 == arguments.length***REMOVED*** {
    // res.json(body, status***REMOVED*** backwards compat
    if ('number' == typeof arguments[1]***REMOVED*** {
      this.statusCode = arguments[1];
  ***REMOVED*** else {
      this.statusCode = obj;
      obj = arguments[1];
  ***REMOVED***
***REMOVED***

  // settings
  var app = this.app;
  var replacer = app.get('json replacer'***REMOVED***;
  var spaces = app.get('json spaces'***REMOVED***;
  var body = JSON.stringify(obj, replacer, spaces***REMOVED***;

  // content-type
  this.charset = this.charset || 'utf-8';
  this.get('Content-Type'***REMOVED*** || this.set('Content-Type', 'application/json'***REMOVED***;

  return this.send(body***REMOVED***;
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null***REMOVED***;
 *     res.jsonp({ user: 'tj' }***REMOVED***;
 *     res.jsonp(500, 'oh noes!'***REMOVED***;
 *     res.jsonp(404, 'I dont have that'***REMOVED***;
 *
 * @param {Mixed} obj or status
 * @param {Mixed} obj
 * @return {ServerResponse}
 * @api public
 */

res.jsonp = function(obj***REMOVED***{
  // allow status / body
  if (2 == arguments.length***REMOVED*** {
    // res.json(body, status***REMOVED*** backwards compat
    if ('number' == typeof arguments[1]***REMOVED*** {
      this.statusCode = arguments[1];
  ***REMOVED*** else {
      this.statusCode = obj;
      obj = arguments[1];
  ***REMOVED***
***REMOVED***

  // settings
  var app = this.app;
  var replacer = app.get('json replacer'***REMOVED***;
  var spaces = app.get('json spaces'***REMOVED***;
  var body = JSON.stringify(obj, replacer, spaces***REMOVED***
    .replace(/\u2028/g, '\\u2028'***REMOVED***
    .replace(/\u2029/g, '\\u2029'***REMOVED***;
  var callback = this.req.query[app.get('jsonp callback name'***REMOVED***];

  // content-type
  this.charset = this.charset || 'utf-8';
  this.set('Content-Type', 'application/json'***REMOVED***;

  // jsonp
  if (callback***REMOVED*** {
    if (Array.isArray(callback***REMOVED******REMOVED*** callback = callback[0];
    this.set('Content-Type', 'text/javascript'***REMOVED***;
    var cb = callback.replace(/[^\[\]\w$.]/g, ''***REMOVED***;
    body = 'typeof ' + cb + ' === \'function\' && ' + cb + '(' + body + '***REMOVED***;';
***REMOVED***

  return this.send(body***REMOVED***;
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `fn(err***REMOVED***` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge` defaulting to 0
 *   - `root`   root directory for relative filenames
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile(***REMOVED***` may
 *  be used as an alternative for the `static(***REMOVED***` middleware for
 *  dynamic situations. The code backing `res.sendfile(***REMOVED***` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res***REMOVED***{
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes***REMOVED***{
 *         if (yes***REMOVED*** {
 *           res.sendfile('/uploads/' + uid + '/' + file***REMOVED***;
 *       ***REMOVED*** else {
 *           res.send(403, 'Sorry! you cant see that.'***REMOVED***;
 *       ***REMOVED***
 *     ***REMOVED******REMOVED***;
 *   ***REMOVED******REMOVED***;
 *
 * @param {String} path
 * @param {Object|Function} options or fn
 * @param {Function} fn
 * @api public
 */

res.sendfile = function(path, options, fn***REMOVED***{
  var self = this
    , req = self.req
    , next = this.req.next
    , options = options || {}
    , done;

  // support function as second arg
  if ('function' == typeof options***REMOVED*** {
    fn = options;
    options = {};
***REMOVED***

  // socket errors
  req.socket.on('error', error***REMOVED***;

  // errors
  function error(err***REMOVED*** {
    if (done***REMOVED*** return;
    done = true;

    // clean up
    cleanup(***REMOVED***;
    if (!self.headerSent***REMOVED*** self.removeHeader('Content-Disposition'***REMOVED***;

    // callback available
    if (fn***REMOVED*** return fn(err***REMOVED***;

    // list in limbo if there's no callback
    if (self.headerSent***REMOVED*** return;

    // delegate
    next(err***REMOVED***;
***REMOVED***

  // streaming
  function stream(stream***REMOVED*** {
    if (done***REMOVED*** return;
    cleanup(***REMOVED***;
    if (fn***REMOVED*** stream.on('end', fn***REMOVED***;
***REMOVED***

  // cleanup
  function cleanup(***REMOVED*** {
    req.socket.removeListener('error', error***REMOVED***;
***REMOVED***

  // transfer
  var file = send(req, path***REMOVED***;
  if (options.root***REMOVED*** file.root(options.root***REMOVED***;
  file.maxage(options.maxAge || 0***REMOVED***;
  file.on('error', error***REMOVED***;
  file.on('directory', next***REMOVED***;
  file.on('stream', stream***REMOVED***;
  file.pipe(this***REMOVED***;
  this.on('finish', cleanup***REMOVED***;
};

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `fn(err***REMOVED***`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * ocurred. Be sure to check `res.headerSent` if you plan to respond.
 *
 * This method uses `res.sendfile(***REMOVED***`.
 *
 * @param {String} path
 * @param {String|Function} filename or fn
 * @param {Function} fn
 * @api public
 */

res.download = function(path, filename, fn***REMOVED***{
  // support function as second arg
  if ('function' == typeof filename***REMOVED*** {
    fn = filename;
    filename = null;
***REMOVED***

  filename = filename || path;
  this.set('Content-Disposition', 'attachment; filename="' + basename(filename***REMOVED*** + '"'***REMOVED***;
  return this.sendfile(path, fn***REMOVED***;
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup(***REMOVED***`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html'***REMOVED***;
 *     res.type('html'***REMOVED***;
 *     res.type('json'***REMOVED***;
 *     res.type('application/json'***REMOVED***;
 *     res.type('png'***REMOVED***;
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @api public
 */

res.contentType =
res.type = function(type***REMOVED***{
  return this.set('Content-Type', ~type.indexOf('/'***REMOVED***
    ? type
    : mime.lookup(type***REMOVED******REMOVED***;
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type(***REMOVED***`
 * or `res.set('Content-Type', ...***REMOVED***`.
 *
 *    res.format({
 *      'text/plain': function(***REMOVED***{
 *        res.send('hey'***REMOVED***;
 *    ***REMOVED***,
 *
 *      'text/html': function(***REMOVED***{
 *        res.send('<p>hey</p>'***REMOVED***;
 *    ***REMOVED***,
 *
 *      'appliation/json': function(***REMOVED***{
 *        res.send({ message: 'hey' }***REMOVED***;
 *    ***REMOVED***
 *  ***REMOVED******REMOVED***;
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(***REMOVED***{
 *        res.send('hey'***REMOVED***;
 *    ***REMOVED***,
 *
 *      html: function(***REMOVED***{
 *        res.send('<p>hey</p>'***REMOVED***;
 *    ***REMOVED***,
 *
 *      json: function(***REMOVED***{
 *        res.send({ message: 'hey' }***REMOVED***;
 *    ***REMOVED***
 *  ***REMOVED******REMOVED***;
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err***REMOVED***`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @api public
 */

res.format = function(obj***REMOVED***{
  var req = this.req
    , next = req.next;

  var fn = obj.default;
  if (fn***REMOVED*** delete obj.default;
  var keys = Object.keys(obj***REMOVED***;

  var key = req.accepts(keys***REMOVED***;

  this.vary("Accept"***REMOVED***;

  if (key***REMOVED*** {
    var type = normalizeType(key***REMOVED***.value;
    var charset = mime.charsets.lookup(type***REMOVED***;
    if (charset***REMOVED*** type += '; charset=' + charset;
    this.set('Content-Type', type***REMOVED***;
    obj[key](req, this, next***REMOVED***;
***REMOVED*** else if (fn***REMOVED*** {
    fn(***REMOVED***;
***REMOVED*** else {
    var err = new Error('Not Acceptable'***REMOVED***;
    err.status = 406;
    err.types = normalizeTypes(keys***REMOVED***.map(function(o***REMOVED***{ return o.value }***REMOVED***;
    next(err***REMOVED***;
***REMOVED***

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @api public
 */

res.attachment = function(filename***REMOVED***{
  if (filename***REMOVED*** this.type(extname(filename***REMOVED******REMOVED***;
  this.set('Content-Disposition', filename
    ? 'attachment; filename="' + basename(filename***REMOVED*** + '"'
    : 'attachment'***REMOVED***;
  return this;
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']***REMOVED***;
 *    res.set('Accept', 'application/json'***REMOVED***;
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' }***REMOVED***;
 *
 * Aliased as `res.header(***REMOVED***`.
 *
 * @param {String|Object|Array} field
 * @param {String} val
 * @return {ServerResponse} for chaining
 * @api public
 */

res.set =
res.header = function(field, val***REMOVED***{
  if (2 == arguments.length***REMOVED*** {
    if (Array.isArray(val***REMOVED******REMOVED*** val = val.map(String***REMOVED***;
    else val = String(val***REMOVED***;
    this.setHeader(field, val***REMOVED***;
***REMOVED*** else {
    for (var key in field***REMOVED*** {
      this.set(key, field[key]***REMOVED***;
  ***REMOVED***
***REMOVED***
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

res.get = function(field***REMOVED***{
  return this.getHeader(field***REMOVED***;
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} options
 * @param {ServerResponse} for chaining
 * @api public
 */

res.clearCookie = function(name, options***REMOVED***{
  var opts = { expires: new Date(1***REMOVED***, path: '/' };
  return this.cookie(name, '', options
    ? utils.merge(opts, options***REMOVED***
    : opts***REMOVED***;
};

/**
 * Set cookie `name` to `val`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now(***REMOVED*** + 900000***REMOVED***, httpOnly: true }***REMOVED***;
 *
 *    // save as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true }***REMOVED***
 *
 * @param {String} name
 * @param {String|Object} val
 * @param {Options} options
 * @api public
 */

res.cookie = function(name, val, options***REMOVED***{
  options = utils.merge({}, options***REMOVED***;
  var secret = this.req.secret;
  var signed = options.signed;
  if (signed && !secret***REMOVED*** throw new Error('connect.cookieParser("secret"***REMOVED*** required for signed cookies'***REMOVED***;
  if ('number' == typeof val***REMOVED*** val = val.toString(***REMOVED***;
  if ('object' == typeof val***REMOVED*** val = 'j:' + JSON.stringify(val***REMOVED***;
  if (signed***REMOVED*** val = 's:' + sign(val, secret***REMOVED***;
  if ('maxAge' in options***REMOVED*** {
    options.expires = new Date(Date.now(***REMOVED*** + options.maxAge***REMOVED***;
    options.maxAge /= 1000;
***REMOVED***
  if (null == options.path***REMOVED*** options.path = '/';
  this.set('Set-Cookie', cookie.serialize(name, String(val***REMOVED***, options***REMOVED******REMOVED***;
  return this;
};


/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar'***REMOVED***.;
 *    res.location('http://example.com'***REMOVED***;
 *    res.location('../login'***REMOVED***; // /blog/post/1 -> /blog/login
 *
 * Mounting:
 *
 *   When an application is mounted and `res.location(***REMOVED***`
 *   is given a path that does _not_ lead with "/" it becomes
 *   relative to the mount-point. For example if the application
 *   is mounted at "/blog", the following would become "/blog/login".
 *
 *      res.location('login'***REMOVED***;
 *
 *   While the leading slash would result in a location of "/login":
 *
 *      res.location('/login'***REMOVED***;
 *
 * @param {String} url
 * @api public
 */

res.location = function(url***REMOVED***{
  var app = this.app
    , req = this.req
    , path;

  // "back" is an alias for the referrer
  if ('back' == url***REMOVED*** url = req.get('Referrer'***REMOVED*** || '/';

  // relative
  if (!~url.indexOf('://'***REMOVED*** && 0 != url.indexOf('//'***REMOVED******REMOVED*** {
    // relative to path
    if ('.' == url[0]***REMOVED*** {
      path = req.originalUrl.split('?'***REMOVED***[0];
      path = path + ('/' == path[path.length - 1] ? '' : '/'***REMOVED***;
      url = resolve(path, url***REMOVED***;
      // relative to mount-point
  ***REMOVED*** else if ('/' != url[0]***REMOVED*** {
      path = app.path(***REMOVED***;
      url = path + '/' + url;
  ***REMOVED***
***REMOVED***

  // Respond
  this.set('Location', url***REMOVED***;
  return this;
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location(***REMOVED***`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar'***REMOVED***;
 *    res.redirect('http://example.com'***REMOVED***;
 *    res.redirect(301, 'http://example.com'***REMOVED***;
 *    res.redirect('http://example.com', 301***REMOVED***;
 *    res.redirect('../login'***REMOVED***; // /blog/post/1 -> /blog/login
 *
 * @param {String} url
 * @param {Number} code
 * @api public
 */

res.redirect = function(url***REMOVED***{
  var head = 'HEAD' == this.req.method
    , status = 302
    , body;

  // allow status / url
  if (2 == arguments.length***REMOVED*** {
    if ('number' == typeof url***REMOVED*** {
      status = url;
      url = arguments[1];
  ***REMOVED*** else {
      status = arguments[1];
  ***REMOVED***
***REMOVED***

  // Set location header
  this.location(url***REMOVED***;
  url = this.get('Location'***REMOVED***;

  // Support text/{plain,html} by default
  this.format({
    text: function(***REMOVED***{
      body = statusCodes[status] + '. Redirecting to ' + encodeURI(url***REMOVED***;
  ***REMOVED***,

    html: function(***REMOVED***{
      var u = utils.escape(url***REMOVED***;
      body = '<p>' + statusCodes[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
  ***REMOVED***,

    default: function(***REMOVED***{
      body = '';
  ***REMOVED***
***REMOVED******REMOVED***;

  // Respond
  this.statusCode = status;
  this.set('Content-Length', Buffer.byteLength(body***REMOVED******REMOVED***;
  this.end(head ? null : body***REMOVED***;
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @param {ServerResponse} for chaining
 * @api public
 */

res.vary = function(field***REMOVED***{
  var self = this;

  // nothing
  if (!field***REMOVED*** return this;

  // array
  if (Array.isArray(field***REMOVED******REMOVED*** {
    field.forEach(function(field***REMOVED***{
      self.vary(field***REMOVED***;
  ***REMOVED******REMOVED***;
    return;
***REMOVED***

  var vary = this.get('Vary'***REMOVED***;

  // append
  if (vary***REMOVED*** {
    vary = vary.split(/ *, */***REMOVED***;
    if (!~vary.indexOf(field***REMOVED******REMOVED*** vary.push(field***REMOVED***;
    this.set('Vary', vary.join(', '***REMOVED******REMOVED***;
    return this;
***REMOVED***

  // set
  this.set('Vary', field***REMOVED***;
  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @param  {String} view
 * @param  {Object|Function} options or callback function
 * @param  {Function} fn
 * @api public
 */

res.render = function(view, options, fn***REMOVED***{
  var self = this
    , options = options || {}
    , req = this.req
    , app = req.app;

  // support callback function as second arg
  if ('function' == typeof options***REMOVED*** {
    fn = options, options = {};
***REMOVED***

  // merge res.locals
  options._locals = self.locals;

  // default callback to respond
  fn = fn || function(err, str***REMOVED***{
    if (err***REMOVED*** return req.next(err***REMOVED***;
    self.send(str***REMOVED***;
***REMOVED***;

  // render
  app.render(view, options, fn***REMOVED***;
};
