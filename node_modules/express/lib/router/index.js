/**
 * Module dependencies.
 */

var Route = require('./route'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , methods = require('methods'***REMOVED***
  , debug = require('debug'***REMOVED***('express:router'***REMOVED***
  , parse = require('connect'***REMOVED***.utils.parseUrl;

/**
 * Expose `Router` constructor.
 */

exports = module.exports = Router;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} options
 * @api private
 */

function Router(options***REMOVED*** {
  options = options || {};
  var self = this;
  this.map = {};
  this.params = {};
  this._params = [];
  this.caseSensitive = options.caseSensitive;
  this.strict = options.strict;
  this.middleware = function router(req, res, next***REMOVED***{
    self._dispatch(req, res, next***REMOVED***;
***REMOVED***;
}

/**
 * Register a param callback `fn` for the given `name`.
 *
 * @param {String|Function} name
 * @param {Function} fn
 * @return {Router} for chaining
 * @api public
 */

Router.prototype.param = function(name, fn***REMOVED***{
  // param logic
  if ('function' == typeof name***REMOVED*** {
    this._params.push(name***REMOVED***;
    return;
***REMOVED***

  // apply param functions
  var params = this._params
    , len = params.length
    , ret;

  for (var i = 0; i < len; ++i***REMOVED*** {
    if (ret = params[i](name, fn***REMOVED******REMOVED*** {
      fn = ret;
  ***REMOVED***
***REMOVED***

  // ensure we end up with a
  // middleware function
  if ('function' != typeof fn***REMOVED*** {
    throw new Error('invalid param(***REMOVED*** call for ' + name + ', got ' + fn***REMOVED***;
***REMOVED***

  (this.params[name] = this.params[name] || []***REMOVED***.push(fn***REMOVED***;
  return this;
};

/**
 * Route dispatcher aka the route "middleware".
 *
 * @param {IncomingMessage} req
 * @param {ServerResponse} res
 * @param {Function} next
 * @api private
 */

Router.prototype._dispatch = function(req, res, next***REMOVED***{
  var params = this.params
    , self = this;

  debug('dispatching %s %s (%s***REMOVED***', req.method, req.url, req.originalUrl***REMOVED***;

  // route dispatch
  (function pass(i, err***REMOVED***{
    var paramCallbacks
      , paramIndex = 0
      , paramVal
      , route
      , keys
      , key;

    // match next route
    function nextRoute(err***REMOVED*** {
      pass(req._route_index + 1, err***REMOVED***;
  ***REMOVED***

    // match route
    req.route = route = self.matchRequest(req, i***REMOVED***;

    // implied OPTIONS
    if (!route && 'OPTIONS' == req.method***REMOVED*** return self._options(req, res, next***REMOVED***;

    // no route
    if (!route***REMOVED*** return next(err***REMOVED***;
    debug('matched %s %s', route.method, route.path***REMOVED***;

    // we have a route
    // start at param 0
    req.params = route.params;
    keys = route.keys;
    i = 0;

    // param callbacks
    function param(err***REMOVED*** {
      paramIndex = 0;
      key = keys[i++];
      paramVal = key && req.params[key.name];
      paramCallbacks = key && params[key.name];

      try {
        if ('route' == err***REMOVED*** {
          nextRoute(***REMOVED***;
      ***REMOVED*** else if (err***REMOVED*** {
          i = 0;
          callbacks(err***REMOVED***;
      ***REMOVED*** else if (paramCallbacks && undefined !== paramVal***REMOVED*** {
          paramCallback(***REMOVED***;
      ***REMOVED*** else if (key***REMOVED*** {
          param(***REMOVED***;
      ***REMOVED*** else {
          i = 0;
          callbacks(***REMOVED***;
      ***REMOVED***
    ***REMOVED*** catch (err***REMOVED*** {
        param(err***REMOVED***;
    ***REMOVED***
  ***REMOVED***;

    param(err***REMOVED***;

    // single param callbacks
    function paramCallback(err***REMOVED*** {
      var fn = paramCallbacks[paramIndex++];
      if (err || !fn***REMOVED*** return param(err***REMOVED***;
      fn(req, res, paramCallback, paramVal, key.name***REMOVED***;
  ***REMOVED***

    // invoke route callbacks
    function callbacks(err***REMOVED*** {
      var fn = route.callbacks[i++];
      try {
        if ('route' == err***REMOVED*** {
          nextRoute(***REMOVED***;
      ***REMOVED*** else if (err && fn***REMOVED*** {
          if (fn.length < 4***REMOVED*** return callbacks(err***REMOVED***;
          fn(err, req, res, callbacks***REMOVED***;
      ***REMOVED*** else if (fn***REMOVED*** {
          if (fn.length < 4***REMOVED*** return fn(req, res, callbacks***REMOVED***;
          callbacks(***REMOVED***;
      ***REMOVED*** else {
          nextRoute(err***REMOVED***;
      ***REMOVED***
    ***REMOVED*** catch (err***REMOVED*** {
        callbacks(err***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED******REMOVED***(0***REMOVED***;
};

/**
 * Respond to __OPTIONS__ method.
 *
 * @param {IncomingMessage} req
 * @param {ServerResponse} res
 * @api private
 */

Router.prototype._options = function(req, res, next***REMOVED***{
  var path = parse(req***REMOVED***.pathname
    , body = this._optionsFor(path***REMOVED***.join(','***REMOVED***;
  if (!body***REMOVED*** return next(***REMOVED***;
  res.set('Allow', body***REMOVED***.send(body***REMOVED***;
};

/**
 * Return an array of HTTP verbs or "options" for `path`.
 *
 * @param {String} path
 * @return {Array}
 * @api private
 */

Router.prototype._optionsFor = function(path***REMOVED***{
  var self = this;
  return methods.filter(function(method***REMOVED***{
    var routes = self.map[method];
    if (!routes || 'options' == method***REMOVED*** return;
    for (var i = 0, len = routes.length; i < len; ++i***REMOVED*** {
      if (routes[i].match(path***REMOVED******REMOVED*** return true;
  ***REMOVED***
***REMOVED******REMOVED***.map(function(method***REMOVED***{
    return method.toUpperCase(***REMOVED***;
***REMOVED******REMOVED***;
};

/**
 * Attempt to match a route for `req`
 * with optional starting index of `i`
 * defaulting to 0.
 *
 * @param {IncomingMessage} req
 * @param {Number} i
 * @return {Route}
 * @api private
 */

Router.prototype.matchRequest = function(req, i, head***REMOVED***{
  var method = req.method.toLowerCase(***REMOVED***
    , url = parse(req***REMOVED***
    , path = url.pathname
    , routes = this.map
    , i = i || 0
    , route;

  // HEAD support
  if (!head && 'head' == method***REMOVED*** {
    route = this.matchRequest(req, i, true***REMOVED***;
    if (route***REMOVED*** return route;
     method = 'get';
***REMOVED***

  // routes for this method
  if (routes = routes[method]***REMOVED*** {

    // matching routes
    for (var len = routes.length; i < len; ++i***REMOVED*** {
      route = routes[i];
      if (route.match(path***REMOVED******REMOVED*** {
        req._route_index = i;
        return route;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
};

/**
 * Attempt to match a route for `method`
 * and `url` with optional starting
 * index of `i` defaulting to 0.
 *
 * @param {String} method
 * @param {String} url
 * @param {Number} i
 * @return {Route}
 * @api private
 */

Router.prototype.match = function(method, url, i, head***REMOVED***{
  var req = { method: method, url: url };
  return  this.matchRequest(req, i, head***REMOVED***;
};

/**
 * Route `method`, `path`, and one or more callbacks.
 *
 * @param {String} method
 * @param {String} path
 * @param {Function} callback...
 * @return {Router} for chaining
 * @api private
 */

Router.prototype.route = function(method, path, callbacks***REMOVED***{
  var method = method.toLowerCase(***REMOVED***
    , callbacks = utils.flatten([].slice.call(arguments, 2***REMOVED******REMOVED***;

  // ensure path was given
  if (!path***REMOVED*** throw new Error('Router#' + method + '(***REMOVED*** requires a path'***REMOVED***;

  // ensure all callbacks are functions
  callbacks.forEach(function(fn***REMOVED***{
    if ('function' == typeof fn***REMOVED*** return;
    var type = {}.toString.call(fn***REMOVED***;
    var msg = '.' + method + '(***REMOVED*** requires callback functions but got a ' + type;
    throw new Error(msg***REMOVED***;
***REMOVED******REMOVED***;

  // create the route
  debug('defined %s %s', method, path***REMOVED***;
  var route = new Route(method, path, callbacks, {
    sensitive: this.caseSensitive,
    strict: this.strict
***REMOVED******REMOVED***;

  // add it
  (this.map[method] = this.map[method] || []***REMOVED***.push(route***REMOVED***;
  return this;
};

Router.prototype.all = function(path***REMOVED*** {
  var self = this;
  var args = [].slice.call(arguments***REMOVED***;
  methods.forEach(function(method***REMOVED***{
      self.route.apply(self, [method].concat(args***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
  return this;
};

methods.forEach(function(method***REMOVED***{
  Router.prototype[method] = function(path***REMOVED***{
    var args = [method].concat([].slice.call(arguments***REMOVED******REMOVED***;
    this.route.apply(this, args***REMOVED***;
    return this;
***REMOVED***;
}***REMOVED***;
