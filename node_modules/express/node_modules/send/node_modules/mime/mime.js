var ***REMOVED***;
var fs = require('fs'***REMOVED***;

function Mime(***REMOVED*** {
  // Map of extension -> mime type
  this.types = Object.create(null***REMOVED***;

  // Map of mime type -> extension
  this.extensions = Object.create(null***REMOVED***;
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']}***REMOVED***;
 *
 * @param map (Object***REMOVED*** type definitions
 */
Mime.prototype.define = function (map***REMOVED*** {
  for (var type in map***REMOVED*** {
    var exts = map[type];

    for (var i = 0; i < exts.length; i++***REMOVED*** {
      if (process.env.DEBUG_MIME && this.types[exts]***REMOVED*** {
        console.warn(this._loading.replace(/.*\//, ''***REMOVED***, 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts] + ' to ' + type***REMOVED***;
    ***REMOVED***

      this.types[exts[i]] = type;
  ***REMOVED***

    // Default extension is the first one we encounter
    if (!this.extensions[type]***REMOVED*** {
      this.extensions[type] = exts[0];
  ***REMOVED***
***REMOVED***
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected***REMOVED***.  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String***REMOVED*** path of file to load.
 */
Mime.prototype.load = function(file***REMOVED*** {

  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'***REMOVED***,
      lines = content.split(/[\r\n]+/***REMOVED***;

  lines.forEach(function(line***REMOVED*** {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, ''***REMOVED***.split(/\s+/***REMOVED***;
    map[fields.shift(***REMOVED***] = fields;
***REMOVED******REMOVED***;

  this.define(map***REMOVED***;

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback***REMOVED*** {
  var ext = path.replace(/.*[\.\/\\]/, ''***REMOVED***.toLowerCase(***REMOVED***;

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType***REMOVED*** {
  var type = mimeType.match(/^\s*([^;\s]****REMOVED***(?:;|\s|$***REMOVED***/***REMOVED***[1].toLowerCase(***REMOVED***;
  return this.extensions[type];
};

// Default instance
var mime = new Mime(***REMOVED***;

// Load local copy of
// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
mime.load(path.join(__dirname, 'types/mime.types'***REMOVED******REMOVED***;

// Load additional types from node.js community
mime.load(path.join(__dirname, 'types/node.types'***REMOVED******REMOVED***;

// Default type
mime.default_type = mime.lookup('bin'***REMOVED***;

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback***REMOVED*** {
    // Assume text types are utf8
    return (/^text\//***REMOVED***.test(mimeType***REMOVED*** ? 'UTF-8' : fallback;
***REMOVED***
};

module.exports = mime;
