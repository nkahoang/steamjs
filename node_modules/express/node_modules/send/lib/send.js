
/**
 * Module dependencies.
 */

var debug = require('debug'***REMOVED***('send'***REMOVED***
  , parseRange = require('range-parser'***REMOVED***
  , Stream = require('stream'***REMOVED***
  , mime = require('mime'***REMOVED***
  , fresh = require('fresh'***REMOVED***
  , ***REMOVED***
  , ***REMOVED***
  , fs = require('fs'***REMOVED***
  , basename = path.basename
  , normalize = path.normalize
  , join = path.join
  , utils = require('./utils'***REMOVED***;

/**
 * Expose `send`.
 */

exports = module.exports = send;

/**
 * Expose mime module.
 */

exports.mime = mime;

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {Object} options
 * @return {SendStream}
 * @api public
 */

function send(req, path, options***REMOVED*** {
  return new SendStream(req, path, options***REMOVED***;
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * Events:
 *
 *  - `error` an error occurred
 *  - `stream` file streaming has started
 *  - `end` streaming has completed
 *  - `directory` a directory was requested
 *
 * @param {Request} req
 * @param {String} path
 * @param {Object} options
 * @api private
 */

function SendStream(req, path, options***REMOVED*** {
  var self = this;
  this.req = req;
  this.path = path;
  this.options = options || {};
  this.maxage(0***REMOVED***;
  this.hidden(false***REMOVED***;
  this.index('index.html'***REMOVED***;
}

/**
 * Inherits from `Stream.prototype`.
 */

SendStream.prototype.__proto__ = Stream.prototype;

/**
 * Enable or disable "hidden" (dot***REMOVED*** files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = function(val***REMOVED***{
  debug('hidden %s', val***REMOVED***;
  this._hidden = val;
  return this;
};

/**
 * Set index `path`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = function(path***REMOVED***{
  debug('index %s', path***REMOVED***;
  this._index = path;
  return this;
};

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = 
SendStream.prototype.from = function(path***REMOVED***{
  this._root = normalize(path***REMOVED***;
  return this;
};

/**
 * Set max-age to `ms`.
 *
 * @param {Number} ms
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = function(ms***REMOVED***{
  if (Infinity == ms***REMOVED*** ms = 60 * 60 * 24 * 365 * 1000;
  debug('max-age %d', ms***REMOVED***;
  this._maxage = ms;
  return this;
};

/**
 * Emit error with `status`.
 *
 * @param {Number} status
 * @api private
 */

SendStream.prototype.error = function(status, err***REMOVED***{
  var res = this.res;
  var msg = http.STATUS_CODES[status];
  err = err || new Error(msg***REMOVED***;
  err.status = status;
  if (this.listeners('error'***REMOVED***.length***REMOVED*** return this.emit('error', err***REMOVED***;
  res.statusCode = err.status;
  res.end(msg***REMOVED***;
};

/**
 * Check if the pathname is potentially malicious.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isMalicious = function(***REMOVED***{
  return !this._root && ~this.path.indexOf('..'***REMOVED***;
};

/**
 * Check if the pathname ends with "/".
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.hasTrailingSlash = function(***REMOVED***{
  return '/' == this.path[this.path.length - 1];
};

/**
 * Check if the basename leads with ".".
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.hasLeadingDot = function(***REMOVED***{
  return '.' == basename(this.path***REMOVED***[0];
};

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function(***REMOVED***{
  return this.req.headers['if-none-match']
    || this.req.headers['if-modified-since'];
};

/**
 * Strip content-* header fields.
 *
 * @api private
 */

SendStream.prototype.removeContentHeaderFields = function(***REMOVED***{
  var res = this.res;
  Object.keys(res._headers***REMOVED***.forEach(function(field***REMOVED***{
    if (0 == field.indexOf('content'***REMOVED******REMOVED*** {
      res.removeHeader(field***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
};

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function(***REMOVED***{
  var res = this.res;
  debug('not modified'***REMOVED***;
  this.removeContentHeaderFields(***REMOVED***;
  res.statusCode = 304;
  res.end(***REMOVED***;
};

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}***REMOVED***.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function(***REMOVED***{
  var res = this.res;
  return (res.statusCode >= 200 && res.statusCode < 300***REMOVED*** || 304 == res.statusCode;
};

/**
 * Handle stat(***REMOVED*** error.
 *
 * @param {Error} err
 * @api private
 */

SendStream.prototype.onStatError = function(err***REMOVED***{
  var notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'];
  if (~notfound.indexOf(err.code***REMOVED******REMOVED*** return this.error(404, err***REMOVED***;
  this.error(500, err***REMOVED***;
};

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function(***REMOVED***{
  return fresh(this.req.headers, this.res._headers***REMOVED***;
};

/**
 * Redirect to `path`.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.redirect = function(path***REMOVED***{
  if (this.listeners('directory'***REMOVED***.length***REMOVED*** return this.emit('directory'***REMOVED***;
  var res = this.res;
  path += '/';
  res.statusCode = 301;
  res.setHeader('Location', path***REMOVED***;
  res.end('Redirecting to ' + utils.escape(path***REMOVED******REMOVED***;
};

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function(res***REMOVED***{
  var self = this
    , args = arguments
    , path = this.path
    , root = this._root;

  // references
  this.res = res;

  // invalid request uri
  path = utils.decode(path***REMOVED***;
  if (-1 == path***REMOVED*** return this.error(400***REMOVED***;

  // null byte(s***REMOVED***
  if (~path.indexOf('\0'***REMOVED******REMOVED*** return this.error(400***REMOVED***;

  // join / normalize from optional root dir
  if (root***REMOVED*** path = normalize(join(this._root, path***REMOVED******REMOVED***;

  // ".." is malicious without "root"
  if (this.isMalicious(***REMOVED******REMOVED*** return this.error(403***REMOVED***;

  // malicious path
  if (root && 0 != path.indexOf(root***REMOVED******REMOVED*** return this.error(403***REMOVED***;

  // hidden file support
  if (!this._hidden && this.hasLeadingDot(***REMOVED******REMOVED*** return this.error(404***REMOVED***;

  // index file support
  if (this._index && this.hasTrailingSlash(***REMOVED******REMOVED*** path += this._index;

  debug('stat "%s"', path***REMOVED***;
  fs.stat(path, function(err, stat***REMOVED***{
    if (err***REMOVED*** return self.onStatError(err***REMOVED***;
    if (stat.isDirectory(***REMOVED******REMOVED*** return self.redirect(self.path***REMOVED***;
    self.emit('file', path, stat***REMOVED***;
    self.send(path, stat***REMOVED***;
***REMOVED******REMOVED***;

  return res;
};

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function(path, stat***REMOVED***{
  var options = this.options;
  var len = stat.size;
  var res = this.res;
  var req = this.req;
  var ranges = req.headers.range;
  var offset = options.start || 0;

  // set header fields
  this.setHeader(stat***REMOVED***;

  // set content-type
  this.type(path***REMOVED***;

  // conditional GET support
  if (this.isConditionalGET(***REMOVED***
    && this.isCachable(***REMOVED***
    && this.isFresh(***REMOVED******REMOVED*** {
    return this.notModified(***REMOVED***;
***REMOVED***

  // adjust len to start/end options
  len = Math.max(0, len - offset***REMOVED***;
  if (options.end !== undefined***REMOVED*** {
    var bytes = options.end - offset + 1;
    if (len > bytes***REMOVED*** len = bytes;
***REMOVED***

  // Range support
  if (ranges***REMOVED*** {
    ranges = parseRange(len, ranges***REMOVED***;

    // unsatisfiable
    if (-1 == ranges***REMOVED*** {
      res.setHeader('Content-Range', 'bytes */' + stat.size***REMOVED***;
      return this.error(416***REMOVED***;
  ***REMOVED***

    // valid (syntactically invalid ranges are treated as a regular response***REMOVED***
    if (-2 != ranges***REMOVED*** {
      options.start = offset + ranges[0].start;
      options.end = offset + ranges[0].end;

      // Content-Range
      res.statusCode = 206;
      res.setHeader('Content-Range', 'bytes '
        + ranges[0].start
        + '-'
        + ranges[0].end
        + '/'
        + len***REMOVED***;
      len = options.end - options.start + 1;
  ***REMOVED***
***REMOVED***

  // content-length
  res.setHeader('Content-Length', len***REMOVED***;

  // HEAD support
  if ('HEAD' == req.method***REMOVED*** return res.end(***REMOVED***;

  this.stream(path, options***REMOVED***;
};

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function(path, options***REMOVED***{
  // TODO: this is all lame, refactor meeee
  var self = this;
  var res = this.res;
  var req = this.req;

  // pipe
  var stream = fs.createReadStream(path, options***REMOVED***;
  this.emit('stream', stream***REMOVED***;
  stream.pipe(res***REMOVED***;

  // socket closed, done with the fd
  req.on('close', stream.destroy.bind(stream***REMOVED******REMOVED***;

  // error handling code-smell
  stream.on('error', function(err***REMOVED***{
    // no hope in responding
    if (res._header***REMOVED*** {
      console.error(err.stack***REMOVED***;
      req.destroy(***REMOVED***;
      return;
  ***REMOVED***

    // 500
    err.status = 500;
    self.emit('error', err***REMOVED***;
***REMOVED******REMOVED***;

  // end
  stream.on('end', function(***REMOVED***{
    self.emit('end'***REMOVED***;
***REMOVED******REMOVED***;
};

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function(path***REMOVED***{
  var res = this.res;
  if (res.getHeader('Content-Type'***REMOVED******REMOVED*** return;
  var type = mime.lookup(path***REMOVED***;
  var charset = mime.charsets.lookup(type***REMOVED***;
  debug('content-type %s', type***REMOVED***;
  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''***REMOVED******REMOVED***;
};

/**
 * Set reaponse header fields, most
 * fields may be pre-defined.
 *
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function(stat***REMOVED***{
  var res = this.res;
  if (!res.getHeader('Accept-Ranges'***REMOVED******REMOVED*** res.setHeader('Accept-Ranges', 'bytes'***REMOVED***;
  if (!res.getHeader('ETag'***REMOVED******REMOVED*** res.setHeader('ETag', utils.etag(stat***REMOVED******REMOVED***;
  if (!res.getHeader('Date'***REMOVED******REMOVED*** res.setHeader('Date', new Date(***REMOVED***.toUTCString(***REMOVED******REMOVED***;
  if (!res.getHeader('Cache-Control'***REMOVED******REMOVED*** res.setHeader('Cache-Control', 'public, max-age=' + (this._maxage / 1000***REMOVED******REMOVED***;
  if (!res.getHeader('Last-Modified'***REMOVED******REMOVED*** res.setHeader('Last-Modified', stat.mtime.toUTCString(***REMOVED******REMOVED***;
};
