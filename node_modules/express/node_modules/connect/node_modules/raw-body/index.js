var StringDecoder = require('string_decoder'***REMOVED***.StringDecoder
var bytes = require('bytes'***REMOVED***

module.exports = function (stream, options, done***REMOVED*** {
  if (typeof options === 'function'***REMOVED*** {
    done = options
    options = {}
***REMOVED*** else if (!options***REMOVED*** {
    options = {}
***REMOVED***

  // convert the limit to an integer
  var limit = null
  if (typeof options.limit === 'number'***REMOVED***
    limit = options.limit
  if (typeof options.limit === 'string'***REMOVED***
    limit = bytes(options.limit***REMOVED***

  // convert the expected length to an integer
  var length = null
  if (options.length != null && !isNaN(options.length***REMOVED******REMOVED***
    length = parseInt(options.length, 10***REMOVED***

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit***REMOVED*** {
    if (typeof stream.pause === 'function'***REMOVED***
      stream.pause(***REMOVED***

    process.nextTick(function (***REMOVED*** {
      var err = makeError('request entity too large', 'entity.too.large'***REMOVED***
      err.status = err.statusCode = 413
      err.length = err.expected = length
      err.limit = limit
      done(err***REMOVED***
  ***REMOVED******REMOVED***
    return defer
***REMOVED***

  var state = stream._readableState
  // streams2+: assert the stream encoding is buffer.
  if (state && state.encoding != null***REMOVED*** {
    if (typeof stream.pause === 'function'***REMOVED***
      stream.pause(***REMOVED***

    process.nextTick(function (***REMOVED*** {
      var err = makeError('stream encoding should not be set',
        'stream.encoding.set'***REMOVED***
      // developer error
      err.status = err.statusCode = 500
      done(err***REMOVED***
  ***REMOVED******REMOVED***
    return defer
***REMOVED***

  var received = 0
  // note: we delegate any invalid encodings to the constructor
  var decoder = options.encoding
    ? new StringDecoder(options.encoding === true ? 'utf8' : options.encoding***REMOVED***
    : null
  var buffer = decoder
    ? ''
    : []

  stream.on('data', onData***REMOVED***
  stream.once('end', onEnd***REMOVED***
  stream.once('error', onEnd***REMOVED***
  stream.once('close', cleanup***REMOVED***

  return defer

  // yieldable support
  function defer(fn***REMOVED*** {
    done = fn
***REMOVED***

  function onData(chunk***REMOVED*** {
    received += chunk.length
    decoder
      ? buffer += decoder.write(chunk***REMOVED***
      : buffer.push(chunk***REMOVED***

    if (limit !== null && received > limit***REMOVED*** {
      if (typeof stream.pause === 'function'***REMOVED***
        stream.pause(***REMOVED***
      var err = makeError('request entity too large', 'entity.too.large'***REMOVED***
      err.status = err.statusCode = 413
      err.received = received
      err.limit = limit
      done(err***REMOVED***
      cleanup(***REMOVED***
  ***REMOVED***
***REMOVED***

  function onEnd(err***REMOVED*** {
    if (err***REMOVED*** {
      if (typeof stream.pause === 'function'***REMOVED***
        stream.pause(***REMOVED***
      done(err***REMOVED***
  ***REMOVED*** else if (length !== null && received !== length***REMOVED*** {
      err = makeError('request size did not match content length',
        'request.size.invalid'***REMOVED***
      err.status = err.statusCode = 400
      err.received = received
      err.length = err.expected = length
      done(err***REMOVED***
  ***REMOVED*** else {
      done(null, decoder
        ? buffer + endStringDecoder(decoder***REMOVED***
        : Buffer.concat(buffer***REMOVED***
      ***REMOVED***
  ***REMOVED***

    cleanup(***REMOVED***
***REMOVED***

  function cleanup(***REMOVED*** {
    received = buffer = null

    stream.removeListener('data', onData***REMOVED***
    stream.removeListener('end', onEnd***REMOVED***
    stream.removeListener('error', onEnd***REMOVED***
    stream.removeListener('close', cleanup***REMOVED***
***REMOVED***
}

// to create serializable errors you must re-set message so
// that it is enumerable and you must re configure the type
// property so that is writable and enumerable
function makeError(message, type***REMOVED*** {
  var error = new Error(***REMOVED***
  error.message = message
  Object.defineProperty(error, 'type', {
    value: type,
    enumerable: true,
    writable: true,
    configurable: true
***REMOVED******REMOVED***
  return error
}

// https://github.com/Raynos/body/blob/2512ced39e31776e5a2f7492b907330badac3a40/index.js#L72
// bug fix for missing `StringDecoder.end` in v0.8.x
function endStringDecoder(decoder***REMOVED*** {
    if (decoder.end***REMOVED*** {
        return decoder.end(***REMOVED***
  ***REMOVED***

    var res = ""

    if (decoder.charReceived***REMOVED*** {
        var cr = decoder.charReceived
        var buf = decoder.charBuffer
        var enc = decoder.encoding
        res += buf.slice(0, cr***REMOVED***.toString(enc***REMOVED***
  ***REMOVED***

    return res
}
