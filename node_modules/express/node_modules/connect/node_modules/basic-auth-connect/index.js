var ***REMOVED***;

/*!
 * Connect - basicAuth
 * Copyright(c***REMOVED*** 2010 Sencha Inc.
 * Copyright(c***REMOVED*** 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Basic Auth:
 *
 * Status: Deprecated. No bug reports or pull requests are welcomed
 * for this middleware. However, this middleware will not be removed.
 * Instead, you should use [basic-auth](https://github.com/visionmedia/node-basic-auth***REMOVED***.
 *
 * Enfore basic authentication by providing a `callback(user, pass***REMOVED***`,
 * which must return `true` in order to gain access. Alternatively an async
 * method is provided as well, invoking `callback(user, pass, callback***REMOVED***`. Populates
 * `req.user`. The final alternative is simply passing username / password
 * strings.
 *
 *  Simple username and password
 *
 *     connect(connect.basicAuth('username', 'password'***REMOVED******REMOVED***;
 *
 *  Callback verification
 *
 *     connect(***REMOVED***
 *       .use(connect.basicAuth(function(user, pass***REMOVED***{
 *         return 'tj' == user && 'wahoo' == pass;
 *     ***REMOVED******REMOVED******REMOVED***
 *
 *  Async callback verification, accepting `fn(err, user***REMOVED***`.
 *
 *     connect(***REMOVED***
 *       .use(connect.basicAuth(function(user, pass, fn***REMOVED***{
 *         User.authenticate({ user: user, pass: pass }, fn***REMOVED***;
 *     ***REMOVED******REMOVED******REMOVED***
 *
 * @param {Function|String} callback or username
 * @param {String} realm
 * @api public
 */

module.exports = function basicAuth(callback, realm***REMOVED*** {
  var username, password;

  // user / pass strings
  if ('string' == typeof callback***REMOVED*** {
    username = callback;
    password = realm;
    if ('string' != typeof password***REMOVED*** throw new Error('password argument required'***REMOVED***;
    realm = arguments[2];
    callback = function(user, pass***REMOVED***{
      return user == username && pass == password;
  ***REMOVED***
***REMOVED***

  realm = realm || 'Authorization Required';

  return function(req, res, next***REMOVED*** {
    var authorization = req.headers.authorization;

    if (req.user***REMOVED*** return next(***REMOVED***;
    if (!authorization***REMOVED*** return unauthorized(res, realm***REMOVED***;

    var parts = authorization.split(' '***REMOVED***;

    if (parts.length !== 2***REMOVED*** return next(error(400***REMOVED******REMOVED***;

    var scheme = parts[0]
      , credentials = new Buffer(parts[1], 'base64'***REMOVED***.toString(***REMOVED***
      , index = credentials.indexOf(':'***REMOVED***;

    if ('Basic' != scheme || index < 0***REMOVED*** return next(error(400***REMOVED******REMOVED***;

    var user = credentials.slice(0, index***REMOVED***
      , pass = credentials.slice(index + 1***REMOVED***;

    // async
    if (callback.length >= 3***REMOVED*** {
      callback(user, pass, function(err, user***REMOVED***{
        if (err || !user***REMOVED***  return unauthorized(res, realm***REMOVED***;
        req.user = req.remoteUser = user;
        next(***REMOVED***;
    ***REMOVED******REMOVED***;
    // sync
  ***REMOVED*** else {
      if (callback(user, pass***REMOVED******REMOVED*** {
        req.user = req.remoteUser = user;
        next(***REMOVED***;
    ***REMOVED*** else {
        unauthorized(res, realm***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
};

/**
 * Respond with 401 "Unauthorized".
 *
 * @param {ServerResponse} res
 * @param {String} realm
 * @api private
 */

function unauthorized(res, realm***REMOVED*** {
  res.statusCode = 401;
  res.setHeader('WWW-Authenticate', 'Basic realm="' + realm + '"'***REMOVED***;
  res.end('Unauthorized'***REMOVED***;
};

/**
 * Generate an `Error` from the given status `code`
 * and optional `msg`.
 *
 * @param {Number} code
 * @param {String} msg
 * @return {Error}
 * @api private
 */

function error(code, msg***REMOVED***{
  var err = new Error(msg || http.STATUS_CODES[code]***REMOVED***;
  err.status = code;
  return err;
};