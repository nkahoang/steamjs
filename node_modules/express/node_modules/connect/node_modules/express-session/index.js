/*!
 * Connect - session
 * Copyright(c***REMOVED*** 2010 Sencha Inc.
 * Copyright(c***REMOVED*** 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var uid = require('uid2'***REMOVED***
  , crc32 = require('buffer-crc32'***REMOVED***
  , parse = require('url'***REMOVED***.parse
  , signature = require('cookie-signature'***REMOVED***
  , debug = require('debug'***REMOVED***('session'***REMOVED***

var Session = require('./session/session'***REMOVED***
  , MemoryStore = require('./session/memory'***REMOVED***
  , Cookie = require('./session/cookie'***REMOVED***
  , Store = require('./session/store'***REMOVED***

// environment

var env = process.env.NODE_ENV;

/**
 * Expose the middleware.
 */

exports = module.exports = session;

/**
 * Expose constructors.
 */

exports.Store = Store;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;

/**
 * Warning message for `MemoryStore` usage in production.
 */

var warning = 'Warning: connect.session(***REMOVED*** MemoryStore is not\n'
  + 'designed for a production environment, as it will leak\n'
  + 'memory, and will not scale past a single process.';

/**
 * Session:
 *
 *   Setup session store with the given `options`.
 *
 *   Session data is _not_ saved in the cookie itself, however
 *   cookies are used, so we must use the [cookieParser(***REMOVED***](cookieParser.html***REMOVED***
 *   middleware _before_ `session(***REMOVED***`.
 *
 * Examples:
 *
 *     connect(***REMOVED***
 *       .use(connect.cookieParser(***REMOVED******REMOVED***
 *       .use(connect.session({ secret: 'keyboard cat', key: 'sid', cookie: { secure: true }}***REMOVED******REMOVED***
 *
 * Options:
 *
 *   - `key` cookie name defaulting to `connect.sid`
 *   - `store` session store instance
 *   - `secret` session cookie is signed with this secret to prevent tampering
 *   - `cookie` session cookie settings, defaulting to `{ path: '/', httpOnly: true, maxAge: null }`
 *   - `proxy` trust the reverse proxy when setting secure cookies (via "x-forwarded-proto"***REMOVED***
 *
 * Cookie option:
 *
 *  By default `cookie.maxAge` is `null`, meaning no "expires" parameter is set
 *  so the cookie becomes a browser-session cookie. When the user closes the
 *  browser the cookie (and session***REMOVED*** will be removed.
 *
 * ## req.session
 *
 *  To store or access session data, simply use the request property `req.session`,
 *  which is (generally***REMOVED*** serialized as JSON by the store, so nested objects
 *  are typically fine. For example below is a user-specific view counter:
 *
 *       connect(***REMOVED***
 *         .use(connect.favicon(***REMOVED******REMOVED***
 *         .use(connect.cookieParser(***REMOVED******REMOVED***
 *         .use(connect.session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }}***REMOVED******REMOVED***
 *         .use(function(req, res, next***REMOVED***{
 *           var sess = req.session;
 *           if (sess.views***REMOVED*** {
 *             res.setHeader('Content-Type', 'text/html'***REMOVED***;
 *             res.write('<p>views: ' + sess.views + '</p>'***REMOVED***;
 *             res.write('<p>expires in: ' + (sess.cookie.maxAge / 1000***REMOVED*** + 's</p>'***REMOVED***;
 *             res.end(***REMOVED***;
 *             sess.views++;
 *         ***REMOVED*** else {
 *             sess.views = 1;
 *             res.end('welcome to the session demo. refresh!'***REMOVED***;
 *         ***REMOVED***
 *       ***REMOVED***
 *       ***REMOVED******REMOVED***.listen(3000***REMOVED***;
 *
 * ## Session#regenerate(***REMOVED***
 *
 *  To regenerate the session simply invoke the method, once complete
 *  a new SID and `Session` instance will be initialized at `req.session`.
 *
 *      req.session.regenerate(function(err***REMOVED***{
 *        // will have a new session here
 *    ***REMOVED******REMOVED***;
 *
 * ## Session#destroy(***REMOVED***
 *
 *  Destroys the session, removing `req.session`, will be re-generated next request.
 *
 *      req.session.destroy(function(err***REMOVED***{
 *        // cannot access session here
 *    ***REMOVED******REMOVED***;
 *
 * ## Session#reload(***REMOVED***
 *
 *  Reloads the session data.
 *
 *      req.session.reload(function(err***REMOVED***{
 *        // session updated
 *    ***REMOVED******REMOVED***;
 *
 * ## Session#save(***REMOVED***
 *
 *  Save the session.
 *
 *      req.session.save(function(err***REMOVED***{
 *        // session saved
 *    ***REMOVED******REMOVED***;
 *
 * ## Session#touch(***REMOVED***
 *
 *   Updates the `.maxAge` property. Typically this is
 *   not necessary to call, as the session middleware does this for you.
 *
 * ## Session#cookie
 *
 *  Each session has a unique cookie object accompany it. This allows
 *  you to alter the session cookie per visitor. For example we can
 *  set `req.session.cookie.expires` to `false` to enable the cookie
 *  to remain for only the duration of the user-agent.
 *
 * ## Session#maxAge
 *
 *  Alternatively `req.session.cookie.maxAge` will return the time
 *  remaining in milliseconds, which we may also re-assign a new value
 *  to adjust the `.expires` property appropriately. The following
 *  are essentially equivalent
 *
 *     var hour = 3600000;
 *     req.session.cookie.expires = new Date(Date.now(***REMOVED*** + hour***REMOVED***;
 *     req.session.cookie.maxAge = hour;
 *
 * For example when `maxAge` is set to `60000` (one minute***REMOVED***, and 30 seconds
 * has elapsed it will return `30000` until the current request has completed,
 * at which time `req.session.touch(***REMOVED***` is called to reset `req.session.maxAge`
 * to its original value.
 *
 *     req.session.cookie.maxAge;
 *     // => 30000
 *
 * Session Store Implementation:
 *
 * Every session store _must_ implement the following methods
 *
 *    - `.get(sid, callback***REMOVED***`
 *    - `.set(sid, session, callback***REMOVED***`
 *    - `.destroy(sid, callback***REMOVED***`
 *
 * Recommended methods include, but are not limited to:
 *
 *    - `.length(callback***REMOVED***`
 *    - `.clear(callback***REMOVED***`
 *
 * For an example implementation view the [connect-redis](http://github.com/visionmedia/connect-redis***REMOVED*** repo.
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */

function session(options***REMOVED***{
  var options = options || {}
    , key = options.key || 'connect.sid'
    , store = options.store || new MemoryStore
    , cookie = options.cookie || {}
    , trustProxy = options.proxy
    , storeReady = true
    , rollingSessions = options.rolling || false;

  // notify user that this store is not
  // meant for a production environment
  if ('production' == env && store instanceof MemoryStore***REMOVED*** {
    console.warn(warning***REMOVED***;
***REMOVED***

  // generates the new session
  store.generate = function(req***REMOVED***{
    req.sessionID = uid(24***REMOVED***;
    req.session = new Session(req***REMOVED***;
    req.session.cookie = new Cookie(cookie***REMOVED***;
***REMOVED***;

  store.on('disconnect', function(***REMOVED***{ storeReady = false; }***REMOVED***;
  store.on('connect', function(***REMOVED***{ storeReady = true; }***REMOVED***;

  return function session(req, res, next***REMOVED*** {
    // self-awareness
    if (req.session***REMOVED*** return next(***REMOVED***;

    // Handle connection as if there is no session if
    // the store has temporarily disconnected etc
    if (!storeReady***REMOVED*** return debug('store is disconnected'***REMOVED***, next(***REMOVED***;

    // pathname mismatch
    var originalPath = parse(req.originalUrl***REMOVED***.pathname;
    if (0 != originalPath.indexOf(cookie.path || '/'***REMOVED******REMOVED*** return next(***REMOVED***;

    // backwards compatibility for signed cookies
    // req.secret is passed from the cookie parser middleware
    var secret = options.secret || req.secret;

    // ensure secret is available or bail
    if (!secret***REMOVED*** throw new Error('`secret` option required for sessions'***REMOVED***;

    var originalHash
      , originalId;

    // expose store
    req.sessionStore = store;

    // grab the session cookie value and check the signature
    var rawCookie = req.cookies[key];

    // get signedCookies for backwards compat with signed cookies
    var unsignedCookie = req.signedCookies[key];

    if (!unsignedCookie && rawCookie***REMOVED*** {
      unsignedCookie = (0 == rawCookie.indexOf('s:'***REMOVED******REMOVED***
        ? signature.unsign(rawCookie.slice(2***REMOVED***, secret***REMOVED***
        : rawCookie;
  ***REMOVED***

    // set-cookie
    var writeHead = res.writeHead;
    res.writeHead = function(***REMOVED***{
      if (!req.session***REMOVED*** {
        debug('no session'***REMOVED***;
        writeHead.apply(res, arguments***REMOVED***;
        return;
    ***REMOVED***

      var cookie = req.session.cookie
        , proto = (req.headers['x-forwarded-proto'] || ''***REMOVED***.split(','***REMOVED***[0].toLowerCase(***REMOVED***.trim(***REMOVED***
        , tls = req.connection.encrypted || (trustProxy && 'https' == proto***REMOVED***
        , isNew = unsignedCookie != req.sessionID;

      // only send secure cookies via https
      if (cookie.secure && !tls***REMOVED*** {
        debug('not secured'***REMOVED***;
        writeHead.apply(res, arguments***REMOVED***;
        return;
    ***REMOVED***

      // in case of rolling session, always reset the cookie
      if (!rollingSessions***REMOVED*** {

        // browser-session length cookie
        if (null == cookie.expires***REMOVED*** {
          if (!isNew***REMOVED*** {
            debug('already set browser-session cookie'***REMOVED***;
            writeHead.apply(res, arguments***REMOVED***;
            return
        ***REMOVED***
        // compare hashes and ids
      ***REMOVED*** else if (originalHash == hash(req.session***REMOVED*** && originalId == req.session.id***REMOVED*** {
          debug('unmodified session'***REMOVED***;
          writeHead.apply(res, arguments***REMOVED***;
          return
      ***REMOVED***

    ***REMOVED***

      var val = 's:' + signature.sign(req.sessionID, secret***REMOVED***;
      val = cookie.serialize(key, val***REMOVED***;
      debug('set-cookie %s', val***REMOVED***;
      res.setHeader('Set-Cookie', val***REMOVED***;
      writeHead.apply(res, arguments***REMOVED***;
  ***REMOVED***;

    // proxy end(***REMOVED*** to commit the session
    var end = res.end;
    res.end = function(data, encoding***REMOVED***{
      res.end = end;
      if (!req.session***REMOVED*** return res.end(data, encoding***REMOVED***;
      debug('saving'***REMOVED***;
      req.session.resetMaxAge(***REMOVED***;
      req.session.save(function(err***REMOVED***{
        if (err***REMOVED*** console.error(err.stack***REMOVED***;
        debug('saved'***REMOVED***;
        res.end(data, encoding***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED***;

    // generate the session
    function generate(***REMOVED*** {
      store.generate(req***REMOVED***;
  ***REMOVED***

    // get the sessionID from the cookie
    req.sessionID = unsignedCookie;

    // generate a session if the browser doesn't send a sessionID
    if (!req.sessionID***REMOVED*** {
      debug('no SID sent, generating session'***REMOVED***;
      generate(***REMOVED***;
      next(***REMOVED***;
      return;
  ***REMOVED***

    // generate the session object
    debug('fetching %s', req.sessionID***REMOVED***;
    store.get(req.sessionID, function(err, sess***REMOVED***{
      // error handling
      if (err***REMOVED*** {
        debug('error %j', err***REMOVED***;
        if ('ENOENT' == err.code***REMOVED*** {
          generate(***REMOVED***;
          next(***REMOVED***;
      ***REMOVED*** else {
          next(err***REMOVED***;
      ***REMOVED***
      // no session
    ***REMOVED*** else if (!sess***REMOVED*** {
        debug('no session found'***REMOVED***;
        generate(***REMOVED***;
        next(***REMOVED***;
      // populate req.session
    ***REMOVED*** else {
        debug('session found'***REMOVED***;
        store.createSession(req, sess***REMOVED***;
        originalId = req.sessionID;
        originalHash = hash(sess***REMOVED***;
        next(***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***;
};

/**
 * Hash the given `sess` object omitting changes
 * to `.cookie`.
 *
 * @param {Object} sess
 * @return {String}
 * @api private
 */

function hash(sess***REMOVED*** {
  return crc32.signed(JSON.stringify(sess, function(key, val***REMOVED***{
    if ('cookie' != key***REMOVED*** return val;
***REMOVED******REMOVED******REMOVED***;
}
