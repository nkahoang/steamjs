/**
 * Module dependencies.
 */

try {
  var EventEmitter = require('events'***REMOVED***.EventEmitter;
} catch (err***REMOVED*** {
  var Emitter = require('emitter'***REMOVED***;
}

/**
 * Noop.
 */

function noop(***REMOVED***{}

/**
 * Expose `Batch`.
 */

module.exports = Batch;

/**
 * Create a new Batch.
 */

function Batch(***REMOVED*** {
  if (!(this instanceof Batch***REMOVED******REMOVED*** return new Batch;
  this.fns = [];
  this.concurrency(Infinity***REMOVED***;
  this.throws(true***REMOVED***;
  for (var i = 0, len = arguments.length; i < len; ++i***REMOVED*** {
    this.push(arguments[i]***REMOVED***;
***REMOVED***
}

/**
 * Inherit from `EventEmitter.prototype`.
 */

if (EventEmitter***REMOVED*** {
  Batch.prototype.__proto__ = EventEmitter.prototype;
} else {
  Emitter(Batch.prototype***REMOVED***;
}

/**
 * Set concurrency to `n`.
 *
 * @param {Number} n
 * @return {Batch}
 * @api public
 */

Batch.prototype.concurrency = function(n***REMOVED***{
  this.n = n;
  return this;
};

/**
 * Queue a function.
 *
 * @param {Function} fn
 * @return {Batch}
 * @api public
 */

Batch.prototype.push = function(fn***REMOVED***{
  this.fns.push(fn***REMOVED***;
  return this;
};

/**
 * Set wether Batch will or will not throw up.
 *
 * @param  {Boolean} throws
 * @return {Batch}
 * @api public
 */
Batch.prototype.throws = function(throws***REMOVED*** {
  this.e = !!throws;
  return this;
};

/**
 * Execute all queued functions in parallel,
 * executing `cb(err, results***REMOVED***`.
 *
 * @param {Function} cb
 * @return {Batch}
 * @api public
 */

Batch.prototype.end = function(cb***REMOVED***{
  var self = this
    , total = this.fns.length
    , pending = total
    , results = []
    , errors = []
    , cb = cb || noop
    , fns = this.fns
    , max = this.n
    , throws = this.e
    , index = 0
    , done;

  // empty
  if (!fns.length***REMOVED*** return cb(null, results***REMOVED***;

  // process
  function next(***REMOVED*** {
    var i = index++;
    var fn = fns[i];
    if (!fn***REMOVED*** return;
    var start = new Date;

    try {
      fn(callback***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
      callback(err***REMOVED***;
  ***REMOVED***

    function callback(err, res***REMOVED***{
      if (done***REMOVED*** return;
      if (err && throws***REMOVED*** return done = true, cb(err***REMOVED***;
      var complete = total - pending + 1;
      var end = new Date;

      results[i] = res;
      errors[i] = err;

      self.emit('progress', {
        index: i,
        value: res,
        error: err,
        pending: pending,
        total: total,
        complete: complete,
        percent: complete / total * 100 | 0,
        start: start,
        end: end,
        duration: end - start
    ***REMOVED******REMOVED***;

      if (--pending***REMOVED*** next(***REMOVED***
      else if(!throws***REMOVED*** cb(errors, results***REMOVED***;
      else cb(null, results***REMOVED***;
  ***REMOVED***
***REMOVED***

  // concurrency
  for (var i = 0; i < fns.length; i++***REMOVED*** {
    if (i == max***REMOVED*** break;
    next(***REMOVED***;
***REMOVED***

  return this;
};
