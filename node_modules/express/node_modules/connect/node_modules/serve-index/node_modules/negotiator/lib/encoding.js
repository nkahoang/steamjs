module.exports = preferredEncodings;
preferredEncodings.preferredEncodings = preferredEncodings;

function parseAcceptEncoding(accept***REMOVED*** {
  var acceptableEncodings;

  if (accept***REMOVED*** {
    acceptableEncodings = accept.split(','***REMOVED***.map(function(e***REMOVED*** {
      return parseEncoding(e.trim(***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED*** else {
    acceptableEncodings = [];
***REMOVED***

  if (!acceptableEncodings.some(function(e***REMOVED*** {
    return e && specify('identity', e***REMOVED***;
***REMOVED******REMOVED******REMOVED*** {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     *
     */
    var lowestQ = 1;

    for(var i = 0; i < acceptableEncodings.length; i++***REMOVED***{
      var e = acceptableEncodings[i];
      if(e && e.q < lowestQ***REMOVED***{
        lowestQ = e.q;
    ***REMOVED***
  ***REMOVED***
    acceptableEncodings.push({
      encoding: 'identity',
      q: lowestQ / 2,
  ***REMOVED******REMOVED***;
***REMOVED***

  return acceptableEncodings.filter(function(e***REMOVED*** {
    return e;
***REMOVED******REMOVED***;
}

function parseEncoding(s***REMOVED*** {
  var match = s.match(/^\s*(\S+?***REMOVED***\s*(?:;(.****REMOVED******REMOVED***?$/***REMOVED***;

  if (!match***REMOVED*** return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]***REMOVED*** {
    var params = match[2].split(';'***REMOVED***;
    for (var i = 0; i < params.length; i ++***REMOVED*** {
      var p = params[i].trim(***REMOVED***.split('='***REMOVED***;
      if (p[0] === 'q'***REMOVED*** {
        q = parseFloat(p[1]***REMOVED***;
        break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  return {
    encoding: encoding,
    q: q
***REMOVED***;
}

function getEncodingPriority(encoding, accepted***REMOVED*** {
  return (accepted.map(function(a***REMOVED*** {
    return specify(encoding, a***REMOVED***;
***REMOVED******REMOVED***.filter(function(a***REMOVED***{
    return a;
***REMOVED******REMOVED***.sort(function (a, b***REMOVED*** {
    // revsort
    return a.s > b.s ? -1 : 1;
***REMOVED******REMOVED***[0] || {q:0}***REMOVED***.q;
}

function specify(encoding, spec***REMOVED*** {
  var s = 0;
  if(spec.encoding === encoding***REMOVED***{
    s |= 1;
***REMOVED*** else if (spec.encoding !== '*' ***REMOVED*** {
    return null
***REMOVED***

  return {
    s: s,
    q: spec.q,
***REMOVED***
};

function preferredEncodings(accept, provided***REMOVED*** {
  accept = parseAcceptEncoding(accept || ''***REMOVED***;
  if (provided***REMOVED*** {
    return provided.map(function(type***REMOVED*** {
      return [type, getEncodingPriority(type, accept***REMOVED***];
  ***REMOVED******REMOVED***.filter(function(pair***REMOVED*** {
      return pair[1] > 0;
  ***REMOVED******REMOVED***.sort(function(a, b***REMOVED*** {
      // revsort
      return a[1] === b[1] ? 0 : a[1] > b[1] ? -1 : 1;
  ***REMOVED******REMOVED***.map(function(pair***REMOVED*** {
      return pair[0];
  ***REMOVED******REMOVED***;
***REMOVED*** else {
    return accept.sort(function (a, b***REMOVED*** {
      // revsort
      return a.q < b.q ? 1 : -1;
  ***REMOVED******REMOVED***.filter(function(type***REMOVED***{
      return type.q > 0;
  ***REMOVED******REMOVED***.map(function(type***REMOVED*** {
      return type.encoding;
  ***REMOVED******REMOVED***;
***REMOVED***
}
