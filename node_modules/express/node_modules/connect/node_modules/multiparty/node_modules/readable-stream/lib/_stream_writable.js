// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"***REMOVED***, to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb***REMOVED***, and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer'***REMOVED***.Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is'***REMOVED***;
util.inherits = require('inherits'***REMOVED***;
/*</replacement>*/

var Stream = require('stream'***REMOVED***;

util.inherits(Writable, Stream***REMOVED***;

function WriteReq(chunk, encoding, cb***REMOVED*** {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream***REMOVED*** {
  options = options || {};

  // the point at which write(***REMOVED*** starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write(***REMOVED***
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0***REMOVED*** ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end(***REMOVED***
  this.ending = false;
  // when end(***REMOVED*** has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork(***REMOVED*** call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write(***REMOVED*** callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb***REMOVED***
  this.onwrite = function(er***REMOVED*** {
    onwrite(stream, er***REMOVED***;
***REMOVED***;

  // the callback that the user supplies to write(chunk,encoding,cb***REMOVED***
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options***REMOVED*** {
  var Duplex = require('./_stream_duplex'***REMOVED***;

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable***REMOVED*** && !(this instanceof Duplex***REMOVED******REMOVED***
    return new Writable(options***REMOVED***;

  this._writableState = new WritableState(options, this***REMOVED***;

  // legacy.
  this.writable = true;

  Stream.call(this***REMOVED***;
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function(***REMOVED*** {
  this.emit('error', new Error('Cannot pipe. Not readable.'***REMOVED******REMOVED***;
};


function writeAfterEnd(stream, state, cb***REMOVED*** {
  var er = new Error('write after end'***REMOVED***;
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er***REMOVED***;
  process.nextTick(function(***REMOVED*** {
    cb(er***REMOVED***;
***REMOVED******REMOVED***;
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb***REMOVED*** {
  var valid = true;
  if (!util.isBuffer(chunk***REMOVED*** &&
      !util.isString(chunk***REMOVED*** &&
      !util.isNullOrUndefined(chunk***REMOVED*** &&
      !state.objectMode***REMOVED*** {
    var er = new TypeError('Invalid non-string/buffer chunk'***REMOVED***;
    stream.emit('error', er***REMOVED***;
    process.nextTick(function(***REMOVED*** {
      cb(er***REMOVED***;
  ***REMOVED******REMOVED***;
    valid = false;
***REMOVED***
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb***REMOVED*** {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding***REMOVED******REMOVED*** {
    cb = encoding;
    encoding = null;
***REMOVED***

  if (util.isBuffer(chunk***REMOVED******REMOVED***
    encoding = 'buffer';
  else if (!encoding***REMOVED***
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb***REMOVED******REMOVED***
    cb = function(***REMOVED*** {};

  if (state.ended***REMOVED***
    writeAfterEnd(this, state, cb***REMOVED***;
  else if (validChunk(this, state, chunk, cb***REMOVED******REMOVED*** {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb***REMOVED***;
***REMOVED***

  return ret;
};

Writable.prototype.cork = function(***REMOVED*** {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function(***REMOVED*** {
  var state = this._writableState;

  if (state.corked***REMOVED*** {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length***REMOVED***
      clearBuffer(this, state***REMOVED***;
***REMOVED***
};

function decodeChunk(state, chunk, encoding***REMOVED*** {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk***REMOVED******REMOVED*** {
    chunk = new Buffer(chunk, encoding***REMOVED***;
***REMOVED***
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb***REMOVED*** {
  chunk = decodeChunk(state, chunk, encoding***REMOVED***;
  if (util.isBuffer(chunk***REMOVED******REMOVED***
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret***REMOVED***
    state.needDrain = true;

  if (state.writing || state.corked***REMOVED***
    state.buffer.push(new WriteReq(chunk, encoding, cb***REMOVED******REMOVED***;
  else
    doWrite(stream, state, false, len, chunk, encoding, cb***REMOVED***;

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb***REMOVED*** {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev***REMOVED***
    stream._writev(chunk, state.onwrite***REMOVED***;
  else
    stream._write(chunk, encoding, state.onwrite***REMOVED***;
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb***REMOVED*** {
  if (sync***REMOVED***
    process.nextTick(function(***REMOVED*** {
      state.pendingcb--;
      cb(er***REMOVED***;
  ***REMOVED******REMOVED***;
  else {
    state.pendingcb--;
    cb(er***REMOVED***;
***REMOVED***

  stream._writableState.errorEmitted = true;
  stream.emit('error', er***REMOVED***;
}

function onwriteStateUpdate(state***REMOVED*** {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er***REMOVED*** {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state***REMOVED***;

  if (er***REMOVED***
    onwriteError(stream, state, sync, er, cb***REMOVED***;
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state***REMOVED***;

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length***REMOVED*** {
      clearBuffer(stream, state***REMOVED***;
  ***REMOVED***

    if (sync***REMOVED*** {
      process.nextTick(function(***REMOVED*** {
        afterWrite(stream, state, finished, cb***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED*** else {
      afterWrite(stream, state, finished, cb***REMOVED***;
  ***REMOVED***
***REMOVED***
}

function afterWrite(stream, state, finished, cb***REMOVED*** {
  if (!finished***REMOVED***
    onwriteDrain(stream, state***REMOVED***;
  state.pendingcb--;
  cb(***REMOVED***;
  finishMaybe(stream, state***REMOVED***;
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write(***REMOVED*** consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state***REMOVED*** {
  if (state.length === 0 && state.needDrain***REMOVED*** {
    state.needDrain = false;
    stream.emit('drain'***REMOVED***;
***REMOVED***
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state***REMOVED*** {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1***REMOVED*** {
    // Fast case, write everything using _writev(***REMOVED***
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++***REMOVED***
      cbs.push(state.buffer[c].callback***REMOVED***;

    // count the one we are adding, as well.
    // TODO(isaacs***REMOVED*** clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err***REMOVED*** {
      for (var i = 0; i < cbs.length; i++***REMOVED*** {
        state.pendingcb--;
        cbs[i](err***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;

    // Clear buffer
    state.buffer = [];
***REMOVED*** else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++***REMOVED*** {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb***REMOVED***;

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing***REMOVED*** {
        c++;
        break;
    ***REMOVED***
  ***REMOVED***

    if (c < state.buffer.length***REMOVED***
      state.buffer = state.buffer.slice(c***REMOVED***;
    else
      state.buffer.length = 0;
***REMOVED***

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb***REMOVED*** {
  cb(new Error('not implemented'***REMOVED******REMOVED***;

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb***REMOVED*** {
  var state = this._writableState;

  if (util.isFunction(chunk***REMOVED******REMOVED*** {
    cb = chunk;
    chunk = null;
    encoding = null;
***REMOVED*** else if (util.isFunction(encoding***REMOVED******REMOVED*** {
    cb = encoding;
    encoding = null;
***REMOVED***

  if (!util.isNullOrUndefined(chunk***REMOVED******REMOVED***
    this.write(chunk, encoding***REMOVED***;

  // .end(***REMOVED*** fully uncorks
  if (state.corked***REMOVED*** {
    state.corked = 1;
    this.uncork(***REMOVED***;
***REMOVED***

  // ignore unnecessary end(***REMOVED*** calls.
  if (!state.ending && !state.finished***REMOVED***
    endWritable(this, state, cb***REMOVED***;
};


function needFinish(stream, state***REMOVED*** {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing***REMOVED***;
}

function prefinish(stream, state***REMOVED*** {
  if (!state.prefinished***REMOVED*** {
    state.prefinished = true;
    stream.emit('prefinish'***REMOVED***;
***REMOVED***
}

function finishMaybe(stream, state***REMOVED*** {
  var need = needFinish(stream, state***REMOVED***;
  if (need***REMOVED*** {
    if (state.pendingcb === 0***REMOVED*** {
      prefinish(stream, state***REMOVED***;
      state.finished = true;
      stream.emit('finish'***REMOVED***;
  ***REMOVED*** else
      prefinish(stream, state***REMOVED***;
***REMOVED***
  return need;
}

function endWritable(stream, state, cb***REMOVED*** {
  state.ending = true;
  finishMaybe(stream, state***REMOVED***;
  if (cb***REMOVED*** {
    if (state.finished***REMOVED***
      process.nextTick(cb***REMOVED***;
    else
      stream.once('finish', cb***REMOVED***;
***REMOVED***
  state.ended = true;
}
