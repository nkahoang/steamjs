exports.Form = Form;

var stream = require('readable-stream'***REMOVED***
  , util = require('util'***REMOVED***
  , fs = require('fs'***REMOVED***
  , crypto = require('crypto'***REMOVED***
  , ***REMOVED***
  , os = require('os'***REMOVED***
  , StringDecoder = require('string_decoder'***REMOVED***.StringDecoder
  , StreamCounter = require('stream-counter'***REMOVED***

var START = 0
  , START_BOUNDARY = 1
  , HEADER_FIELD_START = 2
  , HEADER_FIELD = 3
  , HEADER_VALUE_START = 4
  , HEADER_VALUE = 5
  , HEADER_VALUE_ALMOST_DONE = 6
  , HEADERS_ALMOST_DONE = 7
  , PART_DATA_START = 8
  , PART_DATA = 9
  , PART_END = 10
  , END = 11

  , LF = 10
  , CR = 13
  , SPACE = 32
  , HYPHEN = 45
  , COLON = 58
  , A = 97
  , Z = 122

var CONTENT_TYPE_RE = /^multipart\/(form-data|related***REMOVED***;\s*boundary=(?:"([^"]+***REMOVED***"|([^;]+***REMOVED******REMOVED***$/i;
var FILE_EXT_RE = /(\.[_\-a-zA-Z0-9]{0,16}***REMOVED***.*/;
var LAST_BOUNDARY_SUFFIX_LEN = 4; // --\r\n

util.inherits(Form, stream.Writable***REMOVED***;
function Form(options***REMOVED*** {
  var self = this;
  stream.Writable.call(self***REMOVED***;

  options = options || {};

  self.error = null;
  self.finished = false;

  self.autoFields = !!options.autoFields;
  self.autoFiles = !!options.autoFields;

  self.maxFields = options.maxFields || 1000;
  self.maxFieldsSize = options.maxFieldsSize || 2 * 1024 * 1024;
  self.uploadDir = options.uploadDir || os.tmpDir(***REMOVED***;
  self.encoding = options.encoding || 'utf8';
  self.hash = options.hash || false;

  self.bytesReceived = 0;
  self.bytesExpected = null;

  self.openedFiles = [];
  self.totalFieldSize = 0;
  self.totalFieldCount = 0;
  self.flushing = 0;

  self.backpressure = false;
  self.writeCbs = [];

  if (options.boundary***REMOVED*** setUpParser(self, options.boundary***REMOVED***;

  self.on('newListener', function(eventName***REMOVED*** {
    if (eventName === 'file'***REMOVED*** {
      self.autoFiles = true;
  ***REMOVED*** else if (eventName === 'field'***REMOVED*** {
      self.autoFields = true;
  ***REMOVED***
***REMOVED******REMOVED***;
}

Form.prototype.parse = function(req, cb***REMOVED*** {
  var self = this;

  // if the user supplies a callback, this implies autoFields and autoFiles
  if (cb***REMOVED*** {
    self.autoFields = true;
    self.autoFiles = true;
***REMOVED***

  self.handleError = handleError;
  self.bytesExpected = getBytesExpected(req.headers***REMOVED***;

  req.on('error', handleError***REMOVED***;
  req.on('aborted', onReqAborted***REMOVED***;

  var contentType = req.headers['content-type'];
  if (!contentType***REMOVED*** {
    handleError(new Error('missing content-type header'***REMOVED******REMOVED***;
    return;
***REMOVED***

  var m = contentType.match(CONTENT_TYPE_RE***REMOVED***;
  if (!m***REMOVED*** {
    handleError(new Error('unrecognized content-type: ' + contentType***REMOVED******REMOVED***;
    return;
***REMOVED***
  var boundary = m[2] || m[3];
  setUpParser(self, boundary***REMOVED***;
  req.pipe(self***REMOVED***;

  if (cb***REMOVED*** {
    var fieldsTable = {};
    var filesTable = {};
    var fieldsList = [];
    var filesList = [];
    self.on('error', function(err***REMOVED*** {
      cb(err***REMOVED***;
  ***REMOVED******REMOVED***;
    self.on('field', function(name, value***REMOVED*** {
      fieldsTable[name] = value;
      fieldsList.push({name: name, value: value}***REMOVED***;
  ***REMOVED******REMOVED***;
    self.on('file', function(name, file***REMOVED*** {
      filesTable[name] = file;
      filesList.push(file***REMOVED***;
  ***REMOVED******REMOVED***;
    self.on('close', function(***REMOVED*** {
      cb(null, fieldsTable, filesTable, fieldsList, filesList***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  function onReqAborted(***REMOVED*** {
    self.emit('aborted'***REMOVED***;
    handleError(new Error("Request aborted"***REMOVED******REMOVED***;
***REMOVED***

  function handleError(err***REMOVED*** {
    var first = !self.error;
    if (first***REMOVED*** {
      self.error = err;
      req.removeListener('aborted', onReqAborted***REMOVED***;

      // welp. 0.8 doesn't support unpipe, too bad so sad.
      // let's drop support for 0.8 soon.
      if (req.unpipe***REMOVED*** {
        req.unpipe(self***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    self.openedFiles.forEach(function(file***REMOVED*** {
      file.ws.destroy(***REMOVED***;
      fs.unlink(file.path, function(err***REMOVED*** {
        // this is already an error condition, ignore 2nd error
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
    self.openedFiles = [];

    if (first***REMOVED*** {
      self.emit('error', err***REMOVED***;
  ***REMOVED***
***REMOVED***

};

Form.prototype._write = function(buffer, encoding, cb***REMOVED*** {
  var self = this
    , i = 0
    , len = buffer.length
    , prevIndex = self.index
    , index = self.index
    , state = self.state
    , lookbehind = self.lookbehind
    , boundary = self.boundary
    , boundaryChars = self.boundaryChars
    , boundaryLength = self.boundary.length
    , boundaryEnd = boundaryLength - 1
    , bufferLength = buffer.length
    , c
    , cl

  for (i = 0; i < len; i++***REMOVED*** {
    c = buffer[i];
    switch (state***REMOVED*** {
      case START:
        index = 0;
        state = START_BOUNDARY;
        /* falls through */
      case START_BOUNDARY:
        if (index === boundaryLength - 2***REMOVED*** {
          if (c !== CR***REMOVED*** return self.handleError(new Error("Expected CR Received " + c***REMOVED******REMOVED***;
          index++;
          break;
      ***REMOVED*** else if (index === boundaryLength - 1***REMOVED*** {
          if (c !== LF***REMOVED*** return self.handleError(new Error("Expected LF Received " + c***REMOVED******REMOVED***;
          index = 0;
          self.onParsePartBegin(***REMOVED***;
          state = HEADER_FIELD_START;
          break;
      ***REMOVED***

        if (c !== boundary[index+2]***REMOVED*** index = -2;
        if (c === boundary[index+2]***REMOVED*** index++;
        break;
      case HEADER_FIELD_START:
        state = HEADER_FIELD;
        self.headerFieldMark = i;
        index = 0;
        /* falls through */
      case HEADER_FIELD:
        if (c === CR***REMOVED*** {
          self.headerFieldMark = null;
          state = HEADERS_ALMOST_DONE;
          break;
      ***REMOVED***

        index++;
        if (c === HYPHEN***REMOVED*** break;

        if (c === COLON***REMOVED*** {
          if (index === 1***REMOVED*** {
            // empty header field
            self.handleError(new Error("Empty header field"***REMOVED******REMOVED***;
            return;
        ***REMOVED***
          self.onParseHeaderField(buffer.slice(self.headerFieldMark, i***REMOVED******REMOVED***;
          self.headerFieldMark = null;
          state = HEADER_VALUE_START;
          break;
      ***REMOVED***

        cl = lower(c***REMOVED***;
        if (cl < A || cl > Z***REMOVED*** {
          self.handleError(new Error("Expected alphabetic character, received " + c***REMOVED******REMOVED***;
          return;
      ***REMOVED***
        break;
      case HEADER_VALUE_START:
        if (c === SPACE***REMOVED*** break;

        self.headerValueMark = i;
        state = HEADER_VALUE;
        /* falls through */
      case HEADER_VALUE:
        if (c === CR***REMOVED*** {
          self.onParseHeaderValue(buffer.slice(self.headerValueMark, i***REMOVED******REMOVED***;
          self.headerValueMark = null;
          self.onParseHeaderEnd(***REMOVED***;
          state = HEADER_VALUE_ALMOST_DONE;
      ***REMOVED***
        break;
      case HEADER_VALUE_ALMOST_DONE:
        if (c !== LF***REMOVED*** return self.handleError(new Error("Expected LF Received " + c***REMOVED******REMOVED***;
        state = HEADER_FIELD_START;
        break;
      case HEADERS_ALMOST_DONE:
        if (c !== LF***REMOVED*** return self.handleError(new Error("Expected LF Received " + c***REMOVED******REMOVED***;
        var err = self.onParseHeadersEnd(i + 1***REMOVED***;
        if (err***REMOVED*** return self.handleError(err***REMOVED***;
        state = PART_DATA_START;
        break;
      case PART_DATA_START:
        state = PART_DATA;
        self.partDataMark = i;
        /* falls through */
      case PART_DATA:
        prevIndex = index;

        if (index === 0***REMOVED*** {
          // boyer-moore derrived algorithm to safely skip non-boundary data
          i += boundaryEnd;
          while (i < bufferLength && !(buffer[i] in boundaryChars***REMOVED******REMOVED*** {
            i += boundaryLength;
        ***REMOVED***
          i -= boundaryEnd;
          c = buffer[i];
      ***REMOVED***

        if (index < boundaryLength***REMOVED*** {
          if (boundary[index] === c***REMOVED*** {
            if (index === 0***REMOVED*** {
              self.onParsePartData(buffer.slice(self.partDataMark, i***REMOVED******REMOVED***;
              self.partDataMark = null;
          ***REMOVED***
            index++;
        ***REMOVED*** else {
            index = 0;
        ***REMOVED***
      ***REMOVED*** else if (index === boundaryLength***REMOVED*** {
          index++;
          if (c === CR***REMOVED*** {
            // CR = part boundary
            self.partBoundaryFlag = true;
        ***REMOVED*** else if (c === HYPHEN***REMOVED*** {
            // HYPHEN = end boundary
            self.lastBoundaryFlag = true;
        ***REMOVED*** else {
            index = 0;
        ***REMOVED***
      ***REMOVED*** else if (index - 1 === boundaryLength***REMOVED***  {
          if (self.partBoundaryFlag***REMOVED*** {
            index = 0;
            if (c === LF***REMOVED*** {
              self.partBoundaryFlag = false;
              self.onParsePartEnd(***REMOVED***;
              self.onParsePartBegin(***REMOVED***;
              state = HEADER_FIELD_START;
              break;
          ***REMOVED***
        ***REMOVED*** else if (self.lastBoundaryFlag***REMOVED*** {
            if (c === HYPHEN***REMOVED*** {
              self.onParsePartEnd(***REMOVED***;
              self.end(***REMOVED***;
              state = END;
          ***REMOVED*** else {
              index = 0;
          ***REMOVED***
        ***REMOVED*** else {
            index = 0;
        ***REMOVED***
      ***REMOVED***

        if (index > 0***REMOVED*** {
          // when matching a possible boundary, keep a lookbehind reference
          // in case it turns out to be a false lead
          lookbehind[index-1] = c;
      ***REMOVED*** else if (prevIndex > 0***REMOVED*** {
          // if our boundary turned out to be rubbish, the captured lookbehind
          // belongs to partData
          self.onParsePartData(lookbehind.slice(0, prevIndex***REMOVED******REMOVED***;
          prevIndex = 0;
          self.partDataMark = i;

          // reconsider the current character even so it interrupted the sequence
          // it could be the beginning of a new sequence
          i--;
      ***REMOVED***

        break;
      case END:
        break;
      default:
        self.handleError(new Error("Parser has invalid state."***REMOVED******REMOVED***;
        return;
  ***REMOVED***
***REMOVED***

  if (self.headerFieldMark != null***REMOVED*** {
    self.onParseHeaderField(buffer.slice(self.headerFieldMark***REMOVED******REMOVED***;
    self.headerFieldMark = 0;
***REMOVED***
  if (self.headerValueMark != null***REMOVED*** {
    self.onParseHeaderValue(buffer.slice(self.headerValueMark***REMOVED******REMOVED***;
    self.headerValueMark = 0;
***REMOVED***
  if (self.partDataMark != null***REMOVED*** {
    self.onParsePartData(buffer.slice(self.partDataMark***REMOVED******REMOVED***;
    self.partDataMark = 0;
***REMOVED***

  self.index = index;
  self.state = state;

  self.bytesReceived += buffer.length;
  self.emit('progress', self.bytesReceived, self.bytesExpected***REMOVED***;

  if (self.backpressure***REMOVED*** {
    self.writeCbs.push(cb***REMOVED***;
***REMOVED*** else {
    cb(***REMOVED***;
***REMOVED***
};

Form.prototype.onParsePartBegin = function(***REMOVED*** {
  clearPartVars(this***REMOVED***;
}

Form.prototype.onParseHeaderField = function(b***REMOVED*** {
  this.headerField += this.headerFieldDecoder.write(b***REMOVED***;
}

Form.prototype.onParseHeaderValue = function(b***REMOVED*** {
  this.headerValue += this.headerValueDecoder.write(b***REMOVED***;
}

Form.prototype.onParseHeaderEnd = function(***REMOVED*** {
  this.headerField = this.headerField.toLowerCase(***REMOVED***;
  this.partHeaders[this.headerField] = this.headerValue;

  var m;
  if (this.headerField === 'content-disposition'***REMOVED*** {
    if (m = this.headerValue.match(/\bname="([^"]+***REMOVED***"/i***REMOVED******REMOVED*** {
      this.partName = m[1];
  ***REMOVED***
    this.partFilename = parseFilename(this.headerValue***REMOVED***;
***REMOVED*** else if (this.headerField === 'content-transfer-encoding'***REMOVED*** {
    this.partTransferEncoding = this.headerValue.toLowerCase(***REMOVED***;
***REMOVED***

  this.headerFieldDecoder = new StringDecoder(this.encoding***REMOVED***;
  this.headerField = '';
  this.headerValueDecoder = new StringDecoder(this.encoding***REMOVED***;
  this.headerValue = '';
}

Form.prototype.onParsePartData = function(b***REMOVED*** {
  if (this.partTransferEncoding === 'base64'***REMOVED*** {
    this.backpressure = ! this.destStream.write(b.toString('ascii'***REMOVED***, 'base64'***REMOVED***;
***REMOVED*** else {
    this.backpressure = ! this.destStream.write(b***REMOVED***;
***REMOVED***
}

Form.prototype.onParsePartEnd = function(***REMOVED*** {
  if (this.destStream***REMOVED*** {
    flushWriteCbs(this***REMOVED***;
    var s = this.destStream;
    process.nextTick(function(***REMOVED*** {
      s.end(***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***
  clearPartVars(this***REMOVED***;
}

Form.prototype.onParseHeadersEnd = function(offset***REMOVED*** {
  var self = this;
  switch(self.partTransferEncoding***REMOVED***{
    case 'binary':
    case '7bit':
    case '8bit':
    self.partTransferEncoding = 'binary';
    break;

    case 'base64': break;
    default:
    return new Error("unknown transfer-encoding: " + self.partTransferEncoding***REMOVED***;
***REMOVED***

  self.totalFieldCount += 1;
  if (self.totalFieldCount >= self.maxFields***REMOVED*** {
    return new Error("maxFields " + self.maxFields + " exceeded."***REMOVED***;
***REMOVED***

  self.destStream = new stream.PassThrough(***REMOVED***;
  self.destStream.on('drain', function(***REMOVED*** {
    flushWriteCbs(self***REMOVED***;
***REMOVED******REMOVED***;
  self.destStream.headers = self.partHeaders;
  self.destStream.name = self.partName;
  self.destStream.filename = self.partFilename;
  self.destStream.byteOffset = self.bytesReceived + offset;
  var partContentLength = self.destStream.headers['content-length'];
  self.destStream.byteCount = partContentLength ?
    parseInt(partContentLength, 10***REMOVED*** :
    (self.bytesExpected - self.destStream.byteOffset -
     self.boundary.length - LAST_BOUNDARY_SUFFIX_LEN***REMOVED***;

  self.emit('part', self.destStream***REMOVED***;
  if (self.destStream.filename == null && self.autoFields***REMOVED*** {
    handleField(self, self.destStream***REMOVED***;
***REMOVED*** else if (self.destStream.filename != null && self.autoFiles***REMOVED*** {
    handleFile(self, self.destStream***REMOVED***;
***REMOVED***
}

function flushWriteCbs(self***REMOVED*** {
  self.writeCbs.forEach(function(cb***REMOVED*** {
    process.nextTick(cb***REMOVED***;
***REMOVED******REMOVED***;
  self.writeCbs = [];
  self.backpressure = false;
}

function getBytesExpected(headers***REMOVED*** {
  var contentLength = headers['content-length'];
  if (contentLength***REMOVED*** {
    return parseInt(contentLength, 10***REMOVED***;
***REMOVED*** else if (headers['transfer-encoding'] == null***REMOVED*** {
    return 0;
***REMOVED*** else {
    return null;
***REMOVED***
}

function beginFlush(self***REMOVED*** {
  self.flushing += 1;
}

function endFlush(self***REMOVED*** {
  self.flushing -= 1;
  maybeClose(self***REMOVED***;
}

function maybeClose(self***REMOVED*** {
  if (!self.flushing && self.finished && !self.error***REMOVED*** {
    self.emit('close'***REMOVED***;
***REMOVED***
}

function handleFile(self, fileStream***REMOVED*** {
  beginFlush(self***REMOVED***;
  var file = {
    fieldName: fileStream.name,
    originalFilename: fileStream.filename,
    path: uploadPath(self.uploadDir, fileStream.filename***REMOVED***,
    headers: fileStream.headers,
***REMOVED***;
  file.ws = fs.createWriteStream(file.path***REMOVED***;
  self.openedFiles.push(file***REMOVED***;
  fileStream.pipe(file.ws***REMOVED***;
  var counter = new StreamCounter(***REMOVED***;
  fileStream.pipe(counter***REMOVED***;
  var hashWorkaroundStream
    , hash = null;
  if (self.hash***REMOVED*** {
    // workaround stream because https://github.com/joyent/node/issues/5216
    hashWorkaroundStream = stream.Writable(***REMOVED***;
    hash = crypto.createHash(self.hash***REMOVED***;
    hashWorkaroundStream._write = function(buffer, encoding, callback***REMOVED*** {
      hash.update(buffer***REMOVED***;
      callback(***REMOVED***;
  ***REMOVED***;
    fileStream.pipe(hashWorkaroundStream***REMOVED***;
***REMOVED***
  file.ws.on('error', function(err***REMOVED*** {
    if (!self.error***REMOVED*** self.handleError(err***REMOVED***;
***REMOVED******REMOVED***;
  file.ws.on('close', function(***REMOVED*** {
    if (hash***REMOVED*** file.hash = hash.digest('hex'***REMOVED***;
    file.size = counter.bytes;
    self.emit('file', fileStream.name, file***REMOVED***;
    endFlush(self***REMOVED***;
***REMOVED******REMOVED***;
}

function handleField(self, fieldStream***REMOVED*** {
  var value = '';
  var decoder = new StringDecoder(self.encoding***REMOVED***;

  beginFlush(self***REMOVED***;
  fieldStream.on('readable', function(***REMOVED*** {
    var buffer = fieldStream.read(***REMOVED***;
    if (!buffer***REMOVED*** return;

    self.totalFieldSize += buffer.length;
    if (self.totalFieldSize > self.maxFieldsSize***REMOVED*** {
      self.handleError(new Error("maxFieldsSize " + self.maxFieldsSize + " exceeded"***REMOVED******REMOVED***;
      return;
  ***REMOVED***
    value += decoder.write(buffer***REMOVED***;
***REMOVED******REMOVED***;

  fieldStream.on('end', function(***REMOVED*** {
    self.emit('field', fieldStream.name, value***REMOVED***;
    endFlush(self***REMOVED***;
***REMOVED******REMOVED***;
}

function clearPartVars(self***REMOVED*** {
  self.partHeaders = {};
  self.partName = null;
  self.partFilename = null;
  self.partTransferEncoding = 'binary';
  self.destStream = null;

  self.headerFieldDecoder = new StringDecoder(self.encoding***REMOVED***;
  self.headerField = "";
  self.headerValueDecoder = new StringDecoder(self.encoding***REMOVED***;
  self.headerValue = "";
}

function setUpParser(self, boundary***REMOVED*** {
  self.boundary = new Buffer(boundary.length + 4***REMOVED***;
  self.boundary.write('\r\n--', 0, boundary.length + 4, 'ascii'***REMOVED***;
  self.boundary.write(boundary, 4, boundary.length, 'ascii'***REMOVED***;
  self.lookbehind = new Buffer(self.boundary.length + 8***REMOVED***;
  self.state = START;
  self.boundaryChars = {};
  for (var i = 0; i < self.boundary.length; i++***REMOVED*** {
    self.boundaryChars[self.boundary[i]] = true;
***REMOVED***

  self.index = null;
  self.partBoundaryFlag = false;
  self.lastBoundaryFlag = false;

  self.on('finish', function(***REMOVED*** {
    if ((self.state === HEADER_FIELD_START && self.index === 0***REMOVED*** ||
        (self.state === PART_DATA && self.index === self.boundary.length***REMOVED******REMOVED***
    {
      self.onParsePartEnd(***REMOVED***;
  ***REMOVED*** else if (self.state !== END***REMOVED*** {
      self.handleError(new Error('stream ended unexpectedly'***REMOVED******REMOVED***;
  ***REMOVED***
    self.finished = true;
    maybeClose(self***REMOVED***;
***REMOVED******REMOVED***;
}

function uploadPath(baseDir, filename***REMOVED*** {
  var ext = path.extname(filename***REMOVED***.replace(FILE_EXT_RE, '$1'***REMOVED***;
  var name = process.pid + '-' +
    (Math.random(***REMOVED*** * 0x100000000 + 1***REMOVED***.toString(36***REMOVED*** + ext;
  return path.join(baseDir, name***REMOVED***;
}

function parseFilename(headerValue***REMOVED*** {
  var m = headerValue.match(/\bfilename="(.*?***REMOVED***"($|; ***REMOVED***/i***REMOVED***;
  if (!m***REMOVED*** return;

  var filename = m[1].substr(m[1].lastIndexOf('\\'***REMOVED*** + 1***REMOVED***;
  filename = filename.replace(/%22/g, '"'***REMOVED***;
  filename = filename.replace(/&#([\d]{4}***REMOVED***;/g, function(m, code***REMOVED*** {
    return String.fromCharCode(code***REMOVED***;
***REMOVED******REMOVED***;
  return filename;
}

function lower(c***REMOVED*** {
  return c | 0x20;
}

