/*!
 * Connect - multipart
 * Copyright(c***REMOVED*** 2010 Sencha Inc.
 * Copyright(c***REMOVED*** 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var multiparty = require('multiparty'***REMOVED***
  , _limit = require('./limit'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , qs = require('qs'***REMOVED***;

/**
 * Multipart:
 *
 * Status: Deprecated. The multipart parser will be removed in Connect 3.0.
 * Please use one of the following parsers/middleware directly:
 *
 *   - [formidable](https://github.com/felixge/node-formidable***REMOVED***
 *   - [connect-multiparty](https://github.com/superjoe30/connect-multiparty***REMOVED*** or [multiparty]
 *   - [connect-busboy](https://github.com/mscdex/connect-busboy***REMOVED*** or [busboy](https://github.com/mscdex/busboy***REMOVED***
 *
 * Parse multipart/form-data request bodies,
 * providing the parsed object as `req.body`
 * and `req.files`.
 *
 * Configuration:
 *
 *  The options passed are merged with [multiparty](https://github.com/superjoe30/node-multiparty***REMOVED***'s
 *  `Form` object, allowing you to configure the upload directory,
 *  size limits, etc. For example if you wish to change the upload dir do the following.
 *
 *     app.use(connect.multipart({ uploadDir: path }***REMOVED******REMOVED***;
 *
 * Options:
 *
 *   - `limit`  byte limit defaulting to [100mb]
 *   - `defer`  defers processing and exposes the multiparty form object as `req.form`.
 *              `next(***REMOVED***` is called without waiting for the form's "end" event.
 *              This option is useful if you need to bind to the "progress" or "part" events, for example.
 *
 * Temporary Files:
 *
 *  By default temporary files are used, stored in `os.tmpDir(***REMOVED***`. These
 *  are not automatically garbage collected, you are in charge of moving them
 *  or deleting them. When `defer` is not used and these files are created you
 *  may refernce them via the `req.files` object.
 *
 *     req.files.images.forEach(function(file***REMOVED***{
 *       console.log('  uploaded : %s %skb : %s', file.originalFilename, file.size / 1024 | 0, file.path***REMOVED***;
 *   ***REMOVED******REMOVED***;
 *
 *  It is highly recommended to monitor and clean up tempfiles in any production
 *  environment, you may use tools like [reap](https://github.com/visionmedia/reap***REMOVED***
 *  to do so.
 *
 * Streaming:
 *
 *  When `defer` is used files are _not_ streamed to tmpfiles, you may
 *  access them via the "part" events and stream them accordingly:
 *
 *     req.form.on('part', function(part***REMOVED***{
 *       // transfer to s3 etc
 *       console.log('upload %s %s', part.name, part.filename***REMOVED***;
 *       var out = fs.createWriteStream('/tmp/' + part.filename***REMOVED***;
 *       part.pipe(out***REMOVED***;
 *   ***REMOVED******REMOVED***;
 *
 *     req.form.on('close', function(***REMOVED***{
 *       res.end('uploaded!'***REMOVED***;
 *   ***REMOVED******REMOVED***;
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */

exports = module.exports = function(options***REMOVED***{
  options = options || {};

  if (process.env.NODE_ENV !== 'test'***REMOVED*** {
    console.warn('connect.multipart(***REMOVED*** will be removed in connect 3.0'***REMOVED***;
    console.warn('visit https://github.com/senchalabs/connect/wiki/Connect-3.0 for alternatives'***REMOVED***;
***REMOVED***

  var limit = _limit(options.limit || '100mb'***REMOVED***;

  return function multipart(req, res, next***REMOVED*** {
    if (req._body***REMOVED*** return next(***REMOVED***;
    req.body = req.body || {};
    req.files = req.files || {};

    if (!utils.hasBody(req***REMOVED******REMOVED*** return next(***REMOVED***;

    // ignore GET
    if ('GET' == req.method || 'HEAD' == req.method***REMOVED*** return next(***REMOVED***;

    // check Content-Type
    if ('multipart/form-data' != utils.mime(req***REMOVED******REMOVED*** return next(***REMOVED***;

    // flag as parsed
    req._body = true;

    // parse
    limit(req, res, function(err***REMOVED***{
      if (err***REMOVED*** return next(err***REMOVED***;

      var form = new multiparty.Form(options***REMOVED***
        , data = {}
        , files = {}
        , done;

      Object.keys(options***REMOVED***.forEach(function(key***REMOVED***{
        form[key] = options[key];
    ***REMOVED******REMOVED***;

      function ondata(name, val, data***REMOVED***{
        if (Array.isArray(data[name]***REMOVED******REMOVED*** {
          data[name].push(val***REMOVED***;
      ***REMOVED*** else if (data[name]***REMOVED*** {
          data[name] = [data[name], val];
      ***REMOVED*** else {
          data[name] = val;
      ***REMOVED***
    ***REMOVED***

      form.on('field', function(name, val***REMOVED***{
        ondata(name, val, data***REMOVED***;
    ***REMOVED******REMOVED***;

      if (!options.defer***REMOVED*** {
        form.on('file', function(name, val***REMOVED***{
          val.name = val.originalFilename;
          val.type = val.headers['content-type'] || null;
          ondata(name, val, files***REMOVED***;
      ***REMOVED******REMOVED***;
    ***REMOVED***

      form.on('error', function(err***REMOVED***{
        if (!options.defer***REMOVED*** {
          err.status = 400;
          next(err***REMOVED***;
      ***REMOVED***
        done = true;
    ***REMOVED******REMOVED***;

      form.on('close', function(***REMOVED***{
        if (done***REMOVED*** return;
        try {
          req.body = qs.parse(data***REMOVED***;
          req.files = qs.parse(files***REMOVED***;
      ***REMOVED*** catch (err***REMOVED*** {
          form.emit('error', err***REMOVED***;
          return;
      ***REMOVED***
        if (!options.defer***REMOVED*** next(***REMOVED***;
    ***REMOVED******REMOVED***;

      form.parse(req***REMOVED***;

      if (options.defer***REMOVED*** {
        req.form = form;
        next(***REMOVED***;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***
};
