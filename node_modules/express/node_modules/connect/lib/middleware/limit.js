
/*!
 * Connect - limit
 * Copyright(c***REMOVED*** 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('../utils'***REMOVED***,
  brokenPause = utils.brokenPause;

/**
 * Limit:
 *
 *   Status: Deprecated. This middleware will be removed in Connect 3.0.
 *   If you still wish to use some type of limit middleware,
 *   you may be interested in:
 *
 *     - [raw-body](https://github.com/stream-utils/raw-body***REMOVED***
 *
 *   Limit request bodies to the given size in `bytes`.
 *
 *   A string representation of the bytesize may also be passed,
 *   for example "5mb", "200kb", "1gb", etc.
 *
 *     connect(***REMOVED***
 *       .use(connect.limit('5.5mb'***REMOVED******REMOVED***
 *       .use(handleImageUpload***REMOVED***
 *
 * @param {Number|String} bytes
 * @return {Function}
 * @api public
 */

module.exports = function limit(bytes***REMOVED***{
  if ('string' == typeof bytes***REMOVED*** bytes = utils.parseBytes(bytes***REMOVED***;
  if ('number' != typeof bytes***REMOVED*** throw new Error('limit(***REMOVED*** bytes required'***REMOVED***;

  if (process.env.NODE_ENV !== 'test'***REMOVED*** {
    console.warn('connect.limit(***REMOVED*** will be removed in connect 3.0'***REMOVED***;
***REMOVED***

  return function limit(req, res, next***REMOVED***{
    var received = 0
      , len = req.headers['content-length']
        ? parseInt(req.headers['content-length'], 10***REMOVED***
        : null;

    // self-awareness
    if (req._limit***REMOVED*** return next(***REMOVED***;
    req._limit = true;

    // limit by content-length
    if (len && len > bytes***REMOVED*** return next(utils.error(413***REMOVED******REMOVED***;

    // limit
    if (brokenPause***REMOVED*** {
      listen(***REMOVED***;
  ***REMOVED*** else {
      req.on('newListener', function handler(event***REMOVED*** {
        if (event !== 'data'***REMOVED*** return;

        req.removeListener('newListener', handler***REMOVED***;
        // Start listening at the end of the current loop
        // otherwise the request will be consumed too early.
        // Sideaffect is `limit` will miss the first chunk,
        // but that's not a big deal.
        // Unfortunately, the tests don't have large enough
        // request bodies to test this.
        process.nextTick(listen***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED***;

    next(***REMOVED***;

    function listen(***REMOVED*** {
      req.on('data', function(chunk***REMOVED*** {
        received += Buffer.isBuffer(chunk***REMOVED***
          ? chunk.length :
          Buffer.byteLength(chunk***REMOVED***;

        if (received > bytes***REMOVED*** req.destroy(***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED***;
***REMOVED***;
};