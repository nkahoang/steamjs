
/*!
 * Connect - staticCache
 * Copyright(c***REMOVED*** 2011 Sencha Inc.
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('../utils'***REMOVED***
  , Cache = require('../cache'***REMOVED***
  , fresh = require('fresh'***REMOVED***;

/**
 * Static cache:
 *
 * Status: Deprecated. This middleware will be removed in
 * Connect 3.0. You may be interested in:
 *
 *   - [st](https://github.com/isaacs/st***REMOVED***
 *
 * Enables a memory cache layer on top of
 * the `static(***REMOVED***` middleware, serving popular
 * static files.
 *
 * By default a maximum of 128 objects are
 * held in cache, with a max of 256k each,
 * totalling ~32mb.
 *
 * A Least-Recently-Used (LRU***REMOVED*** cache algo
 * is implemented through the `Cache` object,
 * simply rotating cache objects as they are
 * hit. This means that increasingly popular
 * objects maintain their positions while
 * others get shoved out of the stack and
 * garbage collected.
 *
 * Benchmarks:
 *
 *     static(***REMOVED***: 2700 rps
 *     node-static: 5300 rps
 *     static(***REMOVED*** + staticCache(***REMOVED***: 7500 rps
 *
 * Options:
 *
 *   - `maxObjects`  max cache objects [128]
 *   - `maxLength`  max cache object length 256kb
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function staticCache(options***REMOVED***{
  var options = options || {}
    , cache = new Cache(options.maxObjects || 128***REMOVED***
    , maxlen = options.maxLength || 1024 * 256;

  if (process.env.NODE_ENV !== 'test'***REMOVED*** {
    console.warn('connect.staticCache(***REMOVED*** is deprecated and will be removed in 3.0'***REMOVED***;
    console.warn('use varnish or similar reverse proxy caches.'***REMOVED***;
***REMOVED***

  return function staticCache(req, res, next***REMOVED***{
    var key = cacheKey(req***REMOVED***
      , ranges = req.headers.range
      , hasCookies = req.headers.cookie
      , hit = cache.get(key***REMOVED***;

    // cache static
    // TODO: change from staticCache(***REMOVED*** -> cache(***REMOVED***
    // and make this work for any request
    req.on('static', function(stream***REMOVED***{
      var headers = res._headers
        , cc = utils.parseCacheControl(headers['cache-control'] || ''***REMOVED***
        , contentLength = headers['content-length']
        , hit;

      // dont cache set-cookie responses
      if (headers['set-cookie']***REMOVED*** return hasCookies = true;

      // dont cache when cookies are present
      if (hasCookies***REMOVED*** return;

      // ignore larger files
      if (!contentLength || contentLength > maxlen***REMOVED*** return;

      // don't cache partial files
      if (headers['content-range']***REMOVED*** return;

      // dont cache items we shouldn't be
      // TODO: real support for must-revalidate / no-cache
      if ( cc['no-cache']
        || cc['no-store']
        || cc['private']
        || cc['must-revalidate']***REMOVED*** return;

      // if already in cache then validate
      if (hit = cache.get(key***REMOVED******REMOVED***{
        if (headers.etag == hit[0].etag***REMOVED*** {
          hit[0].date = new Date;
          return;
      ***REMOVED*** else {
          cache.remove(key***REMOVED***;
      ***REMOVED***
    ***REMOVED***

      // validation notifiactions don't contain a steam
      if (null == stream***REMOVED*** return;

      // add the cache object
      var arr = [];

      // store the chunks
      stream.on('data', function(chunk***REMOVED***{
        arr.push(chunk***REMOVED***;
    ***REMOVED******REMOVED***;

      // flag it as complete
      stream.on('end', function(***REMOVED***{
        var cacheEntry = cache.add(key***REMOVED***;
        delete headers['x-cache']; // Clean up (TODO: others***REMOVED***
        cacheEntry.push(200***REMOVED***;
        cacheEntry.push(headers***REMOVED***;
        cacheEntry.push.apply(cacheEntry, arr***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;

    if (req.method == 'GET' || req.method == 'HEAD'***REMOVED*** {
      if (ranges***REMOVED*** {
        next(***REMOVED***;
    ***REMOVED*** else if (!hasCookies && hit && !mustRevalidate(req, hit***REMOVED******REMOVED*** {
        res.setHeader('X-Cache', 'HIT'***REMOVED***;
        respondFromCache(req, res, hit***REMOVED***;
    ***REMOVED*** else {
        res.setHeader('X-Cache', 'MISS'***REMOVED***;
        next(***REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      next(***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Respond with the provided cached value.
 * TODO: Assume 200 code, that's iffy.
 *
 * @param {Object} req
 * @param {Object} res
 * @param {Object} cacheEntry
 * @return {String}
 * @api private
 */

function respondFromCache(req, res, cacheEntry***REMOVED*** {
  var status = cacheEntry[0]
    , headers = utils.merge({}, cacheEntry[1]***REMOVED***
    , content = cacheEntry.slice(2***REMOVED***;

  headers.age = (new Date - new Date(headers.date***REMOVED******REMOVED*** / 1000 || 0;

  switch (req.method***REMOVED*** {
    case 'HEAD':
      res.writeHead(status, headers***REMOVED***;
      res.end(***REMOVED***;
      break;
    case 'GET':
      if (utils.conditionalGET(req***REMOVED*** && fresh(req.headers, headers***REMOVED******REMOVED*** {
        headers['content-length'] = 0;
        res.writeHead(304, headers***REMOVED***;
        res.end(***REMOVED***;
    ***REMOVED*** else {
        res.writeHead(status, headers***REMOVED***;

        function write(***REMOVED*** {
          while (content.length***REMOVED*** {
            if (false === res.write(content.shift(***REMOVED******REMOVED******REMOVED*** {
              res.once('drain', write***REMOVED***;
              return;
          ***REMOVED***
        ***REMOVED***
          res.end(***REMOVED***;
      ***REMOVED***

        write(***REMOVED***;
    ***REMOVED***
      break;
    default:
      // This should never happen.
      res.writeHead(500, ''***REMOVED***;
      res.end(***REMOVED***;
***REMOVED***
}

/**
 * Determine whether or not a cached value must be revalidated.
 *
 * @param {Object} req
 * @param {Object} cacheEntry
 * @return {String}
 * @api private
 */

function mustRevalidate(req, cacheEntry***REMOVED*** {
  var cacheHeaders = cacheEntry[1]
    , reqCC = utils.parseCacheControl(req.headers['cache-control'] || ''***REMOVED***
    , cacheCC = utils.parseCacheControl(cacheHeaders['cache-control'] || ''***REMOVED***
    , cacheAge = (new Date - new Date(cacheHeaders.date***REMOVED******REMOVED*** / 1000 || 0;

  if ( cacheCC['no-cache']
    || cacheCC['must-revalidate']
    || cacheCC['proxy-revalidate']***REMOVED*** return true;

  if (reqCC['no-cache']***REMOVED*** return true;

  if (null != reqCC['max-age']***REMOVED*** return reqCC['max-age'] < cacheAge;

  if (null != cacheCC['max-age']***REMOVED*** return cacheCC['max-age'] < cacheAge;

  return false;
}

/**
 * The key to use in the cache. For now, this is the URL path and query.
 *
 * 'http://example.com?key=value' -> '/?key=value'
 *
 * @param {Object} req
 * @return {String}
 * @api private
 */

function cacheKey(req***REMOVED*** {
  return utils.parseUrl(req***REMOVED***.path;
}
