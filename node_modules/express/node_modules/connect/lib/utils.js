
/*!
 * Connect - utils
 * Copyright(c***REMOVED*** 2010 Sencha Inc.
 * Copyright(c***REMOVED*** 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var ***REMOVED***
  , crypto = require('crypto'***REMOVED***
  , parse = require('url'***REMOVED***.parse
  , sep = require('path'***REMOVED***.sep
  , signature = require('cookie-signature'***REMOVED***
  , nodeVersion = process.versions.node.split('.'***REMOVED***;

// pause is broken in node < 0.10
exports.brokenPause = parseInt(nodeVersion[0], 10***REMOVED*** === 0
  && parseInt(nodeVersion[1], 10***REMOVED*** < 10;

/**
 * Return `true` if the request has a body, otherwise return `false`.
 *
 * @param  {IncomingMessage} req
 * @return {Boolean}
 * @api private
 */

exports.hasBody = function(req***REMOVED*** {
  var encoding = 'transfer-encoding' in req.headers;
  var length = 'content-length' in req.headers && req.headers['content-length'] !== '0';
  return encoding || length;
};

/**
 * Extract the mime type from the given request's
 * _Content-Type_ header.
 *
 * @param  {IncomingMessage} req
 * @return {String}
 * @api private
 */

exports.mime = function(req***REMOVED*** {
  var str = req.headers['content-type'] || ''
    , i = str.indexOf(';'***REMOVED***;
  return ~i ? str.slice(0, i***REMOVED*** : str;
};

/**
 * Generate an `Error` from the given status `code`
 * and optional `msg`.
 *
 * @param {Number} code
 * @param {String} msg
 * @return {Error}
 * @api private
 */

exports.error = function(code, msg***REMOVED***{
  var err = new Error(msg || http.STATUS_CODES[code]***REMOVED***;
  err.status = code;
  return err;
};

/**
 * Return md5 hash of the given string and optional encoding,
 * defaulting to hex.
 *
 *     utils.md5('wahoo'***REMOVED***;
 *     // => "e493298061761236c96b02ea6aa8a2ad"
 *
 * @param {String} str
 * @param {String} encoding
 * @return {String}
 * @api private
 */

exports.md5 = function(str, encoding***REMOVED***{
  return crypto
    .createHash('md5'***REMOVED***
    .update(str, 'utf8'***REMOVED***
    .digest(encoding || 'hex'***REMOVED***;
};

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     utils.merge(a, b***REMOVED***;
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api private
 */

exports.merge = function(a, b***REMOVED***{
  if (a && b***REMOVED*** {
    for (var key in b***REMOVED*** {
      a[key] = b[key];
  ***REMOVED***
***REMOVED***
  return a;
};

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html***REMOVED***{
  return String(html***REMOVED***
    .replace(/&(?!\w+;***REMOVED***/g, '&amp;'***REMOVED***
    .replace(/</g, '&lt;'***REMOVED***
    .replace(/>/g, '&gt;'***REMOVED***
    .replace(/"/g, '&quot;'***REMOVED***;
};

/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function(val, secret***REMOVED***{
  console.warn('do not use utils.sign(***REMOVED***, use https://github.com/visionmedia/node-cookie-signature'***REMOVED***
  return val + '.' + crypto
    .createHmac('sha256', secret***REMOVED***
    .update(val***REMOVED***
    .digest('base64'***REMOVED***
    .replace(/=+$/, ''***REMOVED***;
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function(val, secret***REMOVED***{
  console.warn('do not use utils.unsign(***REMOVED***, use https://github.com/visionmedia/node-cookie-signature'***REMOVED***
  var str = val.slice(0, val.lastIndexOf('.'***REMOVED******REMOVED***;
  return exports.sign(str, secret***REMOVED*** == val
    ? str
    : false;
};

/**
 * Parse signed cookies, returning an object
 * containing the decoded key/value pairs,
 * while removing the signed key from `obj`.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

exports.parseSignedCookies = function(obj, secret***REMOVED***{
  var ret = {};
  Object.keys(obj***REMOVED***.forEach(function(key***REMOVED***{
    var val = obj[key];
    if (0 == val.indexOf('s:'***REMOVED******REMOVED*** {
      val = signature.unsign(val.slice(2***REMOVED***, secret***REMOVED***;
      if (val***REMOVED*** {
        ret[key] = val;
        delete obj[key];
    ***REMOVED***
  ***REMOVED***
***REMOVED******REMOVED***;
  return ret;
};

/**
 * Parse a signed cookie string, return the decoded value
 *
 * @param {String} str signed cookie string
 * @param {String} secret
 * @return {String} decoded value
 * @api private
 */

exports.parseSignedCookie = function(str, secret***REMOVED***{
  return 0 == str.indexOf('s:'***REMOVED***
    ? signature.unsign(str.slice(2***REMOVED***, secret***REMOVED***
    : str;
};

/**
 * Parse JSON cookies.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

exports.parseJSONCookies = function(obj***REMOVED***{
  Object.keys(obj***REMOVED***.forEach(function(key***REMOVED***{
    var val = obj[key];
    var res = exports.parseJSONCookie(val***REMOVED***;
    if (res***REMOVED*** obj[key] = res;
***REMOVED******REMOVED***;
  return obj;
};

/**
 * Parse JSON cookie string
 *
 * @param {String} str
 * @return {Object} Parsed object or null if not json cookie
 * @api private
 */

exports.parseJSONCookie = function(str***REMOVED*** {
  if (0 == str.indexOf('j:'***REMOVED******REMOVED*** {
    try {
      return JSON.parse(str.slice(2***REMOVED******REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
      // no op
  ***REMOVED***
***REMOVED***
};

/**
 * Pause `data` and `end` events on the given `obj`.
 * Middleware performing async tasks _should_ utilize
 * this utility (or similar***REMOVED***, to re-emit data once
 * the async operation has completed, otherwise these
 * events may be lost. Pause is only required for
 * node versions less than 10, and is replaced with
 * noop's otherwise.
 *
 *      var pause = utils.pause(req***REMOVED***;
 *      fs.readFile(path, function(***REMOVED***{
 *         next(***REMOVED***;
 *         pause.resume(***REMOVED***;
 *    ***REMOVED******REMOVED***;
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

exports.pause = exports.brokenPause
  ? require('pause'***REMOVED***
  : function (***REMOVED*** {
    return {
      end: noop,
      resume: noop
  ***REMOVED***
***REMOVED***

/**
 * Strip `Content-*` headers from `res`.
 *
 * @param {ServerResponse} res
 * @api private
 */

exports.removeContentHeaders = function(res***REMOVED***{
  if (!res._headers***REMOVED*** return;
  Object.keys(res._headers***REMOVED***.forEach(function(field***REMOVED***{
    if (0 == field.indexOf('content'***REMOVED******REMOVED*** {
      res.removeHeader(field***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
};

/**
 * Check if `req` is a conditional GET request.
 *
 * @param {IncomingMessage} req
 * @return {Boolean}
 * @api private
 */

exports.conditionalGET = function(req***REMOVED*** {
  return req.headers['if-modified-since']
    || req.headers['if-none-match'];
};

/**
 * Respond with 401 "Unauthorized".
 *
 * @param {ServerResponse} res
 * @param {String} realm
 * @api private
 */

exports.unauthorized = function(res, realm***REMOVED*** {
  res.statusCode = 401;
  res.setHeader('WWW-Authenticate', 'Basic realm="' + realm + '"'***REMOVED***;
  res.end('Unauthorized'***REMOVED***;
};

/**
 * Respond with 304 "Not Modified".
 *
 * @param {ServerResponse} res
 * @param {Object} headers
 * @api private
 */

exports.notModified = function(res***REMOVED*** {
  exports.removeContentHeaders(res***REMOVED***;
  res.statusCode = 304;
  res.end(***REMOVED***;
};

/**
 * Return an ETag in the form of `"<size>-<mtime>"`
 * from the given `stat`.
 *
 * @param {Object} stat
 * @return {String}
 * @api private
 */

exports.etag = function(stat***REMOVED*** {
  return '"' + stat.size + '-' + Number(stat.mtime***REMOVED*** + '"';
};

/**
 * Parse the given Cache-Control `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseCacheControl = function(str***REMOVED***{
  var directives = str.split(','***REMOVED***
    , obj = {};

  for(var i = 0, len = directives.length; i < len; i++***REMOVED*** {
    var parts = directives[i].split('='***REMOVED***
      , key = parts.shift(***REMOVED***.trim(***REMOVED***
      , val = parseInt(parts.shift(***REMOVED***, 10***REMOVED***;

    obj[key] = isNaN(val***REMOVED*** ? true : val;
***REMOVED***

  return obj;
};

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @api private
 */

exports.parseUrl = function(req***REMOVED***{
  var parsed = req._parsedUrl;
  if (parsed && parsed.href == req.url***REMOVED*** {
    return parsed;
***REMOVED*** else {
    parsed = parse(req.url***REMOVED***;

    if (parsed.auth && !parsed.protocol && ~parsed.href.indexOf('//'***REMOVED******REMOVED*** {
      // This parses pathnames, and a strange pathname like //r@e should work
      parsed = parse(req.url.replace(/@/g, '%40'***REMOVED******REMOVED***;
  ***REMOVED***

    return req._parsedUrl = parsed;
***REMOVED***
};

/**
 * Parse byte `size` string.
 *
 * @param {String} size
 * @return {Number}
 * @api private
 */

exports.parseBytes = require('bytes'***REMOVED***;

/**
 * Normalizes the path separator from system separator
 * to URL separator, aka `/`.
 *
 * @param {String} path
 * @return {String}
 * @api private
 */

exports.normalizeSlashes = function normalizeSlashes(path***REMOVED*** {
  return path.split(sep***REMOVED***.join('/'***REMOVED***;
};

function noop(***REMOVED*** {}
