/*!
 * Connect - HTTPServer
 * Copyright(c***REMOVED*** 2010 Sencha Inc.
 * Copyright(c***REMOVED*** 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var ***REMOVED***
  , utils = require('./utils'***REMOVED***
  , debug = require('debug'***REMOVED***('connect:dispatcher'***REMOVED***;

// prototype

var app = module.exports = {};

// environment

var env = process.env.NODE_ENV || 'development';

/**
 * Utilize the given middleware `handle` to the given `route`,
 * defaulting to _/_. This "route" is the mount-point for the
 * middleware, when given a value other than _/_ the middleware
 * is only effective when that segment is present in the request's
 * pathname.
 *
 * For example if we were to mount a function at _/admin_, it would
 * be invoked on _/admin_, and _/admin/settings_, however it would
 * not be invoked for _/_, or _/posts_.
 *
 * Examples:
 *
 *      var app = connect(***REMOVED***;
 *      app.use(connect.favicon(***REMOVED******REMOVED***;
 *      app.use(connect.logger(***REMOVED******REMOVED***;
 *      app.use(connect.static(__dirname + '/public'***REMOVED******REMOVED***;
 *
 * If we wanted to prefix static files with _/public_, we could
 * "mount" the `static(***REMOVED***` middleware:
 *
 *      app.use('/public', connect.static(__dirname + '/public'***REMOVED******REMOVED***;
 *
 * This api is chainable, so the following is valid:
 *
 *      connect(***REMOVED***
 *        .use(connect.favicon(***REMOVED******REMOVED***
 *        .use(connect.logger(***REMOVED******REMOVED***
 *        .use(connect.static(__dirname + '/public'***REMOVED******REMOVED***
 *        .listen(3000***REMOVED***;
 *
 * @param {String|Function|Server} route, callback or server
 * @param {Function|Server} callback or server
 * @return {Server} for chaining
 * @api public
 */

app.use = function(route, fn***REMOVED***{
  // default route to '/'
  if ('string' != typeof route***REMOVED*** {
    fn = route;
    route = '/';
***REMOVED***

  // wrap sub-apps
  if ('function' == typeof fn.handle***REMOVED*** {
    var server = fn;
    fn.route = route;
    fn = function(req, res, next***REMOVED***{
      server.handle(req, res, next***REMOVED***;
  ***REMOVED***;
***REMOVED***

  // wrap vanilla http.Servers
  if (fn instanceof http.Server***REMOVED*** {
    fn = fn.listeners('request'***REMOVED***[0];
***REMOVED***

  // strip trailing slash
  if ('/' == route[route.length - 1]***REMOVED*** {
    route = route.slice(0, -1***REMOVED***;
***REMOVED***

  // add the middleware
  debug('use %s %s', route || '/', fn.name || 'anonymous'***REMOVED***;
  this.stack.push({ route: route, handle: fn }***REMOVED***;

  return this;
};

/**
 * Handle server requests, punting them down
 * the middleware stack.
 *
 * @api private
 */

app.handle = function(req, res, out***REMOVED*** {
  var stack = this.stack
    , search = 1 + req.url.indexOf('?'***REMOVED***
    , pathlength = search ? search - 1 : req.url.length
    , fqdn = 1 + req.url.substr(0, pathlength***REMOVED***.indexOf('://'***REMOVED***
    , protohost = fqdn ? req.url.substr(0, req.url.indexOf('/', 2 + fqdn***REMOVED******REMOVED*** : ''
    , removed = ''
    , slashAdded = false
    , index = 0;

  function next(err***REMOVED*** {
    var layer, path, c;

    if (slashAdded***REMOVED*** {
      req.url = req.url.substr(1***REMOVED***;
      slashAdded = false;
  ***REMOVED***

    req.url = protohost + removed + req.url.substr(protohost.length***REMOVED***;
    req.originalUrl = req.originalUrl || req.url;
    removed = '';

    // next callback
    layer = stack[index++];

    // all done
    if (!layer || res.headerSent***REMOVED*** {
      // delegate to parent
      if (out***REMOVED*** return out(err***REMOVED***;

      // unhandled error
      if (err***REMOVED*** {
        // default to 500
        if (res.statusCode < 400***REMOVED*** res.statusCode = 500;
        debug('default %s', res.statusCode***REMOVED***;

        // respect err.status
        if (err.status***REMOVED*** res.statusCode = err.status;

        // production gets a basic error message
        var msg = 'production' == env
          ? http.STATUS_CODES[res.statusCode]
          : err.stack || err.toString(***REMOVED***;
        msg = utils.escape(msg***REMOVED***;

        // log to stderr in a non-test env
        if ('test' != env***REMOVED*** console.error(err.stack || err.toString(***REMOVED******REMOVED***;
        if (res.headerSent***REMOVED*** return req.socket.destroy(***REMOVED***;
        res.setHeader('Content-Type', 'text/html'***REMOVED***;
        res.setHeader('Content-Length', Buffer.byteLength(msg***REMOVED******REMOVED***;
        if ('HEAD' == req.method***REMOVED*** return res.end(***REMOVED***;
        res.end(msg***REMOVED***;
    ***REMOVED*** else {
        debug('default 404'***REMOVED***;
        res.statusCode = 404;
        res.setHeader('Content-Type', 'text/html'***REMOVED***;
        if ('HEAD' == req.method***REMOVED*** return res.end(***REMOVED***;
        res.end('Cannot ' + utils.escape(req.method***REMOVED*** + ' ' + utils.escape(req.originalUrl***REMOVED*** + '\n'***REMOVED***;
    ***REMOVED***
      return;
  ***REMOVED***

    try {
      path = utils.parseUrl(req***REMOVED***.pathname;
      if (undefined == path***REMOVED*** path = '/';

      // skip this layer if the route doesn't match.
      if (0 != path.toLowerCase(***REMOVED***.indexOf(layer.route.toLowerCase(***REMOVED******REMOVED******REMOVED*** return next(err***REMOVED***;

      c = path[layer.route.length];
      if (c && '/' != c && '.' != c***REMOVED*** return next(err***REMOVED***;

      // Call the layer handler
      // Trim off the part of the url that matches the route
      removed = layer.route;
      req.url = protohost + req.url.substr(protohost.length + removed.length***REMOVED***;

      // Ensure leading slash
      if (!fqdn && '/' != req.url[0]***REMOVED*** {
        req.url = '/' + req.url;
        slashAdded = true;
    ***REMOVED***

      debug('%s %s : %s', layer.handle.name || 'anonymous', layer.route, req.originalUrl***REMOVED***;
      var arity = layer.handle.length;
      if (err***REMOVED*** {
        if (arity === 4***REMOVED*** {
          layer.handle(err, req, res, next***REMOVED***;
      ***REMOVED*** else {
          next(err***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else if (arity < 4***REMOVED*** {
        layer.handle(req, res, next***REMOVED***;
    ***REMOVED*** else {
        next(***REMOVED***;
    ***REMOVED***
  ***REMOVED*** catch (e***REMOVED*** {
      next(e***REMOVED***;
  ***REMOVED***
***REMOVED***
  next(***REMOVED***;
};

/**
 * Listen for connections.
 *
 * This method takes the same arguments
 * as node's `http.Server#listen(***REMOVED***`.
 *
 * HTTP and HTTPS:
 *
 * If you run your application both as HTTP
 * and HTTPS you may wrap them individually,
 * since your Connect "server" is really just
 * a JavaScript `Function`.
 *
 *      var connect = require('connect'***REMOVED***
 *        , ***REMOVED***
 *        , https = require('https'***REMOVED***;
 *
 *      var app = connect(***REMOVED***;
 *
 *      http.createServer(app***REMOVED***.listen(80***REMOVED***;
 *      https.createServer(options, app***REMOVED***.listen(443***REMOVED***;
 *
 * @return {http.Server}
 * @api public
 */

app.listen = function(***REMOVED***{
  var server = http.createServer(this***REMOVED***;
  return server.listen.apply(server, arguments***REMOVED***;
};
