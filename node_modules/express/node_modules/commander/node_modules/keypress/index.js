
/**
 * This module offers the internal "keypress" functionality from node-core's
 * `readline` module, for your own programs and modules to use.
 *
 * Usage:
 *
 *   require('keypress'***REMOVED***(process.stdin***REMOVED***;
 *
 *   process.stdin.on('keypress', function (ch, key***REMOVED*** {
 *     console.log(ch, key***REMOVED***;
 *     if (key.ctrl && key.name == 'c'***REMOVED*** {
 *       process.stdin.pause(***REMOVED***;
 *   ***REMOVED***
 * ***REMOVED******REMOVED***;
 *   proces.stdin.resume(***REMOVED***;
 */
var exports = module.exports = keypress;

exports.enableMouse = function (stream***REMOVED*** {
  stream.write('\x1b' +'[?1000h'***REMOVED***
}

exports.disableMouse = function (stream***REMOVED*** {
  stream.write('\x1b' +'[?1000l'***REMOVED***
}


/**
 * accepts a readable Stream instance and makes it emit "keypress" events
 */

function keypress(stream***REMOVED*** {
  if (isEmittingKeypress(stream***REMOVED******REMOVED*** return;
  stream._emitKeypress = true;

  function onData(b***REMOVED*** {
    if (stream.listeners('keypress'***REMOVED***.length > 0***REMOVED*** {
      emitKey(stream, b***REMOVED***;
  ***REMOVED*** else {
      // Nobody's watching anyway
      stream.removeListener('data', onData***REMOVED***;
      stream.on('newListener', onNewListener***REMOVED***;
  ***REMOVED***
***REMOVED***

  function onNewListener(event***REMOVED*** {
    if (event == 'keypress'***REMOVED*** {
      stream.on('data', onData***REMOVED***;
      stream.removeListener('newListener', onNewListener***REMOVED***;
  ***REMOVED***
***REMOVED***

  if (stream.listeners('keypress'***REMOVED***.length > 0***REMOVED*** {
    stream.on('data', onData***REMOVED***;
***REMOVED*** else {
    stream.on('newListener', onNewListener***REMOVED***;
***REMOVED***
}

/**
 * Returns `true` if the stream is already emitting "keypress" events.
 * `false` otherwise.
 */

function isEmittingKeypress(stream***REMOVED*** {
  var rtn = stream._emitKeypress;
  if (!rtn***REMOVED*** {
    // hack: check for the v0.6.x "data" event
    stream.listeners('data'***REMOVED***.forEach(function (l***REMOVED*** {
      if (l.name == 'onData' && /emitKey/.test(l.toString(***REMOVED******REMOVED******REMOVED*** {
        rtn = true;
        stream._emitKeypress = true;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***
  if (!rtn***REMOVED*** {
    // hack: check for the v0.6.x "newListener" event
    stream.listeners('newListener'***REMOVED***.forEach(function (l***REMOVED*** {
      if (l.name == 'onNewListener' && /keypress/.test(l.toString(***REMOVED******REMOVED******REMOVED*** {
        rtn = true;
        stream._emitKeypress = true;
    ***REMOVED***
  ***REMOVED******REMOVED***;
***REMOVED***
  return rtn;
}


/*
  Some patterns seen in terminal key escape codes, derived from combos seen
  at http://www.midnight-commander.org/browser/lib/tty/key.c

  ESC letter
  ESC [ letter
  ESC [ modifier letter
  ESC [ 1 ; modifier letter
  ESC [ num char
  ESC [ num ; modifier char
  ESC O letter
  ESC O modifier letter
  ESC O 1 ; modifier letter
  ESC N letter
  ESC [ [ num ; modifier char
  ESC [ [ 1 ; modifier letter
  ESC ESC [ num char
  ESC ESC O letter

  - char is usually ~ but $ and ^ also happen with rxvt
  - modifier is 1 +
                (shift     * 1***REMOVED*** +
                (left_alt  * 2***REMOVED*** +
                (ctrl      * 4***REMOVED*** +
                (right_alt * 8***REMOVED***
  - two leading ESCs apparently mean the same as one leading ESC
*/

// Regexes used for ansi escape code splitting
var metaKeyCodeRe = /^(?:\x1b***REMOVED***([a-zA-Z0-9]***REMOVED***$/;
var functionKeyCodeRe =
    /^(?:\x1b+***REMOVED***(O|N|\[|\[\[***REMOVED***(?:(\d+***REMOVED***(?:;(\d+***REMOVED******REMOVED***?([~^$]***REMOVED***|(?:1;***REMOVED***?(\d+***REMOVED***?([a-zA-Z]***REMOVED******REMOVED***/;

function emitKey(stream, s***REMOVED*** {
  var ch,
      key = {
        name: undefined,
        ctrl: false,
        meta: false,
        shift: false
    ***REMOVED***,
      parts;

  if (Buffer.isBuffer(s***REMOVED******REMOVED*** {
    if (s[0] > 127 && s[1] === undefined***REMOVED*** {
      s[0] -= 128;
      s = '\x1b' + s.toString(stream.encoding || 'utf-8'***REMOVED***;
  ***REMOVED*** else {
      s = s.toString(stream.encoding || 'utf-8'***REMOVED***;
  ***REMOVED***
***REMOVED***

  key.sequence = s;

  if (s === '\r' || s === '\n'***REMOVED*** {
    // enter
    key.name = 'enter';

***REMOVED*** else if (s === '\t'***REMOVED*** {
    // tab
    key.name = 'tab';

***REMOVED*** else if (s === '\b' || s === '\x7f' ||
             s === '\x1b\x7f' || s === '\x1b\b'***REMOVED*** {
    // backspace or ctrl+h
    key.name = 'backspace';
    key.meta = (s.charAt(0***REMOVED*** === '\x1b'***REMOVED***;

***REMOVED*** else if (s === '\x1b' || s === '\x1b\x1b'***REMOVED*** {
    // escape key
    key.name = 'escape';
    key.meta = (s.length === 2***REMOVED***;

***REMOVED*** else if (s === ' ' || s === '\x1b '***REMOVED*** {
    key.name = 'space';
    key.meta = (s.length === 2***REMOVED***;

***REMOVED*** else if (s <= '\x1a'***REMOVED*** {
    // ctrl+letter
    key.name = String.fromCharCode(s.charCodeAt(0***REMOVED*** + 'a'.charCodeAt(0***REMOVED*** - 1***REMOVED***;
    key.ctrl = true;

***REMOVED*** else if (s.length === 1 && s >= 'a' && s <= 'z'***REMOVED*** {
    // lowercase letter
    key.name = s;

***REMOVED*** else if (s.length === 1 && s >= 'A' && s <= 'Z'***REMOVED*** {
    // shift+letter
    key.name = s.toLowerCase(***REMOVED***;
    key.shift = true;

***REMOVED*** else if (parts = metaKeyCodeRe.exec(s***REMOVED******REMOVED*** {
    // meta+character key
    key.name = parts[1].toLowerCase(***REMOVED***;
    key.meta = true;
    key.shift = /^[A-Z]$/.test(parts[1]***REMOVED***;

***REMOVED*** else if (parts = functionKeyCodeRe.exec(s***REMOVED******REMOVED*** {
    // ansi escape sequence

    // reassemble the key code leaving out leading \x1b's,
    // the modifier key bitflag and any meaningless "1;" sequence
    var code = (parts[1] || ''***REMOVED*** + (parts[2] || ''***REMOVED*** +
               (parts[4] || ''***REMOVED*** + (parts[6] || ''***REMOVED***,
        modifier = (parts[3] || parts[5] || 1***REMOVED*** - 1;

    // Parse the key modifier
    key.ctrl = !!(modifier & 4***REMOVED***;
    key.meta = !!(modifier & 10***REMOVED***;
    key.shift = !!(modifier & 1***REMOVED***;
    key.code = code;

    // Parse the key itself
    switch (code***REMOVED*** {
      /* xterm/gnome ESC O letter */
      case 'OP': key.name = 'f1'; break;
      case 'OQ': key.name = 'f2'; break;
      case 'OR': key.name = 'f3'; break;
      case 'OS': key.name = 'f4'; break;

      /* xterm/rxvt ESC [ number ~ */
      case '[11~': key.name = 'f1'; break;
      case '[12~': key.name = 'f2'; break;
      case '[13~': key.name = 'f3'; break;
      case '[14~': key.name = 'f4'; break;

      /* from Cygwin and used in libuv */
      case '[[A': key.name = 'f1'; break;
      case '[[B': key.name = 'f2'; break;
      case '[[C': key.name = 'f3'; break;
      case '[[D': key.name = 'f4'; break;
      case '[[E': key.name = 'f5'; break;

      /* common */
      case '[15~': key.name = 'f5'; break;
      case '[17~': key.name = 'f6'; break;
      case '[18~': key.name = 'f7'; break;
      case '[19~': key.name = 'f8'; break;
      case '[20~': key.name = 'f9'; break;
      case '[21~': key.name = 'f10'; break;
      case '[23~': key.name = 'f11'; break;
      case '[24~': key.name = 'f12'; break;

      /* xterm ESC [ letter */
      case '[A': key.name = 'up'; break;
      case '[B': key.name = 'down'; break;
      case '[C': key.name = 'right'; break;
      case '[D': key.name = 'left'; break;
      case '[E': key.name = 'clear'; break;
      case '[F': key.name = 'end'; break;
      case '[H': key.name = 'home'; break;

      /* xterm/gnome ESC O letter */
      case 'OA': key.name = 'up'; break;
      case 'OB': key.name = 'down'; break;
      case 'OC': key.name = 'right'; break;
      case 'OD': key.name = 'left'; break;
      case 'OE': key.name = 'clear'; break;
      case 'OF': key.name = 'end'; break;
      case 'OH': key.name = 'home'; break;

      /* xterm/rxvt ESC [ number ~ */
      case '[1~': key.name = 'home'; break;
      case '[2~': key.name = 'insert'; break;
      case '[3~': key.name = 'delete'; break;
      case '[4~': key.name = 'end'; break;
      case '[5~': key.name = 'pageup'; break;
      case '[6~': key.name = 'pagedown'; break;

      /* putty */
      case '[[5~': key.name = 'pageup'; break;
      case '[[6~': key.name = 'pagedown'; break;

      /* rxvt */
      case '[7~': key.name = 'home'; break;
      case '[8~': key.name = 'end'; break;

      /* rxvt keys with modifiers */
      case '[a': key.name = 'up'; key.shift = true; break;
      case '[b': key.name = 'down'; key.shift = true; break;
      case '[c': key.name = 'right'; key.shift = true; break;
      case '[d': key.name = 'left'; key.shift = true; break;
      case '[e': key.name = 'clear'; key.shift = true; break;

      case '[2$': key.name = 'insert'; key.shift = true; break;
      case '[3$': key.name = 'delete'; key.shift = true; break;
      case '[5$': key.name = 'pageup'; key.shift = true; break;
      case '[6$': key.name = 'pagedown'; key.shift = true; break;
      case '[7$': key.name = 'home'; key.shift = true; break;
      case '[8$': key.name = 'end'; key.shift = true; break;

      case 'Oa': key.name = 'up'; key.ctrl = true; break;
      case 'Ob': key.name = 'down'; key.ctrl = true; break;
      case 'Oc': key.name = 'right'; key.ctrl = true; break;
      case 'Od': key.name = 'left'; key.ctrl = true; break;
      case 'Oe': key.name = 'clear'; key.ctrl = true; break;

      case '[2^': key.name = 'insert'; key.ctrl = true; break;
      case '[3^': key.name = 'delete'; key.ctrl = true; break;
      case '[5^': key.name = 'pageup'; key.ctrl = true; break;
      case '[6^': key.name = 'pagedown'; key.ctrl = true; break;
      case '[7^': key.name = 'home'; key.ctrl = true; break;
      case '[8^': key.name = 'end'; key.ctrl = true; break;

      /* misc. */
      case '[Z': key.name = 'tab'; key.shift = true; break;
      default: key.name = 'undefined'; break;

  ***REMOVED***
***REMOVED*** else if (s.length > 1 && s[0] !== '\x1b'***REMOVED*** {
    // Got a longer-than-one string of characters.
    // Probably a paste, since it wasn't a control sequence.
    Array.prototype.forEach.call(s, function(c***REMOVED*** {
      emitKey(stream, c***REMOVED***;
  ***REMOVED******REMOVED***;
    return;
***REMOVED***

  if (key.code == '[M'***REMOVED*** {
    key.name = 'mouse';
    var s = key.sequence;
    var b = s.charCodeAt(3***REMOVED***;
    key.x = s.charCodeAt(4***REMOVED*** - 040;
    key.y = s.charCodeAt(5***REMOVED*** - 040;

    key.scroll = 0;

    key.ctrl  = !!(1<<4 & b***REMOVED***;
    key.meta  = !!(1<<3 & b***REMOVED***;
    key.shift = !!(1<<2 & b***REMOVED***;

    key.release = (3 & b***REMOVED*** === 3;

    if (1<<6 & b***REMOVED*** { //scroll
      key.scroll = 1 & b ? 1 : -1;
  ***REMOVED***

    if (!key.release && !key.scroll***REMOVED*** {
      key.button = b & 3;
  ***REMOVED***
***REMOVED***

  // Don't emit a key if no name was found
  if (key.name === undefined***REMOVED*** {
    key = undefined;
***REMOVED***

  if (s.length === 1***REMOVED*** {
    ch = s;
***REMOVED***

  if (key && key.name == 'mouse'***REMOVED*** {
    stream.emit('mousepress', key***REMOVED***
***REMOVED*** else if (key || ch***REMOVED*** {
    stream.emit('keypress', ch, key***REMOVED***;
***REMOVED***
}
