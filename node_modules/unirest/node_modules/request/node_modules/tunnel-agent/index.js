'use strict'

var net = require('net'***REMOVED***
  , tls = require('tls'***REMOVED***
  , ***REMOVED***
  , https = require('https'***REMOVED***
  , events = require('events'***REMOVED***
  , assert = require('assert'***REMOVED***
  , util = require('util'***REMOVED***
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options***REMOVED*** {
  var agent = new TunnelingAgent(options***REMOVED***
  agent.request = http.request
  return agent
}

function httpsOverHttp(options***REMOVED*** {
  var agent = new TunnelingAgent(options***REMOVED***
  agent.request = http.request
  agent.createSocket = createSecureSocket
  return agent
}

function httpOverHttps(options***REMOVED*** {
  var agent = new TunnelingAgent(options***REMOVED***
  agent.request = https.request
  return agent
}

function httpsOverHttps(options***REMOVED*** {
  var agent = new TunnelingAgent(options***REMOVED***
  agent.request = https.request
  agent.createSocket = createSecureSocket
  return agent
}


function TunnelingAgent(options***REMOVED*** {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port***REMOVED*** {
    for (var i = 0, len = self.requests.length; i < len; ++i***REMOVED*** {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port***REMOVED*** {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1***REMOVED***
        pending.request.onSocket(socket***REMOVED***
        return
    ***REMOVED***
  ***REMOVED***
    socket.destroy(***REMOVED***
    self.removeSocket(socket***REMOVED***
***REMOVED******REMOVED***
}
util.inherits(TunnelingAgent, events.EventEmitter***REMOVED***

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port***REMOVED*** {
  var self = this

  if (self.sockets.length >= this.maxSockets***REMOVED*** {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: host, port: port, request: req}***REMOVED***
    return
***REMOVED***

  // If we are under maxSockets create a new one.
  self.createSocket({host: host, port: port, request: req}, function(socket***REMOVED*** {
    socket.on('free', onFree***REMOVED***
    socket.on('close', onCloseOrRemove***REMOVED***
    socket.on('agentRemove', onCloseOrRemove***REMOVED***
    req.onSocket(socket***REMOVED***

    function onFree(***REMOVED*** {
      self.emit('free', socket, host, port***REMOVED***
  ***REMOVED***

    function onCloseOrRemove(err***REMOVED*** {
      self.removeSocket(***REMOVED***
      socket.removeListener('free', onFree***REMOVED***
      socket.removeListener('close', onCloseOrRemove***REMOVED***
      socket.removeListener('agentRemove', onCloseOrRemove***REMOVED***
  ***REMOVED***
***REMOVED******REMOVED***
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb***REMOVED*** {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder***REMOVED***

  var connectOptions = mergeOptions({}, self.proxyOptions, 
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
  ***REMOVED***
  ***REMOVED***
  if (connectOptions.proxyAuth***REMOVED*** {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth***REMOVED***.toString('base64'***REMOVED***
***REMOVED***

  debug('making CONNECT request'***REMOVED***
  var connectReq = self.request(connectOptions***REMOVED***
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse***REMOVED*** // for v0.6
  connectReq.once('upgrade', onUpgrade***REMOVED***   // for v0.6
  connectReq.once('connect', onConnect***REMOVED***   // for v0.7 or later
  connectReq.once('error', onError***REMOVED***
  connectReq.end(***REMOVED***

  function onResponse(res***REMOVED*** {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
***REMOVED***

  function onUpgrade(res, socket, head***REMOVED*** {
    // Hacky.
    process.nextTick(function(***REMOVED*** {
      onConnect(res, socket, head***REMOVED***
  ***REMOVED******REMOVED***
***REMOVED***

  function onConnect(res, socket, head***REMOVED*** {
    connectReq.removeAllListeners(***REMOVED***
    socket.removeAllListeners(***REMOVED***

    if (res.statusCode === 200***REMOVED*** {
      assert.equal(head.length, 0***REMOVED***
      debug('tunneling connection has established'***REMOVED***
      self.sockets[self.sockets.indexOf(placeholder***REMOVED***] = socket
      cb(socket***REMOVED***
  ***REMOVED*** else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode***REMOVED***
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode***REMOVED***
      error.code = 'ECONNRESET'
      options.request.emit('error', error***REMOVED***
      self.removeSocket(placeholder***REMOVED***
  ***REMOVED***
***REMOVED***

  function onError(cause***REMOVED*** {
    connectReq.removeAllListeners(***REMOVED***

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack***REMOVED***
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message***REMOVED***
    error.code = 'ECONNRESET'
    options.request.emit('error', error***REMOVED***
    self.removeSocket(placeholder***REMOVED***
***REMOVED***
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket***REMOVED*** {
  var pos = this.sockets.indexOf(socket***REMOVED***
  if (pos === -1***REMOVED*** return
  
  this.sockets.splice(pos, 1***REMOVED***

  var pending = this.requests.shift(***REMOVED***
  if (pending***REMOVED*** {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket***REMOVED*** {
      pending.request.onSocket(socket***REMOVED***
  ***REMOVED******REMOVED***
***REMOVED***
}

function createSecureSocket(options, cb***REMOVED*** {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket***REMOVED*** {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
      { servername: options.host
      , socket: socket
    ***REMOVED***
    ***REMOVED******REMOVED***
    cb(secureSocket***REMOVED***
***REMOVED******REMOVED***
}


function mergeOptions(target***REMOVED*** {
  for (var i = 1, len = arguments.length; i < len; ++i***REMOVED*** {
    var overrides = arguments[i]
    if (typeof overrides === 'object'***REMOVED*** {
      var keys = Object.keys(overrides***REMOVED***
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j***REMOVED*** {
        var k = keys[j]
        if (overrides[k] !== undefined***REMOVED*** {
          target[k] = overrides[k]
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG***REMOVED******REMOVED*** {
  debug = function(***REMOVED*** {
    var args = Array.prototype.slice.call(arguments***REMOVED***
    if (typeof args[0] === 'string'***REMOVED*** {
      args[0] = 'TUNNEL: ' + args[0]
  ***REMOVED*** else {
      args.unshift('TUNNEL:'***REMOVED***
  ***REMOVED***
    console.error.apply(console, args***REMOVED***
***REMOVED***
} else {
  debug = function(***REMOVED*** {}
}
exports.debug = debug // for test
