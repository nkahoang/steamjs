var crypto = require('crypto'***REMOVED***
  , qs = require('querystring'***REMOVED***
  ;

function sha1 (key, body***REMOVED*** {
  return crypto.createHmac('sha1', key***REMOVED***.update(body***REMOVED***.digest('base64'***REMOVED***
}

function rfc3986 (str***REMOVED*** {
  return encodeURIComponent(str***REMOVED***
    .replace(/!/g,'%21'***REMOVED***
    .replace(/\*/g,'%2A'***REMOVED***
    .replace(/\(/g,'%28'***REMOVED***
    .replace(/\***REMOVED***/g,'%29'***REMOVED***
    .replace(/'/g,'%27'***REMOVED***
    ;
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret***REMOVED*** {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  var querystring = Object.keys(params***REMOVED***.sort(***REMOVED***.map(function(key***REMOVED***{
    // big WTF here with the escape + encoding but it's what twitter wants
    return escape(rfc3986(key***REMOVED******REMOVED*** + "%3D" + escape(rfc3986(params[key]***REMOVED******REMOVED***
***REMOVED******REMOVED***.join('%26'***REMOVED***

  var base = [
    httpMethod ? httpMethod.toUpperCase(***REMOVED*** : 'GET',
    rfc3986(base_uri***REMOVED***,
    querystring
  ].join('&'***REMOVED***

  var key = [
    consumer_secret,
    token_secret || ''
  ].map(rfc3986***REMOVED***.join('&'***REMOVED***

  return sha1(key, base***REMOVED***
}

exports.hmacsign = hmacsign
exports.rfc3986 = rfc3986
