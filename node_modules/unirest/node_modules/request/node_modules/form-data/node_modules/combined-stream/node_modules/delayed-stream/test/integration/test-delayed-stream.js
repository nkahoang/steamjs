var common = require('../common'***REMOVED***;
var assert = common.assert;
var fake = common.fake.create(***REMOVED***;
var DelayedStream = common.DelayedStream;
var Stream = require('stream'***REMOVED***.Stream;

(function testDelayEventsUntilResume(***REMOVED*** {
  var source = new Stream(***REMOVED***;
  var delayedStream = DelayedStream.create(source, {pauseStream: false}***REMOVED***;

  // delayedStream must not emit until we resume
  fake.expect(delayedStream, 'emit', 0***REMOVED***;

  // but our original source must emit
  var params = [];
  source.on('foo', function(param***REMOVED*** {
    params.push(param***REMOVED***;
***REMOVED******REMOVED***;

  source.emit('foo', 1***REMOVED***;
  source.emit('foo', 2***REMOVED***;

  // Make sure delayedStream did not emit, and source did
  assert.deepEqual(params, [1, 2]***REMOVED***;
  fake.verify(***REMOVED***;

  // After resume, delayedStream must playback all events
  fake
    .stub(delayedStream, 'emit'***REMOVED***
    .times(Infinity***REMOVED***
    .withArg(1, 'newListener'***REMOVED***;
  fake.expect(delayedStream, 'emit', ['foo', 1]***REMOVED***;
  fake.expect(delayedStream, 'emit', ['foo', 2]***REMOVED***;
  fake.expect(source, 'resume'***REMOVED***;

  delayedStream.resume(***REMOVED***;
  fake.verify(***REMOVED***;

  // Calling resume again will delegate to source
  fake.expect(source, 'resume'***REMOVED***;
  delayedStream.resume(***REMOVED***;
  fake.verify(***REMOVED***;

  // Emitting more events directly leads to them being emitted
  fake.expect(delayedStream, 'emit', ['foo', 3]***REMOVED***;
  source.emit('foo', 3***REMOVED***;
  fake.verify(***REMOVED***;
}***REMOVED***(***REMOVED***;
