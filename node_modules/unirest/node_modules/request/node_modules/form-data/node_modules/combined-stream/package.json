{
  "author": {
    "name": "Felix Geisend√∂rfer",
    "email": "felix@debuggable.com",
    "url": "http://debuggable.com/"
***REMOVED***,
  "name": "combined-stream",
  "description": "A stream that emits multiple other streams one after another.",
  "version": "0.0.4",
  "homepage": "https://github.com/felixge/node-combined-stream",
  "repository": {
    "type": "git",
    "url": "git://github.com/felixge/node-combined-stream.git"
***REMOVED***,
  "main": "./lib/combined_stream",
  "engines": {
    "node": "*"
***REMOVED***,
  "dependencies": {
    "delayed-stream": "0.0.5"
***REMOVED***,
  "devDependencies": {
    "far": "0.0.1"
***REMOVED***,
  "readme": "# combined-stream\n\nA stream that emits multiple other streams one after another.\n\n## Installation\n\n``` bash\nnpm install combined-stream\n```\n\n## Usage\n\nHere is a simple example that shows how you can use combined-stream to combine\ntwo files into one:\n\n``` javascript\nvar CombinedStream = require('combined-stream'***REMOVED***;\nvar fs = require('fs'***REMOVED***;\n\nvar combinedStream = CombinedStream.create(***REMOVED***;\ncombinedStream.append(fs.createReadStream('file1.txt'***REMOVED******REMOVED***;\ncombinedStream.append(fs.createReadStream('file2.txt'***REMOVED******REMOVED***;\n\ncombinedStream.pipe(fs.createWriteStream('combined.txt'***REMOVED******REMOVED***;\n```\n\nWhile the example above works great, it will pause all source streams until\nthey are needed. If you don't want that to happen, you can set `pauseStreams`\nto `false`:\n\n``` javascript\nvar CombinedStream = require('combined-stream'***REMOVED***;\nvar fs = require('fs'***REMOVED***;\n\nvar combinedStream = CombinedStream.create({pauseStreams: false}***REMOVED***;\ncombinedStream.append(fs.createReadStream('file1.txt'***REMOVED******REMOVED***;\ncombinedStream.append(fs.createReadStream('file2.txt'***REMOVED******REMOVED***;\n\ncombinedStream.pipe(fs.createWriteStream('combined.txt'***REMOVED******REMOVED***;\n```\n\nHowever, what if you don't have all the source streams yet, or you don't want\nto allocate the resources (file descriptors, memory, etc.***REMOVED*** for them right away?\nWell, in that case you can simply provide a callback that supplies the stream\nby calling a `next(***REMOVED***` function:\n\n``` javascript\nvar CombinedStream = require('combined-stream'***REMOVED***;\nvar fs = require('fs'***REMOVED***;\n\nvar combinedStream = CombinedStream.create(***REMOVED***;\ncombinedStream.append(function(next***REMOVED*** {\n  next(fs.createReadStream('file1.txt'***REMOVED******REMOVED***;\n}***REMOVED***;\ncombinedStream.append(function(next***REMOVED*** {\n  next(fs.createReadStream('file2.txt'***REMOVED******REMOVED***;\n}***REMOVED***;\n\ncombinedStream.pipe(fs.createWriteStream('combined.txt'***REMOVED******REMOVED***;\n```\n\n## API\n\n### CombinedStream.create([options]***REMOVED***\n\nReturns a new combined stream object. Available options are:\n\n* `maxDataSize`\n* `pauseStreams`\n\nThe effect of those options is described below.\n\n### combinedStream.pauseStreams = true\n\nWhether to apply back pressure to the underlaying streams. If set to `false`,\nthe underlaying streams will never be paused. If set to `true`, the\nunderlaying streams will be paused right after being appended, as well as when\n`delayedStream.pipe(***REMOVED***` wants to throttle.\n\n### combinedStream.maxDataSize = 2 * 1024 * 1024\n\nThe maximum amount of bytes (or characters***REMOVED*** to buffer for all source streams.\nIf this value is exceeded, `combinedStream` emits an `'error'` event.\n\n### combinedStream.dataSize = 0\n\nThe amount of bytes (or characters***REMOVED*** currently buffered by `combinedStream`.\n\n### combinedStream.append(stream***REMOVED***\n\nAppends the given `stream` to the combinedStream object. If `pauseStreams` is\nset to `true, this stream will also be paused right away.\n\n`streams` can also be a function that takes one parameter called `next`. `next`\nis a function that must be invoked in order to provide the `next` stream, see\nexample above.\n\nRegardless of how the `stream` is appended, combined-stream always attaches an\n`'error'` listener to it, so you don't have to do that manually.\n\nSpecial case: `stream` can also be a String or Buffer.\n\n### combinedStream.write(data***REMOVED***\n\nYou should not call this, `combinedStream` takes care of piping the appended\nstreams into itself for you.\n\n### combinedStream.resume(***REMOVED***\n\nCauses `combinedStream` to start drain the streams it manages. The function is\nidempotent, and also emits a `'resume'` event each time which usually goes to\nthe stream that is currently being drained.\n\n### combinedStream.pause(***REMOVED***;\n\nIf `combinedStream.pauseStreams` is set to `false`, this does nothing.\nOtherwise a `'pause'` event is emitted, this goes to the stream that is\ncurrently being drained, so you can use it to apply back pressure.\n\n### combinedStream.end(***REMOVED***;\n\nSets `combinedStream.writable` to false, emits an `'end'` event, and removes\nall streams from the queue.\n\n### combinedStream.destroy(***REMOVED***;\n\nSame as `combinedStream.end(***REMOVED***`, except it emits a `'close'` event instead of\n`'end'`.\n\n## License\n\ncombined-stream is licensed under the MIT license.\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/felixge/node-combined-stream/issues"
***REMOVED***,
  "_id": "combined-stream@0.0.4",
  "_from": "combined-stream@~0.0.4"
}
