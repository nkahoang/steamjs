/*global setImmediate: false, setTimeout: false, console: false */
(function (***REMOVED*** {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null***REMOVED*** {
      previous_async = root.async;
  ***REMOVED***

    async.noConflict = function (***REMOVED*** {
        root.async = previous_async;
        return async;
  ***REMOVED***;

    function only_once(fn***REMOVED*** {
        var called = false;
        return function(***REMOVED*** {
            if (called***REMOVED*** throw new Error("Callback was already called."***REMOVED***;
            called = true;
            fn.apply(root, arguments***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator***REMOVED*** {
        if (arr.forEach***REMOVED*** {
            return arr.forEach(iterator***REMOVED***;
      ***REMOVED***
        for (var i = 0; i < arr.length; i += 1***REMOVED*** {
            iterator(arr[i], i, arr***REMOVED***;
      ***REMOVED***
  ***REMOVED***;

    var _map = function (arr, iterator***REMOVED*** {
        if (arr.map***REMOVED*** {
            return arr.map(iterator***REMOVED***;
      ***REMOVED***
        var results = [];
        _each(arr, function (x, i, a***REMOVED*** {
            results.push(iterator(x, i, a***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
        return results;
  ***REMOVED***;

    var _reduce = function (arr, iterator, memo***REMOVED*** {
        if (arr.reduce***REMOVED*** {
            return arr.reduce(iterator, memo***REMOVED***;
      ***REMOVED***
        _each(arr, function (x, i, a***REMOVED*** {
            memo = iterator(memo, x, i, a***REMOVED***;
      ***REMOVED******REMOVED***;
        return memo;
  ***REMOVED***;

    var _keys = function (obj***REMOVED*** {
        if (Object.keys***REMOVED*** {
            return Object.keys(obj***REMOVED***;
      ***REMOVED***
        var keys = [];
        for (var k in obj***REMOVED*** {
            if (obj.hasOwnProperty(k***REMOVED******REMOVED*** {
                keys.push(k***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        return keys;
  ***REMOVED***;

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick***REMOVED******REMOVED*** {
        if (typeof setImmediate === 'function'***REMOVED*** {
            async.nextTick = function (fn***REMOVED*** {
                // not a direct alias for IE10 compatibility
                setImmediate(fn***REMOVED***;
          ***REMOVED***;
            async.setImmediate = async.nextTick;
      ***REMOVED***
        else {
            async.nextTick = function (fn***REMOVED*** {
                setTimeout(fn, 0***REMOVED***;
          ***REMOVED***;
            async.setImmediate = async.nextTick;
      ***REMOVED***
  ***REMOVED***
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined'***REMOVED*** {
            async.setImmediate = function (fn***REMOVED*** {
              // not a direct alias for IE10 compatibility
              setImmediate(fn***REMOVED***;
          ***REMOVED***;
      ***REMOVED***
        else {
            async.setImmediate = async.nextTick;
      ***REMOVED***
  ***REMOVED***

    async.each = function (arr, iterator, callback***REMOVED*** {
        callback = callback || function (***REMOVED*** {};
        if (!arr.length***REMOVED*** {
            return callback(***REMOVED***;
      ***REMOVED***
        var completed = 0;
        _each(arr, function (x***REMOVED*** {
            iterator(x, only_once(function (err***REMOVED*** {
                if (err***REMOVED*** {
                    callback(err***REMOVED***;
                    callback = function (***REMOVED*** {};
              ***REMOVED***
                else {
                    completed += 1;
                    if (completed >= arr.length***REMOVED*** {
                        callback(null***REMOVED***;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED******REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback***REMOVED*** {
        callback = callback || function (***REMOVED*** {};
        if (!arr.length***REMOVED*** {
            return callback(***REMOVED***;
      ***REMOVED***
        var completed = 0;
        var iterate = function (***REMOVED*** {
            iterator(arr[completed], function (err***REMOVED*** {
                if (err***REMOVED*** {
                    callback(err***REMOVED***;
                    callback = function (***REMOVED*** {};
              ***REMOVED***
                else {
                    completed += 1;
                    if (completed >= arr.length***REMOVED*** {
                        callback(null***REMOVED***;
                  ***REMOVED***
                    else {
                        iterate(***REMOVED***;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED******REMOVED***;
      ***REMOVED***;
        iterate(***REMOVED***;
  ***REMOVED***;
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback***REMOVED*** {
        var fn = _eachLimit(limit***REMOVED***;
        fn.apply(null, [arr, iterator, callback]***REMOVED***;
  ***REMOVED***;
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit***REMOVED*** {

        return function (arr, iterator, callback***REMOVED*** {
            callback = callback || function (***REMOVED*** {};
            if (!arr.length || limit <= 0***REMOVED*** {
                return callback(***REMOVED***;
          ***REMOVED***
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish (***REMOVED*** {
                if (completed >= arr.length***REMOVED*** {
                    return callback(***REMOVED***;
              ***REMOVED***

                while (running < limit && started < arr.length***REMOVED*** {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err***REMOVED*** {
                        if (err***REMOVED*** {
                            callback(err***REMOVED***;
                            callback = function (***REMOVED*** {};
                      ***REMOVED***
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length***REMOVED*** {
                                callback(***REMOVED***;
                          ***REMOVED***
                            else {
                                replenish(***REMOVED***;
                          ***REMOVED***
                      ***REMOVED***
                  ***REMOVED******REMOVED***;
              ***REMOVED***
          ***REMOVED******REMOVED***(***REMOVED***;
      ***REMOVED***;
  ***REMOVED***;


    var doParallel = function (fn***REMOVED*** {
        return function (***REMOVED*** {
            var args = Array.prototype.slice.call(arguments***REMOVED***;
            return fn.apply(null, [async.each].concat(args***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED***;
    var doParallelLimit = function(limit, fn***REMOVED*** {
        return function (***REMOVED*** {
            var args = Array.prototype.slice.call(arguments***REMOVED***;
            return fn.apply(null, [_eachLimit(limit***REMOVED***].concat(args***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED***;
    var doSeries = function (fn***REMOVED*** {
        return function (***REMOVED*** {
            var args = Array.prototype.slice.call(arguments***REMOVED***;
            return fn.apply(null, [async.eachSeries].concat(args***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED***;


    var _asyncMap = function (eachfn, arr, iterator, callback***REMOVED*** {
        var results = [];
        arr = _map(arr, function (x, i***REMOVED*** {
            return {index: i, value: x};
      ***REMOVED******REMOVED***;
        eachfn(arr, function (x, callback***REMOVED*** {
            iterator(x.value, function (err, v***REMOVED*** {
                results[x.index] = v;
                callback(err***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            callback(err, results***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    async.map = doParallel(_asyncMap***REMOVED***;
    async.mapSeries = doSeries(_asyncMap***REMOVED***;
    async.mapLimit = function (arr, limit, iterator, callback***REMOVED*** {
        return _mapLimit(limit***REMOVED***(arr, iterator, callback***REMOVED***;
  ***REMOVED***;

    var _mapLimit = function(limit***REMOVED*** {
        return doParallelLimit(limit, _asyncMap***REMOVED***;
  ***REMOVED***;

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback***REMOVED*** {
        async.eachSeries(arr, function (x, callback***REMOVED*** {
            iterator(memo, x, function (err, v***REMOVED*** {
                memo = v;
                callback(err***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            callback(err, memo***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback***REMOVED*** {
        var reversed = _map(arr, function (x***REMOVED*** {
            return x;
      ***REMOVED******REMOVED***.reverse(***REMOVED***;
        async.reduce(reversed, memo, iterator, callback***REMOVED***;
  ***REMOVED***;
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback***REMOVED*** {
        var results = [];
        arr = _map(arr, function (x, i***REMOVED*** {
            return {index: i, value: x};
      ***REMOVED******REMOVED***;
        eachfn(arr, function (x, callback***REMOVED*** {
            iterator(x.value, function (v***REMOVED*** {
                if (v***REMOVED*** {
                    results.push(x***REMOVED***;
              ***REMOVED***
                callback(***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            callback(_map(results.sort(function (a, b***REMOVED*** {
                return a.index - b.index;
          ***REMOVED******REMOVED***, function (x***REMOVED*** {
                return x.value;
          ***REMOVED******REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    async.filter = doParallel(_filter***REMOVED***;
    async.filterSeries = doSeries(_filter***REMOVED***;
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback***REMOVED*** {
        var results = [];
        arr = _map(arr, function (x, i***REMOVED*** {
            return {index: i, value: x};
      ***REMOVED******REMOVED***;
        eachfn(arr, function (x, callback***REMOVED*** {
            iterator(x.value, function (v***REMOVED*** {
                if (!v***REMOVED*** {
                    results.push(x***REMOVED***;
              ***REMOVED***
                callback(***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            callback(_map(results.sort(function (a, b***REMOVED*** {
                return a.index - b.index;
          ***REMOVED******REMOVED***, function (x***REMOVED*** {
                return x.value;
          ***REMOVED******REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    async.reject = doParallel(_reject***REMOVED***;
    async.rejectSeries = doSeries(_reject***REMOVED***;

    var _detect = function (eachfn, arr, iterator, main_callback***REMOVED*** {
        eachfn(arr, function (x, callback***REMOVED*** {
            iterator(x, function (result***REMOVED*** {
                if (result***REMOVED*** {
                    main_callback(x***REMOVED***;
                    main_callback = function (***REMOVED*** {};
              ***REMOVED***
                else {
                    callback(***REMOVED***;
              ***REMOVED***
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            main_callback(***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    async.detect = doParallel(_detect***REMOVED***;
    async.detectSeries = doSeries(_detect***REMOVED***;

    async.some = function (arr, iterator, main_callback***REMOVED*** {
        async.each(arr, function (x, callback***REMOVED*** {
            iterator(x, function (v***REMOVED*** {
                if (v***REMOVED*** {
                    main_callback(true***REMOVED***;
                    main_callback = function (***REMOVED*** {};
              ***REMOVED***
                callback(***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            main_callback(false***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback***REMOVED*** {
        async.each(arr, function (x, callback***REMOVED*** {
            iterator(x, function (v***REMOVED*** {
                if (!v***REMOVED*** {
                    main_callback(false***REMOVED***;
                    main_callback = function (***REMOVED*** {};
              ***REMOVED***
                callback(***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            main_callback(true***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback***REMOVED*** {
        async.map(arr, function (x, callback***REMOVED*** {
            iterator(x, function (err, criteria***REMOVED*** {
                if (err***REMOVED*** {
                    callback(err***REMOVED***;
              ***REMOVED***
                else {
                    callback(null, {value: x, criteria: criteria}***REMOVED***;
              ***REMOVED***
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err, results***REMOVED*** {
            if (err***REMOVED*** {
                return callback(err***REMOVED***;
          ***REMOVED***
            else {
                var fn = function (left, right***REMOVED*** {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
              ***REMOVED***;
                callback(null, _map(results.sort(fn***REMOVED***, function (x***REMOVED*** {
                    return x.value;
              ***REMOVED******REMOVED******REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***;

    async.auto = function (tasks, callback***REMOVED*** {
        callback = callback || function (***REMOVED*** {};
        var keys = _keys(tasks***REMOVED***;
        if (!keys.length***REMOVED*** {
            return callback(null***REMOVED***;
      ***REMOVED***

        var results = {};

        var listeners = [];
        var addListener = function (fn***REMOVED*** {
            listeners.unshift(fn***REMOVED***;
      ***REMOVED***;
        var removeListener = function (fn***REMOVED*** {
            for (var i = 0; i < listeners.length; i += 1***REMOVED*** {
                if (listeners[i] === fn***REMOVED*** {
                    listeners.splice(i, 1***REMOVED***;
                    return;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        var taskComplete = function (***REMOVED*** {
            _each(listeners.slice(0***REMOVED***, function (fn***REMOVED*** {
                fn(***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***;

        addListener(function (***REMOVED*** {
            if (_keys(results***REMOVED***.length === keys.length***REMOVED*** {
                callback(null, results***REMOVED***;
                callback = function (***REMOVED*** {};
          ***REMOVED***
      ***REMOVED******REMOVED***;

        _each(keys, function (k***REMOVED*** {
            var task = (tasks[k] instanceof Function***REMOVED*** ? [tasks[k]]: tasks[k];
            var taskCallback = function (err***REMOVED*** {
                var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                if (args.length <= 1***REMOVED*** {
                    args = args[0];
              ***REMOVED***
                if (err***REMOVED*** {
                    var safeResults = {};
                    _each(_keys(results***REMOVED***, function(rkey***REMOVED*** {
                        safeResults[rkey] = results[rkey];
                  ***REMOVED******REMOVED***;
                    safeResults[k] = args;
                    callback(err, safeResults***REMOVED***;
                    // stop subsequent errors hitting callback multiple times
                    callback = function (***REMOVED*** {};
              ***REMOVED***
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete***REMOVED***;
              ***REMOVED***
          ***REMOVED***;
            var requires = task.slice(0, Math.abs(task.length - 1***REMOVED******REMOVED*** || [];
            var ready = function (***REMOVED*** {
                return _reduce(requires, function (a, x***REMOVED*** {
                    return (a && results.hasOwnProperty(x***REMOVED******REMOVED***;
              ***REMOVED***, true***REMOVED*** && !results.hasOwnProperty(k***REMOVED***;
          ***REMOVED***;
            if (ready(***REMOVED******REMOVED*** {
                task[task.length - 1](taskCallback, results***REMOVED***;
          ***REMOVED***
            else {
                var listener = function (***REMOVED*** {
                    if (ready(***REMOVED******REMOVED*** {
                        removeListener(listener***REMOVED***;
                        task[task.length - 1](taskCallback, results***REMOVED***;
                  ***REMOVED***
              ***REMOVED***;
                addListener(listener***REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***;

    async.waterfall = function (tasks, callback***REMOVED*** {
        callback = callback || function (***REMOVED*** {};
        if (tasks.constructor !== Array***REMOVED*** {
          var err = new Error('First argument to waterfall must be an array of functions'***REMOVED***;
          return callback(err***REMOVED***;
      ***REMOVED***
        if (!tasks.length***REMOVED*** {
            return callback(***REMOVED***;
      ***REMOVED***
        var wrapIterator = function (iterator***REMOVED*** {
            return function (err***REMOVED*** {
                if (err***REMOVED*** {
                    callback.apply(null, arguments***REMOVED***;
                    callback = function (***REMOVED*** {};
              ***REMOVED***
                else {
                    var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                    var next = iterator.next(***REMOVED***;
                    if (next***REMOVED*** {
                        args.push(wrapIterator(next***REMOVED******REMOVED***;
                  ***REMOVED***
                    else {
                        args.push(callback***REMOVED***;
                  ***REMOVED***
                    async.setImmediate(function (***REMOVED*** {
                        iterator.apply(null, args***REMOVED***;
                  ***REMOVED******REMOVED***;
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***;
        wrapIterator(async.iterator(tasks***REMOVED******REMOVED***(***REMOVED***;
  ***REMOVED***;

    var _parallel = function(eachfn, tasks, callback***REMOVED*** {
        callback = callback || function (***REMOVED*** {};
        if (tasks.constructor === Array***REMOVED*** {
            eachfn.map(tasks, function (fn, callback***REMOVED*** {
                if (fn***REMOVED*** {
                    fn(function (err***REMOVED*** {
                        var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                        if (args.length <= 1***REMOVED*** {
                            args = args[0];
                      ***REMOVED***
                        callback.call(null, err, args***REMOVED***;
                  ***REMOVED******REMOVED***;
              ***REMOVED***
          ***REMOVED***, callback***REMOVED***;
      ***REMOVED***
        else {
            var results = {};
            eachfn.each(_keys(tasks***REMOVED***, function (k, callback***REMOVED*** {
                tasks[k](function (err***REMOVED*** {
                    var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                    if (args.length <= 1***REMOVED*** {
                        args = args[0];
                  ***REMOVED***
                    results[k] = args;
                    callback(err***REMOVED***;
              ***REMOVED******REMOVED***;
          ***REMOVED***, function (err***REMOVED*** {
                callback(err, results***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED***;

    async.parallel = function (tasks, callback***REMOVED*** {
        _parallel({ map: async.map, each: async.each }, tasks, callback***REMOVED***;
  ***REMOVED***;

    async.parallelLimit = function(tasks, limit, callback***REMOVED*** {
        _parallel({ map: _mapLimit(limit***REMOVED***, each: _eachLimit(limit***REMOVED*** }, tasks, callback***REMOVED***;
  ***REMOVED***;

    async.series = function (tasks, callback***REMOVED*** {
        callback = callback || function (***REMOVED*** {};
        if (tasks.constructor === Array***REMOVED*** {
            async.mapSeries(tasks, function (fn, callback***REMOVED*** {
                if (fn***REMOVED*** {
                    fn(function (err***REMOVED*** {
                        var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                        if (args.length <= 1***REMOVED*** {
                            args = args[0];
                      ***REMOVED***
                        callback.call(null, err, args***REMOVED***;
                  ***REMOVED******REMOVED***;
              ***REMOVED***
          ***REMOVED***, callback***REMOVED***;
      ***REMOVED***
        else {
            var results = {};
            async.eachSeries(_keys(tasks***REMOVED***, function (k, callback***REMOVED*** {
                tasks[k](function (err***REMOVED*** {
                    var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                    if (args.length <= 1***REMOVED*** {
                        args = args[0];
                  ***REMOVED***
                    results[k] = args;
                    callback(err***REMOVED***;
              ***REMOVED******REMOVED***;
          ***REMOVED***, function (err***REMOVED*** {
                callback(err, results***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED***;

    async.iterator = function (tasks***REMOVED*** {
        var makeCallback = function (index***REMOVED*** {
            var fn = function (***REMOVED*** {
                if (tasks.length***REMOVED*** {
                    tasks[index].apply(null, arguments***REMOVED***;
              ***REMOVED***
                return fn.next(***REMOVED***;
          ***REMOVED***;
            fn.next = function (***REMOVED*** {
                return (index < tasks.length - 1***REMOVED*** ? makeCallback(index + 1***REMOVED***: null;
          ***REMOVED***;
            return fn;
      ***REMOVED***;
        return makeCallback(0***REMOVED***;
  ***REMOVED***;

    async.apply = function (fn***REMOVED*** {
        var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
        return function (***REMOVED*** {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments***REMOVED******REMOVED***
            ***REMOVED***;
      ***REMOVED***;
  ***REMOVED***;

    var _concat = function (eachfn, arr, fn, callback***REMOVED*** {
        var r = [];
        eachfn(arr, function (x, cb***REMOVED*** {
            fn(x, function (err, y***REMOVED*** {
                r = r.concat(y || []***REMOVED***;
                cb(err***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***, function (err***REMOVED*** {
            callback(err, r***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
    async.concat = doParallel(_concat***REMOVED***;
    async.concatSeries = doSeries(_concat***REMOVED***;

    async.whilst = function (test, iterator, callback***REMOVED*** {
        if (test(***REMOVED******REMOVED*** {
            iterator(function (err***REMOVED*** {
                if (err***REMOVED*** {
                    return callback(err***REMOVED***;
              ***REMOVED***
                async.whilst(test, iterator, callback***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
        else {
            callback(***REMOVED***;
      ***REMOVED***
  ***REMOVED***;

    async.doWhilst = function (iterator, test, callback***REMOVED*** {
        iterator(function (err***REMOVED*** {
            if (err***REMOVED*** {
                return callback(err***REMOVED***;
          ***REMOVED***
            if (test(***REMOVED******REMOVED*** {
                async.doWhilst(iterator, test, callback***REMOVED***;
          ***REMOVED***
            else {
                callback(***REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***;

    async.until = function (test, iterator, callback***REMOVED*** {
        if (!test(***REMOVED******REMOVED*** {
            iterator(function (err***REMOVED*** {
                if (err***REMOVED*** {
                    return callback(err***REMOVED***;
              ***REMOVED***
                async.until(test, iterator, callback***REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***
        else {
            callback(***REMOVED***;
      ***REMOVED***
  ***REMOVED***;

    async.doUntil = function (iterator, test, callback***REMOVED*** {
        iterator(function (err***REMOVED*** {
            if (err***REMOVED*** {
                return callback(err***REMOVED***;
          ***REMOVED***
            if (!test(***REMOVED******REMOVED*** {
                async.doUntil(iterator, test, callback***REMOVED***;
          ***REMOVED***
            else {
                callback(***REMOVED***;
          ***REMOVED***
      ***REMOVED******REMOVED***;
  ***REMOVED***;

    async.queue = function (worker, concurrency***REMOVED*** {
        if (concurrency === undefined***REMOVED*** {
            concurrency = 1;
      ***REMOVED***
        function _insert(q, data, pos, callback***REMOVED*** {
          if(data.constructor !== Array***REMOVED*** {
              data = [data];
        ***REMOVED***
          _each(data, function(task***REMOVED*** {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
            ***REMOVED***;

              if (pos***REMOVED*** {
                q.tasks.unshift(item***REMOVED***;
            ***REMOVED*** else {
                q.tasks.push(item***REMOVED***;
            ***REMOVED***

              if (q.saturated && q.tasks.length === concurrency***REMOVED*** {
                  q.saturated(***REMOVED***;
            ***REMOVED***
              async.setImmediate(q.process***REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED***

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback***REMOVED*** {
              _insert(q, data, false, callback***REMOVED***;
          ***REMOVED***,
            unshift: function (data, callback***REMOVED*** {
              _insert(q, data, true, callback***REMOVED***;
          ***REMOVED***,
            process: function (***REMOVED*** {
                if (workers < q.concurrency && q.tasks.length***REMOVED*** {
                    var task = q.tasks.shift(***REMOVED***;
                    if (q.empty && q.tasks.length === 0***REMOVED*** {
                        q.empty(***REMOVED***;
                  ***REMOVED***
                    workers += 1;
                    var next = function (***REMOVED*** {
                        workers -= 1;
                        if (task.callback***REMOVED*** {
                            task.callback.apply(task, arguments***REMOVED***;
                      ***REMOVED***
                        if (q.drain && q.tasks.length + workers === 0***REMOVED*** {
                            q.drain(***REMOVED***;
                      ***REMOVED***
                        q.process(***REMOVED***;
                  ***REMOVED***;
                    var cb = only_once(next***REMOVED***;
                    worker(task.data, cb***REMOVED***;
              ***REMOVED***
          ***REMOVED***,
            length: function (***REMOVED*** {
                return q.tasks.length;
          ***REMOVED***,
            running: function (***REMOVED*** {
                return workers;
          ***REMOVED***
      ***REMOVED***;
        return q;
  ***REMOVED***;

    async.cargo = function (worker, payload***REMOVED*** {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback***REMOVED*** {
                if(data.constructor !== Array***REMOVED*** {
                    data = [data];
              ***REMOVED***
                _each(data, function(task***REMOVED*** {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                  ***REMOVED******REMOVED***;
                    if (cargo.saturated && tasks.length === payload***REMOVED*** {
                        cargo.saturated(***REMOVED***;
                  ***REMOVED***
              ***REMOVED******REMOVED***;
                async.setImmediate(cargo.process***REMOVED***;
          ***REMOVED***,
            process: function process(***REMOVED*** {
                if (working***REMOVED*** return;
                if (tasks.length === 0***REMOVED*** {
                    if(cargo.drain***REMOVED*** cargo.drain(***REMOVED***;
                    return;
              ***REMOVED***

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload***REMOVED***
                            : tasks.splice(0***REMOVED***;

                var ds = _map(ts, function (task***REMOVED*** {
                    return task.data;
              ***REMOVED******REMOVED***;

                if(cargo.empty***REMOVED*** cargo.empty(***REMOVED***;
                working = true;
                worker(ds, function (***REMOVED*** {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data***REMOVED*** {
                        if (data.callback***REMOVED*** {
                            data.callback.apply(null, args***REMOVED***;
                      ***REMOVED***
                  ***REMOVED******REMOVED***;

                    process(***REMOVED***;
              ***REMOVED******REMOVED***;
          ***REMOVED***,
            length: function (***REMOVED*** {
                return tasks.length;
          ***REMOVED***,
            running: function (***REMOVED*** {
                return working;
          ***REMOVED***
      ***REMOVED***;
        return cargo;
  ***REMOVED***;

    var _console_fn = function (name***REMOVED*** {
        return function (fn***REMOVED*** {
            var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
            fn.apply(null, args.concat([function (err***REMOVED*** {
                var args = Array.prototype.slice.call(arguments, 1***REMOVED***;
                if (typeof console !== 'undefined'***REMOVED*** {
                    if (err***REMOVED*** {
                        if (console.error***REMOVED*** {
                            console.error(err***REMOVED***;
                      ***REMOVED***
                  ***REMOVED***
                    else if (console[name]***REMOVED*** {
                        _each(args, function (x***REMOVED*** {
                            console[name](x***REMOVED***;
                      ***REMOVED******REMOVED***;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***]***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED***;
    async.log = _console_fn('log'***REMOVED***;
    async.dir = _console_fn('dir'***REMOVED***;
    /*async.info = _console_fn('info'***REMOVED***;
    async.warn = _console_fn('warn'***REMOVED***;
    async.error = _console_fn('error'***REMOVED***;*/

    async.memoize = function (fn, hasher***REMOVED*** {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x***REMOVED*** {
            return x;
      ***REMOVED***;
        var memoized = function (***REMOVED*** {
            var args = Array.prototype.slice.call(arguments***REMOVED***;
            var callback = args.pop(***REMOVED***;
            var key = hasher.apply(null, args***REMOVED***;
            if (key in memo***REMOVED*** {
                callback.apply(null, memo[key]***REMOVED***;
          ***REMOVED***
            else if (key in queues***REMOVED*** {
                queues[key].push(callback***REMOVED***;
          ***REMOVED***
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function (***REMOVED*** {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++***REMOVED*** {
                      q[i].apply(null, arguments***REMOVED***;
                  ***REMOVED***
              ***REMOVED***]***REMOVED******REMOVED***;
          ***REMOVED***
      ***REMOVED***;
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
  ***REMOVED***;

    async.unmemoize = function (fn***REMOVED*** {
      return function (***REMOVED*** {
        return (fn.unmemoized || fn***REMOVED***.apply(null, arguments***REMOVED***;
    ***REMOVED***;
  ***REMOVED***;

    async.times = function (count, iterator, callback***REMOVED*** {
        var counter = [];
        for (var i = 0; i < count; i++***REMOVED*** {
            counter.push(i***REMOVED***;
      ***REMOVED***
        return async.map(counter, iterator, callback***REMOVED***;
  ***REMOVED***;

    async.timesSeries = function (count, iterator, callback***REMOVED*** {
        var counter = [];
        for (var i = 0; i < count; i++***REMOVED*** {
            counter.push(i***REMOVED***;
      ***REMOVED***
        return async.mapSeries(counter, iterator, callback***REMOVED***;
  ***REMOVED***;

    async.compose = function (/* functions... */***REMOVED*** {
        var fns = Array.prototype.reverse.call(arguments***REMOVED***;
        return function (***REMOVED*** {
            var that = this;
            var args = Array.prototype.slice.call(arguments***REMOVED***;
            var callback = args.pop(***REMOVED***;
            async.reduce(fns, args, function (newargs, fn, cb***REMOVED*** {
                fn.apply(that, newargs.concat([function (***REMOVED*** {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1***REMOVED***;
                    cb(err, nextargs***REMOVED***;
              ***REMOVED***]***REMOVED******REMOVED***
          ***REMOVED***,
            function (err, results***REMOVED*** {
                callback.apply(that, [err].concat(results***REMOVED******REMOVED***;
          ***REMOVED******REMOVED***;
      ***REMOVED***;
  ***REMOVED***;

    var _applyEach = function (eachfn, fns /*args...*/***REMOVED*** {
        var go = function (***REMOVED*** {
            var that = this;
            var args = Array.prototype.slice.call(arguments***REMOVED***;
            var callback = args.pop(***REMOVED***;
            return eachfn(fns, function (fn, cb***REMOVED*** {
                fn.apply(that, args.concat([cb]***REMOVED******REMOVED***;
          ***REMOVED***,
            callback***REMOVED***;
      ***REMOVED***;
        if (arguments.length > 2***REMOVED*** {
            var args = Array.prototype.slice.call(arguments, 2***REMOVED***;
            return go.apply(this, args***REMOVED***;
      ***REMOVED***
        else {
            return go;
      ***REMOVED***
  ***REMOVED***;
    async.applyEach = doParallel(_applyEach***REMOVED***;
    async.applyEachSeries = doSeries(_applyEach***REMOVED***;

    async.forever = function (fn, callback***REMOVED*** {
        function next(err***REMOVED*** {
            if (err***REMOVED*** {
                if (callback***REMOVED*** {
                    return callback(err***REMOVED***;
              ***REMOVED***
                throw err;
          ***REMOVED***
            fn(next***REMOVED***;
      ***REMOVED***
        next(***REMOVED***;
  ***REMOVED***;

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd***REMOVED*** {
        define([], function (***REMOVED*** {
            return async;
      ***REMOVED******REMOVED***;
  ***REMOVED***
    // Node.js
    else if (typeof module !== 'undefined' && module.exports***REMOVED*** {
        module.exports = async;
  ***REMOVED***
    // included directly via <script> tag
    else {
        root.async = async;
  ***REMOVED***

}(***REMOVED******REMOVED***;
