var CombinedStream = require('combined-stream'***REMOVED***;
var util = require('util'***REMOVED***;
var ***REMOVED***;
var ***REMOVED***;
var https = require('https'***REMOVED***;
var parseUrl = require('url'***REMOVED***.parse;
var fs = require('fs'***REMOVED***;
var mime = require('mime'***REMOVED***;
var async = require('async'***REMOVED***;

module.exports = FormData;
function FormData(***REMOVED*** {
  this._overheadLength = 0;
  this._valueLength = 0;
  this._lengthRetrievers = [];

  CombinedStream.call(this***REMOVED***;
}
util.inherits(FormData, CombinedStream***REMOVED***;

FormData.LINE_BREAK = '\r\n';

FormData.prototype.append = function(field, value, options***REMOVED*** {
  options = options || {};

  var append = CombinedStream.prototype.append.bind(this***REMOVED***;

  // all that streamy business can't handle numbers
  if (typeof value == 'number'***REMOVED*** value = ''+value;

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value***REMOVED******REMOVED*** {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'***REMOVED******REMOVED***;
    return;
***REMOVED***

  var header = this._multiPartHeader(field, value, options***REMOVED***;
  var footer = this._multiPartFooter(field, value, options***REMOVED***;

  append(header***REMOVED***;
  append(value***REMOVED***;
  append(footer***REMOVED***;

  // pass along options.knownLength
  this._trackLength(header, value, options***REMOVED***;
};

FormData.prototype._trackLength = function(header, value, options***REMOVED*** {
  var valueLength = 0;

  // used w/ getLengthSync(***REMOVED***, when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null***REMOVED*** {
    valueLength += +options.knownLength;
***REMOVED*** else if (Buffer.isBuffer(value***REMOVED******REMOVED*** {
    valueLength = value.length;
***REMOVED*** else if (typeof value === 'string'***REMOVED*** {
    valueLength = Buffer.byteLength(value***REMOVED***;
***REMOVED***

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header***REMOVED*** +
    + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion'***REMOVED******REMOVED*** ***REMOVED******REMOVED*** {
    return;
***REMOVED***

  // no need to bother with the length
  if (!options.knownLength***REMOVED***
  this._lengthRetrievers.push(function(next***REMOVED*** {

    if (value.hasOwnProperty('fd'***REMOVED******REMOVED*** {
      fs.stat(value.path, function(err, stat***REMOVED*** {
        if (err***REMOVED*** {
          next(err***REMOVED***;
          return;
      ***REMOVED***

        next(null, stat.size***REMOVED***;
    ***REMOVED******REMOVED***;

    // or http response
  ***REMOVED*** else if (value.hasOwnProperty('httpVersion'***REMOVED******REMOVED*** {
      next(null, +value.headers['content-length']***REMOVED***;

    // or request stream http://github.com/mikeal/request
  ***REMOVED*** else if (value.hasOwnProperty('httpModule'***REMOVED******REMOVED*** {
      // wait till response come back
      value.on('response', function(response***REMOVED*** {
        value.pause(***REMOVED***;
        next(null, +response.headers['content-length']***REMOVED***;
    ***REMOVED******REMOVED***;
      value.resume(***REMOVED***;

    // something else
  ***REMOVED*** else {
      next('Unknown stream'***REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
};

FormData.prototype._multiPartHeader = function(field, value, options***REMOVED*** {
  var boundary = this.getBoundary(***REMOVED***;
  var header = '';

  // custom header specified (as string***REMOVED***?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers***REMOVED***
  if (options.header != null***REMOVED*** {
    header = options.header;
***REMOVED*** else {
    header += '--' + boundary + FormData.LINE_BREAK +
      'Content-Disposition: form-data; name="' + field + '"';

    // fs- and request- streams have path property
    // or use custom filename and/or contentType
    // TODO: Use request's response mime-type
    if (options.filename || value.path***REMOVED*** {
      header +=
        '; filename="' + path.basename(options.filename || value.path***REMOVED*** + '"' + FormData.LINE_BREAK +
        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path***REMOVED******REMOVED***;

    // http response has not
  ***REMOVED*** else if (value.readable && value.hasOwnProperty('httpVersion'***REMOVED******REMOVED*** {
      header +=
        '; filename="' + path.basename(value.client._httpMessage.path***REMOVED*** + '"' + FormData.LINE_BREAK +
        'Content-Type: ' + value.headers['content-type'];
  ***REMOVED***

    header += FormData.LINE_BREAK + FormData.LINE_BREAK;
***REMOVED***

  return header;
};

FormData.prototype._multiPartFooter = function(field, value, options***REMOVED*** {
  return function(next***REMOVED*** {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0***REMOVED***;
    if (lastPart***REMOVED*** {
      footer += this._lastBoundary(***REMOVED***;
  ***REMOVED***

    next(footer***REMOVED***;
***REMOVED***.bind(this***REMOVED***;
};

FormData.prototype._lastBoundary = function(***REMOVED*** {
  return '--' + this.getBoundary(***REMOVED*** + '--';
};

FormData.prototype.getHeaders = function(userHeaders***REMOVED*** {
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary(***REMOVED***
***REMOVED***;

  for (var header in userHeaders***REMOVED*** {
    formHeaders[header.toLowerCase(***REMOVED***] = userHeaders[header];
***REMOVED***

  return formHeaders;
}

FormData.prototype.getCustomHeaders = function(contentType***REMOVED*** {
    contentType = contentType ? contentType : 'multipart/form-data';

    var formHeaders = {
        'content-type': contentType + '; boundary=' + this.getBoundary(***REMOVED***,
        'content-length': this.getLengthSync(***REMOVED***
  ***REMOVED***;

    return formHeaders;
}

FormData.prototype.getBoundary = function(***REMOVED*** {
  if (!this._boundary***REMOVED*** {
    this._generateBoundary(***REMOVED***;
***REMOVED***

  return this._boundary;
};

FormData.prototype._generateBoundary = function(***REMOVED*** {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++***REMOVED*** {
    boundary += Math.floor(Math.random(***REMOVED*** * 10***REMOVED***.toString(16***REMOVED***;
***REMOVED***

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function(debug***REMOVED*** {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length***REMOVED*** {
    knownLength += this._lastBoundary(***REMOVED***.length;
***REMOVED***

  // https://github.com/felixge/node-form-data/issues/40
  if (this._lengthRetrievers.length***REMOVED*** {
    // Some async length retrivers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback***REMOVED*** to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'***REMOVED******REMOVED***;
***REMOVED***

  return knownLength;
};

FormData.prototype.getLength = function(cb***REMOVED*** {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length***REMOVED*** {
    knownLength += this._lastBoundary(***REMOVED***.length;
***REMOVED***

  if (!this._lengthRetrievers.length***REMOVED*** {
    process.nextTick(cb.bind(this, null, knownLength***REMOVED******REMOVED***;
    return;
***REMOVED***

  async.parallel(this._lengthRetrievers, function(err, values***REMOVED*** {
    if (err***REMOVED*** {
      cb(err***REMOVED***;
      return;
  ***REMOVED***

    values.forEach(function(length***REMOVED*** {
      knownLength += length;
  ***REMOVED******REMOVED***;

    cb(null, knownLength***REMOVED***;
***REMOVED******REMOVED***;
};

FormData.prototype.submit = function(params, cb***REMOVED*** {

  var request
    , options
    , defaults = {
        method : 'post',
        headers: this.getHeaders(***REMOVED***
  ***REMOVED***;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string'***REMOVED*** {
    params = parseUrl(params***REMOVED***;

    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname
  ***REMOVED***, defaults***REMOVED***;
***REMOVED***
  else // use custom params
  {
    options = populate(params, defaults***REMOVED***;
    // if no port provided use default one
    if (!options.port***REMOVED*** {
      options.port = options.protocol == 'https:' ? 443 : 80;
  ***REMOVED***
***REMOVED***

  // https if specified, fallback to http in any other case
  if (params.protocol == 'https:'***REMOVED*** {
    request = https.request(options***REMOVED***;
***REMOVED*** else {
    request = http.request(options***REMOVED***;
***REMOVED***

  // get content length and fire away
  this.getLength(function(err, length***REMOVED*** {

    // TODO: Add chunked encoding when no length (if err***REMOVED***

    // add content length
    request.setHeader('Content-Length', length***REMOVED***;

    this.pipe(request***REMOVED***;
    if (cb***REMOVED*** {
      request.on('error', cb***REMOVED***;
      request.on('response', cb.bind(this, null***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***.bind(this***REMOVED******REMOVED***;

  return request;
};

FormData.prototype._error = function(err***REMOVED*** {
  if (this.error***REMOVED*** return;

  this.error = err;
  this.pause(***REMOVED***;
  this.emit('error', err***REMOVED***;
};

/*
 * Santa's little helpers
 */

// populates missing values
function populate(dst, src***REMOVED*** {
  for (var prop in src***REMOVED*** {
    if (!dst[prop]***REMOVED*** dst[prop] = src[prop];
***REMOVED***
  return dst;
}
