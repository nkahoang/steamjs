// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus'***REMOVED***;
var crypto = require('crypto'***REMOVED***;

var asn1 = require('asn1'***REMOVED***;
var ctype = require('ctype'***REMOVED***;



///--- Helpers

function readNext(buffer, offset***REMOVED*** {
  var len = ctype.ruint32(buffer, 'big', offset***REMOVED***;
  offset += 4;

  var newOffset = offset + len;

  return {
    data: buffer.slice(offset, newOffset***REMOVED***,
    offset: newOffset
***REMOVED***;
}


function writeInt(writer, buffer***REMOVED*** {
  writer.writeByte(0x02***REMOVED***; // ASN1.Integer
  writer.writeLength(buffer.length***REMOVED***;

  for (var i = 0; i < buffer.length; i++***REMOVED***
    writer.writeByte(buffer[i]***REMOVED***;

  return writer;
}


function rsaToPEM(key***REMOVED*** {
  var buffer;
  var der;
  var exponent;
  var i;
  var modulus;
  var newKey = '';
  var offset = 0;
  var type;
  var tmp;

  try {
    buffer = new Buffer(key.split(' '***REMOVED***[1], 'base64'***REMOVED***;

    tmp = readNext(buffer, offset***REMOVED***;
    type = tmp.data.toString(***REMOVED***;
    offset = tmp.offset;

    if (type !== 'ssh-rsa'***REMOVED***
      throw new Error('Invalid ssh key type: ' + type***REMOVED***;

    tmp = readNext(buffer, offset***REMOVED***;
    exponent = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset***REMOVED***;
    modulus = tmp.data;
***REMOVED*** catch (e***REMOVED*** {
    throw new Error('Invalid ssh key: ' + key***REMOVED***;
***REMOVED***

  // DER is a subset of BER
  der = new asn1.BerWriter(***REMOVED***;

  der.startSequence(***REMOVED***;

  der.startSequence(***REMOVED***;
  der.writeOID('1.2.840.113549.1.1.1'***REMOVED***;
  der.writeNull(***REMOVED***;
  der.endSequence(***REMOVED***;

  der.startSequence(0x03***REMOVED***; // bit string
  der.writeByte(0x00***REMOVED***;

  // Actual key
  der.startSequence(***REMOVED***;
  writeInt(der, modulus***REMOVED***;
  writeInt(der, exponent***REMOVED***;
  der.endSequence(***REMOVED***;

  // bit string
  der.endSequence(***REMOVED***;

  der.endSequence(***REMOVED***;

  tmp = der.buffer.toString('base64'***REMOVED***;
  for (i = 0; i < tmp.length; i++***REMOVED*** {
    if ((i % 64***REMOVED*** === 0***REMOVED***
      newKey += '\n';
    newKey += tmp.charAt(i***REMOVED***;
***REMOVED***

  if (!/\\n$/.test(newKey***REMOVED******REMOVED***
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


function dsaToPEM(key***REMOVED*** {
  var buffer;
  var offset = 0;
  var tmp;
  var der;
  var newKey = '';

  var type;
  var p;
  var q;
  var g;
  var y;

  try {
    buffer = new Buffer(key.split(' '***REMOVED***[1], 'base64'***REMOVED***;

    tmp = readNext(buffer, offset***REMOVED***;
    type = tmp.data.toString(***REMOVED***;
    offset = tmp.offset;

    /* JSSTYLED */
    if (!/^ssh-ds[as].*/.test(type***REMOVED******REMOVED***
      throw new Error('Invalid ssh key type: ' + type***REMOVED***;

    tmp = readNext(buffer, offset***REMOVED***;
    p = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset***REMOVED***;
    q = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset***REMOVED***;
    g = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset***REMOVED***;
    y = tmp.data;
***REMOVED*** catch (e***REMOVED*** {
    console.log(e.stack***REMOVED***;
    throw new Error('Invalid ssh key: ' + key***REMOVED***;
***REMOVED***

  // DER is a subset of BER
  der = new asn1.BerWriter(***REMOVED***;

  der.startSequence(***REMOVED***;

  der.startSequence(***REMOVED***;
  der.writeOID('1.2.840.10040.4.1'***REMOVED***;

  der.startSequence(***REMOVED***;
  writeInt(der, p***REMOVED***;
  writeInt(der, q***REMOVED***;
  writeInt(der, g***REMOVED***;
  der.endSequence(***REMOVED***;

  der.endSequence(***REMOVED***;

  der.startSequence(0x03***REMOVED***; // bit string
  der.writeByte(0x00***REMOVED***;
  writeInt(der, y***REMOVED***;
  der.endSequence(***REMOVED***;

  der.endSequence(***REMOVED***;

  tmp = der.buffer.toString('base64'***REMOVED***;
  for (var i = 0; i < tmp.length; i++***REMOVED*** {
    if ((i % 64***REMOVED*** === 0***REMOVED***
      newKey += '\n';
    newKey += tmp.charAt(i***REMOVED***;
***REMOVED***

  if (!/\\n$/.test(newKey***REMOVED******REMOVED***
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


///--- API

module.exports = {

  /**
   * Converts an OpenSSH public key (rsa only***REMOVED*** to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key***REMOVED*** {
    assert.string(key, 'ssh_key'***REMOVED***;

    /* JSSTYLED */
    if (/^ssh-rsa.*/.test(key***REMOVED******REMOVED***
      return rsaToPEM(key***REMOVED***;

    /* JSSTYLED */
    if (/^ssh-ds[as].*/.test(key***REMOVED******REMOVED***
      return dsaToPEM(key***REMOVED***;

    throw new Error('Only RSA and DSA public keys are allowed'***REMOVED***;
***REMOVED***,


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key***REMOVED*** {
    assert.string(key, 'ssh_key'***REMOVED***;

    var pieces = key.split(' '***REMOVED***;
    if (!pieces || !pieces.length || pieces.length < 2***REMOVED***
      throw new Error('invalid ssh key'***REMOVED***;

    var data = new Buffer(pieces[1], 'base64'***REMOVED***;

    var hash = crypto.createHash('md5'***REMOVED***;
    hash.update(data***REMOVED***;
    var digest = hash.digest('hex'***REMOVED***;

    var fp = '';
    for (var i = 0; i < digest.length; i++***REMOVED*** {
      if (i && i % 2 === 0***REMOVED***
        fp += ':';

      fp += digest[i];
  ***REMOVED***

    return fp;
***REMOVED***


};
