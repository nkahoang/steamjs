/*
 * ctf.js
 *
 * Understand and parse all of the different JSON formats of CTF data and
 * translate that into a series of node-ctype friendly pieces. The reason for
 * the abstraction is to handle different changes in the file format.
 *
 * We have to be careful here that we don't end up using a name that is already
 * a built in type.
 */
var mod_assert = require('assert'***REMOVED***;
var ASSERT = mod_assert.ok;

var ctf_versions = [ '1.0' ];
var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
    'uint32_t', 'float', 'double' ];

function ctfParseInteger(entry, ctype***REMOVED***
{
	var name, sign, len, type;

	name = entry['name'];
	if (!('signed' in entry['integer']***REMOVED******REMOVED***
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'signed value'***REMOVED******REMOVED***;


	if (!('length' in entry['integer']***REMOVED******REMOVED***
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'length value'***REMOVED******REMOVED***;

	sign = entry['integer']['signed'];
	len = entry['integer']['length'];
	type = null;

	if (sign && len == 1***REMOVED***
		type = 'int8_t';
	else if (len == 1***REMOVED***
		type = 'uint8_t';
	else if (sign && len == 2***REMOVED***
		type = 'int16_t';
	else if (len == 2***REMOVED***
		type = 'uint16_t';
	else if (sign && len == 4***REMOVED***
		type = 'int32_t';
	else if (len == 4***REMOVED***
		type = 'uint32_t';
	else if (sign && len == 8***REMOVED***
		type = 'int64_t';
	else if (len == 8***REMOVED***
		type = 'uint64_t';

	if (type === null***REMOVED***
		throw (new Error('Malformed CTF JSON: integer has ' +
		    'unsupported length and sign - ' + len + '/' + sign***REMOVED******REMOVED***;

	/*
	 * This means that this is the same as one of our built in types. If
	 * that's the case defining it would be an error. So instead of trying
	 * to typedef it, we'll return here.
	 */
	if (name == type***REMOVED***
		return;

	if (name == 'char'***REMOVED*** {
		ASSERT(type == 'int8_t'***REMOVED***;
		return;
	}

	ctype.typedef(name, type***REMOVED***;
}

function ctfParseFloat(entry, ctype***REMOVED***
{
	var name, len;

	name = entry['name'];
	if (!('length' in entry['float']***REMOVED******REMOVED***
		throw (new Error('Malformed CTF JSON: float missing ' +
		    'length value'***REMOVED******REMOVED***;

	len = entry['float']['length'];
	if (len != 4 && len != 8***REMOVED***
		throw (new Error('Malformed CTF JSON: float has invalid ' +
		    'length value'***REMOVED******REMOVED***;

	if (len == 4***REMOVED*** {
		if (name == 'float'***REMOVED***
			return;
		ctype.typedef(name, 'float'***REMOVED***;
	} else if (len == 8***REMOVED*** {
		if (name == 'double'***REMOVED***
			return;
		ctype.typedef(name, 'double'***REMOVED***;
	}
}

function ctfParseTypedef(entry, ctype***REMOVED***
{
	var name, type, ii;

	name = entry['name'];
	if (typeof (entry['typedef']***REMOVED*** != 'string'***REMOVED***
		throw (new Error('Malformed CTF JSON: typedef value in not ' +
		    'a string'***REMOVED******REMOVED***;

	type = entry['typedef'];

	/*
	 * We need to ensure that we're not looking at type that's one of our
	 * built in types. Traditionally in C a uint32_t would be a typedef to
	 * some kind of integer. However, those size types are built ins.
	 */
	for (ii = 0; ii < ctf_deftypes.length; ii++***REMOVED*** {
		if (name == ctf_deftypes[ii]***REMOVED***
			return;
	}

	ctype.typedef(name, type***REMOVED***;
}

function ctfParseStruct(entry, ctype***REMOVED***
{
	var name, type, ii, val, index, member, push;

	member = [];
	if (!Array.isArray(entry['struct']***REMOVED******REMOVED***
		throw (new Error('Malformed CTF JSON: struct value is not ' +
		    'an array'***REMOVED******REMOVED***;

	for (ii = 0; ii < entry['struct'].length; ii++***REMOVED*** {
		val = entry['struct'][ii];
		if (!('name' in val***REMOVED******REMOVED***
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing name'***REMOVED******REMOVED***;

		if (!('type' in val***REMOVED******REMOVED***
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing type'***REMOVED******REMOVED***;

		if (typeof (val['name']***REMOVED*** != 'string'***REMOVED***
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'name isn\'t a string'***REMOVED******REMOVED***;

		if (typeof (val['type']***REMOVED*** != 'string'***REMOVED***
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'type isn\'t a string'***REMOVED******REMOVED***;

		/*
		 * CTF version 2 specifies array names as <type> [<num>] where
		 * as node-ctype does this as <type>[<num>].
		 */
		name = val['name'];
		type = val['type'];
		index = type.indexOf(' ['***REMOVED***;
		if (index != -1***REMOVED*** {
			type = type.substring(0, index***REMOVED*** +
			    type.substring(index + 1, type.length***REMOVED***;
		}
		push = {};
		push[name] = { 'type': type };
		member.push(push***REMOVED***;
	}

	name = entry['name'];
	ctype.typedef(name, member***REMOVED***;
}

function ctfParseEntry(entry, ctype***REMOVED***
{
	var ii, found;

	if (!('name' in entry***REMOVED******REMOVED***
		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
		    'section'***REMOVED******REMOVED***;

	for (ii = 0; ii < ctf_entries.length; ii++***REMOVED*** {
		if (ctf_entries[ii] in entry***REMOVED***
			found++;
	}

	if (found === 0***REMOVED***
		throw (new Error('Malformed CTF JSON: found no entries'***REMOVED******REMOVED***;

	if (found >= 2***REMOVED***
		throw (new Error('Malformed CTF JSON: found more than one ' +
		    'entry'***REMOVED******REMOVED***;

	if ('integer' in entry***REMOVED*** {
		ctfParseInteger(entry, ctype***REMOVED***;
		return;
	}

	if ('float' in entry***REMOVED*** {
		ctfParseFloat(entry, ctype***REMOVED***;
		return;
	}

	if ('typedef' in entry***REMOVED*** {
		ctfParseTypedef(entry, ctype***REMOVED***;
		return;
	}

	if ('struct' in entry***REMOVED*** {
		ctfParseStruct(entry, ctype***REMOVED***;
		return;
	}

	ASSERT(false, 'shouldn\'t reach here'***REMOVED***;
}

function ctfParseJson(json, ctype***REMOVED***
{
	var version, ii;

	ASSERT(json***REMOVED***;
	ASSERT(ctype***REMOVED***;
	if (!('metadata' in json***REMOVED******REMOVED***
		throw (new Error('Invalid CTF JSON: missing metadata section'***REMOVED******REMOVED***;

	if (!('ctf2json_version' in json['metadata']***REMOVED******REMOVED***
		throw (new Error('Invalid CTF JSON: missing ctf2json_version'***REMOVED******REMOVED***;

	version = json['metadata']['ctf2json_version'];
	for (ii = 0; ii < ctf_versions.length; ii++***REMOVED*** {
		if (ctf_versions[ii] == version***REMOVED***
			break;
	}

	if (ii == ctf_versions.length***REMOVED***
		throw (new Error('Unsuported ctf2json_version: ' + version***REMOVED******REMOVED***;

	if (!('data' in json***REMOVED******REMOVED***
		throw (new Error('Invalid CTF JSON: missing data section'***REMOVED******REMOVED***;

	if (!Array.isArray(json['data']***REMOVED******REMOVED***
		throw (new Error('Malformed CTF JSON: data section is not ' +
		    'an array'***REMOVED******REMOVED***;

	for (ii = 0; ii < json['data'].length; ii++***REMOVED***
		ctfParseEntry(json['data'][ii], ctype***REMOVED***;
}

exports.ctfParseJson = ctfParseJson;
