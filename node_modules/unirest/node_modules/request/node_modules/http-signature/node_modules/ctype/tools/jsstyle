#!/usr/bin/env perl
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License"***REMOVED***.
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
# Copyright 2011 Joyent, Inc. All rights reserved.
#
# jsstyle - check for some common stylistic errors.
#
#	jsstyle is a sort of "lint" for Javascript coding style.  This tool is
#	derived from the cstyle tool, used to check for the style used in the
#	Solaris kernel, sometimes known as "Bill Joy Normal Form".
#
#	There's a lot this can't check for, like proper indentation of code
#	blocks.  There's also a lot more this could check for.
#
#	A note to the non perl literate:
#
#		perl regular expressions are pretty much like egrep
#		regular expressions, with the following special symbols
#
#		\s	any space character
#		\S	any non-space character
#		\w	any "word" character [a-zA-Z0-9_]
#		\W	any non-word character
#		\d	a digit [0-9]
#		\D	a non-digit
#		\b	word boundary (between \w and \W***REMOVED***
#		\B	non-word boundary
#

require 5.0;
use IO::File;
use Getopt::Std;
use strict;

my $usage =
"usage: jsstyle [-chvC] [-o constructs] file ...
	-c	check continuation indentation inside functions
	-h	perform heuristic checks that are sometimes wrong
	-v	verbose
	-C	don't check anything in header block comments
	-o constructs
		allow a comma-seperated list of optional constructs:
		    doxygen	allow doxygen-style block comments (/** /*!***REMOVED***
		    splint	allow splint-style lint comments (/*@ ... @*/***REMOVED***
";

my %opts;

if (!getopts("cho:vC", \%opts***REMOVED******REMOVED*** {
	print $usage;
	exit 2;
}

my $check_continuation = $opts{'c'};
my $heuristic = $opts{'h'};
my $verbose = $opts{'v'};
my $ignore_hdr_comment = $opts{'C'};

my $doxygen_comments = 0;
my $splint_comments = 0;

if (defined($opts{'o'}***REMOVED******REMOVED*** {
	for my $x (split /,/, $opts{'o'}***REMOVED*** {
		if ($x eq "doxygen"***REMOVED*** {
			$doxygen_comments = 1;
		} elsif ($x eq "splint"***REMOVED*** {
			$splint_comments = 1;
		} else {
			print "jsstyle: unrecognized construct \"$x\"\n";
			print $usage;
			exit 2;
		}
	}
}

my ($filename, $line, $prev***REMOVED***;		# shared globals

my $fmt;
my $hdr_comment_start;

if ($verbose***REMOVED*** {
	$fmt = "%s: %d: %s\n%s\n";
} else {
	$fmt = "%s: %d: %s\n";
}

if ($doxygen_comments***REMOVED*** {
	# doxygen comments look like "/*!" or "/**"; allow them.
	$hdr_comment_start = qr/^\s*\/\*[\!\*]?$/;
} else {
	$hdr_comment_start = qr/^\s*\/\*$/;
}

# Note, following must be in single quotes so that \s and \w work right.
my $lint_re = qr/\/\*(?:
	jsl:\w+?|ARGSUSED[0-9]*|NOTREACHED|LINTLIBRARY|VARARGS[0-9]*|
	CONSTCOND|CONSTANTCOND|CONSTANTCONDITION|EMPTY|
	FALLTHRU|FALLTHROUGH|LINTED.*?|PRINTFLIKE[0-9]*|
	PROTOLIB[0-9]*|SCANFLIKE[0-9]*|JSSTYLED.*?
    ***REMOVED***\*\//x;

my $splint_re = qr/\/\*@.*?@\*\//x;

my $err_stat = 0;		# exit status

if ($#ARGV >= 0***REMOVED*** {
	foreach my $arg (@ARGV***REMOVED*** {
		my $fh = new IO::File $arg, "r";
		if (!defined($fh***REMOVED******REMOVED*** {
			printf "%s: cannot open\n", $arg;
		} else {
			&jsstyle($arg, $fh***REMOVED***;
			close $fh;
		}
	}
} else {
	&jsstyle("<stdin>", *STDIN***REMOVED***;
}
exit $err_stat;

my $no_errs = 0;		# set for JSSTYLED-protected lines

sub err($***REMOVED*** {
	my ($error***REMOVED*** = @_;
	unless ($no_errs***REMOVED*** {
		printf $fmt, $filename, $., $error, $line;
		$err_stat = 1;
	}
}

sub err_prefix($$***REMOVED*** {
	my ($prevline, $error***REMOVED*** = @_;
	my $out = $prevline."\n".$line;
	unless ($no_errs***REMOVED*** {
		printf $fmt, $filename, $., $error, $out;
		$err_stat = 1;
	}
}

sub err_prev($***REMOVED*** {
	my ($error***REMOVED*** = @_;
	unless ($no_errs***REMOVED*** {
		printf $fmt, $filename, $. - 1, $error, $prev;
		$err_stat = 1;
	}
}

sub jsstyle($$***REMOVED*** {

my ($fn, $filehandle***REMOVED*** = @_;
$filename = $fn;			# share it globally

my $in_cpp = 0;
my $next_in_cpp = 0;

my $in_comment = 0;
my $in_header_comment = 0;
my $comment_done = 0;
my $in_function = 0;
my $in_function_header = 0;
my $in_declaration = 0;
my $note_level = 0;
my $nextok = 0;
my $nocheck = 0;

my $in_string = 0;

my ($okmsg, $comment_prefix***REMOVED***;

$line = '';
$prev = '';
reset_indent(***REMOVED***;

line: while (<$filehandle>***REMOVED*** {
	s/\r?\n$//;	# strip return and newline

	# save the original line, then remove all text from within
	# double or single quotes, we do not want to check such text.

	$line = $_;

	#
	# C allows strings to be continued with a backslash at the end of
	# the line.  We translate that into a quoted string on the previous
	# line followed by an initial quote on the next line.
	#
	# (we assume that no-one will use backslash-continuation with character
	# constants***REMOVED***
	#
	$_ = '"' . $_		if ($in_string && !$nocheck && !$in_comment***REMOVED***;

	#
	# normal strings and characters
	#
	s/'([^\\']|\\.***REMOVED****'/\'\'/g;
	s/"([^\\"]|\\.***REMOVED****"/\"\"/g;

	#
	# detect string continuation
	#
	if ($nocheck || $in_comment***REMOVED*** {
		$in_string = 0;
	} else {
		#
		# Now that all full strings are replaced with "", we check
		# for unfinished strings continuing onto the next line.
		#
		$in_string =
		    (s/([^"](?:""***REMOVED*******REMOVED***"([^\\"]|\\.***REMOVED****\\$/$1""/ ||
		    s/^(""***REMOVED****"([^\\"]|\\.***REMOVED****\\$/""/***REMOVED***;
	}

	#
	# figure out if we are in a cpp directive
	#
	$in_cpp = $next_in_cpp || /^\s*#/;	# continued or started
	$next_in_cpp = $in_cpp && /\\$/;	# only if continued

	# strip off trailing backslashes, which appear in long macros
	s/\s*\\$//;

	# an /* END JSSTYLED */ comment ends a no-check block.
	if ($nocheck***REMOVED*** {
		if (/\/\* *END *JSSTYLED *\*\//***REMOVED*** {
			$nocheck = 0;
		} else {
			reset_indent(***REMOVED***;
			next line;
		}
	}

	# a /*JSSTYLED*/ comment indicates that the next line is ok.
	if ($nextok***REMOVED*** {
		if ($okmsg***REMOVED*** {
			err($okmsg***REMOVED***;
		}
		$nextok = 0;
		$okmsg = 0;
		if (/\/\* *JSSTYLED.*\*\//***REMOVED*** {
			/^.*\/\* *JSSTYLED *(.****REMOVED*** *\*\/.*$/;
			$okmsg = $1;
			$nextok = 1;
		}
		$no_errs = 1;
	} elsif ($no_errs***REMOVED*** {
		$no_errs = 0;
	}

	# check length of line.
	# first, a quick check to see if there is any chance of being too long.
	if (($line =~ tr/\t/\t/***REMOVED*** * 7 + length($line***REMOVED*** > 80***REMOVED*** {
		# yes, there is a chance.
		# replace tabs with spaces and check again.
		my $eline = $line;
		1 while $eline =~
		    s/\t+/' ' x (length($&***REMOVED*** * 8 - length($`***REMOVED*** % 8***REMOVED***/e;
		if (length($eline***REMOVED*** > 80***REMOVED*** {
			err("line > 80 characters"***REMOVED***;
		}
	}

	# ignore NOTE(...***REMOVED*** annotations (assumes NOTE is on lines by itself***REMOVED***.
	if ($note_level || /\b_?NOTE\s*\(/***REMOVED*** { # if in NOTE or this is NOTE
		s/[^(***REMOVED***]//g;			  # eliminate all non-parens
		$note_level += s/\(//g - length;  # update paren nest level
		next;
	}

	# a /* BEGIN JSSTYLED */ comment starts a no-check block.
	if (/\/\* *BEGIN *JSSTYLED *\*\//***REMOVED*** {
		$nocheck = 1;
	}

	# a /*JSSTYLED*/ comment indicates that the next line is ok.
	if (/\/\* *JSSTYLED.*\*\//***REMOVED*** {
		/^.*\/\* *JSSTYLED *(.****REMOVED*** *\*\/.*$/;
		$okmsg = $1;
		$nextok = 1;
	}
	if (/\/\/ *JSSTYLED/***REMOVED*** {
		/^.*\/\/ *JSSTYLED *(.****REMOVED***$/;
		$okmsg = $1;
		$nextok = 1;
	}

	# universal checks; apply to everything
	if (/\t +\t/***REMOVED*** {
		err("spaces between tabs"***REMOVED***;
	}
	if (/ \t+ /***REMOVED*** {
		err("tabs between spaces"***REMOVED***;
	}
	if (/\s$/***REMOVED*** {
		err("space or tab at end of line"***REMOVED***;
	}
	if (/[^ \t(]\/\*/ && !/\w\(\/\*.*\*\/\***REMOVED***;/***REMOVED*** {
		err("comment preceded by non-blank"***REMOVED***;
	}

	# is this the beginning or ending of a function?
	# (not if "struct foo\n{\n"***REMOVED***
	if (/^{$/ && $prev =~ /\***REMOVED***\s*(const\s****REMOVED***?(\/\*.*\*\/\s****REMOVED***?\\?$/***REMOVED*** {
		$in_function = 1;
		$in_declaration = 1;
		$in_function_header = 0;
		$prev = $line;
		next line;
	}
	if (/^}\s*(\/\*.*\*\/\s****REMOVED****$/***REMOVED*** {
		if ($prev =~ /^\s*return\s*;/***REMOVED*** {
			err_prev("unneeded return at end of function"***REMOVED***;
		}
		$in_function = 0;
		reset_indent(***REMOVED***;		# we don't check between functions
		$prev = $line;
		next line;
	}
	if (/^\w*\($/***REMOVED*** {
		$in_function_header = 1;
	}

	# a blank line terminates the declarations within a function.
	# XXX - but still a problem in sub-blocks.
	if ($in_declaration && /^$/***REMOVED*** {
		$in_declaration = 0;
	}

	if ($comment_done***REMOVED*** {
		$in_comment = 0;
		$in_header_comment = 0;
		$comment_done = 0;
	}
	# does this looks like the start of a block comment?
	if (/$hdr_comment_start/***REMOVED*** {
		if (!/^\t*\/\*/***REMOVED*** {
			err("block comment not indented by tabs"***REMOVED***;
		}
		$in_comment = 1;
		/^(\s****REMOVED***\//;
		$comment_prefix = $1;
		if ($comment_prefix eq ""***REMOVED*** {
			$in_header_comment = 1;
		}
		$prev = $line;
		next line;
	}
	# are we still in the block comment?
	if ($in_comment***REMOVED*** {
		if (/^$comment_prefix \*\/$/***REMOVED*** {
			$comment_done = 1;
		} elsif (/\*\//***REMOVED*** {
			$comment_done = 1;
			err("improper block comment close"***REMOVED***
			    unless ($ignore_hdr_comment && $in_header_comment***REMOVED***;
		} elsif (!/^$comment_prefix \*[ \t]/ &&
		    !/^$comment_prefix \*$/***REMOVED*** {
			err("improper block comment"***REMOVED***
			    unless ($ignore_hdr_comment && $in_header_comment***REMOVED***;
		}
	}

	if ($in_header_comment && $ignore_hdr_comment***REMOVED*** {
		$prev = $line;
		next line;
	}

	# check for errors that might occur in comments and in code.

	# allow spaces to be used to draw pictures in header comments.
	#if (/[^ ]     / && !/".*     .*"/ && !$in_header_comment***REMOVED*** {
	#	err("spaces instead of tabs"***REMOVED***;
	#}
	#if (/^ / && !/^ \*[ \t\/]/ && !/^ \*$/ &&
	#    (!/^    \w/ || $in_function != 0***REMOVED******REMOVED*** {
	#	err("indent by spaces instead of tabs"***REMOVED***;
	#}
	if (/^ {2,}/ && !/^    [^ ]/***REMOVED*** {
		err("indent by spaces instead of tabs"***REMOVED***;
	}
	if (/^\t+ [^ \t\*]/ || /^\t+  \S/ || /^\t+   \S/***REMOVED*** {
		err("continuation line not indented by 4 spaces"***REMOVED***;
	}

	if (/^\s*\/\*./ && !/^\s*\/\*.*\*\// && !/$hdr_comment_start/***REMOVED*** {
		err("improper first line of block comment"***REMOVED***;
	}

	if ($in_comment***REMOVED*** {	# still in comment, don't do further checks
		$prev = $line;
		next line;
	}

	if ((/[^(]\/\*\S/ || /^\/\*\S/***REMOVED*** &&
	    !(/$lint_re/ || ($splint_comments && /$splint_re/***REMOVED******REMOVED******REMOVED*** {
		err("missing blank after open comment"***REMOVED***;
	}
	if (/\S\*\/[^***REMOVED***]|\S\*\/$/ &&
	    !(/$lint_re/ || ($splint_comments && /$splint_re/***REMOVED******REMOVED******REMOVED*** {
		err("missing blank before close comment"***REMOVED***;
	}
	if (/\/\/\S/***REMOVED*** {		# C++ comments
		err("missing blank after start comment"***REMOVED***;
	}
	# check for unterminated single line comments, but allow them when
	# they are used to comment out the argument list of a function
	# declaration.
	if (/\S.*\/\*/ && !/\S.*\/\*.*\*\// && !/\(\/\*/***REMOVED*** {
		err("unterminated single line comment"***REMOVED***;
	}

	if (/^(#else|#endif|#include***REMOVED***(.****REMOVED***$/***REMOVED*** {
		$prev = $line;
		next line;
	}

	#
	# delete any comments and check everything else.  Note that
	# ".*?" is a non-greedy match, so that we don't get confused by
	# multiple comments on the same line.
	#
	s/\/\*.*?\*\///g;
	s/\/\/.*$//;		# C++ comments

	# delete any trailing whitespace; we have already checked for that.
	s/\s*$//;

	# following checks do not apply to text in comments.
	if (/"/***REMOVED*** {
		err("literal string using double-quote instead of single"***REMOVED***;
	}

	if (/[^=!<>\s][!<>=]=/ || /[^<>!=][!<>=]==?[^\s,=]/ ||
	    (/[^->]>[^,=>\s]/ && !/[^->]>$/***REMOVED*** ||
	    (/[^<]<[^,=<\s]/ && !/[^<]<$/***REMOVED*** ||
	    /[^<\s]<[^<]/ || /[^->\s]>[^>]/***REMOVED*** {
		err("missing space around relational operator"***REMOVED***;
	}
	if (/\S>>=/ || /\S<<=/ || />>=\S/ || /<<=\S/ || /\S[-+*\/&|^%]=/ ||
	    (/[^-+*\/&|^%!<>=\s]=[^=]/ && !/[^-+*\/&|^%!<>=\s]=$/***REMOVED*** ||
	    (/[^!<>=]=[^=\s]/ && !/[^!<>=]=$/***REMOVED******REMOVED*** {
		# XXX - should only check this for C++ code
		# XXX - there are probably other forms that should be allowed
		if (!/\soperator=/***REMOVED*** {
			err("missing space around assignment operator"***REMOVED***;
		}
	}
	if (/[,;]\S/ && !/\bfor \(;;\***REMOVED***/***REMOVED*** {
		err("comma or semicolon followed by non-blank"***REMOVED***;
	}
	# allow "for" statements to have empty "while" clauses
	if (/\s[,;]/ && !/^[\t]+;$/ && !/^\s*for \([^;]*; ;[^;]*\***REMOVED***/***REMOVED*** {
		err("comma or semicolon preceded by blank"***REMOVED***;
	}
	if (/^\s*(&&|\|\|***REMOVED***/***REMOVED*** {
		err("improper boolean continuation"***REMOVED***;
	}
	if (/\S   *(&&|\|\|***REMOVED***/ || /(&&|\|\|***REMOVED***   *\S/***REMOVED*** {
		err("more than one space around boolean operator"***REMOVED***;
	}
	if (/\b(delete|typeof|instanceOf|throw|with|catch|new|function|in|for|if|while|switch|return|case***REMOVED***\(/***REMOVED*** {
		err("missing space between keyword and paren"***REMOVED***;
	}
	if (/(\b(catch|for|if|with|while|switch|return***REMOVED***\b.****REMOVED***{2,}/***REMOVED*** {
		# multiple "case" and "sizeof" allowed
		err("more than one keyword on line"***REMOVED***;
	}
	if (/\b(delete|typeof|instanceOf|with|throw|catch|new|function|in|for|if|while|switch|return|case***REMOVED***\s\s+\(/ &&
	    !/^#if\s+\(/***REMOVED*** {
		err("extra space between keyword and paren"***REMOVED***;
	}
	# try to detect "func (x***REMOVED***" but not "if (x***REMOVED***" or
	# "#define foo (x***REMOVED***" or "int (*func***REMOVED***(***REMOVED***;"
	if (/\w\s\(/***REMOVED*** {
		my $s = $_;
		# strip off all keywords on the line
		s/\b(delete|typeof|instanceOf|throw|with|catch|new|function|in|for|if|while|switch|return|case***REMOVED***\s\(/XXX(/g;
		s/#elif\s\(/XXX(/g;
		s/^#define\s+\w+\s+\(/XXX(/;
		# do not match things like "void (*f***REMOVED***(***REMOVED***;"
		# or "typedef void (func_t***REMOVED***(***REMOVED***;"
		s/\w\s\(+\*/XXX(*/g;
		s/\b(void***REMOVED***\s+\(+/XXX(/og;
		if (/\w\s\(/***REMOVED*** {
			err("extra space between function name and left paren"***REMOVED***;
		}
		$_ = $s;
	}

	if (/^\s*return\W[^;]*;/ && !/^\s*return\s*\(.*\***REMOVED***;/***REMOVED*** {
		err("unparenthesized return expression"***REMOVED***;
	}
	if (/\btypeof\b/ && !/\btypeof\s*\(.*\***REMOVED***/***REMOVED*** {
		err("unparenthesized typeof expression"***REMOVED***;
	}
	if (/\(\s/***REMOVED*** {
		err("whitespace after left paren"***REMOVED***;
	}
	# allow "for" statements to have empty "continue" clauses
	if (/\s\***REMOVED***/ && !/^\s*for \([^;]*;[^;]*; \***REMOVED***/***REMOVED*** {
		err("whitespace before right paren"***REMOVED***;
	}
	if (/^\s*\(void\***REMOVED***[^ ]/***REMOVED*** {
		err("missing space after (void***REMOVED*** cast"***REMOVED***;
	}
	if (/\S{/ && !/({|\(***REMOVED***{/***REMOVED*** {
		err("missing space before left brace"***REMOVED***;
	}
	if ($in_function && /^\s+{/ &&
	    ($prev =~ /\***REMOVED***\s*$/ || $prev =~ /\bstruct\s+\w+$/***REMOVED******REMOVED*** {
		err("left brace starting a line"***REMOVED***;
	}
	if (/}(else|while***REMOVED***/***REMOVED*** {
		err("missing space after right brace"***REMOVED***;
	}
	if (/}\s\s+(else|while***REMOVED***/***REMOVED*** {
		err("extra space after right brace"***REMOVED***;
	}
	if (/^\s+#/***REMOVED*** {
		err("preprocessor statement not in column 1"***REMOVED***;
	}
	if (/^#\s/***REMOVED*** {
		err("blank after preprocessor #"***REMOVED***;
	}

	#
	# We completely ignore, for purposes of indentation:
	#  * lines outside of functions
	#  * preprocessor lines
	#
	if ($check_continuation && $in_function && !$in_cpp***REMOVED*** {
		process_indent($_***REMOVED***;
	}

	if ($heuristic***REMOVED*** {
		# cannot check this everywhere due to "struct {\n...\n} foo;"
		if ($in_function && !$in_declaration &&
		    /}./ && !/}\s+=/ && !/{.*}[;,]$/ && !/}(\s|***REMOVED****$/ &&
		    !/} (else|while***REMOVED***/ && !/}}/***REMOVED*** {
			err("possible bad text following right brace"***REMOVED***;
		}
		# cannot check this because sub-blocks in
		# the middle of code are ok
		if ($in_function && /^\s+{/***REMOVED*** {
			err("possible left brace starting a line"***REMOVED***;
		}
	}
	if (/^\s*else\W/***REMOVED*** {
		if ($prev =~ /^\s*}$/***REMOVED*** {
			err_prefix($prev,
			    "else and right brace should be on same line"***REMOVED***;
		}
	}
	$prev = $line;
}

if ($prev eq ""***REMOVED*** {
	err("last line in file is blank"***REMOVED***;
}

}

#
# Continuation-line checking
#
# The rest of this file contains the code for the continuation checking
# engine.  It's a pretty simple state machine which tracks the expression
# depth (unmatched '('s and '['s***REMOVED***.
#
# Keep in mind that the argument to process_indent(***REMOVED*** has already been heavily
# processed; all comments have been replaced by control-A, and the contents of
# strings and character constants have been elided.
#

my $cont_in;		# currently inside of a continuation
my $cont_off;		# skipping an initializer or definition
my $cont_noerr;		# suppress cascading errors
my $cont_start;		# the line being continued
my $cont_base;		# the base indentation
my $cont_first;		# this is the first line of a statement
my $cont_multiseg;	# this continuation has multiple segments

my $cont_special;	# this is a C statement (if, for, etc.***REMOVED***
my $cont_macro;		# this is a macro
my $cont_case;		# this is a multi-line case

my @cont_paren;		# the stack of unmatched ( and [s we've seen

sub
reset_indent(***REMOVED***
{
	$cont_in = 0;
	$cont_off = 0;
}

sub
delabel($***REMOVED***
{
	#
	# replace labels with tabs.  Note that there may be multiple
	# labels on a line.
	#
	local $_ = $_[0];

	while (/^(\t****REMOVED***( *(?:(?:\w+\s****REMOVED***|(?:case\b[^:]****REMOVED******REMOVED***: ****REMOVED***(.****REMOVED***$/***REMOVED*** {
		my ($pre_tabs, $label, $rest***REMOVED*** = ($1, $2, $3***REMOVED***;
		$_ = $pre_tabs;
		while ($label =~ s/^([^\t]****REMOVED***(\t+***REMOVED***//***REMOVED*** {
			$_ .= "\t" x (length($2***REMOVED*** + length($1***REMOVED*** / 8***REMOVED***;
		}
		$_ .= ("\t" x (length($label***REMOVED*** / 8***REMOVED******REMOVED***.$rest;
	}

	return ($_***REMOVED***;
}

sub
process_indent($***REMOVED***
{
	require strict;
	local $_ = $_[0];			# preserve the global $_

	s///g;	# No comments
	s/\s+$//;	# Strip trailing whitespace

	return			if (/^$/***REMOVED***;	# skip empty lines

	# regexps used below; keywords taking (***REMOVED***, macros, and continued cases
	my $special = '(?:(?:\}\s****REMOVED***?else\s+***REMOVED***?(?:if|for|while|switch***REMOVED***\b';
	my $macro = '[A-Z_][A-Z_0-9]*\(';
	my $case = 'case\b[^:]*$';

	# skip over enumerations, array definitions, initializers, etc.
	if ($cont_off <= 0 && !/^\s*$special/ &&
	    (/(?:(?:\b(?:enum|struct|union***REMOVED***\s*[^\{]****REMOVED***|(?:\s+=\s****REMOVED******REMOVED***{/ ||
	    (/^\s*{/ && $prev =~ /=\s*(?:\/\*.*\*\/\s****REMOVED****$/***REMOVED******REMOVED******REMOVED*** {
		$cont_in = 0;
		$cont_off = tr/{/{/ - tr/}/}/;
		return;
	}
	if ($cont_off***REMOVED*** {
		$cont_off += tr/{/{/ - tr/}/}/;
		return;
	}

	if (!$cont_in***REMOVED*** {
		$cont_start = $line;

		if (/^\t* /***REMOVED*** {
			err("non-continuation indented 4 spaces"***REMOVED***;
			$cont_noerr = 1;		# stop reporting
		}
		$_ = delabel($_***REMOVED***;	# replace labels with tabs

		# check if the statement is complete
		return		if (/^\s*\}?$/***REMOVED***;
		return		if (/^\s*\}?\s*else\s*\{?$/***REMOVED***;
		return		if (/^\s*do\s*\{?$/***REMOVED***;
		return		if (/{$/***REMOVED***;
		return		if (/}[,;]?$/***REMOVED***;

		# Allow macros on their own lines
		return		if (/^\s*[A-Z_][A-Z_0-9]*$/***REMOVED***;

		# cases we don't deal with, generally non-kosher
		if (/{/***REMOVED*** {
			err("stuff after {"***REMOVED***;
			return;
		}

		# Get the base line, and set up the state machine
		/^(\t****REMOVED***/;
		$cont_base = $1;
		$cont_in = 1;
		@cont_paren = (***REMOVED***;
		$cont_first = 1;
		$cont_multiseg = 0;

		# certain things need special processing
		$cont_special = /^\s*$special/? 1 : 0;
		$cont_macro = /^\s*$macro/? 1 : 0;
		$cont_case = /^\s*$case/? 1 : 0;
	} else {
		$cont_first = 0;

		# Strings may be pulled back to an earlier (half-***REMOVED***tabstop
		unless ($cont_noerr || /^$cont_base    / ||
		    (/^\t*(?:    ***REMOVED***?(?:gettext\(***REMOVED***?\"/ && !/^$cont_base\t/***REMOVED******REMOVED*** {
			err_prefix($cont_start,
			    "continuation should be indented 4 spaces"***REMOVED***;
		}
	}

	my $rest = $_;			# keeps the remainder of the line

	#
	# The split matches 0 characters, so that each 'special' character
	# is processed separately.  Parens and brackets are pushed and
	# popped off the @cont_paren stack.  For normal processing, we wait
	# until a ; or { terminates the statement.  "special" processing
	# (if/for/while/switch***REMOVED*** is allowed to stop when the stack empties,
	# as is macro processing.  Case statements are terminated with a :
	# and an empty paren stack.
	#
	foreach $_ (split /[^\(\***REMOVED***\[\]\{\}\;\:]*/***REMOVED*** {
		next		if (length($_***REMOVED*** == 0***REMOVED***;

		# rest contains the remainder of the line
		my $rxp = "[^\Q$_\E]*\Q$_\E";
		$rest =~ s/^$rxp//;

		if (/\(/ || /\[/***REMOVED*** {
			push @cont_paren, $_;
		} elsif (/\***REMOVED***/ || /\]/***REMOVED*** {
			my $cur = $_;
			tr/\***REMOVED***\]/\(\[/;

			my $old = (pop @cont_paren***REMOVED***;
			if (!defined($old***REMOVED******REMOVED*** {
				err("unexpected '$cur'"***REMOVED***;
				$cont_in = 0;
				last;
			} elsif ($old ne $_***REMOVED*** {
				err("'$cur' mismatched with '$old'"***REMOVED***;
				$cont_in = 0;
				last;
			}

			#
			# If the stack is now empty, do special processing
			# for if/for/while/switch and macro statements.
			#
			next		if (@cont_paren != 0***REMOVED***;
			if ($cont_special***REMOVED*** {
				if ($rest =~ /^\s*{?$/***REMOVED*** {
					$cont_in = 0;
					last;
				}
				if ($rest =~ /^\s*;$/***REMOVED*** {
					err("empty if/for/while body ".
					    "not on its own line"***REMOVED***;
					$cont_in = 0;
					last;
				}
				if (!$cont_first && $cont_multiseg == 1***REMOVED*** {
					err_prefix($cont_start,
					    "multiple statements continued ".
					    "over multiple lines"***REMOVED***;
					$cont_multiseg = 2;
				} elsif ($cont_multiseg == 0***REMOVED*** {
					$cont_multiseg = 1;
				}
				# We've finished this section, start
				# processing the next.
				goto section_ended;
			}
			if ($cont_macro***REMOVED*** {
				if ($rest =~ /^$/***REMOVED*** {
					$cont_in = 0;
					last;
				}
			}
		} elsif (/\;/***REMOVED*** {
			if ($cont_case***REMOVED*** {
				err("unexpected ;"***REMOVED***;
			} elsif (!$cont_special***REMOVED*** {
				err("unexpected ;"***REMOVED***	if (@cont_paren != 0***REMOVED***;
				if (!$cont_first && $cont_multiseg == 1***REMOVED*** {
					err_prefix($cont_start,
					    "multiple statements continued ".
					    "over multiple lines"***REMOVED***;
					$cont_multiseg = 2;
				} elsif ($cont_multiseg == 0***REMOVED*** {
					$cont_multiseg = 1;
				}
				if ($rest =~ /^$/***REMOVED*** {
					$cont_in = 0;
					last;
				}
				if ($rest =~ /^\s*special/***REMOVED*** {
					err("if/for/while/switch not started ".
					    "on its own line"***REMOVED***;
				}
				goto section_ended;
			}
		} elsif (/\{/***REMOVED*** {
			err("{ while in parens/brackets"***REMOVED*** if (@cont_paren != 0***REMOVED***;
			err("stuff after {"***REMOVED***		if ($rest =~ /[^\s}]/***REMOVED***;
			$cont_in = 0;
			last;
		} elsif (/\}/***REMOVED*** {
			err("} while in parens/brackets"***REMOVED*** if (@cont_paren != 0***REMOVED***;
			if (!$cont_special && $rest !~ /^\s*(while|else***REMOVED***\b/***REMOVED*** {
				if ($rest =~ /^$/***REMOVED*** {
					err("unexpected }"***REMOVED***;
				} else {
					err("stuff after }"***REMOVED***;
				}
				$cont_in = 0;
				last;
			}
		} elsif (/\:/ && $cont_case && @cont_paren == 0***REMOVED*** {
			err("stuff after multi-line case"***REMOVED*** if ($rest !~ /$^/***REMOVED***;
			$cont_in = 0;
			last;
		}
		next;
section_ended:
		# End of a statement or if/while/for loop.  Reset
		# cont_special and cont_macro based on the rest of the
		# line.
		$cont_special = ($rest =~ /^\s*$special/***REMOVED***? 1 : 0;
		$cont_macro = ($rest =~ /^\s*$macro/***REMOVED***? 1 : 0;
		$cont_case = 0;
		next;
	}
	$cont_noerr = 0			if (!$cont_in***REMOVED***;
}
