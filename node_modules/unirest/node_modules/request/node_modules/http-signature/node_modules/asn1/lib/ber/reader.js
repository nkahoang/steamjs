// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert'***REMOVED***;

var ASN1 = require('./types'***REMOVED***;
var errors = require('./errors'***REMOVED***;


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



///--- API

function Reader(data***REMOVED*** {
  if (!data || !Buffer.isBuffer(data***REMOVED******REMOVED***
    throw new TypeError('data must be a node Buffer'***REMOVED***;

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;

  var self = this;
  this.__defineGetter__('length', function(***REMOVED*** { return self._len; }***REMOVED***;
  this.__defineGetter__('offset', function(***REMOVED*** { return self._offset; }***REMOVED***;
  this.__defineGetter__('remain', function(***REMOVED*** {
    return self._size - self._offset;
***REMOVED******REMOVED***;
  this.__defineGetter__('buffer', function(***REMOVED*** {
    return self._buf.slice(self._offset***REMOVED***;
***REMOVED******REMOVED***;
}


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset***REMOVED***.
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function(peek***REMOVED*** {
  if (this._size - this._offset < 1***REMOVED***
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek***REMOVED***
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function(***REMOVED*** {
  return this.readByte(true***REMOVED***;
};


/**
 * Reads a (potentially***REMOVED*** variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function(offset***REMOVED*** {
  if (offset === undefined***REMOVED***
    offset = this._offset;

  if (offset >= this._size***REMOVED***
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null***REMOVED***
    return null;

  if ((lenB & 0x80***REMOVED*** == 0x80***REMOVED*** {
    lenB &= 0x7f;

    if (lenB == 0***REMOVED***
      throw newInvalidAsn1Error('Indefinite length not supported'***REMOVED***;

    if (lenB > 4***REMOVED***
      throw newInvalidAsn1Error('encoding too long'***REMOVED***;

    if (this._size - offset < lenB***REMOVED***
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++***REMOVED***
      this._len = (this._len << 8***REMOVED*** + (this._buf[offset++] & 0xff***REMOVED***;

***REMOVED*** else {
    // Wasn't a variable length
    this._len = lenB;
***REMOVED***

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function(tag***REMOVED*** {
  var seq = this.peek(***REMOVED***;
  if (seq === null***REMOVED***
    return null;
  if (tag !== undefined && tag !== seq***REMOVED***
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16***REMOVED*** +
                              ': got 0x' + seq.toString(16***REMOVED******REMOVED***;

  var o = this.readLength(this._offset + 1***REMOVED***; // stored in `length`
  if (o === null***REMOVED***
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function(***REMOVED*** {
  return this._readTag(ASN1.Integer***REMOVED***;
};


Reader.prototype.readBoolean = function(***REMOVED*** {
  return (this._readTag(ASN1.Boolean***REMOVED*** === 0 ? false : true***REMOVED***;
};


Reader.prototype.readEnumeration = function(***REMOVED*** {
  return this._readTag(ASN1.Enumeration***REMOVED***;
};


Reader.prototype.readString = function(tag, retbuf***REMOVED*** {
  if (!tag***REMOVED***
    tag = ASN1.OctetString;

  var b = this.peek(***REMOVED***;
  if (b === null***REMOVED***
    return null;

  if (b !== tag***REMOVED***
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16***REMOVED*** +
                              ': got 0x' + b.toString(16***REMOVED******REMOVED***;

  var o = this.readLength(this._offset + 1***REMOVED***; // stored in `length`

  if (o === null***REMOVED***
    return null;

  if (this.length > this._size - o***REMOVED***
    return null;

  this._offset = o;

  if (this.length === 0***REMOVED***
    return '';

  var str = this._buf.slice(this._offset, this._offset + this.length***REMOVED***;
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8'***REMOVED***;
};

Reader.prototype.readOID = function(tag***REMOVED*** {
  if (!tag***REMOVED***
    tag = ASN1.OID;

  var b = this.peek(***REMOVED***;
  if (b === null***REMOVED***
    return null;

  if (b !== tag***REMOVED***
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16***REMOVED*** +
                              ': got 0x' + b.toString(16***REMOVED******REMOVED***;

  var o = this.readLength(this._offset + 1***REMOVED***; // stored in `length`
  if (o === null***REMOVED***
    return null;

  if (this.length > this._size - o***REMOVED***
    return null;

  this._offset = o;

  var values = [];
  var value = 0;

  for (var i = 0; i < this.length; i++***REMOVED*** {
    var byte = this._buf[this._offset++] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80***REMOVED*** == 0***REMOVED*** {
      values.push(value***REMOVED***;
      value = 0;
  ***REMOVED***
***REMOVED***

  value = values.shift(***REMOVED***;
  values.unshift(value % 40***REMOVED***;
  values.unshift((value / 40***REMOVED*** >> 0***REMOVED***;

  return values.join('.'***REMOVED***;
};


Reader.prototype._readTag = function(tag***REMOVED*** {
  assert.ok(tag !== undefined***REMOVED***;

  var b = this.peek(***REMOVED***;

  if (b === null***REMOVED***
    return null;

  if (b !== tag***REMOVED***
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16***REMOVED*** +
                              ': got 0x' + b.toString(16***REMOVED******REMOVED***;

  var o = this.readLength(this._offset + 1***REMOVED***; // stored in `length`
  if (o === null***REMOVED***
    return null;

  if (this.length > 4***REMOVED***
    throw newInvalidAsn1Error('Integer too long: ' + this.length***REMOVED***;

  if (this.length > this._size - o***REMOVED***
    return null;
  this._offset = o;

  var fb = this._buf[this._offset++];
  var value = 0;

  value = fb & 0x7F;
  for (var i = 1; i < this.length; i++***REMOVED*** {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff***REMOVED***;
***REMOVED***

  if ((fb & 0x80***REMOVED*** == 0x80***REMOVED***
    value = -value;

  return value;
};



///--- Exported API

module.exports = Reader;
