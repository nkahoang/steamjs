// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert'***REMOVED***;
var ASN1 = require('./types'***REMOVED***;
var errors = require('./errors'***REMOVED***;


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


///--- Helpers

function merge(from, to***REMOVED*** {
  assert.ok(from***REMOVED***;
  assert.equal(typeof(from***REMOVED***, 'object'***REMOVED***;
  assert.ok(to***REMOVED***;
  assert.equal(typeof(to***REMOVED***, 'object'***REMOVED***;

  var keys = Object.getOwnPropertyNames(from***REMOVED***;
  keys.forEach(function(key***REMOVED*** {
    if (to[key]***REMOVED***
      return;

    var value = Object.getOwnPropertyDescriptor(from, key***REMOVED***;
    Object.defineProperty(to, key, value***REMOVED***;
***REMOVED******REMOVED***;

  return to;
}



///--- API

function Writer(options***REMOVED*** {
  options = merge(DEFAULT_OPTS, options || {}***REMOVED***;

  this._buf = new Buffer(options.size || 1024***REMOVED***;
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];

  var self = this;
  this.__defineGetter__('buffer', function(***REMOVED*** {
    if (self._seq.length***REMOVED***
      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s***REMOVED***'***REMOVED***;

    return self._buf.slice(0, self._offset***REMOVED***;
***REMOVED******REMOVED***;
}


Writer.prototype.writeByte = function(b***REMOVED*** {
  if (typeof(b***REMOVED*** !== 'number'***REMOVED***
    throw new TypeError('argument must be a Number'***REMOVED***;

  this._ensure(1***REMOVED***;
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function(i, tag***REMOVED*** {
  if (typeof(i***REMOVED*** !== 'number'***REMOVED***
    throw new TypeError('argument must be a Number'***REMOVED***;
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000***REMOVED*** === 0***REMOVED*** || ((i & 0xff800000***REMOVED*** === 0xff800000***REMOVED******REMOVED*** &&
         (sz > 1***REMOVED******REMOVED*** {
    sz--;
    i <<= 8;
***REMOVED***

  if (sz > 4***REMOVED***
    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff'***REMOVED***;

  this._ensure(2 + sz***REMOVED***;
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0***REMOVED*** {
    this._buf[this._offset++] = ((i & 0xff000000***REMOVED*** >> 24***REMOVED***;
    i <<= 8;
***REMOVED***

};


Writer.prototype.writeNull = function(***REMOVED*** {
  this.writeByte(ASN1.Null***REMOVED***;
  this.writeByte(0x00***REMOVED***;
};


Writer.prototype.writeEnumeration = function(i, tag***REMOVED*** {
  if (typeof(i***REMOVED*** !== 'number'***REMOVED***
    throw new TypeError('argument must be a Number'***REMOVED***;
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag***REMOVED***;
};


Writer.prototype.writeBoolean = function(b, tag***REMOVED*** {
  if (typeof(b***REMOVED*** !== 'boolean'***REMOVED***
    throw new TypeError('argument must be a Boolean'***REMOVED***;
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    tag = ASN1.Boolean;

  this._ensure(3***REMOVED***;
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function(s, tag***REMOVED*** {
  if (typeof(s***REMOVED*** !== 'string'***REMOVED***
    throw new TypeError('argument must be a string (was: ' + typeof(s***REMOVED*** + '***REMOVED***'***REMOVED***;
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s***REMOVED***;
  this.writeByte(tag***REMOVED***;
  this.writeLength(len***REMOVED***;
  if (len***REMOVED*** {
    this._ensure(len***REMOVED***;
    this._buf.write(s, this._offset***REMOVED***;
    this._offset += len;
***REMOVED***
};


Writer.prototype.writeBuffer = function(buf, tag***REMOVED*** {
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    throw new TypeError('tag must be a number'***REMOVED***;
  if (!Buffer.isBuffer(buf***REMOVED******REMOVED***
    throw new TypeError('argument must be a buffer'***REMOVED***;

  this.writeByte(tag***REMOVED***;
  this.writeLength(buf.length***REMOVED***;
  this._ensure(buf.length***REMOVED***;
  buf.copy(this._buf, this._offset, 0, buf.length***REMOVED***;
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function(strings***REMOVED*** {
  if ((!strings instanceof Array***REMOVED******REMOVED***
    throw new TypeError('argument must be an Array[String]'***REMOVED***;

  var self = this;
  strings.forEach(function(s***REMOVED*** {
    self.writeString(s***REMOVED***;
***REMOVED******REMOVED***;
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function(s, tag***REMOVED*** {
  if (typeof(s***REMOVED*** !== 'string'***REMOVED***
    throw new TypeError('argument must be a string'***REMOVED***;
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    tag = ASN1.OID;

  if (!/^([0-9]+\.***REMOVED***{3,}[0-9]+$/.test(s***REMOVED******REMOVED***
    throw new Error('argument is not a valid OID string'***REMOVED***;

  function encodeOctet(bytes, octet***REMOVED*** {
    if (octet < 128***REMOVED*** {
        bytes.push(octet***REMOVED***;
  ***REMOVED*** else if (octet < 16384***REMOVED*** {
        bytes.push((octet >>> 7***REMOVED*** | 0x80***REMOVED***;
        bytes.push(octet & 0x7F***REMOVED***;
  ***REMOVED*** else if (octet < 2097152***REMOVED*** {
      bytes.push((octet >>> 14***REMOVED*** | 0x80***REMOVED***;
      bytes.push(((octet >>> 7***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(octet & 0x7F***REMOVED***;
  ***REMOVED*** else if (octet < 268435456***REMOVED*** {
      bytes.push((octet >>> 21***REMOVED*** | 0x80***REMOVED***;
      bytes.push(((octet >>> 14***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(((octet >>> 7***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(octet & 0x7F***REMOVED***;
  ***REMOVED*** else {
      bytes.push(((octet >>> 28***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(((octet >>> 21***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(((octet >>> 14***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(((octet >>> 7***REMOVED*** | 0x80***REMOVED*** & 0xFF***REMOVED***;
      bytes.push(octet & 0x7F***REMOVED***;
  ***REMOVED***
***REMOVED***

  var tmp = s.split('.'***REMOVED***;
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10***REMOVED*** * 40 + parseInt(tmp[1], 10***REMOVED******REMOVED***;
  tmp.slice(2***REMOVED***.forEach(function(b***REMOVED*** {
    encodeOctet(bytes, parseInt(b, 10***REMOVED******REMOVED***;
***REMOVED******REMOVED***;

  var self = this;
  this._ensure(2 + bytes.length***REMOVED***;
  this.writeByte(tag***REMOVED***;
  this.writeLength(bytes.length***REMOVED***;
  bytes.forEach(function(b***REMOVED*** {
    self.writeByte(b***REMOVED***;
***REMOVED******REMOVED***;
};


Writer.prototype.writeLength = function(len***REMOVED*** {
  if (typeof(len***REMOVED*** !== 'number'***REMOVED***
    throw new TypeError('argument must be a Number'***REMOVED***;

  this._ensure(4***REMOVED***;

  if (len <= 0x7f***REMOVED*** {
    this._buf[this._offset++] = len;
***REMOVED*** else if (len <= 0xff***REMOVED*** {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
***REMOVED*** else if (len <= 0xffff***REMOVED*** {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
***REMOVED*** else if (len <= 0xffffff***REMOVED*** {
    this._shift(start, len, 1***REMOVED***;
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
***REMOVED*** else {
    throw new InvalidAsn1ERror('Length too long (> 4 bytes***REMOVED***'***REMOVED***;
***REMOVED***
};

Writer.prototype.startSequence = function(tag***REMOVED*** {
  if (typeof(tag***REMOVED*** !== 'number'***REMOVED***
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag***REMOVED***;
  this._seq.push(this._offset***REMOVED***;
  this._ensure(3***REMOVED***;
  this._offset += 3;
};


Writer.prototype.endSequence = function(***REMOVED*** {
  var seq = this._seq.pop(***REMOVED***;
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f***REMOVED*** {
    this._shift(start, len, -2***REMOVED***;
    this._buf[seq] = len;
***REMOVED*** else if (len <= 0xff***REMOVED*** {
    this._shift(start, len, -1***REMOVED***;
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
***REMOVED*** else if (len <= 0xffff***REMOVED*** {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
***REMOVED*** else if (len <= 0xffffff***REMOVED*** {
    this._shift(start, len, 1***REMOVED***;
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
***REMOVED*** else {
    throw new InvalidAsn1Error('Sequence too long'***REMOVED***;
***REMOVED***
};


Writer.prototype._shift = function(start, len, shift***REMOVED*** {
  assert.ok(start !== undefined***REMOVED***;
  assert.ok(len !== undefined***REMOVED***;
  assert.ok(shift***REMOVED***;

  this._buf.copy(this._buf, start + shift, start, start + len***REMOVED***;
  this._offset += shift;
};

Writer.prototype._ensure = function(len***REMOVED*** {
  assert.ok(len***REMOVED***;

  if (this._size - this._offset < len***REMOVED*** {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len***REMOVED***
      sz += len;

    var buf = new Buffer(sz***REMOVED***;

    this._buf.copy(buf, 0, 0, this._offset***REMOVED***;
    this._buf = buf;
    this._size = sz;
***REMOVED***
};



///--- Exported API

module.exports = Writer;
