if (!this.uuid***REMOVED*** {
  // node.js
  uuid = require('../uuid'***REMOVED***;
}

//
// x-platform log/assert shims
//

function _log(msg, type***REMOVED*** {
  type = type || 'log';

  if (typeof(document***REMOVED*** != 'undefined'***REMOVED*** {
    document.write('<div class="' + type + '">' + msg.replace(/\n/g, '<br />'***REMOVED*** + '</div>'***REMOVED***;
***REMOVED***
  if (typeof(console***REMOVED*** != 'undefined'***REMOVED*** {
    var color = {
      log: '\033[39m',
      warn: '\033[33m',
      error: '\033[31m'
  ***REMOVED***;
    console[type](color[type] + msg + color.log***REMOVED***;
***REMOVED***
}

function log(msg***REMOVED*** {_log(msg, 'log'***REMOVED***;}
function warn(msg***REMOVED*** {_log(msg, 'warn'***REMOVED***;}
function error(msg***REMOVED*** {_log(msg, 'error'***REMOVED***;}

function assert(res, msg***REMOVED*** {
  if (!res***REMOVED*** {
    error('FAIL: ' + msg***REMOVED***;
***REMOVED*** else {
    log('Pass: ' + msg***REMOVED***;
***REMOVED***
}

//
// Unit tests
//

// Verify ordering of v1 ids created with explicit times
var TIME = 1321644961388; // 2011-11-18 11:36:01.388-08:00

function compare(name, ids***REMOVED*** {
  ids = ids.map(function(id***REMOVED*** {
    return id.split('-'***REMOVED***.reverse(***REMOVED***.join('-'***REMOVED***;
***REMOVED******REMOVED***.sort(***REMOVED***;
  var sorted = ([].concat(ids***REMOVED******REMOVED***.sort(***REMOVED***;

  assert(sorted.toString(***REMOVED*** == ids.toString(***REMOVED***, name + ' have expected order'***REMOVED***;
}

// Verify ordering of v1 ids created using default behavior
compare('uuids with current time', [
  uuid.v1(***REMOVED***,
  uuid.v1(***REMOVED***,
  uuid.v1(***REMOVED***,
  uuid.v1(***REMOVED***,
  uuid.v1(***REMOVED***
]***REMOVED***;

// Verify ordering of v1 ids created with explicit times
compare('uuids with time option', [
  uuid.v1({msecs: TIME - 10*3600*1000}***REMOVED***,
  uuid.v1({msecs: TIME - 1}***REMOVED***,
  uuid.v1({msecs: TIME}***REMOVED***,
  uuid.v1({msecs: TIME + 1}***REMOVED***,
  uuid.v1({msecs: TIME + 28*24*3600*1000}***REMOVED***
]***REMOVED***;

assert(
  uuid.v1({msecs: TIME}***REMOVED*** != uuid.v1({msecs: TIME}***REMOVED***,
  'IDs created at same msec are different'
***REMOVED***;

// Verify throw if too many ids created
var thrown = false;
try {
  uuid.v1({msecs: TIME, nsecs: 10000}***REMOVED***;
} catch (e***REMOVED*** {
  thrown = true;
}
assert(thrown, 'Exception thrown when > 10K ids created in 1 ms'***REMOVED***;

// Verify clock regression bumps clockseq
var uidt = uuid.v1({msecs: TIME}***REMOVED***;
var uidtb = uuid.v1({msecs: TIME - 1}***REMOVED***;
assert(
  parseInt(uidtb.split('-'***REMOVED***[3], 16***REMOVED*** - parseInt(uidt.split('-'***REMOVED***[3], 16***REMOVED*** === 1,
  'Clock regression by msec increments the clockseq'
***REMOVED***;

// Verify clock regression bumps clockseq
var uidtn = uuid.v1({msecs: TIME, nsecs: 10}***REMOVED***;
var uidtnb = uuid.v1({msecs: TIME, nsecs: 9}***REMOVED***;
assert(
  parseInt(uidtnb.split('-'***REMOVED***[3], 16***REMOVED*** - parseInt(uidtn.split('-'***REMOVED***[3], 16***REMOVED*** === 1,
  'Clock regression by nsec increments the clockseq'
***REMOVED***;

// Verify explicit options produce expected id
var id = uuid.v1({
  msecs: 1321651533573,
  nsecs: 5432,
  clockseq: 0x385c,
  node: [ 0x61, 0xcd, 0x3c, 0xbb, 0x32, 0x10 ]
}***REMOVED***;
assert(id == 'd9428888-122b-11e1-b85c-61cd3cbb3210', 'Explicit options produce expected id'***REMOVED***;

// Verify adjacent ids across a msec boundary are 1 time unit apart
var u0 = uuid.v1({msecs: TIME, nsecs: 9999}***REMOVED***;
var u1 = uuid.v1({msecs: TIME + 1, nsecs: 0}***REMOVED***;

var before = u0.split('-'***REMOVED***[0], after = u1.split('-'***REMOVED***[0];
var dt = parseInt(after, 16***REMOVED*** - parseInt(before, 16***REMOVED***;
assert(dt === 1, 'Ids spanning 1ms boundary are 100ns apart'***REMOVED***;

//
// Test parse/unparse
//

id = '00112233445566778899aabbccddeeff';
assert(uuid.unparse(uuid.parse(id.substr(0,10***REMOVED******REMOVED******REMOVED*** ==
  '00112233-4400-0000-0000-000000000000', 'Short parse'***REMOVED***;
assert(uuid.unparse(uuid.parse('(this is the uuid -> ' + id + id***REMOVED******REMOVED*** ==
  '00112233-4455-6677-8899-aabbccddeeff', 'Dirty parse'***REMOVED***;

//
// Perf tests
//

var generators = {
  v1: uuid.v1,
  v4: uuid.v4
};

var UUID_FORMAT = {
  v1: /[0-9a-f]{8}-[0-9a-f]{4}-1[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,
  v4: /[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i
};

var N = 1e4;

// Get %'age an actual value differs from the ideal value
function divergence(actual, ideal***REMOVED*** {
  return Math.round(100*100*(actual - ideal***REMOVED***/ideal***REMOVED***/100;
}

function rate(msg, t***REMOVED*** {
  log(msg + ': ' + (N / (Date.now(***REMOVED*** - t***REMOVED*** * 1e3 | 0***REMOVED*** + ' uuids\/second'***REMOVED***;
}

for (var version in generators***REMOVED*** {
  var counts = {}, max = 0;
  var generator = generators[version];
  var format = UUID_FORMAT[version];

  log('\nSanity check ' + N + ' ' + version + ' uuids'***REMOVED***;
  for (var i = 0, ok = 0; i < N; i++***REMOVED*** {
    id = generator(***REMOVED***;
    if (!format.test(id***REMOVED******REMOVED*** {
      throw Error(id + ' is not a valid UUID string'***REMOVED***;
  ***REMOVED***

    if (id != uuid.unparse(uuid.parse(id***REMOVED******REMOVED******REMOVED*** {
      assert(fail, id + ' is not a valid id'***REMOVED***;
  ***REMOVED***

    // Count digits for our randomness check
    if (version == 'v4'***REMOVED*** {
      var digits = id.replace(/-/g, ''***REMOVED***.split(''***REMOVED***;
      for (var j = digits.length-1; j >= 0; j--***REMOVED*** {
        var c = digits[j];
        max = Math.max(max, counts[c] = (counts[c] || 0***REMOVED*** + 1***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  // Check randomness for v4 UUIDs
  if (version == 'v4'***REMOVED*** {
    // Limit that we get worried about randomness. (Purely empirical choice, this!***REMOVED***
    var limit = 2*100*Math.sqrt(1/N***REMOVED***;

    log('\nChecking v4 randomness.  Distribution of Hex Digits (% deviation from ideal***REMOVED***'***REMOVED***;

    for (var i = 0; i < 16; i++***REMOVED*** {
      var c = i.toString(16***REMOVED***;
      var bar = '', n = counts[c], p = Math.round(n/max*100|0***REMOVED***;

      // 1-3,5-8, and D-F: 1:16 odds over 30 digits
      var ideal = N*30/16;
      if (i == 4***REMOVED*** {
        // 4: 1:1 odds on 1 digit, plus 1:16 odds on 30 digits
        ideal = N*(1 + 30/16***REMOVED***;
    ***REMOVED*** else if (i >= 8 && i <= 11***REMOVED*** {
        // 8-B: 1:4 odds on 1 digit, plus 1:16 odds on 30 digits
        ideal = N*(1/4 + 30/16***REMOVED***;
    ***REMOVED*** else {
        // Otherwise: 1:16 odds on 30 digits
        ideal = N*30/16;
    ***REMOVED***
      var d = divergence(n, ideal***REMOVED***;

      // Draw bar using UTF squares (just for grins***REMOVED***
      var s = n/max*50 | 0;
      while (s--***REMOVED*** bar += '=';

      assert(Math.abs(d***REMOVED*** < limit, c + ' |' + bar + '| ' + counts[c] + ' (' + d + '% < ' + limit + '%***REMOVED***'***REMOVED***;
  ***REMOVED***
***REMOVED***
}

// Perf tests
for (var version in generators***REMOVED*** {
  log('\nPerformance testing ' + version + ' UUIDs'***REMOVED***;
  var generator = generators[version];
  var buf = new uuid.BufferClass(16***REMOVED***;

  for (var i = 0, t = Date.now(***REMOVED***; i < N; i++***REMOVED*** generator(***REMOVED***;
  rate('uuid.' + version + '(***REMOVED***', t***REMOVED***;

  for (var i = 0, t = Date.now(***REMOVED***; i < N; i++***REMOVED*** generator('binary'***REMOVED***;
  rate('uuid.' + version + '(\'binary\'***REMOVED***', t***REMOVED***;

  for (var i = 0, t = Date.now(***REMOVED***; i < N; i++***REMOVED*** generator('binary', buf***REMOVED***;
  rate('uuid.' + version + '(\'binary\', buffer***REMOVED***', t***REMOVED***;
}
