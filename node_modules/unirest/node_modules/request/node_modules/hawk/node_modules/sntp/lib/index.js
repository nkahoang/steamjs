// Load modules

var Dgram = require('dgram'***REMOVED***;
var Dns = require('dns'***REMOVED***;
var Hoek = require('hoek'***REMOVED***;


// Declare internals

var internals = {};


exports.time = function (options, callback***REMOVED*** {

    if (arguments.length !== 2***REMOVED*** {
        callback = arguments[0];
        options = {};
  ***REMOVED***

    var settings = Hoek.clone(options***REMOVED***;
    settings.host = settings.host || 'pool.ntp.org';
    settings.port = settings.port || 123;
    settings.resolveReference = settings.resolveReference || false;

    // Declare variables used by callback

    var timeoutId = 0;
    var sent = 0;

    // Ensure callback is only called once

    var isFinished = false;
    var finish = function (err, result***REMOVED*** {

        if (timeoutId***REMOVED*** {
            clearTimeout(timeoutId***REMOVED***;
            timeoutId = 0;
      ***REMOVED***

        if (!isFinished***REMOVED*** {
            isFinished = true;
            socket.removeAllListeners(***REMOVED***;
            socket.close(***REMOVED***;
            return callback(err, result***REMOVED***;
      ***REMOVED***
  ***REMOVED***;

    // Create UDP socket

    var socket = Dgram.createSocket('udp4'***REMOVED***;

    socket.once('error', function (err***REMOVED*** {

        return finish(err***REMOVED***;
  ***REMOVED******REMOVED***;

    // Listen to incoming messages

    socket.on('message', function (buffer, rinfo***REMOVED*** {

        var received = Date.now(***REMOVED***;

        var message = new internals.NtpMessage(buffer***REMOVED***;
        if (!message.isValid***REMOVED*** {
            return finish(new Error('Invalid server response'***REMOVED***, message***REMOVED***;
      ***REMOVED***

        if (message.originateTimestamp !== sent***REMOVED*** {
            return finish(new Error('Wrong originate timestamp'***REMOVED***, message***REMOVED***;
      ***REMOVED***

        // Timestamp Name          ID   When Generated
        // ------------------------------------------------------------
        // Originate Timestamp     T1   time request sent by client
        // Receive Timestamp       T2   time request received by server
        // Transmit Timestamp      T3   time reply sent by server
        // Destination Timestamp   T4   time reply received by client
        //
        // The roundtrip delay d and system clock offset t are defined as:
        //
        // d = (T4 - T1***REMOVED*** - (T3 - T2***REMOVED***     t = ((T2 - T1***REMOVED*** + (T3 - T4***REMOVED******REMOVED*** / 2

        var T1 = message.originateTimestamp;
        var T2 = message.receiveTimestamp;
        var T3 = message.transmitTimestamp;
        var T4 = received;

        message.d = (T4 - T1***REMOVED*** - (T3 - T2***REMOVED***;
        message.t = ((T2 - T1***REMOVED*** + (T3 - T4***REMOVED******REMOVED*** / 2;
        message.receivedLocally = received;

        if (!settings.resolveReference ||
            message.stratum !== 'secondary'***REMOVED*** {

            return finish(null, message***REMOVED***;
      ***REMOVED***

        // Resolve reference IP address

        Dns.reverse(message.referenceId, function (err, domains***REMOVED*** {

            if (!err***REMOVED*** {
                message.referenceHost = domains[0];
          ***REMOVED***

            return finish(null, message***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;

    // Set timeout

    if (settings.timeout***REMOVED*** {
        timeoutId = setTimeout(function (***REMOVED*** {

            timeoutId = 0;
            return finish(new Error('Timeout'***REMOVED******REMOVED***;
      ***REMOVED***, settings.timeout***REMOVED***;
  ***REMOVED***

    // Construct NTP message

    var message = new Buffer(48***REMOVED***;
    for (var i = 0; i < 48; i++***REMOVED*** {                      // Zero message
        message[i] = 0;
  ***REMOVED***

    message[0] = (0 << 6***REMOVED*** + (4 << 3***REMOVED*** + (3 << 0***REMOVED***         // Set version number to 4 and Mode to 3 (client***REMOVED***
    sent = Date.now(***REMOVED***;
    internals.fromMsecs(sent, message, 40***REMOVED***;               // Set transmit timestamp (returns as originate***REMOVED***

    // Send NTP request

    socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes***REMOVED*** {

        if (err ||
            bytes !== 48***REMOVED*** {

            return finish(err || new Error('Could not send entire message'***REMOVED******REMOVED***;
      ***REMOVED***
  ***REMOVED******REMOVED***;
};


internals.NtpMessage = function (buffer***REMOVED*** {

    this.isValid = false;

    // Validate

    if (buffer.length !== 48***REMOVED*** {
        return;
  ***REMOVED***

    // Leap indicator

    var li = (buffer[0] >> 6***REMOVED***;
    switch (li***REMOVED*** {
        case 0: this.leapIndicator = 'no-warning'; break;
        case 1: this.leapIndicator = 'last-minute-61'; break;
        case 2: this.leapIndicator = 'last-minute-59'; break;
        case 3: this.leapIndicator = 'alarm'; break;
  ***REMOVED***

    // Version

    var vn = ((buffer[0] & 0x38***REMOVED*** >> 3***REMOVED***;
    this.version = vn;

    // Mode

    var mode = (buffer[0] & 0x7***REMOVED***;
    switch (mode***REMOVED*** {
        case 1: this.mode = 'symmetric-active'; break;
        case 2: this.mode = 'symmetric-passive'; break;
        case 3: this.mode = 'client'; break;
        case 4: this.mode = 'server'; break;
        case 5: this.mode = 'broadcast'; break;
        case 0:
        case 6:
        case 7: this.mode = 'reserved'; break;
  ***REMOVED***

    // Stratum

    var stratum = buffer[1];
    if (stratum === 0***REMOVED*** {
        this.stratum = 'death';
  ***REMOVED***
    else if (stratum === 1***REMOVED*** {
        this.stratum = 'primary';
  ***REMOVED***
    else if (stratum <= 15***REMOVED*** {
        this.stratum = 'secondary';
  ***REMOVED***
    else {
        this.stratum = 'reserved';
  ***REMOVED***

    // Poll interval (msec***REMOVED***

    this.pollInterval = Math.round(Math.pow(2, buffer[2]***REMOVED******REMOVED*** * 1000;

    // Precision (msecs***REMOVED***

    this.precision = Math.pow(2, buffer[3]***REMOVED*** * 1000;

    // Root delay (msecs***REMOVED***

    var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]***REMOVED*** + buffer[6]***REMOVED*** + buffer[7];
    this.rootDelay = 1000 * (rootDelay / 0x10000***REMOVED***;

    // Root dispersion (msecs***REMOVED***

    this.rootDispersion = ((buffer[8] << 8***REMOVED*** + buffer[9] + ((buffer[10] << 8***REMOVED*** + buffer[11]***REMOVED*** / Math.pow(2, 16***REMOVED******REMOVED*** * 1000;

    // Reference identifier

    this.referenceId = '';
    switch (this.stratum***REMOVED*** {
        case 'death':
        case 'primary':
            this.referenceId = String.fromCharCode(buffer[12]***REMOVED*** + String.fromCharCode(buffer[13]***REMOVED*** + String.fromCharCode(buffer[14]***REMOVED*** + String.fromCharCode(buffer[15]***REMOVED***;
            break;
        case 'secondary':
            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
            break;
  ***REMOVED***

    // Reference timestamp

    this.referenceTimestamp = internals.toMsecs(buffer, 16***REMOVED***;

    // Originate timestamp

    this.originateTimestamp = internals.toMsecs(buffer, 24***REMOVED***;

    // Receive timestamp

    this.receiveTimestamp = internals.toMsecs(buffer, 32***REMOVED***;

    // Transmit timestamp

    this.transmitTimestamp = internals.toMsecs(buffer, 40***REMOVED***;

    // Validate

    if (this.version === 4 &&
        this.stratum !== 'reserved' &&
        this.mode === 'server' &&
        this.originateTimestamp &&
        this.receiveTimestamp &&
        this.transmitTimestamp***REMOVED*** {

        this.isValid = true;
  ***REMOVED***

    return this;
};


internals.toMsecs = function (buffer, offset***REMOVED*** {

    var seconds = 0;
    var fraction = 0;

    for (var i = 0; i < 4; ++i***REMOVED*** {
        seconds = (seconds * 256***REMOVED*** + buffer[offset + i];
  ***REMOVED***

    for (i = 4; i < 8; ++i***REMOVED*** {
        fraction = (fraction * 256***REMOVED*** + buffer[offset + i];
  ***REMOVED***

    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32***REMOVED******REMOVED******REMOVED*** * 1000***REMOVED***;
};


internals.fromMsecs = function (ts, buffer, offset***REMOVED*** {

    var seconds = Math.floor(ts / 1000***REMOVED*** + 2208988800;
    var fraction = Math.round((ts % 1000***REMOVED*** / 1000 * Math.pow(2, 32***REMOVED******REMOVED***;

    buffer[offset + 0] = (seconds & 0xFF000000***REMOVED*** >> 24;
    buffer[offset + 1] = (seconds & 0x00FF0000***REMOVED*** >> 16;
    buffer[offset + 2] = (seconds & 0x0000FF00***REMOVED*** >> 8;
    buffer[offset + 3] = (seconds & 0x000000FF***REMOVED***;

    buffer[offset + 4] = (fraction & 0xFF000000***REMOVED*** >> 24;
    buffer[offset + 5] = (fraction & 0x00FF0000***REMOVED*** >> 16;
    buffer[offset + 6] = (fraction & 0x0000FF00***REMOVED*** >> 8;
    buffer[offset + 7] = (fraction & 0x000000FF***REMOVED***;
};


// Offset singleton

internals.last = {
    offset: 0,
    expires: 0,
    host: '',
    port: 0
};


exports.offset = function (options, callback***REMOVED*** {

    if (arguments.length !== 2***REMOVED*** {
        callback = arguments[0];
        options = {};
  ***REMOVED***

    var now = Date.now(***REMOVED***;
    var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily

    if (internals.last.offset &&
        internals.last.host === options.host &&
        internals.last.port === options.port &&
        now < internals.last.expires***REMOVED*** {

        process.nextTick(function (***REMOVED*** {
                
            callback(null, internals.last.offset***REMOVED***;
      ***REMOVED******REMOVED***;

        return;
  ***REMOVED***

    exports.time(options, function (err, time***REMOVED*** {

        if (err***REMOVED*** {
            return callback(err, 0***REMOVED***;
      ***REMOVED***

        internals.last = {
            offset: Math.round(time.t***REMOVED***,
            expires: now + clockSyncRefresh,
            host: options.host,
            port: options.port
      ***REMOVED***;

        return callback(null, internals.last.offset***REMOVED***;
  ***REMOVED******REMOVED***;
};


// Now singleton

internals.now = {
    intervalId: 0
};


exports.start = function (options, callback***REMOVED*** {

    if (arguments.length !== 2***REMOVED*** {
        callback = arguments[0];
        options = {};
  ***REMOVED***

    if (internals.now.intervalId***REMOVED*** {
        process.nextTick(function (***REMOVED*** {
            
            callback(***REMOVED***;
      ***REMOVED******REMOVED***;
        
        return;
  ***REMOVED***

    exports.offset(options, function (err, offset***REMOVED*** {

        internals.now.intervalId = setInterval(function (***REMOVED*** {

            exports.offset(options, function (***REMOVED*** { }***REMOVED***;
      ***REMOVED***, options.clockSyncRefresh || 24 * 60 * 60 * 1000***REMOVED***;                                // Daily

        return callback(***REMOVED***;
  ***REMOVED******REMOVED***;
};


exports.stop = function (***REMOVED*** {

    if (!internals.now.intervalId***REMOVED*** {
        return;
  ***REMOVED***

    clearInterval(internals.now.intervalId***REMOVED***;
    internals.now.intervalId = 0;
};


exports.isLive = function (***REMOVED*** {

    return !!internals.now.intervalId;
};


exports.now = function (***REMOVED*** {

    var now = Date.now(***REMOVED***;
    if (!exports.isLive(***REMOVED*** ||
        now >= internals.last.expires***REMOVED*** {

        return now;
  ***REMOVED***

    return now + internals.last.offset;
};

