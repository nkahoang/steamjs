// Load modules

var Fs = require('fs'***REMOVED***;
var Escape = require('./escape'***REMOVED***;


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen***REMOVED*** {

    if (typeof obj !== 'object' ||
        obj === null***REMOVED*** {

        return obj;
  ***REMOVED***

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj***REMOVED***;
    if (lookup !== -1***REMOVED*** {
        return seen.copy[lookup];
  ***REMOVED***

    var newObj = (obj instanceof Array***REMOVED*** ? [] : {};

    seen.orig.push(obj***REMOVED***;
    seen.copy.push(newObj***REMOVED***;

    for (var i in obj***REMOVED*** {
        if (obj.hasOwnProperty(i***REMOVED******REMOVED*** {
            if (obj[i] instanceof Buffer***REMOVED*** {
                newObj[i] = new Buffer(obj[i]***REMOVED***;
          ***REMOVED***
            else if (obj[i] instanceof Date***REMOVED*** {
                newObj[i] = new Date(obj[i].getTime(***REMOVED******REMOVED***;
          ***REMOVED***
            else if (obj[i] instanceof RegExp***REMOVED*** {
                var flags = '' + (obj[i].global ? 'g' : ''***REMOVED*** + (obj[i].ignoreCase ? 'i' : ''***REMOVED*** + (obj[i].multiline ? 'm' : ''***REMOVED***;
                newObj[i] = new RegExp(obj[i].source, flags***REMOVED***;
          ***REMOVED***
            else {
                newObj[i] = exports.clone(obj[i], seen***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */***REMOVED*** {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object'***REMOVED***;
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object'***REMOVED***;

    if (!source***REMOVED*** {
        return target;
  ***REMOVED***

    if (source instanceof Array***REMOVED*** {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object'***REMOVED***;
        if (isMergeArrays === false***REMOVED*** {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
      ***REMOVED***

        for (var i = 0, il = source.length; i < il; ++i***REMOVED*** {
            target.push(source[i]***REMOVED***;
      ***REMOVED***

        return target;
  ***REMOVED***

    var keys = Object.keys(source***REMOVED***;
    for (var k = 0, kl = keys.length; k < kl; ++k***REMOVED*** {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object'***REMOVED*** {

            if (!target[key] ||
                typeof target[key] !== 'object'***REMOVED*** {

                target[key] = exports.clone(value***REMOVED***;
          ***REMOVED***
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        else {
            if (value !== null && value !== undefined***REMOVED*** {            // Explicit to preserve empty strings
                target[key] = value;
          ***REMOVED***
            else if (isNullOverride !== false***REMOVED*** {                    // Defaults to true
                target[key] = value;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options***REMOVED*** {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object'***REMOVED***;
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object'***REMOVED***;

    if (!options***REMOVED*** {                                                 // If no options, return null
        return null;
  ***REMOVED***

    var copy = exports.clone(defaults***REMOVED***;

    if (options === true***REMOVED*** {                                         // If options is set to true, use defaults
        return copy;
  ***REMOVED***

    return exports.merge(copy, options, false, false***REMOVED***;
};


// Remove duplicate items from array

exports.unique = function (array, key***REMOVED*** {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i***REMOVED*** {
        var id = (key ? array[i][key] : array[i]***REMOVED***;
        if (index[id] !== true***REMOVED*** {

            result.push(array[i]***REMOVED***;
            index[id] = true;
      ***REMOVED***
  ***REMOVED***

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key***REMOVED*** {

    if (!array***REMOVED*** {
        return null;
  ***REMOVED***

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i***REMOVED*** {
        if (key***REMOVED*** {
            if (array[i][key]***REMOVED*** {
                obj[array[i][key]] = true;
          ***REMOVED***
      ***REMOVED***
        else {
            obj[array[i]] = true;
      ***REMOVED***
  ***REMOVED***

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst***REMOVED*** {

    if (!array1 || !array2***REMOVED*** {
        return [];
  ***REMOVED***

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1***REMOVED*** : array1***REMOVED***;
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i***REMOVED*** {
        if (hash[array2[i]] && !found[array2[i]]***REMOVED*** {
            if (justFirst***REMOVED*** {
                return array2[i];
          ***REMOVED***

            common.push(array2[i]***REMOVED***;
            found[array2[i]] = true;
      ***REMOVED***
  ***REMOVED***

    return (justFirst ? null : common***REMOVED***;
};


// Find which keys are present

exports.matchKeys = function (obj, keys***REMOVED*** {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i***REMOVED*** {
        if (obj.hasOwnProperty(keys[i]***REMOVED******REMOVED*** {
            matched.push(keys[i]***REMOVED***;
      ***REMOVED***
  ***REMOVED***
    return matched;
};


// Flatten array

exports.flatten = function (array, target***REMOVED*** {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i***REMOVED*** {
        if (Array.isArray(array[i]***REMOVED******REMOVED*** {
            exports.flatten(array[i], result***REMOVED***;
      ***REMOVED***
        else {
            result.push(array[i]***REMOVED***;
      ***REMOVED***
  ***REMOVED***

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys***REMOVED*** {

    for (var i = 0, il = keys.length; i < il; i++***REMOVED*** {
        delete object[keys[i]];
  ***REMOVED***
};


// Convert an object key chain string ('a.b.c'***REMOVED*** to reference (object[a][b][c]***REMOVED***

exports.reach = function (obj, chain***REMOVED*** {

    var path = chain.split('.'***REMOVED***;
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i***REMOVED*** {
        if (ref***REMOVED*** {
            ref = ref[path[i]];
      ***REMOVED***
  ***REMOVED***

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys***REMOVED*** {

    keys = keys || null;

    for (var i in obj***REMOVED*** {
        if (obj.hasOwnProperty(i***REMOVED******REMOVED*** {
            if (keys instanceof Array &&
                keys.indexOf(i***REMOVED*** < 0***REMOVED*** {

                continue;
          ***REMOVED***

            self.prototype[i] = (function (fn***REMOVED*** {

                return function (next***REMOVED*** {

                    var result = null;
                    try {
                        result = fn(***REMOVED***;
                  ***REMOVED***
                    catch (err***REMOVED*** {
                        return next(err***REMOVED***;
                  ***REMOVED***

                    return next(null, result***REMOVED***;
              ***REMOVED***;
          ***REMOVED******REMOVED***(obj[i]***REMOVED***;
      ***REMOVED***
  ***REMOVED***
};


exports.formatStack = function (stack***REMOVED*** {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i***REMOVED*** {
        var item = stack[i];
        trace.push([item.getFileName(***REMOVED***, item.getLineNumber(***REMOVED***, item.getColumnNumber(***REMOVED***, item.getFunctionName(***REMOVED***, item.isConstructor(***REMOVED***]***REMOVED***;
  ***REMOVED***

    return trace;
};


exports.formatTrace = function (trace***REMOVED*** {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i***REMOVED*** {
        var row = trace[i];
        display.push((row[4] ? 'new ' : ''***REMOVED*** + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + '***REMOVED***'***REMOVED***;
  ***REMOVED***

    return display;
};


exports.callStack = function (slice***REMOVED*** {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack***REMOVED*** {

        return stack;
  ***REMOVED***;

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee***REMOVED***;
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack***REMOVED***;

    if (slice***REMOVED*** {
        return trace.slice(slice***REMOVED***;
  ***REMOVED***

    return trace;
};


exports.displayStack = function (slice***REMOVED*** {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1***REMOVED***;

    return exports.formatTrace(trace***REMOVED***;
};


exports.abortThrow = false;


exports.abort = function (message, hideStack***REMOVED*** {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true***REMOVED*** {
        throw new Error(message || 'Unknown error'***REMOVED***;
  ***REMOVED***

    var stack = '';
    if (!hideStack***REMOVED*** {
        stack = exports.displayStack(1***REMOVED***.join('\n\t'***REMOVED***;
  ***REMOVED***
    console.log('ABORT: ' + message + '\n\t' + stack***REMOVED***;
    process.exit(1***REMOVED***;
};


exports.assert = function (condition /*, msg1, msg2, msg3 */***REMOVED*** {

    if (condition***REMOVED*** {
        return;
  ***REMOVED***

    var msgs = Array.prototype.slice.call(arguments, 1***REMOVED***;
    msgs = msgs.map(function (msg***REMOVED*** {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg***REMOVED***;
  ***REMOVED******REMOVED***;
    throw new Error(msgs.join(' '***REMOVED*** || 'Unknown error'***REMOVED***;
};


exports.loadDirModules = function (path, excludeFiles, target***REMOVED*** {      // target(filename, name, capName***REMOVED***

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i***REMOVED*** {
        exclude[excludeFiles[i] + '.js'] = true;
  ***REMOVED***

    var files = Fs.readdirSync(path***REMOVED***;
    for (i = 0, il = files.length; i < il; ++i***REMOVED*** {
        var filename = files[i];
        if (/\.js$/.test(filename***REMOVED*** &&
            !exclude[filename]***REMOVED*** {

            var name = filename.substr(0, filename.lastIndexOf('.'***REMOVED******REMOVED***;
            var capName = name.charAt(0***REMOVED***.toUpperCase(***REMOVED*** + name.substr(1***REMOVED***.toLowerCase(***REMOVED***;

            if (typeof target !== 'function'***REMOVED*** {
                target[capName] = require(path + '/' + name***REMOVED***;
          ***REMOVED***
            else {
                target(path + '/' + name, name, capName***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
};


exports.rename = function (obj, from, to***REMOVED*** {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function (***REMOVED*** {

    this.reset(***REMOVED***;
};


exports.Timer.prototype.reset = function (***REMOVED*** {

    this.ts = Date.now(***REMOVED***;
};


exports.Timer.prototype.elapsed = function (***REMOVED*** {

    return Date.now(***REMOVED*** - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir***REMOVED*** {

    var result = {};
    var filepath = (dir || process.env.PWD***REMOVED*** + '/package.json';
    if (Fs.existsSync(filepath***REMOVED******REMOVED*** {
        try {
            result = JSON.parse(Fs.readFileSync(filepath***REMOVED******REMOVED***;
      ***REMOVED***
        catch (e***REMOVED*** { }
  ***REMOVED***

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string***REMOVED*** {

    // Escape ^$.*+-?=!:|\/(***REMOVED***[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\***REMOVED***\[\]\{\}\,]/g, '\\$&'***REMOVED***;
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */***REMOVED*** {

    var message = (arguments.length === 3 ? arguments[1] : ''***REMOVED***;
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]***REMOVED***;

    var err = (message instanceof Error ? message : (message ? new Error(message***REMOVED*** : (condition instanceof Error ? condition : new Error(***REMOVED******REMOVED******REMOVED******REMOVED***;

    if (condition instanceof Error ||
        !condition***REMOVED*** {

        return next(err***REMOVED***;
  ***REMOVED***
};


// Base64url (RFC 4648***REMOVED*** encode

exports.base64urlEncode = function (value***REMOVED*** {

    return (new Buffer(value, 'binary'***REMOVED******REMOVED***.toString('base64'***REMOVED***.replace(/\+/g, '-'***REMOVED***.replace(/\//g, '_'***REMOVED***.replace(/\=/g, ''***REMOVED***;
};


// Base64url (RFC 4648***REMOVED*** decode

exports.base64urlDecode = function (encoded***REMOVED*** {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/***REMOVED******REMOVED*** {

        return new Error('Invalid character'***REMOVED***;
  ***REMOVED***

    try {
        return (new Buffer(encoded.replace(/-/g, '+'***REMOVED***.replace(/:/g, '/'***REMOVED***, 'base64'***REMOVED******REMOVED***.toString('binary'***REMOVED***;
  ***REMOVED***
    catch (err***REMOVED*** {
        return err;
  ***REMOVED***
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute***REMOVED*** {

    // Allowed value characters: !#$%&'(***REMOVED****+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\***REMOVED***\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/***REMOVED***, 'Bad attribute value (' + attribute + '***REMOVED***'***REMOVED***;

    return attribute.replace(/\\/g, '\\\\'***REMOVED***.replace(/\"/g, '\\"'***REMOVED***;                             // Escape quotes and slash
};


exports.escapeHtml = function (string***REMOVED*** {

    return Escape.escapeHtml(string***REMOVED***;
};


exports.escapeJavaScript = function (string***REMOVED*** {

    return Escape.escapeJavaScript(string***REMOVED***;
};


/*
var event = {
    timestamp: now.getTime(***REMOVED***,
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event***REMOVED*** {

    var pad = function (value***REMOVED*** {

        return (value < 10 ? '0' : ''***REMOVED*** + value;
  ***REMOVED***;

    var now = new Date(event.timestamp***REMOVED***;
    var timestring = (now.getYear(***REMOVED*** - 100***REMOVED***.toString(***REMOVED*** +
        pad(now.getMonth(***REMOVED*** + 1***REMOVED*** +
        pad(now.getDate(***REMOVED******REMOVED*** +
        '/' +
        pad(now.getHours(***REMOVED******REMOVED*** +
        pad(now.getMinutes(***REMOVED******REMOVED*** +
        pad(now.getSeconds(***REMOVED******REMOVED*** +
        '.' +
        now.getMilliseconds(***REMOVED***;

    var data = event.data;
    if (typeof event.data !== 'string'***REMOVED*** {
        try {
            data = JSON.stringify(event.data***REMOVED***;
      ***REMOVED***
        catch (e***REMOVED*** {
            data = 'JSON Error: ' + e.message;
      ***REMOVED***
  ***REMOVED***

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output***REMOVED***;
};


exports.nextTick = function (callback***REMOVED*** {

    return function (***REMOVED*** {

        var args = arguments;
        process.nextTick(function (***REMOVED*** {

            callback.apply(null, args***REMOVED***;
      ***REMOVED******REMOVED***;
  ***REMOVED***;
};
