// Load modules

var Url = require('url'***REMOVED***;
var Hoek = require('hoek'***REMOVED***;
var Cryptiles = require('cryptiles'***REMOVED***;
var Crypto = require('./crypto'***REMOVED***;
var Utils = require('./utils'***REMOVED***;


// Declare internals

var internals = {};


// Generate an Authorization header for a given request

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse(***REMOVED***
    method: HTTP verb (e.g. 'GET', 'POST'***REMOVED***
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                                 // 'sha1', 'sha256'
      ***REMOVED***,

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        timestamp: Date.now(***REMOVED***,                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided***REMOVED***
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided***REMOVED***
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided***REMOVED***
        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
        app: '24s23423f34dx',                               // Oz application id
        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
  ***REMOVED***
*/

exports.header = function (uri, method, options***REMOVED*** {

    var result = {
        field: '',
        artifacts: {}
  ***REMOVED***;

    // Validate inputs

    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object'***REMOVED*** ||
        !method || typeof method !== 'string' ||
        !options || typeof options !== 'object'***REMOVED*** {

        return result;
  ***REMOVED***

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now(***REMOVED*** + (options.localtimeOffsetMsec || 0***REMOVED******REMOVED*** / 1000***REMOVED***

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm***REMOVED*** {

        // Invalid credential object
        return result;
  ***REMOVED***

    if (Crypto.algorithms.indexOf(credentials.algorithm***REMOVED*** === -1***REMOVED*** {
        return result;
  ***REMOVED***

    // Parse URI

    if (typeof uri === 'string'***REMOVED*** {
        uri = Url.parse(uri***REMOVED***;
  ***REMOVED***

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6***REMOVED***,
        method: method,
        resource: uri.pathname + (uri.search || ''***REMOVED***,                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443***REMOVED***,
        hash: options.hash,
        ext: options.ext,
        app: options.app,
        dlg: options.dlg
  ***REMOVED***;

    result.artifacts = artifacts;

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload'***REMOVED******REMOVED*** {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType***REMOVED***;
  ***REMOVED***

    var mac = Crypto.calculateMac('header', credentials, artifacts***REMOVED***;

    // Construct header

    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
    var header = 'Hawk id="' + credentials.id +
                 '", ts="' + artifacts.ts +
                 '", nonce="' + artifacts.nonce +
                 (artifacts.hash ? '", hash="' + artifacts.hash : ''***REMOVED*** +
                 (hasExt ? '", ext="' + Utils.escapeHeaderAttribute(artifacts.ext***REMOVED*** : ''***REMOVED*** +
                 '", mac="' + mac + '"';

    if (artifacts.app***REMOVED*** {
        header += ', app="' + artifacts.app +
                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : ''***REMOVED*** + '"';
  ***REMOVED***

    result.field = header;

    return result;
};


// Validate server response

/*
    res:        node's response object
    artifacts:  object recieved from header(***REMOVED***.artifacts
    options: {
        payload:    optional payload received
        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
  ***REMOVED***
*/

exports.authenticate = function (res, credentials, artifacts, options***REMOVED*** {

    artifacts = Hoek.clone(artifacts***REMOVED***;
    options = options || {};

    if (res.headers['www-authenticate']***REMOVED*** {

        // Parse HTTP WWW-Authenticate header

        var attributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']***REMOVED***;
        if (attributes instanceof Error***REMOVED*** {
            return false;
      ***REMOVED***

        if (attributes.ts***REMOVED*** {
            var tsm = Crypto.calculateTsMac(attributes.ts, credentials***REMOVED***;
            if (tsm !== attributes.tsm***REMOVED*** {
                return false;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    // Parse HTTP Server-Authorization header

    if (!res.headers['server-authorization'] &&
        !options.required***REMOVED*** {

        return true;
  ***REMOVED***

    var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']***REMOVED***;
    if (attributes instanceof Error***REMOVED*** {
        return false;
  ***REMOVED***

    artifacts.ext = attributes.ext;
    artifacts.hash = attributes.hash;

    var mac = Crypto.calculateMac('response', credentials, artifacts***REMOVED***;
    if (mac !== attributes.mac***REMOVED*** {
        return false;
  ***REMOVED***

    if (!options.hasOwnProperty('payload'***REMOVED******REMOVED*** {
        return true;
  ***REMOVED***

    if (!attributes.hash***REMOVED*** {
        return false;
  ***REMOVED***

    var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']***REMOVED***;
    return (calculatedHash === attributes.hash***REMOVED***;
};


// Generate a bewit value for a given URI

/*
 * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
 * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'
 */
/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse(***REMOVED***
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
      ***REMOVED***,
        ttlSec: 60 * 60,                                    // TTL in seconds

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        localtimeOffsetMsec: 400                            // Time offset to sync with server time
  ***REMOVED***;
*/

exports.getBewit = function (uri, options***REMOVED*** {

    // Validate inputs

    if (!uri ||
        (typeof uri !== 'string' && typeof uri !== 'object'***REMOVED*** ||
        !options ||
        typeof options !== 'object' ||
        !options.ttlSec***REMOVED*** {

        return '';
  ***REMOVED***

    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext***REMOVED***;       // Zero is valid value

    // Application time

    var now = Utils.now(***REMOVED*** + (options.localtimeOffsetMsec || 0***REMOVED***;

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm***REMOVED*** {

        return '';
  ***REMOVED***

    if (Crypto.algorithms.indexOf(credentials.algorithm***REMOVED*** === -1***REMOVED*** {
        return '';
  ***REMOVED***

    // Parse URI

    if (typeof uri === 'string'***REMOVED*** {
        uri = Url.parse(uri***REMOVED***;
  ***REMOVED***

    // Calculate signature

    var exp = Math.floor(now / 1000***REMOVED*** + options.ttlSec;
    var mac = Crypto.calculateMac('bewit', credentials, {
        ts: exp,
        nonce: '',
        method: 'GET',
        resource: uri.pathname + (uri.search || ''***REMOVED***,                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443***REMOVED***,
        ext: options.ext
  ***REMOVED******REMOVED***;

    // Construct bewit: id\exp\mac\ext

    var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
    return Utils.base64urlEncode(bewit***REMOVED***;
};


// Generate an authorization string for a message

/*
    host: 'example.com',
    port: 8000,
    message: '{"some":"payload"}',                          // UTF-8 encoded string for body hash generation
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
      ***REMOVED***,

        // Optional

        timestamp: Date.now(***REMOVED***,                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided***REMOVED***
  ***REMOVED***
*/

exports.message = function (host, port, message, options***REMOVED*** {

    // Validate inputs

    if (!host || typeof host !== 'string' ||
        !port || typeof port !== 'number' ||
        message === null || message === undefined || typeof message !== 'string' ||
        !options || typeof options !== 'object'***REMOVED*** {

        return null;
  ***REMOVED***

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now(***REMOVED*** + (options.localtimeOffsetMsec || 0***REMOVED******REMOVED*** / 1000***REMOVED***

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm***REMOVED*** {

        // Invalid credential object
        return null;
  ***REMOVED***

    if (Crypto.algorithms.indexOf(credentials.algorithm***REMOVED*** === -1***REMOVED*** {
        return null;
  ***REMOVED***

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6***REMOVED***,
        host: host,
        port: port,
        hash: Crypto.calculatePayloadHash(message, credentials.algorithm***REMOVED***
  ***REMOVED***;

    // Construct authorization

    var result = {
        id: credentials.id,
        ts: artifacts.ts,
        nonce: artifacts.nonce,
        hash: artifacts.hash,
        mac: Crypto.calculateMac('message', credentials, artifacts***REMOVED***
  ***REMOVED***;

    return result;
};



