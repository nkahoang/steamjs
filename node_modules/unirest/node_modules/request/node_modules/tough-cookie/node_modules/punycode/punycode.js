/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root***REMOVED*** {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal***REMOVED*** {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point***REMOVED***',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type***REMOVED*** {
		throw RangeError(errors[type]***REMOVED***;
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn***REMOVED*** {
		var length = array.length;
		while (length--***REMOVED*** {
			array[length] = fn(array[length]***REMOVED***;
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn***REMOVED*** {
		return map(string.split(regexSeparators***REMOVED***, fn***REMOVED***.join('.'***REMOVED***;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters***REMOVED*** into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2***REMOVED***.
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string***REMOVED*** {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length***REMOVED*** {
			value = string.charCodeAt(counter++***REMOVED***;
			if (value >= 0xD800 && value <= 0xDBFF && counter < length***REMOVED*** {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++***REMOVED***;
				if ((extra & 0xFC00***REMOVED*** == 0xDC00***REMOVED*** { // low surrogate
					output.push(((value & 0x3FF***REMOVED*** << 10***REMOVED*** + (extra & 0x3FF***REMOVED*** + 0x10000***REMOVED***;
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value***REMOVED***;
					counter--;
				}
			} else {
				output.push(value***REMOVED***;
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2***REMOVED***.
	 */
	function ucs2encode(array***REMOVED*** {
		return map(array, function(value***REMOVED*** {
			var output = '';
			if (value > 0xFFFF***REMOVED*** {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800***REMOVED***;
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value***REMOVED***;
			return output;
		}***REMOVED***.join(''***REMOVED***;
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic(***REMOVED***`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers***REMOVED*** in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint***REMOVED*** {
		if (codePoint - 48 < 10***REMOVED*** {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26***REMOVED*** {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26***REMOVED*** {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit(***REMOVED***`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers***REMOVED*** is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag***REMOVED*** {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26***REMOVED*** - ((flag != 0***REMOVED*** << 5***REMOVED***;
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime***REMOVED*** {
		var k = 0;
		delta = firstTime ? floor(delta / damp***REMOVED*** : delta >> 1;
		delta += floor(delta / numPoints***REMOVED***;
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base***REMOVED*** {
			delta = floor(delta / baseMinusTMin***REMOVED***;
		}
		return floor(k + (baseMinusTMin + 1***REMOVED*** * delta / (delta + skew***REMOVED******REMOVED***;
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input***REMOVED*** {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter***REMOVED***;
		if (basic < 0***REMOVED*** {
			basic = 0;
		}

		for (j = 0; j < basic; ++j***REMOVED*** {
			// if it's not a basic code point
			if (input.charCodeAt(j***REMOVED*** >= 0x80***REMOVED*** {
				error('not-basic'***REMOVED***;
			}
			output.push(input.charCodeAt(j***REMOVED******REMOVED***;
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */***REMOVED*** {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base***REMOVED*** {

				if (index >= inputLength***REMOVED*** {
					error('invalid-input'***REMOVED***;
				}

				digit = basicToDigit(input.charCodeAt(index++***REMOVED******REMOVED***;

				if (digit >= base || digit > floor((maxInt - i***REMOVED*** / w***REMOVED******REMOVED*** {
					error('overflow'***REMOVED***;
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias***REMOVED***;

				if (digit < t***REMOVED*** {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT***REMOVED******REMOVED*** {
					error('overflow'***REMOVED***;
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0***REMOVED***;

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out***REMOVED*** > maxInt - n***REMOVED*** {
				error('overflow'***REMOVED***;
			}

			n += floor(i / out***REMOVED***;
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n***REMOVED***;

		}

		return ucs2encode(output***REMOVED***;
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input***REMOVED*** {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input***REMOVED***;

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j***REMOVED*** {
			currentValue = input[j];
			if (currentValue < 0x80***REMOVED*** {
				output.push(stringFromCharCode(currentValue***REMOVED******REMOVED***;
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength***REMOVED*** {
			output.push(delimiter***REMOVED***;
		}

		// Main encoding loop:
		while (handledCPCount < inputLength***REMOVED*** {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j***REMOVED*** {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m***REMOVED*** {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta***REMOVED*** / handledCPCountPlusOne***REMOVED******REMOVED*** {
				error('overflow'***REMOVED***;
			}

			delta += (m - n***REMOVED*** * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j***REMOVED*** {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt***REMOVED*** {
					error('overflow'***REMOVED***;
				}

				if (currentValue == n***REMOVED*** {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base***REMOVED*** {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias***REMOVED***;
						if (q < t***REMOVED*** {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0***REMOVED******REMOVED***
						***REMOVED***;
						q = floor(qMinusT / baseMinusT***REMOVED***;
					}

					output.push(stringFromCharCode(digitToBasic(q, 0***REMOVED******REMOVED******REMOVED***;
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength***REMOVED***;
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join(''***REMOVED***;
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain***REMOVED*** {
		return mapDomain(domain, function(string***REMOVED*** {
			return regexPunycode.test(string***REMOVED***
				? decode(string.slice(4***REMOVED***.toLowerCase(***REMOVED******REMOVED***
				: string;
		}***REMOVED***;
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain***REMOVED*** {
		return mapDomain(domain, function(string***REMOVED*** {
			return regexNonASCII.test(string***REMOVED***
				? 'xn--' + encode(string***REMOVED***
				: string;
		}***REMOVED***;
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2***REMOVED*** to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	***REMOVED*** {
		define('punycode', function(***REMOVED*** {
			return punycode;
		}***REMOVED***;
	} else if (freeExports && !freeExports.nodeType***REMOVED*** {
		if (freeModule***REMOVED*** { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode***REMOVED*** {
				punycode.hasOwnProperty(key***REMOVED*** && (freeExports[key] = punycode[key]***REMOVED***;
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this***REMOVED******REMOVED***;
