/*
 * Copyright GoInstant, Inc. and other contributors. All rights reserved.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"***REMOVED***, to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

'use strict';
var net = require('net'***REMOVED***;
var urlParse = require('url'***REMOVED***.parse;
var pubsuffix = require('./pubsuffix'***REMOVED***;
var Store = require('./store'***REMOVED***.Store;

var punycode;
try {
  punycode = require('punycode'***REMOVED***;
} catch(e***REMOVED*** {
  console.warn("cookie: can't load punycode; won't use punycode for domain normalization"***REMOVED***;
}

var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

// From RFC2616 S2.2:
var TOKEN = /[\x21\x23-\x26\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;

// From RFC6265 S4.1.1
// note that it excludes \x3B ";"
var COOKIE_OCTET  = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/;
var COOKIE_OCTETS = new RegExp('^'+COOKIE_OCTET.source+'$'***REMOVED***;

// The name/key cannot be empty but the value can (S5.2***REMOVED***:
var COOKIE_PAIR_STRICT = new RegExp('^('+TOKEN.source+'+***REMOVED***=("?***REMOVED***('+COOKIE_OCTET.source+'****REMOVED***\\2$'***REMOVED***;
var COOKIE_PAIR = /^([^=\s]+***REMOVED***\s*=\s*("?***REMOVED***\s*(.****REMOVED***\s*\2\s*$/;

// RFC6265 S4.1.1 defines extension-av as 'any CHAR except CTLs or ";"'
// Note ';' is \x3B
var NON_CTL_SEMICOLON = /[\x20-\x3A\x3C-\x7E]+/;
var EXTENSION_AV = NON_CTL_SEMICOLON;
var PATH_VALUE = NON_CTL_SEMICOLON;

// Used for checking whether or not there is a trailing semi-colon
var TRAILING_SEMICOLON = /;+$/;

/* RFC6265 S5.1.1.5:
 * [fail if] the day-of-month-value is less than 1 or greater than 31
 */
var DAY_OF_MONTH = /^(0?[1-9]|[12][0-9]|3[01]***REMOVED***$/;

/* RFC6265 S5.1.1.5:
 * [fail if]
 * *  the hour-value is greater than 23,
 * *  the minute-value is greater than 59, or
 * *  the second-value is greater than 59.
 */
var TIME = /(0?[0-9]|1[0-9]|2[0-3]***REMOVED***:([0-5][0-9]***REMOVED***:([0-5][0-9]***REMOVED***/;
var STRICT_TIME = /^(0?[0-9]|1[0-9]|2[0-3]***REMOVED***:([0-5][0-9]***REMOVED***:([0-5][0-9]***REMOVED***$/;

var MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec***REMOVED***$/i;
var MONTH_TO_NUM = {
  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
};
var NUM_TO_MONTH = [
  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
];
var NUM_TO_DAY = [
  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
];

var YEAR = /^([1-9][0-9]{1,3}***REMOVED***$/; // 2 to 4 digits

var MAX_TIME = 2147483647000; // 31-bit max
var MIN_TIME = 0; // 31-bit min


// RFC6265 S5.1.1 date parser:
function parseDate(str,strict***REMOVED*** {
  if (!str***REMOVED*** {
    return;
***REMOVED***
  var found_time, found_dom, found_month, found_year;

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  var tokens = str.split(DATE_DELIM***REMOVED***;
  if (!tokens***REMOVED*** {
    return;
***REMOVED***

  var date = new Date(***REMOVED***;
  date.setMilliseconds(0***REMOVED***;

  for (var i=0; i<tokens.length; i++***REMOVED*** {
    var token = tokens[i].trim(***REMOVED***;
    if (!token.length***REMOVED*** {
      continue;
  ***REMOVED***

    var result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (!found_time***REMOVED*** {
      result = (strict ? STRICT_TIME : TIME***REMOVED***.exec(token***REMOVED***;
      if (result***REMOVED*** {
        found_time = true;
        date.setUTCHours(result[1]***REMOVED***;
        date.setUTCMinutes(result[2]***REMOVED***;
        date.setUTCSeconds(result[3]***REMOVED***;
        continue;
    ***REMOVED***
  ***REMOVED***

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (!found_dom***REMOVED*** {
      result = DAY_OF_MONTH.exec(token***REMOVED***;
      if (result***REMOVED*** {
        found_dom = true;
        date.setUTCDate(result[1]***REMOVED***;
        continue;
    ***REMOVED***
  ***REMOVED***

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (!found_month***REMOVED*** {
      result = MONTH.exec(token***REMOVED***;
      if (result***REMOVED*** {
        found_month = true;
        date.setUTCMonth(MONTH_TO_NUM[result[1].toLowerCase(***REMOVED***]***REMOVED***;
        continue;
    ***REMOVED***
  ***REMOVED***

    /* 2.4. If the found-year flag is not set and the date-token matches the year
     * production, set the found-year flag and set the year-value to the number
     * denoted by the date-token.  Skip the remaining sub-steps and continue to
     * the next date-token.
     */
    if (!found_year***REMOVED*** {
      result = YEAR.exec(token***REMOVED***;
      if (result***REMOVED*** {
        var year = result[0];
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (70 <= year && year <= 99***REMOVED*** {
          year += 1900;
      ***REMOVED*** else if (0 <= year && year <= 69***REMOVED*** {
          year += 2000;
      ***REMOVED***

        if (year < 1601***REMOVED*** {
          return; // 5. ... the year-value is less than 1601
      ***REMOVED***

        found_year = true;
        date.setUTCFullYear(year***REMOVED***;
        continue;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  if (!(found_time && found_dom && found_month && found_year***REMOVED******REMOVED*** {
    return; // 5. ... at least one of the found-day-of-month, found-month, found-
            // year, or found-time flags is not set,
***REMOVED***

  return date;
}

function formatDate(date***REMOVED*** {
  var d = date.getUTCDate(***REMOVED***; d = d >= 10 ? d : '0'+d;
  var h = date.getUTCHours(***REMOVED***; h = h >= 10 ? h : '0'+h;
  var m = date.getUTCMinutes(***REMOVED***; m = m >= 10 ? m : '0'+m;
  var s = date.getUTCSeconds(***REMOVED***; s = s >= 10 ? s : '0'+s;
  return NUM_TO_DAY[date.getUTCDay(***REMOVED***] + ', ' +
    d+' '+ NUM_TO_MONTH[date.getUTCMonth(***REMOVED***] +' '+ date.getUTCFullYear(***REMOVED*** +' '+
    h+':'+m+':'+s+' GMT';
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str***REMOVED*** {
  if (str == null***REMOVED*** {
    return null;
***REMOVED***
  str = str.trim(***REMOVED***.replace(/^\./,''***REMOVED***; // S4.1.2.3 & S5.2.3: ignore leading .

  // convert to IDN if any non-ASCII characters
  if (punycode && /[^\u0001-\u007f]/.test(str***REMOVED******REMOVED*** {
    str = punycode.toASCII(str***REMOVED***;
***REMOVED***

  return str.toLowerCase(***REMOVED***;
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize***REMOVED*** {
  if (str == null || domStr == null***REMOVED*** {
    return null;
***REMOVED***
  if (canonicalize !== false***REMOVED*** {
    str = canonicalDomain(str***REMOVED***;
    domStr = canonicalDomain(domStr***REMOVED***;
***REMOVED***

  /*
   * "The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point***REMOVED***"
   */
  if (str == domStr***REMOVED*** {
    return true;
***REMOVED***

  /* "All of the following [three] conditions hold:" (order adjusted from the RFC***REMOVED*** */

  /* "* The string is a host name (i.e., not an IP address***REMOVED***." */
  if (net.isIP(str***REMOVED******REMOVED*** {
    return false;
***REMOVED***

  /* "* The domain string is a suffix of the string" */
  var idx = str.indexOf(domStr***REMOVED***;
  if (idx <= 0***REMOVED*** {
    return false; // it's a non-match (-1***REMOVED*** or prefix (0***REMOVED***
***REMOVED***

  // e.g "a.b.c".indexOf("b.c"***REMOVED*** === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx***REMOVED*** { // it's not a suffix
    return false;
***REMOVED***

  /* "* The last character of the string that is not included in the domain
  * string is a %x2E ("."***REMOVED*** character." */
  if (str.substr(idx-1,1***REMOVED*** !== '.'***REMOVED*** {
    return false;
***REMOVED***

  return true;
}


// RFC6265 S5.1.4 Paths and Path-Match

/*
 * "The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:"
 *
 * Assumption: the path (and not query part or absolute uri***REMOVED*** is passed in.
 */
function defaultPath(path***REMOVED*** {
  // "2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F ("/"***REMOVED*** character, output %x2F ("/"***REMOVED*** and skip the remaining steps.
  if (!path || path.substr(0,1***REMOVED*** !== "/"***REMOVED*** {
    return "/";
***REMOVED***

  // "3. If the uri-path contains no more than one %x2F ("/"***REMOVED*** character, output
  // %x2F ("/"***REMOVED*** and skip the remaining step."
  if (path === "/"***REMOVED*** {
    return path;
***REMOVED***

  var rightSlash = path.lastIndexOf("/"***REMOVED***;
  if (rightSlash === 0***REMOVED*** {
    return "/";
***REMOVED***

  // "4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F ("/"***REMOVED***."
  return path.slice(0, rightSlash***REMOVED***;
}

/*
 * "A request-path path-matches a given cookie-path if at least one of the
 * following conditions holds:"
 */
function pathMatch(reqPath,cookiePath***REMOVED*** {
  // "o  The cookie-path and the request-path are identical."
  if (cookiePath === reqPath***REMOVED*** {
    return true;
***REMOVED***

  var idx = reqPath.indexOf(cookiePath***REMOVED***;
  if (idx === 0***REMOVED*** {
    // "o  The cookie-path is a prefix of the request-path, and the last
    // character of the cookie-path is %x2F ("/"***REMOVED***."
    if (cookiePath.substr(-1***REMOVED*** === "/"***REMOVED*** {
      return true;
  ***REMOVED***

    // " o  The cookie-path is a prefix of the request-path, and the first
    // character of the request-path that is not included in the cookie- path
    // is a %x2F ("/"***REMOVED*** character."
    if (reqPath.substr(cookiePath.length,1***REMOVED*** === "/"***REMOVED*** {
      return true;
  ***REMOVED***
***REMOVED***

  return false;
}

function parse(str, strict***REMOVED*** {
  str = str.trim(***REMOVED***;

  // S4.1.1 Trailing semi-colons are not part of the specification.
  // If we are not in strict mode we remove the trailing semi-colons.
  var semiColonCheck = TRAILING_SEMICOLON.exec(str***REMOVED***;
  if (semiColonCheck***REMOVED*** {
    if (strict***REMOVED*** {
      return;
  ***REMOVED***
    str = str.slice(0, semiColonCheck.index***REMOVED***;
***REMOVED***

  // We use a regex to parse the "name-value-pair" part of S5.2
  var firstSemi = str.indexOf(';'***REMOVED***; // S5.2 step 1
  var pairRx = strict ? COOKIE_PAIR_STRICT : COOKIE_PAIR;
  var result = pairRx.exec(firstSemi === -1 ? str : str.substr(0,firstSemi***REMOVED******REMOVED***;

  // Rx satisfies the "the name string is empty" and "lacks a %x3D ("="***REMOVED***"
  // constraints as well as trimming any whitespace.
  if (!result***REMOVED*** {
    return;
***REMOVED***

  var c = new Cookie(***REMOVED***;
  c.key = result[1]; // the regexp should trim(***REMOVED*** already
  c.value = result[3]; // [2] is quotes or empty-string

  if (firstSemi === -1***REMOVED*** {
    return c;
***REMOVED***

  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (";"***REMOVED*** in question***REMOVED***." plus later on in the same section
  // "discard the first ";" and trim".
  var unparsed = str.slice(firstSemi***REMOVED***.replace(/^\s*;\s*/,''***REMOVED***.trim(***REMOVED***;

  // "If the unparsed-attributes string is empty, skip the rest of these
  // steps."
  if (unparsed.length === 0***REMOVED*** {
    return c;
***REMOVED***

  /*
   * S5.2 says that when looping over the items "[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections" for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the "attribute-value of the last attribute in the
   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  var cookie_avs = unparsed.split(/\s*;\s*/***REMOVED***;
  while (cookie_avs.length***REMOVED*** {
    var av = cookie_avs.shift(***REMOVED***;

    if (strict && !EXTENSION_AV.test(av***REMOVED******REMOVED*** {
      return;
  ***REMOVED***

    var av_sep = av.indexOf('='***REMOVED***;
    var av_key, av_value;
    if (av_sep === -1***REMOVED*** {
      av_key = av;
      av_value = null;
  ***REMOVED*** else {
      av_key = av.substr(0,av_sep***REMOVED***;
      av_value = av.substr(av_sep+1***REMOVED***;
  ***REMOVED***

    av_key = av_key.trim(***REMOVED***.toLowerCase(***REMOVED***;
    if (av_value***REMOVED*** {
      av_value = av_value.trim(***REMOVED***;
  ***REMOVED***

    switch(av_key***REMOVED*** {
    case 'expires': // S5.2.1
      if (!av_value***REMOVED*** {if(strict***REMOVED***{return;}else{break;} }
      var exp = parseDate(av_value,strict***REMOVED***;
      // "If the attribute-value failed to parse as a cookie date, ignore the
      // cookie-av."
      if (exp == null***REMOVED*** { if(strict***REMOVED***{return;}else{break;} }
      c.expires = exp;
      // over and underflow not realistically a concern: V8's getTime(***REMOVED*** seems to
      // store something larger than a 32-bit time_t (even with 32-bit node***REMOVED***
      break;

    case 'max-age': // S5.2.2
      if (!av_value***REMOVED*** { if(strict***REMOVED***{return;}else{break;} }
      // "If the first character of the attribute-value is not a DIGIT or a "-"
      // character ...[or]... If the remainder of attribute-value contains a
      // non-DIGIT character, ignore the cookie-av."
      if (!/^-?[0-9]+$/.test(av_value***REMOVED******REMOVED*** { if(strict***REMOVED***{return;}else{break;} }
      var delta = parseInt(av_value,10***REMOVED***;
      if (strict && delta <= 0***REMOVED*** {
        return; // S4.1.1
    ***REMOVED***
      // "If delta-seconds is less than or equal to zero (0***REMOVED***, let expiry-time
      // be the earliest representable date and time."
      c.setMaxAge(delta***REMOVED***;
      break;

    case 'domain': // S5.2.3
      // "If the attribute-value is empty, the behavior is undefined.  However,
      // the user agent SHOULD ignore the cookie-av entirely."
      if (!av_value***REMOVED*** { if(strict***REMOVED***{return;}else{break;} }
      // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
      // ("."***REMOVED*** character."
      var domain = av_value.trim(***REMOVED***.replace(/^\./,''***REMOVED***;
      if (!domain***REMOVED*** { if(strict***REMOVED***{return;}else{break;} } // see "is empty" above
      // "Convert the cookie-domain to lower case."
      c.domain = domain.toLowerCase(***REMOVED***;
      break;

    case 'path': // S5.2.4
      /*
       * "If the attribute-value is empty or if the first character of the
       * attribute-value is not %x2F ("/"***REMOVED***:
       *   Let cookie-path be the default-path.
       * Otherwise:
       *   Let cookie-path be the attribute-value."
       *
       * We'll represent the default-path as null since it depends on the
       * context of the parsing.
       */
      if (!av_value || av_value.substr(0,1***REMOVED*** != "/"***REMOVED*** {
        if(strict***REMOVED***{return;}else{break;}
    ***REMOVED***
      c.path = av_value;
      break;

    case 'secure': // S5.2.5
      /*
       * "If the attribute-name case-insensitively matches the string "Secure",
       * the user agent MUST append an attribute to the cookie-attribute-list
       * with an attribute-name of Secure and an empty attribute-value."
       */
      if (av_value != null***REMOVED*** { if(strict***REMOVED***{return;} }
      c.secure = true;
      break;

    case 'httponly': // S5.2.6 -- effectively the same as 'secure'
      if (av_value != null***REMOVED*** { if(strict***REMOVED***{return;} }
      c.httpOnly = true;
      break;

    default:
      c.extensions = c.extensions || [];
      c.extensions.push(av***REMOVED***;
      break;
  ***REMOVED***
***REMOVED***

  // ensure a default date for sorting:
  c.creation = new Date(***REMOVED***;
  return c;
}

function fromJSON(str***REMOVED*** {
  if (!str***REMOVED*** {
    return null;
***REMOVED***

  var obj;
  try {
    obj = JSON.parse(str***REMOVED***;
***REMOVED*** catch (e***REMOVED*** {
    return null;
***REMOVED***

  var c = new Cookie(***REMOVED***;
  for (var i=0; i<numCookieProperties; i++***REMOVED*** {
    var prop = cookieProperties[i];
    if (obj[prop] == null***REMOVED*** {
      continue;
  ***REMOVED***
    if (prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed'***REMOVED***
    {
      c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]***REMOVED***;
  ***REMOVED*** else {
      c[prop] = obj[prop];
  ***REMOVED***
***REMOVED***


  // ensure a default date for sorting:
  c.creation = c.creation || new Date(***REMOVED***;

  return c;
}

/* Section 5.4 part 2:
 * "*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times."
 */

function cookieCompare(a,b***REMOVED*** {
  // descending for length: b CMP a
  var deltaLen = (b.path ? b.path.length : 0***REMOVED*** - (a.path ? a.path.length : 0***REMOVED***;
  if (deltaLen !== 0***REMOVED*** {
    return deltaLen;
***REMOVED***
  // ascending for time: a CMP b
  return (a.creation ? a.creation.getTime(***REMOVED*** : MAX_TIME***REMOVED*** -
         (b.creation ? b.creation.getTime(***REMOVED*** : MAX_TIME***REMOVED***;
}

// Gives the permutation of all possible domainMatch(***REMOVED***es of a given domain. The
// array is in shortest-to-longest order.  Handy for indexing.
function permuteDomain(domain***REMOVED*** {
  var pubSuf = pubsuffix.getPublicSuffix(domain***REMOVED***;
  if (!pubSuf***REMOVED*** {
    return null;
***REMOVED***
  if (pubSuf == domain***REMOVED*** {
    return [domain];
***REMOVED***

  var prefix = domain.slice(0,-(pubSuf.length+1***REMOVED******REMOVED***; // ".example.com"
  var parts = prefix.split('.'***REMOVED***.reverse(***REMOVED***;
  var cur = pubSuf;
  var permutations = [cur];
  while (parts.length***REMOVED*** {
    cur = parts.shift(***REMOVED***+'.'+cur;
    permutations.push(cur***REMOVED***;
***REMOVED***
  return permutations;
}

// Gives the permutation of all possible pathMatch(***REMOVED***es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path***REMOVED*** {
  if (path === '/'***REMOVED*** {
    return ['/'];
***REMOVED***
  if (path.lastIndexOf('/'***REMOVED*** === path.length-1***REMOVED*** {
    path = path.substr(0,path.length-1***REMOVED***;
***REMOVED***
  var permutations = [path];
  while (path.length > 1***REMOVED*** {
    var lindex = path.lastIndexOf('/'***REMOVED***;
    if (lindex === 0***REMOVED*** {
      break;
  ***REMOVED***
    path = path.substr(0,lindex***REMOVED***;
    permutations.push(path***REMOVED***;
***REMOVED***
  permutations.push('/'***REMOVED***;
  return permutations;
}


function Cookie (opts***REMOVED*** {
  if (typeof opts !== "object"***REMOVED*** {
    return;
***REMOVED***
  Object.keys(opts***REMOVED***.forEach(function (key***REMOVED*** {
    if (Cookie.prototype.hasOwnProperty(key***REMOVED******REMOVED*** {
      this[key] = opts[key] || Cookie.prototype[key];
  ***REMOVED***
***REMOVED***.bind(this***REMOVED******REMOVED***;
}

Cookie.parse = parse;
Cookie.fromJSON = fromJSON;

Cookie.prototype.key = "";
Cookie.prototype.value = "";

// the order in which the RFC has them:
Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
Cookie.prototype.domain = null;
Cookie.prototype.path = null;
Cookie.prototype.secure = false;
Cookie.prototype.httpOnly = false;
Cookie.prototype.extensions = null;

// set by the CookieJar:
Cookie.prototype.hostOnly = null; // boolean when set
Cookie.prototype.pathIsDefault = null; // boolean when set
Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
Cookie.prototype.lastAccessed = null; // Date when set

var cookieProperties = Object.freeze(Object.keys(Cookie.prototype***REMOVED***.map(function(p***REMOVED*** {
  if (p instanceof Function***REMOVED*** {
    return;
***REMOVED***
  return p;
}***REMOVED******REMOVED***;
var numCookieProperties = cookieProperties.length;

Cookie.prototype.inspect = function inspect(***REMOVED*** {
  var now = Date.now(***REMOVED***;
  return 'Cookie="'+this.toString(***REMOVED*** +
    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?'***REMOVED*** +
    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime(***REMOVED******REMOVED***+'ms' : '?'***REMOVED*** +
    '; cAge='+(this.creation ? (now-this.creation.getTime(***REMOVED******REMOVED***+'ms' : '?'***REMOVED*** +
    '"';
};

Cookie.prototype.validate = function validate(***REMOVED*** {
  if (!COOKIE_OCTETS.test(this.value***REMOVED******REMOVED*** {
    return false;
***REMOVED***
  if (this.expires != Infinity && !(this.expires instanceof Date***REMOVED*** && !parseDate(this.expires,true***REMOVED******REMOVED*** {
    return false;
***REMOVED***
  if (this.maxAge != null && this.maxAge <= 0***REMOVED*** {
    return false; // "Max-Age=" non-zero-digit *DIGIT
***REMOVED***
  if (this.path != null && !PATH_VALUE.test(this.path***REMOVED******REMOVED*** {
    return false;
***REMOVED***

  var cdomain = this.cdomain(***REMOVED***;
  if (cdomain***REMOVED*** {
    if (cdomain.match(/\.$/***REMOVED******REMOVED*** {
      return false; // S4.1.2.3 suggests that this is bad. domainMatch(***REMOVED*** tests confirm this
  ***REMOVED***
    var suffix = pubsuffix.getPublicSuffix(cdomain***REMOVED***;
    if (suffix == null***REMOVED*** { // it's a public suffix
      return false;
  ***REMOVED***
***REMOVED***
  return true;
};

Cookie.prototype.setExpires = function setExpires(exp***REMOVED*** {
  if (exp instanceof Date***REMOVED*** {
    this.expires = exp;
***REMOVED*** else {
    this.expires = parseDate(exp***REMOVED*** || "Infinity";
***REMOVED***
};

Cookie.prototype.setMaxAge = function setMaxAge(age***REMOVED*** {
  if (age === Infinity || age === -Infinity***REMOVED*** {
    this.maxAge = age.toString(***REMOVED***; // so JSON.stringify(***REMOVED*** works
***REMOVED*** else {
    this.maxAge = age;
***REMOVED***
};

// gives Cookie header format
Cookie.prototype.cookieString = function cookieString(***REMOVED*** {
  var val = this.value;
  if (val == null***REMOVED*** {
    val = '';
***REMOVED***
  return this.key+'='+val;
};

// gives Set-Cookie header format
Cookie.prototype.toString = function toString(***REMOVED*** {
  var str = this.cookieString(***REMOVED***;

  if (this.expires != Infinity***REMOVED*** {
    if (this.expires instanceof Date***REMOVED*** {
      str += '; Expires='+formatDate(this.expires***REMOVED***;
  ***REMOVED*** else {
      str += '; Expires='+this.expires;
  ***REMOVED***
***REMOVED***

  if (this.maxAge != null && this.maxAge != Infinity***REMOVED*** {
    str += '; Max-Age='+this.maxAge;
***REMOVED***

  if (this.domain && !this.hostOnly***REMOVED*** {
    str += '; Domain='+this.domain;
***REMOVED***
  if (this.path***REMOVED*** {
    str += '; Path='+this.path;
***REMOVED***

  if (this.secure***REMOVED*** {
    str += '; Secure';
***REMOVED***
  if (this.httpOnly***REMOVED*** {
    str += '; HttpOnly';
***REMOVED***
  if (this.extensions***REMOVED*** {
    this.extensions.forEach(function(ext***REMOVED*** {
      str += '; '+ext;
  ***REMOVED******REMOVED***;
***REMOVED***

  return str;
};

// TTL(***REMOVED*** partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie(***REMOVED***
// elsewhere***REMOVED***
// S5.3 says to give the "latest representable date" for which we use Infinity
// For "expired" we use 0
Cookie.prototype.TTL = function TTL(now***REMOVED*** {
  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
   * attribute, the Max-Age attribute has precedence and controls the
   * expiration date of the cookie.
   * (Concurs with S5.3 step 3***REMOVED***
   */
  if (this.maxAge != null***REMOVED*** {
    return this.maxAge<=0 ? 0 : this.maxAge*1000;
***REMOVED***

  var expires = this.expires;
  if (expires != Infinity***REMOVED*** {
    if (!(expires instanceof Date***REMOVED******REMOVED*** {
      expires = parseDate(expires***REMOVED*** || Infinity;
  ***REMOVED***

    if (expires == Infinity***REMOVED*** {
      return Infinity;
  ***REMOVED***

    return expires.getTime(***REMOVED*** - (now || Date.now(***REMOVED******REMOVED***;
***REMOVED***

  return Infinity;
};

// expiryTime(***REMOVED*** replaces the "expiry-time" parts of S5.3 step 3 (setCookie(***REMOVED***
// elsewhere***REMOVED***
Cookie.prototype.expiryTime = function expiryTime(now***REMOVED*** {
  if (this.maxAge != null***REMOVED*** {
    var relativeTo = this.creation || now || new Date(***REMOVED***;
    var age = (this.maxAge <= 0***REMOVED*** ? -Infinity : this.maxAge*1000;
    return relativeTo.getTime(***REMOVED*** + age;
***REMOVED***

  if (this.expires == Infinity***REMOVED*** {
    return Infinity;
***REMOVED***
  return this.expires.getTime(***REMOVED***;
};

// expiryDate(***REMOVED*** replaces the "expiry-time" parts of S5.3 step 3 (setCookie(***REMOVED***
// elsewhere***REMOVED***, except it returns a Date
Cookie.prototype.expiryDate = function expiryDate(now***REMOVED*** {
  var millisec = this.expiryTime(now***REMOVED***;
  if (millisec == Infinity***REMOVED*** {
    return new Date(MAX_TIME***REMOVED***;
***REMOVED*** else if (millisec == -Infinity***REMOVED*** {
    return new Date(MIN_TIME***REMOVED***;
***REMOVED*** else {
    return new Date(millisec***REMOVED***;
***REMOVED***
};

// This replaces the "persistent-flag" parts of S5.3 step 3
Cookie.prototype.isPersistent = function isPersistent(***REMOVED*** {
  return (this.maxAge != null || this.expires != Infinity***REMOVED***;
};

// Mostly S5.1.2 and S5.2.3:
Cookie.prototype.cdomain =
Cookie.prototype.canonicalizedDomain = function canonicalizedDomain(***REMOVED*** {
  if (this.domain == null***REMOVED*** {
    return null;
***REMOVED***
  return canonicalDomain(this.domain***REMOVED***;
};


var memstore;
function CookieJar(store, rejectPublicSuffixes***REMOVED*** {
  if (rejectPublicSuffixes != null***REMOVED*** {
    this.rejectPublicSuffixes = rejectPublicSuffixes;
***REMOVED***

  if (!store***REMOVED*** {
    memstore = memstore || require('./memstore'***REMOVED***;
    store = new memstore.MemoryCookieStore(***REMOVED***;
***REMOVED***
  this.store = store;
}
CookieJar.prototype.store = null;
CookieJar.prototype.rejectPublicSuffixes = true;
var CAN_BE_SYNC = [];

CAN_BE_SYNC.push('setCookie'***REMOVED***;
CookieJar.prototype.setCookie = function(cookie, url, options, cb***REMOVED*** {
  var err;
  var context = (url instanceof Object***REMOVED*** ? url : urlParse(url***REMOVED***;
  if (options instanceof Function***REMOVED*** {
    cb = options;
    options = {};
***REMOVED***

  var host = canonicalDomain(context.hostname***REMOVED***;

  // S5.3 step 1
  if (!(cookie instanceof Cookie***REMOVED******REMOVED*** {
    cookie = Cookie.parse(cookie, options.strict === true***REMOVED***;
***REMOVED***
  if (!cookie***REMOVED*** {
    err = new Error("Cookie failed to parse"***REMOVED***;
    return cb(options.ignoreError ? null : err***REMOVED***;
***REMOVED***

  // S5.3 step 2
  var now = options.now || new Date(***REMOVED***; // will assign later to save effort in the face of errors

  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie(***REMOVED***

  // S5.3 step 4: NOOP; domain is null by default

  // S5.3 step 5: public suffixes
  if (this.rejectPublicSuffixes && cookie.domain***REMOVED*** {
    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain(***REMOVED******REMOVED***;
    if (suffix == null***REMOVED*** { // e.g. "com"
      err = new Error("Cookie has domain set to a public suffix"***REMOVED***;
      return cb(options.ignoreError ? null : err***REMOVED***;
  ***REMOVED***
***REMOVED***

  // S5.3 step 6:
  if (cookie.domain***REMOVED*** {
    if (!domainMatch(host, cookie.cdomain(***REMOVED***, false***REMOVED******REMOVED*** {
      err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain(***REMOVED***+" Request:"+host***REMOVED***;
      return cb(options.ignoreError ? null : err***REMOVED***;
  ***REMOVED***

    if (cookie.hostOnly == null***REMOVED*** { // don't reset if already set
      cookie.hostOnly = false;
  ***REMOVED***

***REMOVED*** else {
    cookie.hostOnly = true;
    cookie.domain = host;
***REMOVED***

  // S5.3 step 7: "Otherwise, set the cookie's path to the default-path of the
  // request-uri"
  if (!cookie.path***REMOVED*** {
    cookie.path = defaultPath(context.pathname***REMOVED***;
    cookie.pathIsDefault = true;
***REMOVED*** else {
    if (cookie.path.length > 1 && cookie.path.substr(-1***REMOVED*** == '/'***REMOVED*** {
      cookie.path = cookie.path.slice(0,-1***REMOVED***;
  ***REMOVED***
***REMOVED***

  // S5.3 step 8: NOOP; secure attribute
  // S5.3 step 9: NOOP; httpOnly attribute

  // S5.3 step 10
  if (options.http === false && cookie.httpOnly***REMOVED*** {
    err = new Error("Cookie is HttpOnly and this isn't an HTTP API"***REMOVED***;
    return cb(options.ignoreError ? null : err***REMOVED***;
***REMOVED***

  var store = this.store;

  if (!store.updateCookie***REMOVED*** {
    store.updateCookie = function(oldCookie, newCookie, cb***REMOVED*** {
      this.putCookie(newCookie, cb***REMOVED***;
  ***REMOVED***;
***REMOVED***

  function withCookie(err, oldCookie***REMOVED*** {
    if (err***REMOVED*** {
      return cb(err***REMOVED***;
  ***REMOVED***

    var next = function(err***REMOVED*** {
      if (err***REMOVED*** {
        return cb(err***REMOVED***;
    ***REMOVED*** else {
        cb(null, cookie***REMOVED***;
    ***REMOVED***
  ***REMOVED***;

    if (oldCookie***REMOVED*** {
      // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
      // domain, and path as the newly created cookie:"
      if (options.http === false && oldCookie.httpOnly***REMOVED*** { // step 11.2
        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API"***REMOVED***;
        return cb(options.ignoreError ? null : err***REMOVED***;
    ***REMOVED***
      cookie.creation = oldCookie.creation; // step 11.3
      cookie.lastAccessed = now;
      // Step 11.4 (delete cookie***REMOVED*** is implied by just setting the new one:
      store.updateCookie(oldCookie, cookie, next***REMOVED***; // step 12

  ***REMOVED*** else {
      cookie.creation = cookie.lastAccessed = now;
      store.putCookie(cookie, next***REMOVED***; // step 12
  ***REMOVED***
***REMOVED***

  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie***REMOVED***;
};

// RFC6365 S5.4
CAN_BE_SYNC.push('getCookies'***REMOVED***;
CookieJar.prototype.getCookies = function(url, options, cb***REMOVED*** {
  var context = (url instanceof Object***REMOVED*** ? url : urlParse(url***REMOVED***;
  if (options instanceof Function***REMOVED*** {
    cb = options;
    options = {};
***REMOVED***

  var host = canonicalDomain(context.hostname***REMOVED***;
  var path = context.pathname || '/';

  var secure = options.secure;
  if (secure == null && context.protocol &&
      (context.protocol == 'https:' || context.protocol == 'wss:'***REMOVED******REMOVED***
  {
    secure = true;
***REMOVED***

  var http = options.http;
  if (http == null***REMOVED*** {
    http = true;
***REMOVED***

  var now = options.now || Date.now(***REMOVED***;
  var expireCheck = options.expire !== false;
  var allPaths = !!options.allPaths;
  var store = this.store;

  function matchingCookie(c***REMOVED*** {
    // "Either:
    //   The cookie's host-only-flag is true and the canonicalized
    //   request-host is identical to the cookie's domain.
    // Or:
    //   The cookie's host-only-flag is false and the canonicalized
    //   request-host domain-matches the cookie's domain."
    if (c.hostOnly***REMOVED*** {
      if (c.domain != host***REMOVED*** {
        return false;
    ***REMOVED***
  ***REMOVED*** else {
      if (!domainMatch(host, c.domain, false***REMOVED******REMOVED*** {
        return false;
    ***REMOVED***
  ***REMOVED***

    // "The request-uri's path path-matches the cookie's path."
    if (!allPaths && !pathMatch(path, c.path***REMOVED******REMOVED*** {
      return false;
  ***REMOVED***

    // "If the cookie's secure-only-flag is true, then the request-uri's
    // scheme must denote a "secure" protocol"
    if (c.secure && !secure***REMOVED*** {
      return false;
  ***REMOVED***

    // "If the cookie's http-only-flag is true, then exclude the cookie if the
    // cookie-string is being generated for a "non-HTTP" API"
    if (c.httpOnly && !http***REMOVED*** {
      return false;
  ***REMOVED***

    // deferred from S5.3
    // non-RFC: allow retention of expired cookies by choice
    if (expireCheck && c.expiryTime(***REMOVED*** <= now***REMOVED*** {
      store.removeCookie(c.domain, c.path, c.key, function(***REMOVED***{}***REMOVED***; // result ignored
      return false;
  ***REMOVED***

    return true;
***REMOVED***

  store.findCookies(host, allPaths ? null : path, function(err,cookies***REMOVED*** {
    if (err***REMOVED*** {
      return cb(err***REMOVED***;
  ***REMOVED***

    cookies = cookies.filter(matchingCookie***REMOVED***;

    // sorting of S5.4 part 2
    if (options.sort !== false***REMOVED*** {
      cookies = cookies.sort(cookieCompare***REMOVED***;
  ***REMOVED***

    // S5.4 part 3
    var now = new Date(***REMOVED***;
    cookies.forEach(function(c***REMOVED*** {
      c.lastAccessed = now;
  ***REMOVED******REMOVED***;
    // TODO persist lastAccessed

    cb(null,cookies***REMOVED***;
***REMOVED******REMOVED***;
};

CAN_BE_SYNC.push('getCookieString'***REMOVED***;
CookieJar.prototype.getCookieString = function(/*..., cb*/***REMOVED*** {
  var args = Array.prototype.slice.call(arguments,0***REMOVED***;
  var cb = args.pop(***REMOVED***;
  var next = function(err,cookies***REMOVED*** {
    if (err***REMOVED*** {
      cb(err***REMOVED***;
  ***REMOVED*** else {
      cb(null, cookies.map(function(c***REMOVED***{
        return c.cookieString(***REMOVED***;
    ***REMOVED******REMOVED***.join('; '***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***;
  args.push(next***REMOVED***;
  this.getCookies.apply(this,args***REMOVED***;
};

CAN_BE_SYNC.push('getSetCookieStrings'***REMOVED***;
CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/***REMOVED*** {
  var args = Array.prototype.slice.call(arguments,0***REMOVED***;
  var cb = args.pop(***REMOVED***;
  var next = function(err,cookies***REMOVED*** {
    if (err***REMOVED*** {
      cb(err***REMOVED***;
  ***REMOVED*** else {
      cb(null, cookies.map(function(c***REMOVED***{
        return c.toString(***REMOVED***;
    ***REMOVED******REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***;
  args.push(next***REMOVED***;
  this.getCookies.apply(this,args***REMOVED***;
};

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method***REMOVED*** {
  return function(***REMOVED*** {
    if (!this.store.synchronous***REMOVED*** {
      throw new Error('CookieJar store is not synchronous; use async API instead.'***REMOVED***;
  ***REMOVED***

    var args = Array.prototype.slice.call(arguments***REMOVED***;
    var syncErr, syncResult;
    args.push(function syncCb(err, result***REMOVED*** {
      syncErr = err;
      syncResult = result;
  ***REMOVED******REMOVED***;
    this[method].apply(this, args***REMOVED***;

    if (syncErr***REMOVED*** {
      throw syncErr;
  ***REMOVED***
    return syncResult;
***REMOVED***;
}

// wrap all declared CAN_BE_SYNC methods in the sync wrapper
CAN_BE_SYNC.forEach(function(method***REMOVED*** {
  CookieJar.prototype[method+'Sync'] = syncWrap(method***REMOVED***;
}***REMOVED***;

module.exports = {
  CookieJar: CookieJar,
  Cookie: Cookie,
  Store: Store,
  parseDate: parseDate,
  formatDate: formatDate,
  parse: parse,
  fromJSON: fromJSON,
  domainMatch: domainMatch,
  defaultPath: defaultPath,
  pathMatch: pathMatch,
  getPublicSuffix: pubsuffix.getPublicSuffix,
  cookieCompare: cookieCompare,
  permuteDomain: permuteDomain,
  permutePath: permutePath,
  canonicalDomain: canonicalDomain,
};
