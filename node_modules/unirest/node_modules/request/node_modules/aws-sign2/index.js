
/*!
 * knox - auth
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var crypto = require('crypto'***REMOVED***
  , parse = require('url'***REMOVED***.parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ]

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options***REMOVED*** {
  return 'AWS ' + options.key + ':' + sign(options***REMOVED***
}

module.exports = authorization
module.exports.authorization = authorization

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options***REMOVED*** {
  return crypto.createHmac('sha1', options.secret***REMOVED***.update(options.message***REMOVED***.digest('base64'***REMOVED***
}

module.exports.hmacSha1 = hmacSha1

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign (options***REMOVED*** {
  options.message = stringToSign(options***REMOVED***
  return hmacSha1(options***REMOVED***
}
module.exports.sign = sign

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options***REMOVED*** {
  options.message = queryStringToSign(options***REMOVED***
  return hmacSha1(options***REMOVED***
}
module.exports.signQuery= signQuery

/**
 * Return a string for sign(***REMOVED*** with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options***REMOVED*** {
  var headers = options.amazonHeaders || ''
  if (headers***REMOVED*** headers += '\n'
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date ? options.date.toUTCString(***REMOVED*** : ''
    , headers + options.resource
    ]
  return r.join('\n'***REMOVED***
}
module.exports.queryStringToSign = stringToSign

/**
 * Return a string for sign(***REMOVED*** with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options***REMOVED***{
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers***REMOVED*** {
  var buf = []
    , fields = Object.keys(headers***REMOVED***
    ;
  for (var i = 0, len = fields.length; i < len; ++i***REMOVED*** {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase(***REMOVED***
      ;
    if (0 !== field.indexOf('x-amz'***REMOVED******REMOVED*** continue
    buf.push(field + ':' + val***REMOVED***
***REMOVED***
  return buf.sort(***REMOVED***.join('\n'***REMOVED***
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource***REMOVED*** {
  var url = parse(resource, true***REMOVED***
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query***REMOVED***.forEach(function(key***REMOVED***{
    if (!~keys.indexOf(key***REMOVED******REMOVED*** return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key]***REMOVED***
    buf.push(key + val***REMOVED***
***REMOVED******REMOVED***

  return path + (buf.length ? '?' + buf.sort(***REMOVED***.join('&'***REMOVED*** : ''***REMOVED***
}
module.exports.canonicalizeResource = canonicalizeResource
