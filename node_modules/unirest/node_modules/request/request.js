var optional = require('./lib/optional'***REMOVED***
  , ***REMOVED***
  , https = optional('https'***REMOVED***
  , tls = optional('tls'***REMOVED***
  , url = require('url'***REMOVED***
  , util = require('util'***REMOVED***
  , stream = require('stream'***REMOVED***
  , qs = require('qs'***REMOVED***
  , querystring = require('querystring'***REMOVED***
  , crypto = require('crypto'***REMOVED***

  , oauth = optional('oauth-sign'***REMOVED***
  , hawk = optional('hawk'***REMOVED***
  , aws = optional('aws-sign2'***REMOVED***
  , httpSignature = optional('http-signature'***REMOVED***
  , uuid = require('node-uuid'***REMOVED***
  , mime = require('mime'***REMOVED***
  , tunnel = optional('tunnel-agent'***REMOVED***
  , _safeStringify = require('json-stringify-safe'***REMOVED***

  , ForeverAgent = require('forever-agent'***REMOVED***
  , FormData = optional('form-data'***REMOVED***

  , cookies = require('./lib/cookies'***REMOVED***
  , globalCookieJar = cookies.jar(***REMOVED***

  , copy = require('./lib/copy'***REMOVED***
  , debug = require('./lib/debug'***REMOVED***
  , getSafe = require('./lib/getSafe'***REMOVED***
  , net = require('net'***REMOVED***
  ;

function safeStringify (obj***REMOVED*** {
  var ret
  try { ret = JSON.stringify(obj***REMOVED*** }
  catch (e***REMOVED*** { ret = _safeStringify(obj***REMOVED*** }
  return ret
}

var globalPool = {}
var isUrl = /^https?:|^unix:/


// Hacky fix for pre-0.4.4 https
if (https && !https.Agent***REMOVED*** {
  https.Agent = function (options***REMOVED*** {
    http.Agent.call(this, options***REMOVED***
***REMOVED***
  util.inherits(https.Agent, http.Agent***REMOVED***
  https.Agent.prototype._getConnection = function (host, port, cb***REMOVED*** {
    var s = tls.connect(port, host, this.options, function (***REMOVED*** {
      // do other checks here?
      if (cb***REMOVED*** cb(***REMOVED***
  ***REMOVED******REMOVED***
    return s
***REMOVED***
}

function isReadStream (rs***REMOVED*** {
  return rs.readable && rs.path && rs.mode;
}

function toBase64 (str***REMOVED*** {
  return (new Buffer(str || "", "ascii"***REMOVED******REMOVED***.toString("base64"***REMOVED***
}

function md5 (str***REMOVED*** {
  return crypto.createHash('md5'***REMOVED***.update(str***REMOVED***.digest('hex'***REMOVED***
}

function Request (options***REMOVED*** {
  stream.Stream.call(this***REMOVED***
  this.readable = true
  this.writable = true

  if (typeof options === 'string'***REMOVED*** {
    options = {uri:options}
***REMOVED***

  var reserved = Object.keys(Request.prototype***REMOVED***
  for (var i in options***REMOVED*** {
    if (reserved.indexOf(i***REMOVED*** === -1***REMOVED*** {
      this[i] = options[i]
  ***REMOVED*** else {
      if (typeof options[i] === 'function'***REMOVED*** {
        delete options[i]
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  if (options.method***REMOVED*** {
    this.explicitMethod = true
***REMOVED***

  this.canTunnel = options.tunnel !== false && tunnel;

  this.init(options***REMOVED***
}
util.inherits(Request, stream.Stream***REMOVED***
Request.prototype.init = function (options***REMOVED*** {
  // init(***REMOVED*** contains all the code to setup the request object.
  // the actual outgoing request is not started until start(***REMOVED*** is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options***REMOVED*** options = {}

  if (!self.method***REMOVED*** self.method = options.method || 'GET'
  self.localAddress = options.localAddress

  debug(options***REMOVED***
  if (!self.pool && self.pool !== false***REMOVED*** self.pool = globalPool
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback && self.callback***REMOVED*** {
    self._callback = self.callback
    self.callback = function (***REMOVED*** {
      if (self._callbackCalled***REMOVED*** return // Print a warning maybe?
      self._callbackCalled = true
      self._callback.apply(self, arguments***REMOVED***
  ***REMOVED***
    self.on('error', self.callback.bind(***REMOVED******REMOVED***
    self.on('complete', self.callback.bind(self, null***REMOVED******REMOVED***
***REMOVED***

  if (self.url && !self.uri***REMOVED*** {
    // People use this property instead all the time so why not just support it.
    self.uri = self.url
    delete self.url
***REMOVED***

  if (!self.uri***REMOVED*** {
    // this will throw if unhandled but is handleable when in a redirect
    return self.emit('error', new Error("options.uri is a required argument"***REMOVED******REMOVED***
***REMOVED*** else {
    if (typeof self.uri == "string"***REMOVED*** self.uri = url.parse(self.uri***REMOVED***
***REMOVED***

  if (self.strictSSL === false***REMOVED*** {
    self.rejectUnauthorized = false
***REMOVED***

  if (self.proxy***REMOVED*** {
    if (typeof self.proxy == 'string'***REMOVED*** self.proxy = url.parse(self.proxy***REMOVED***

    // do the HTTP CONNECT dance using koichik/node-tunnel
    if (http.globalAgent && self.uri.protocol === "https:" && self.canTunnel***REMOVED*** {
      var tunnelFn = self.proxy.protocol === "http:"
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps

      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth
                                   , headers: { Host: self.uri.hostname + ':' +
                                        (self.uri.port || self.uri.protocol === 'https:' ? 443 : 80***REMOVED*** }}
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: this.ca }

      self.agent = tunnelFn(tunnelOptions***REMOVED***
      self.tunnel = true
  ***REMOVED***
***REMOVED***

  if (!self.uri.pathname***REMOVED*** {self.uri.pathname = '/'}

  if (!self.uri.host && !self.protocol=='unix:'***REMOVED*** {
    // Invalid URI: it may generate lot of bad errors, like "TypeError: Cannot call method 'indexOf' of undefined" in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri***REMOVED***
    var message = 'Invalid URI "' + faultyUri + '"'
    if (Object.keys(options***REMOVED***.length === 0***REMOVED*** {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (they didn't call request directly with this URL***REMOVED***
      // they should be warned that it can be caused by a redirection (can save some hair***REMOVED***
      message += '. This can be caused by a crappy redirection.'
  ***REMOVED***
    self.emit('error', new Error(message***REMOVED******REMOVED***
    return // This error was fatal
***REMOVED***

  self._redirectsFollowed = self._redirectsFollowed || 0
  self.maxRedirects = (self.maxRedirects !== undefined***REMOVED*** ? self.maxRedirects : 10
  self.followRedirect = (self.followRedirect !== undefined***REMOVED*** ? self.followRedirect : true
  self.followAllRedirects = (self.followAllRedirects !== undefined***REMOVED*** ? self.followAllRedirects : false
  if (self.followRedirect || self.followAllRedirects***REMOVED***
    self.redirects = self.redirects || []

  self.headers = self.headers ? copy(self.headers***REMOVED*** : {}

  self.setHost = false
  if (!self.hasHeader('host'***REMOVED******REMOVED*** {
    self.setHeader('host', self.uri.hostname***REMOVED***
    if (self.uri.port***REMOVED*** {
      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:'***REMOVED*** &&
           !(self.uri.port === 443 && self.uri.protocol === 'https:'***REMOVED*** ***REMOVED***
      self.setHeader('host', self.getHeader('host'***REMOVED*** + (':'+self.uri.port***REMOVED*** ***REMOVED***
  ***REMOVED***
    self.setHost = true
***REMOVED***

  self.jar(self._jar || options.jar***REMOVED***

  if (!self.uri.port***REMOVED*** {
    if (self.uri.protocol == 'http:'***REMOVED*** {self.uri.port = 80}
    else if (self.uri.protocol == 'https:'***REMOVED*** {self.uri.port = 443}
***REMOVED***

  if (self.proxy && !self.tunnel***REMOVED*** {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
***REMOVED*** else {
    self.port = self.uri.port
    self.host = self.uri.hostname
***REMOVED***

  self.clientErrorHandler = function (error***REMOVED*** {
    if (self._aborted***REMOVED*** return
    if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
        && self.agent.addRequestNoreuse***REMOVED*** {
      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent***REMOVED*** }
      self.start(***REMOVED***
      self.req.end(***REMOVED***
      return
  ***REMOVED***
    if (self.timeout && self.timeoutTimer***REMOVED*** {
      clearTimeout(self.timeoutTimer***REMOVED***
      self.timeoutTimer = null
  ***REMOVED***
    self.emit('error', error***REMOVED***
***REMOVED***

  self._parserErrorHandler = function (error***REMOVED*** {
    if (this.res***REMOVED*** {
      if (this.res.request***REMOVED*** {
        this.res.request.emit('error', error***REMOVED***
    ***REMOVED*** else {
        this.res.emit('error', error***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
      this._httpMessage.emit('error', error***REMOVED***
  ***REMOVED***
***REMOVED***

  self._buildRequest = function(***REMOVED***{
    var self = this;
    
    if (options.form***REMOVED*** {
      self.form(options.form***REMOVED***
  ***REMOVED***
    
    if (options.qs***REMOVED*** self.qs(options.qs***REMOVED***
    
    if (self.uri.path***REMOVED*** {
      self.path = self.uri.path
  ***REMOVED*** else {
      self.path = self.uri.pathname + (self.uri.search || ""***REMOVED***
  ***REMOVED***
    
    if (self.path.length === 0***REMOVED*** self.path = '/'
    
    
    // Auth must happen last in case signing is dependent on other headers
    if (options.oauth***REMOVED*** {
      self.oauth(options.oauth***REMOVED***
  ***REMOVED***
    
    if (options.aws***REMOVED*** {
      self.aws(options.aws***REMOVED***
  ***REMOVED***
    
    if (options.hawk***REMOVED*** {
      self.hawk(options.hawk***REMOVED***
  ***REMOVED***
    
    if (options.httpSignature***REMOVED*** {
      self.httpSignature(options.httpSignature***REMOVED***
  ***REMOVED***
    
    if (options.auth***REMOVED*** {
      if (Object.prototype.hasOwnProperty.call(options.auth, 'username'***REMOVED******REMOVED*** options.auth.user = options.auth.username
      if (Object.prototype.hasOwnProperty.call(options.auth, 'password'***REMOVED******REMOVED*** options.auth.pass = options.auth.password
    
      self.auth(
        options.auth.user,
        options.auth.pass,
        options.auth.sendImmediately
      ***REMOVED***
  ***REMOVED***
    
    if (self.uri.auth && !self.hasHeader('authorization'***REMOVED******REMOVED*** {
      var authPieces = self.uri.auth.split(':'***REMOVED***.map(function(item***REMOVED***{ return querystring.unescape(item***REMOVED*** }***REMOVED***
      self.auth(authPieces[0], authPieces.slice(1***REMOVED***.join(':'***REMOVED***, true***REMOVED***
  ***REMOVED***
    if (self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization'***REMOVED*** && !self.tunnel***REMOVED*** {
      self.setHeader('proxy-authorization', "Basic " + toBase64(self.proxy.auth.split(':'***REMOVED***.map(function(item***REMOVED***{ return querystring.unescape(item***REMOVED***}***REMOVED***.join(':'***REMOVED******REMOVED******REMOVED***
  ***REMOVED***
    
    
    if (self.proxy && !self.tunnel***REMOVED*** self.path = (self.uri.protocol + '//' + self.uri.host + self.path***REMOVED***
    
    if (options.json***REMOVED*** {
      self.json(options.json***REMOVED***
  ***REMOVED*** else if (options.multipart***REMOVED*** {
      self.boundary = uuid(***REMOVED***
      self.multipart(options.multipart***REMOVED***
  ***REMOVED***
    
    if (self.body***REMOVED*** {
      var length = 0
      if (!Buffer.isBuffer(self.body***REMOVED******REMOVED*** {
        if (Array.isArray(self.body***REMOVED******REMOVED*** {
          for (var i = 0; i < self.body.length; i++***REMOVED*** {
            length += self.body[i].length
        ***REMOVED***
      ***REMOVED*** else {
          self.body = new Buffer(self.body***REMOVED***
          length = self.body.length
      ***REMOVED***
    ***REMOVED*** else {
        length = self.body.length
    ***REMOVED***
      if (length***REMOVED*** {
        if (!self.hasHeader('content-length'***REMOVED******REMOVED*** self.setHeader('content-length', length***REMOVED***
    ***REMOVED*** else {
        throw new Error('Argument error, options.body.'***REMOVED***
    ***REMOVED***
  ***REMOVED***
    
    var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
      , defaultModules = {'http:':http, 'https:':https, 'unix:':http}
      , httpModules = self.httpModules || {}
      ;
    self.httpModule = httpModules[protocol] || defaultModules[protocol]
    
    if (!self.httpModule***REMOVED*** return this.emit('error', new Error("Invalid protocol"***REMOVED******REMOVED***
    
    if (options.ca***REMOVED*** self.ca = options.ca
    
    if (!self.agent***REMOVED*** {
      if (options.agentOptions***REMOVED*** self.agentOptions = options.agentOptions
    
      if (options.agentClass***REMOVED*** {
        self.agentClass = options.agentClass
    ***REMOVED*** else if (options.forever***REMOVED*** {
        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
    ***REMOVED*** else {
        self.agentClass = self.httpModule.Agent
    ***REMOVED***
  ***REMOVED***
    
    if (self.pool === false***REMOVED*** {
      self.agent = false
  ***REMOVED*** else {
      self.agent = self.agent || self.getAgent(***REMOVED***
      if (self.maxSockets***REMOVED*** {
        // Don't use our pooling if node has the refactored client
        self.agent.maxSockets = self.maxSockets
    ***REMOVED***
      if (self.pool.maxSockets***REMOVED*** {
        // Don't use our pooling if node has the refactored client
        self.agent.maxSockets = self.pool.maxSockets
    ***REMOVED***
  ***REMOVED***
    
    self.on('pipe', function (src***REMOVED*** {
      if (self.ntick && self._started***REMOVED*** throw new Error("You cannot pipe to this stream after the outbound request has started."***REMOVED***
      self.src = src
      if (isReadStream(src***REMOVED******REMOVED*** {
        if (!self.hasHeader('content-type'***REMOVED******REMOVED*** self.setHeader('content-type', mime.lookup(src.path***REMOVED******REMOVED***
    ***REMOVED*** else {
        if (src.headers***REMOVED*** {
          for (var i in src.headers***REMOVED*** {
            if (!self.hasHeader(i***REMOVED******REMOVED*** {
              self.setHeader(i, src.headers[i]***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
        if (self._json && !self.hasHeader('content-type'***REMOVED******REMOVED***
          self.setHeader('content-type', 'application/json'***REMOVED***
        if (src.method && !self.explicitMethod***REMOVED*** {
          self.method = src.method
      ***REMOVED***
    ***REMOVED***
    
      // self.on('pipe', function (***REMOVED*** {
      //   console.error("You have already piped to this stream. Pipeing twice is likely to break the request."***REMOVED***
      // }***REMOVED***
  ***REMOVED******REMOVED***
    
    process.nextTick(function (***REMOVED*** {
      if (self._aborted***REMOVED*** return
    
      if (self._form***REMOVED*** {
        self.setHeaders(self._form.getHeaders(***REMOVED******REMOVED***
        try {
          var length = self._form.getLengthSync(***REMOVED***
          self.setHeader('content-length', length***REMOVED***
      ***REMOVED*** catch(e***REMOVED***{}
        self._form.pipe(self***REMOVED***
    ***REMOVED***
      if (self.body***REMOVED*** {
        if (Array.isArray(self.body***REMOVED******REMOVED*** {
          self.body.forEach(function (part***REMOVED*** {
            self.write(part***REMOVED***
        ***REMOVED******REMOVED***
      ***REMOVED*** else {
          self.write(self.body***REMOVED***
      ***REMOVED***
        self.end(***REMOVED***
    ***REMOVED*** else if (self.requestBodyStream***REMOVED*** {
        console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe."***REMOVED***
        self.requestBodyStream.pipe(self***REMOVED***
    ***REMOVED*** else if (!self.src***REMOVED*** {
        if (self.method !== 'GET' && typeof self.method !== 'undefined'***REMOVED*** {
          self.setHeader('content-length', 0***REMOVED***
      ***REMOVED***
        self.end(***REMOVED***
    ***REMOVED***
      self.ntick = true
  ***REMOVED******REMOVED***
    
***REMOVED*** // End _buildRequest
  
  self._handleUnixSocketURI = function(self***REMOVED***{
    // Parse URI and extract a socket path (tested as a valid socket using net.connect***REMOVED***, and a http style path suffix
    // Thus http requests can be made to a socket using the uri unix://tmp/my.socket/urlpath
    // and a request for '/urlpath' will be sent to the unix socket at /tmp/my.socket
    
    self.unixsocket = true;
    
    var full_path = self.uri.href.replace(self.uri.protocol+'/', ''***REMOVED***;
    
    var lookup = full_path.split('/'***REMOVED***;
    var error_connecting = true;
    
    var lookup_table = {}; 
    do { lookup_table[lookup.join('/'***REMOVED***]={} } while(lookup.pop(***REMOVED******REMOVED***
    for (r in lookup_table***REMOVED***{
      try_next(r***REMOVED***;
  ***REMOVED***
    
    function try_next(table_row***REMOVED***{
      var client = net.connect( table_row ***REMOVED***;
      client.path = table_row
      client.on('error', function(***REMOVED***{ lookup_table[this.path].error_connecting=true; this.end(***REMOVED***; }***REMOVED***;
      client.on('connect', function(***REMOVED***{ lookup_table[this.path].error_connecting=false; this.end(***REMOVED***; }***REMOVED***;
      table_row.client = client;
  ***REMOVED***
    
    wait_for_socket_response(***REMOVED***;
    
    response_counter = 0;

    function wait_for_socket_response(***REMOVED***{
      var detach;
      if('undefined' == typeof setImmediate ***REMOVED*** detach = process.nextTick
      else detach = setImmediate;
      detach(function(***REMOVED***{
        // counter to prevent infinite blocking waiting for an open socket to be found.
        response_counter++;
        var trying = false;
        for (r in lookup_table***REMOVED***{
          //console.log(r, lookup_table[r], lookup_table[r].error_connecting***REMOVED***
          if('undefined' == typeof lookup_table[r].error_connecting***REMOVED***
            trying = true;
      ***REMOVED***
        if(trying && response_counter<1000***REMOVED***
          wait_for_socket_response(***REMOVED***
        else 
          set_socket_properties(***REMOVED***;
    ***REMOVED******REMOVED***
  ***REMOVED***
    
    function set_socket_properties(***REMOVED***{
      var host;
      for (r in lookup_table***REMOVED***{
        if(lookup_table[r].error_connecting === false***REMOVED***{
          host = r
      ***REMOVED***
    ***REMOVED***
      if(!host***REMOVED***{
        self.emit('error', new Error("Failed to connect to any socket in "+full_path***REMOVED******REMOVED***
    ***REMOVED***
      var path = full_path.replace(host, ''***REMOVED***
      
      self.socketPath = host
      self.uri.pathname = path
      self.uri.href = path
      self.uri.path = path
      self.host = ''
      self.hostname = ''
      delete self.host
      delete self.hostname
      self._buildRequest(***REMOVED***;
  ***REMOVED***
***REMOVED***
  
  // Intercept UNIX protocol requests to change properties to match socket
  if(/^unix:/.test(self.uri.protocol***REMOVED******REMOVED***{
    self._handleUnixSocketURI(self***REMOVED***;
***REMOVED*** else {
    self._buildRequest(***REMOVED***;
***REMOVED***
  
}

// Must call this when following a redirect from https to http or vice versa
// Attempts to keep everything as identical as possible, but update the
// httpModule, Tunneling agent, and/or Forever Agent in use.
Request.prototype._updateProtocol = function (***REMOVED*** {
  var self = this
  var protocol = self.uri.protocol

  if (protocol === 'https:'***REMOVED*** {
    // previously was doing http, now doing https
    // if it's https, then we might need to tunnel now.
    if (self.proxy && self.canTunnel***REMOVED*** {
      self.tunnel = true
      var tunnelFn = self.proxy.protocol === 'http:'
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps
      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: self.ca }
      self.agent = tunnelFn(tunnelOptions***REMOVED***
      return
  ***REMOVED***

    self.httpModule = https
    switch (self.agentClass***REMOVED*** {
      case ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        break
      case http.Agent:
        self.agentClass = https.Agent
        break
      default:
        // nothing we can do.  Just hope for the best.
        return
  ***REMOVED***

    // if there's an agent, we need to get a new one.
    if (self.agent***REMOVED*** self.agent = self.getAgent(***REMOVED***

***REMOVED*** else {
    // previously was doing https, now doing http
    // stop any tunneling.
    if (self.tunnel***REMOVED*** self.tunnel = false
    self.httpModule = http
    switch (self.agentClass***REMOVED*** {
      case ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        break
      case https.Agent:
        self.agentClass = http.Agent
        break
      default:
        // nothing we can do.  just hope for the best
        return
  ***REMOVED***

    // if there's an agent, then get a new one.
    if (self.agent***REMOVED*** {
      self.agent = null
      self.agent = self.getAgent(***REMOVED***
  ***REMOVED***
***REMOVED***
}

Request.prototype.getAgent = function (***REMOVED*** {
  var Agent = this.agentClass
  var options = {}
  if (this.agentOptions***REMOVED*** {
    for (var i in this.agentOptions***REMOVED*** {
      options[i] = this.agentOptions[i]
  ***REMOVED***
***REMOVED***
  if (this.ca***REMOVED*** options.ca = this.ca
  if (this.ciphers***REMOVED*** options.ciphers = this.ciphers
  if (this.secureProtocol***REMOVED*** options.secureProtocol = this.secureProtocol
  if (typeof this.rejectUnauthorized !== 'undefined'***REMOVED*** options.rejectUnauthorized = this.rejectUnauthorized

  if (this.cert && this.key***REMOVED*** {
    options.key = this.key
    options.cert = this.cert
***REMOVED***

  var poolKey = ''

  // different types of agents are in different pools
  if (Agent !== this.httpModule.Agent***REMOVED*** {
    poolKey += Agent.name
***REMOVED***

  if (!this.httpModule.globalAgent***REMOVED*** {
    // node 0.4.x
    options.host = this.host
    options.port = this.port
    if (poolKey***REMOVED*** poolKey += ':'
    poolKey += this.host + ':' + this.port
***REMOVED***

  // ca option is only relevant if proxy or destination are https
  var proxy = this.proxy
  if (typeof proxy === 'string'***REMOVED*** proxy = url.parse(proxy***REMOVED***
  var isHttps = (proxy && proxy.protocol === 'https:'***REMOVED*** || this.uri.protocol === 'https:'
  if (isHttps***REMOVED*** {
    if (options.ca***REMOVED*** {
      if (poolKey***REMOVED*** poolKey += ':'
      poolKey += options.ca
  ***REMOVED***

    if (typeof options.rejectUnauthorized !== 'undefined'***REMOVED*** {
      if (poolKey***REMOVED*** poolKey += ':'
      poolKey += options.rejectUnauthorized
  ***REMOVED***

    if (options.cert***REMOVED***
      poolKey += options.cert.toString('ascii'***REMOVED*** + options.key.toString('ascii'***REMOVED***

    if (options.ciphers***REMOVED*** {
      if (poolKey***REMOVED*** poolKey += ':'
      poolKey += options.ciphers
  ***REMOVED***

    if (options.secureProtocol***REMOVED*** {
      if (poolKey***REMOVED*** poolKey += ':'
      poolKey += options.secureProtocol
  ***REMOVED***
***REMOVED***

  if (this.pool === globalPool && !poolKey && Object.keys(options***REMOVED***.length === 0 && this.httpModule.globalAgent***REMOVED*** {
    // not doing anything special.  Use the globalAgent
    return this.httpModule.globalAgent
***REMOVED***

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = this.uri.protocol + poolKey

  // already generated an agent for this setting
  if (this.pool[poolKey]***REMOVED*** return this.pool[poolKey]

  return this.pool[poolKey] = new Agent(options***REMOVED***
}

Request.prototype.start = function (***REMOVED*** {
  // start(***REMOVED*** is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(***REMOVED***, end(***REMOVED*** or on nextTick(***REMOVED***
  var self = this

  if (self._aborted***REMOVED*** return

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length'***REMOVED******REMOVED*** {
    self.setHeader('content-length', self.src.stat.size***REMOVED***
***REMOVED***
  if (self._aws***REMOVED*** {
    self.aws(self._aws, true***REMOVED***
***REMOVED***

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self***REMOVED***
  delete reqOptions.auth

  debug('make request', self.uri.href***REMOVED***
  self.req = self.httpModule.request(reqOptions, self.onResponse.bind(self***REMOVED******REMOVED***

  if (self.timeout && !self.timeoutTimer***REMOVED*** {
    self.timeoutTimer = setTimeout(function (***REMOVED*** {
      self.req.abort(***REMOVED***
      var e = new Error("ETIMEDOUT"***REMOVED***
      e.code = "ETIMEDOUT"
      self.emit("error", e***REMOVED***
  ***REMOVED***, self.timeout***REMOVED***

    // Set additional timeout on socket - in case if remote
    // server freeze after sending headers
    if (self.req.setTimeout***REMOVED*** { // only works on node 0.6+
      self.req.setTimeout(self.timeout, function (***REMOVED*** {
        if (self.req***REMOVED*** {
          self.req.abort(***REMOVED***
          var e = new Error("ESOCKETTIMEDOUT"***REMOVED***
          e.code = "ESOCKETTIMEDOUT"
          self.emit("error", e***REMOVED***
      ***REMOVED***
    ***REMOVED******REMOVED***
  ***REMOVED***
***REMOVED***

  self.req.on('error', self.clientErrorHandler***REMOVED***
  self.req.on('drain', function(***REMOVED*** {
    self.emit('drain'***REMOVED***
***REMOVED******REMOVED***
  self.on('end', function(***REMOVED*** {
    if ( self.req.connection ***REMOVED*** self.req.connection.removeListener('error', self._parserErrorHandler***REMOVED***
***REMOVED******REMOVED***
  self.emit('request', self.req***REMOVED***
}
Request.prototype.onResponse = function (response***REMOVED*** {
  var self = this
  debug('onResponse', self.uri.href, response.statusCode, response.headers***REMOVED***
  response.on('end', function(***REMOVED*** {
    debug('response end', self.uri.href, response.statusCode, response.headers***REMOVED***
***REMOVED******REMOVED***;

  if (response.connection.listeners('error'***REMOVED***.indexOf(self._parserErrorHandler***REMOVED*** === -1***REMOVED*** {
    response.connection.once('error', self._parserErrorHandler***REMOVED***
***REMOVED***
  if (self._aborted***REMOVED*** {
    debug('aborted', self.uri.href***REMOVED***
    response.resume(***REMOVED***
    return
***REMOVED***
  if (self._paused***REMOVED*** response.pause(***REMOVED***
  else response.resume(***REMOVED***

  self.response = response
  response.request = self
  response.toJSON = toJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
      self.strictSSL &&
      !response.client.authorized***REMOVED*** {
    debug('strict ssl error', self.uri.href***REMOVED***
    var sslErr = response.client.authorizationError
    self.emit('error', new Error('SSL Error: '+ sslErr***REMOVED******REMOVED***
    return
***REMOVED***

  if (self.setHost && self.hasHeader('host'***REMOVED******REMOVED*** delete self.headers[self.hasHeader('host'***REMOVED***]
  if (self.timeout && self.timeoutTimer***REMOVED*** {
    clearTimeout(self.timeoutTimer***REMOVED***
    self.timeoutTimer = null
***REMOVED***

  var targetCookieJar = (self._jar && self._jar.setCookie***REMOVED***?self._jar:globalCookieJar;
  var addCookie = function (cookie***REMOVED*** {
    //set the cookie if it's domain in the href's domain.
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true}***REMOVED***;
  ***REMOVED*** catch (e***REMOVED*** {
      self.emit('error', e***REMOVED***;
  ***REMOVED***
***REMOVED***

  if (hasHeader('set-cookie', response.headers***REMOVED*** && (!self._disableCookies***REMOVED******REMOVED*** {
    var headerName = hasHeader('set-cookie', response.headers***REMOVED***
    if (Array.isArray(response.headers[headerName]***REMOVED******REMOVED*** response.headers[headerName].forEach(addCookie***REMOVED***
    else addCookie(response.headers[headerName]***REMOVED***
***REMOVED***

  var redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && hasHeader('location', response.headers***REMOVED******REMOVED*** {
    var location = response.headers[hasHeader('location', response.headers***REMOVED***]
    debug('redirect', location***REMOVED***

    if (self.followAllRedirects***REMOVED*** {
      redirectTo = location
  ***REMOVED*** else if (self.followRedirect***REMOVED*** {
      switch (self.method***REMOVED*** {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = location
          break
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if (response.statusCode == 401 && self._hasAuth && !self._sentAuth***REMOVED*** {
    var authHeader = response.headers[hasHeader('www-authenticate', response.headers***REMOVED***]
    var authVerb = authHeader && authHeader.split(' '***REMOVED***[0].toLowerCase(***REMOVED***
    debug('reauth', authVerb***REMOVED***

    switch (authVerb***REMOVED*** {
      case 'basic':
        self.auth(self._user, self._pass, true***REMOVED***
        redirectTo = self.uri
        break

      case 'digest':
        // TODO: More complete implementation of RFC 2617.
        //   - check challenge.algorithm
        //   - support algorithm="MD5-sess"
        //   - handle challenge.domain
        //   - support qop="auth-int" only
        //   - handle Authentication-Info (not necessarily?***REMOVED***
        //   - check challenge.stale (not necessarily?***REMOVED***
        //   - increase nc (not necessarily?***REMOVED***
        // For reference:
        // http://tools.ietf.org/html/rfc2617#section-3
        // https://github.com/bagder/curl/blob/master/lib/http_digest.c

        var challenge = {}
        var re = /([a-z0-9_-]+***REMOVED***=(?:"([^"]+***REMOVED***"|([a-z0-9_-]+***REMOVED******REMOVED***/gi
        for (;;***REMOVED*** {
          var match = re.exec(authHeader***REMOVED***
          if (!match***REMOVED*** break
          challenge[match[1]] = match[2] || match[3];
      ***REMOVED***

        var ha1 = md5(self._user + ':' + challenge.realm + ':' + self._pass***REMOVED***
        var ha2 = md5(self.method + ':' + self.uri.path***REMOVED***
        var qop = /(^|,***REMOVED***\s*auth\s*($|,***REMOVED***/.test(challenge.qop***REMOVED*** && 'auth'
        var nc = qop && '00000001'
        var cnonce = qop && uuid(***REMOVED***.replace(/-/g, ''***REMOVED***
        var digestResponse = qop ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2***REMOVED*** : md5(ha1 + ':' + challenge.nonce + ':' + ha2***REMOVED***
        var authValues = {
          username: self._user,
          realm: challenge.realm,
          nonce: challenge.nonce,
          uri: self.uri.path,
          qop: qop,
          response: digestResponse,
          nc: nc,
          cnonce: cnonce,
          algorithm: challenge.algorithm,
          opaque: challenge.opaque
      ***REMOVED***

        authHeader = []
        for (var k in authValues***REMOVED*** {
          if (!authValues[k]***REMOVED*** {
            //ignore
        ***REMOVED*** else if (k === 'qop' || k === 'nc' || k === 'algorithm'***REMOVED*** {
            authHeader.push(k + '=' + authValues[k]***REMOVED***
        ***REMOVED*** else {
            authHeader.push(k + '="' + authValues[k] + '"'***REMOVED***
        ***REMOVED***
      ***REMOVED***
        authHeader = 'Digest ' + authHeader.join(', '***REMOVED***
        self.setHeader('authorization', authHeader***REMOVED***
        self._sentAuth = true

        redirectTo = self.uri
        break
  ***REMOVED***
***REMOVED***

  if (redirectTo***REMOVED*** {
    debug('redirect to', redirectTo***REMOVED***

    // ignore any potential response body.  it cannot possibly be useful
    // to us at this point.
    if (self._paused***REMOVED*** response.resume(***REMOVED***

    if (self._redirectsFollowed >= self.maxRedirects***REMOVED*** {
      self.emit('error', new Error("Exceeded maxRedirects. Probably stuck in a redirect loop "+self.uri.href***REMOVED******REMOVED***
      return
  ***REMOVED***
    self._redirectsFollowed += 1

    if (!isUrl.test(redirectTo***REMOVED******REMOVED*** {
      redirectTo = url.resolve(self.uri.href, redirectTo***REMOVED***
  ***REMOVED***

    var uriPrev = self.uri
    self.uri = url.parse(redirectTo***REMOVED***

    // handle the case where we change protocol from https to http or vice versa
    if (self.uri.protocol !== uriPrev.protocol***REMOVED*** {
      self._updateProtocol(***REMOVED***
  ***REMOVED***

    self.redirects.push(
      { statusCode : response.statusCode
      , redirectUri: redirectTo
    ***REMOVED***
    ***REMOVED***
    if (self.followAllRedirects && response.statusCode != 401***REMOVED*** self.method = 'GET'
    // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215
    delete self.src
    delete self.req
    delete self.agent
    delete self._started
    if (response.statusCode != 401***REMOVED*** {
      // Remove parameters from the previous response, unless this is the second request
      // for a server that requires digest authentication.
      delete self.body
      delete self._form
      if (self.headers***REMOVED*** {
        if (self.hasHeader('host'***REMOVED******REMOVED*** delete self.headers[self.hasHeader('host'***REMOVED***]
        if (self.hasHeader('content-type'***REMOVED******REMOVED*** delete self.headers[self.hasHeader('content-type'***REMOVED***]
        if (self.hasHeader('content-length'***REMOVED******REMOVED*** delete self.headers[self.hasHeader('content-length'***REMOVED***]
    ***REMOVED***
  ***REMOVED***

    self.emit('redirect'***REMOVED***;

    self.init(***REMOVED***
    return // Ignore the rest of the response
***REMOVED*** else {
    self._redirectsFollowed = self._redirectsFollowed || 0
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function (***REMOVED*** {
      if (!self._ended***REMOVED*** self.response.emit('end'***REMOVED***
  ***REMOVED******REMOVED***

    if (self.encoding***REMOVED*** {
      if (self.dests.length !== 0***REMOVED*** {
        console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid."***REMOVED***
    ***REMOVED*** else {
        response.setEncoding(self.encoding***REMOVED***
    ***REMOVED***
  ***REMOVED***

    self.emit('response', response***REMOVED***

    self.dests.forEach(function (dest***REMOVED*** {
      self.pipeDest(dest***REMOVED***
  ***REMOVED******REMOVED***

    response.on("data", function (chunk***REMOVED*** {
      self._destdata = true
      self.emit("data", chunk***REMOVED***
  ***REMOVED******REMOVED***
    response.on("end", function (chunk***REMOVED*** {
      self._ended = true
      self.emit("end", chunk***REMOVED***
  ***REMOVED******REMOVED***
    response.on("close", function (***REMOVED*** {self.emit("close"***REMOVED***}***REMOVED***

    if (self.callback***REMOVED*** {
      var buffer = []
      var bodyLen = 0
      self.on("data", function (chunk***REMOVED*** {
        buffer.push(chunk***REMOVED***
        bodyLen += chunk.length
    ***REMOVED******REMOVED***
      self.on("end", function (***REMOVED*** {
        debug('end event', self.uri.href***REMOVED***
        if (self._aborted***REMOVED*** {
          debug('aborted', self.uri.href***REMOVED***
          return
      ***REMOVED***

        if (buffer.length && Buffer.isBuffer(buffer[0]***REMOVED******REMOVED*** {
          debug('has body', self.uri.href, bodyLen***REMOVED***
          var body = new Buffer(bodyLen***REMOVED***
          var i = 0
          buffer.forEach(function (chunk***REMOVED*** {
            chunk.copy(body, i, 0, chunk.length***REMOVED***
            i += chunk.length
        ***REMOVED******REMOVED***
          if (self.encoding === null***REMOVED*** {
            response.body = body
        ***REMOVED*** else {
            response.body = body.toString(self.encoding***REMOVED***
        ***REMOVED***
      ***REMOVED*** else if (buffer.length***REMOVED*** {
          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse(***REMOVED***.
          if (self.encoding === 'utf8' && buffer[0].length > 0 && buffer[0][0] === "\uFEFF"***REMOVED*** {
            buffer[0] = buffer[0].substring(1***REMOVED***
        ***REMOVED***
          response.body = buffer.join(''***REMOVED***
      ***REMOVED***

        if (self._json***REMOVED*** {
          try {
            response.body = JSON.parse(response.body***REMOVED***
        ***REMOVED*** catch (e***REMOVED*** {}
      ***REMOVED***
        debug('emitting complete', self.uri.href***REMOVED***
        if(response.body == undefined && !self._json***REMOVED*** {
          response.body = "";
      ***REMOVED***
        self.emit('complete', response, response.body***REMOVED***
    ***REMOVED******REMOVED***
  ***REMOVED***
    //if no callback
    else{
      self.on("end", function (***REMOVED*** {
        if (self._aborted***REMOVED*** {
          debug('aborted', self.uri.href***REMOVED***
          return
      ***REMOVED***
        self.emit('complete', response***REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***
  debug('finish init function', self.uri.href***REMOVED***
}

Request.prototype.abort = function (***REMOVED*** {
  this._aborted = true

  if (this.req***REMOVED*** {
    this.req.abort(***REMOVED***
***REMOVED***
  else if (this.response***REMOVED*** {
    this.response.abort(***REMOVED***
***REMOVED***

  this.emit("abort"***REMOVED***
}

Request.prototype.pipeDest = function (dest***REMOVED*** {
  var response = this.response
  // Called after the response is received
  if (dest.headers && !dest.headersSent***REMOVED*** {
    if (hasHeader('content-type', response.headers***REMOVED******REMOVED*** {
      var ctname = hasHeader('content-type', response.headers***REMOVED***
      if (dest.setHeader***REMOVED*** dest.setHeader(ctname, response.headers[ctname]***REMOVED***
      else dest.headers[ctname] = response.headers[ctname]
  ***REMOVED***

    if (hasHeader('content-length', response.headers***REMOVED******REMOVED*** {
      var clname = hasHeader('content-length', response.headers***REMOVED***
      if (dest.setHeader***REMOVED*** dest.setHeader(clname, response.headers[clname]***REMOVED***
      else dest.headers[clname] = response.headers[clname]
  ***REMOVED***
***REMOVED***
  if (dest.setHeader && !dest.headersSent***REMOVED*** {
    for (var i in response.headers***REMOVED*** {
      dest.setHeader(i, response.headers[i]***REMOVED***
  ***REMOVED***
    dest.statusCode = response.statusCode
***REMOVED***
  if (this.pipefilter***REMOVED*** this.pipefilter(response, dest***REMOVED***
}

// Composable API
Request.prototype.setHeader = function (name, value, clobber***REMOVED*** {
  if (clobber === undefined***REMOVED*** clobber = true
  if (clobber || !this.hasHeader(name***REMOVED******REMOVED*** this.headers[name] = value
  else this.headers[this.hasHeader(name***REMOVED***] += ',' + value
  return this
}
Request.prototype.setHeaders = function (headers***REMOVED*** {
  for (var i in headers***REMOVED*** {this.setHeader(i, headers[i]***REMOVED***}
  return this
}
Request.prototype.hasHeader = function (header, headers***REMOVED*** {
  var headers = Object.keys(headers || this.headers***REMOVED***
    , lheaders = headers.map(function (h***REMOVED*** {return h.toLowerCase(***REMOVED***}***REMOVED***
    ;
  header = header.toLowerCase(***REMOVED***
  for (var i=0;i<lheaders.length;i++***REMOVED*** {
    if (lheaders[i] === header***REMOVED*** return headers[i]
***REMOVED***
  return false
}

var hasHeader = Request.prototype.hasHeader

Request.prototype.qs = function (q, clobber***REMOVED*** {
  var base
  if (!clobber && this.uri.query***REMOVED*** base = qs.parse(this.uri.query***REMOVED***
  else base = {}

  for (var i in q***REMOVED*** {
    base[i] = q[i]
***REMOVED***

  if (qs.stringify(base***REMOVED*** === ''***REMOVED***{
    return this
***REMOVED***

  this.uri = url.parse(this.uri.href.split('?'***REMOVED***[0] + '?' + qs.stringify(base***REMOVED******REMOVED***
  this.url = this.uri
  this.path = this.uri.path

  return this
}
Request.prototype.form = function (form***REMOVED*** {
  if (form***REMOVED*** {
    this.setHeader('content-type', 'application/x-www-form-urlencoded; charset=utf-8'***REMOVED***
    this.body = qs.stringify(form***REMOVED***.toString('utf8'***REMOVED***
    return this
***REMOVED***
  // create form-data object
  this._form = new FormData(***REMOVED***
  return this._form
}
Request.prototype.multipart = function (multipart***REMOVED*** {
  var self = this
  self.body = []

  if (!self.hasHeader('content-type'***REMOVED******REMOVED*** {
    self.setHeader('content-type', 'multipart/related; boundary=' + self.boundary***REMOVED***
***REMOVED*** else {
    var headerName = self.hasHeader('content-type'***REMOVED***;
    self.setHeader(headerName, self.headers[headerName].split(';'***REMOVED***[0] + '; boundary=' + self.boundary***REMOVED***
***REMOVED***

  if (!multipart.forEach***REMOVED*** throw new Error('Argument error, options.multipart.'***REMOVED***

  if (self.preambleCRLF***REMOVED*** {
    self.body.push(new Buffer('\r\n'***REMOVED******REMOVED***
***REMOVED***

  multipart.forEach(function (part***REMOVED*** {
    var body = part.body
    if(body == null***REMOVED*** throw Error('Body attribute missing in multipart.'***REMOVED***
    delete part.body
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part***REMOVED***.forEach(function (key***REMOVED*** {
      preamble += key + ': ' + part[key] + '\r\n'
  ***REMOVED******REMOVED***
    preamble += '\r\n'
    self.body.push(new Buffer(preamble***REMOVED******REMOVED***
    self.body.push(new Buffer(body***REMOVED******REMOVED***
    self.body.push(new Buffer('\r\n'***REMOVED******REMOVED***
***REMOVED******REMOVED***
  self.body.push(new Buffer('--' + self.boundary + '--'***REMOVED******REMOVED***
  return self
}
Request.prototype.json = function (val***REMOVED*** {
  var self = this

  if (!self.hasHeader('accept'***REMOVED******REMOVED*** self.setHeader('accept', 'application/json'***REMOVED***

  this._json = true
  if (typeof val === 'boolean'***REMOVED*** {
    if (typeof this.body === 'object'***REMOVED*** {
      this.body = safeStringify(this.body***REMOVED***
      if (!self.hasHeader('content-type'***REMOVED******REMOVED***
        self.setHeader('content-type', 'application/json'***REMOVED***
  ***REMOVED***
***REMOVED*** else {
    this.body = safeStringify(val***REMOVED***
    if (!self.hasHeader('content-type'***REMOVED******REMOVED***
      self.setHeader('content-type', 'application/json'***REMOVED***
***REMOVED***

  return this
}
Request.prototype.getHeader = function (name, headers***REMOVED*** {
  var result, re, match
  if (!headers***REMOVED*** headers = this.headers
  Object.keys(headers***REMOVED***.forEach(function (key***REMOVED*** {
    re = new RegExp(name, 'i'***REMOVED***
    match = key.match(re***REMOVED***
    if (match***REMOVED*** result = headers[key]
***REMOVED******REMOVED***
  return result
}
var getHeader = Request.prototype.getHeader

Request.prototype.auth = function (user, pass, sendImmediately***REMOVED*** {
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string'***REMOVED******REMOVED*** {
    throw new Error('auth(***REMOVED*** received invalid user or password'***REMOVED***
***REMOVED***
  this._user = user
  this._pass = pass
  this._hasAuth = true
  var header = typeof pass !== 'undefined' ? user + ':' + pass : user
  if (sendImmediately || typeof sendImmediately == 'undefined'***REMOVED*** {
    this.setHeader('authorization', 'Basic ' + toBase64(header***REMOVED******REMOVED***
    this._sentAuth = true
***REMOVED***
  return this
}
Request.prototype.aws = function (opts, now***REMOVED*** {
  if (!now***REMOVED*** {
    this._aws = opts
    return this
***REMOVED***
  var date = new Date(***REMOVED***
  this.setHeader('date', date.toUTCString(***REMOVED******REMOVED***
  var auth =
    { key: opts.key
    , secret: opts.secret
    , verb: this.method.toUpperCase(***REMOVED***
    , date: date
    , contentType: this.getHeader('content-type'***REMOVED*** || ''
    , md5: this.getHeader('content-md5'***REMOVED*** || ''
    , amazonHeaders: aws.canonicalizeHeaders(this.headers***REMOVED***
  ***REMOVED***
  if (opts.bucket && this.path***REMOVED*** {
    auth.resource = '/' + opts.bucket + this.path
***REMOVED*** else if (opts.bucket && !this.path***REMOVED*** {
    auth.resource = '/' + opts.bucket
***REMOVED*** else if (!opts.bucket && this.path***REMOVED*** {
    auth.resource = this.path
***REMOVED*** else if (!opts.bucket && !this.path***REMOVED*** {
    auth.resource = '/'
***REMOVED***
  auth.resource = aws.canonicalizeResource(auth.resource***REMOVED***
  this.setHeader('authorization', aws.authorization(auth***REMOVED******REMOVED***

  return this
}
Request.prototype.httpSignature = function (opts***REMOVED*** {
  var req = this
  httpSignature.signRequest({
    getHeader: function(header***REMOVED*** {
      return getHeader(header, req.headers***REMOVED***
  ***REMOVED***,
    setHeader: function(header, value***REMOVED*** {
      req.setHeader(header, value***REMOVED***
  ***REMOVED***,
    method: this.method,
    path: this.path
***REMOVED***, opts***REMOVED***
  debug('httpSignature authorization', this.getHeader('authorization'***REMOVED******REMOVED***

  return this
}

Request.prototype.hawk = function (opts***REMOVED*** {
  this.setHeader('Authorization', hawk.client.header(this.uri, this.method, opts***REMOVED***.field***REMOVED***
}

Request.prototype.oauth = function (_oauth***REMOVED*** {
  var form
  if (this.hasHeader('content-type'***REMOVED*** &&
      this.getHeader('content-type'***REMOVED***.slice(0, 'application/x-www-form-urlencoded'.length***REMOVED*** ===
        'application/x-www-form-urlencoded'
     ***REMOVED*** {
    form = qs.parse(this.body***REMOVED***
***REMOVED***
  if (this.uri.query***REMOVED*** {
    form = qs.parse(this.uri.query***REMOVED***
***REMOVED***
  if (!form***REMOVED*** form = {}
  var oa = {}
  for (var i in form***REMOVED*** oa[i] = form[i]
  for (var i in _oauth***REMOVED*** oa['oauth_'+i] = _oauth[i]
  if (!oa.oauth_version***REMOVED*** oa.oauth_version = '1.0'
  if (!oa.oauth_timestamp***REMOVED*** oa.oauth_timestamp = Math.floor( Date.now(***REMOVED*** / 1000 ***REMOVED***.toString(***REMOVED***
  if (!oa.oauth_nonce***REMOVED*** oa.oauth_nonce = uuid(***REMOVED***.replace(/-/g, ''***REMOVED***

  oa.oauth_signature_method = 'HMAC-SHA1'

  var consumer_secret = oa.oauth_consumer_secret
  delete oa.oauth_consumer_secret
  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret
  var timestamp = oa.oauth_timestamp

  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname
  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret***REMOVED***

  // oa.oauth_signature = signature
  for (var i in form***REMOVED*** {
    if ( i.slice(0, 'oauth_'***REMOVED*** in _oauth***REMOVED*** {
      // skip
  ***REMOVED*** else {
      delete oa['oauth_'+i]
      if (i !== 'x_auth_mode'***REMOVED*** delete oa[i]
  ***REMOVED***
***REMOVED***
  oa.oauth_timestamp = timestamp
  var authHeader = 'OAuth '+Object.keys(oa***REMOVED***.sort(***REMOVED***.map(function (i***REMOVED*** {return i+'="'+oauth.rfc3986(oa[i]***REMOVED***+'"'}***REMOVED***.join(','***REMOVED***
  authHeader += ',oauth_signature="' + oauth.rfc3986(signature***REMOVED*** + '"'
  this.setHeader('Authorization', authHeader***REMOVED***
  return this
}
Request.prototype.jar = function (jar***REMOVED*** {
  var cookies

  if (this._redirectsFollowed === 0***REMOVED*** {
    this.originalCookieHeader = this.getHeader('cookie'***REMOVED***
***REMOVED***

  if (!jar***REMOVED*** {
    // disable cookies
    cookies = false
    this._disableCookies = true
***REMOVED*** else {
    var targetCookieJar = (jar && jar.getCookieString***REMOVED***?jar:globalCookieJar;
    var urihref = this.uri.href
    //fetch cookie in the Specified host
    if (targetCookieJar***REMOVED*** {
      cookies = targetCookieJar.getCookieString(urihref***REMOVED***;
  ***REMOVED***
***REMOVED***

  //if need cookie and cookie is not empty
  if (cookies && cookies.length***REMOVED*** {
    if (this.originalCookieHeader***REMOVED*** {
      // Don't overwrite existing Cookie header
      this.setHeader('cookie', this.originalCookieHeader + '; ' + cookies***REMOVED***
  ***REMOVED*** else {
      this.setHeader('cookie', cookies***REMOVED***
  ***REMOVED***
***REMOVED***
  this._jar = jar
  return this
}


// Stream API
Request.prototype.pipe = function (dest, opts***REMOVED*** {
  if (this.response***REMOVED*** {
    if (this._destdata***REMOVED*** {
      throw new Error("You cannot pipe after data has been emitted from the response."***REMOVED***
  ***REMOVED*** else if (this._ended***REMOVED*** {
      throw new Error("You cannot pipe after the response has been ended."***REMOVED***
  ***REMOVED*** else {
      stream.Stream.prototype.pipe.call(this, dest, opts***REMOVED***
      this.pipeDest(dest***REMOVED***
      return dest
  ***REMOVED***
***REMOVED*** else {
    this.dests.push(dest***REMOVED***
    stream.Stream.prototype.pipe.call(this, dest, opts***REMOVED***
    return dest
***REMOVED***
}
Request.prototype.write = function (***REMOVED*** {
  if (!this._started***REMOVED*** this.start(***REMOVED***
  return this.req.write.apply(this.req, arguments***REMOVED***
}
Request.prototype.end = function (chunk***REMOVED*** {
  if (chunk***REMOVED*** this.write(chunk***REMOVED***
  if (!this._started***REMOVED*** this.start(***REMOVED***
  this.req.end(***REMOVED***
}
Request.prototype.pause = function (***REMOVED*** {
  if (!this.response***REMOVED*** this._paused = true
  else this.response.pause.apply(this.response, arguments***REMOVED***
}
Request.prototype.resume = function (***REMOVED*** {
  if (!this.response***REMOVED*** this._paused = false
  else this.response.resume.apply(this.response, arguments***REMOVED***
}
Request.prototype.destroy = function (***REMOVED*** {
  if (!this._ended***REMOVED*** this.end(***REMOVED***
  else if (this.response***REMOVED*** this.response.destroy(***REMOVED***
}

function toJSON (***REMOVED*** {
  return getSafe(this, '__' + (((1+Math.random(***REMOVED******REMOVED****0x10000***REMOVED***|0***REMOVED***.toString(16***REMOVED******REMOVED***
}

Request.prototype.toJSON = toJSON


module.exports = Request
