// Taken from node's assert module, because it sucks
// and exposes next to nothing useful.
var util = require('./util'***REMOVED***;

module.exports = _deepEqual;

var pSlice = Array.prototype.slice;

function _deepEqual(actual, expected***REMOVED*** {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected***REMOVED*** {
    return true;

***REMOVED*** else if (util.isBuffer(actual***REMOVED*** && util.isBuffer(expected***REMOVED******REMOVED*** {
    if (actual.length != expected.length***REMOVED*** return false;

    for (var i = 0; i < actual.length; i++***REMOVED*** {
      if (actual[i] !== expected[i]***REMOVED*** return false;
  ***REMOVED***

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
***REMOVED*** else if (util.isDate(actual***REMOVED*** && util.isDate(expected***REMOVED******REMOVED*** {
    return actual.getTime(***REMOVED*** === expected.getTime(***REMOVED***;

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`***REMOVED***.
***REMOVED*** else if (util.isRegExp(actual***REMOVED*** && util.isRegExp(expected***REMOVED******REMOVED*** {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
***REMOVED*** else if (!util.isObject(actual***REMOVED*** && !util.isObject(expected***REMOVED******REMOVED*** {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call***REMOVED***, the same set of keys
  // (although not necessarily the same order***REMOVED***, equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
***REMOVED*** else {
    return objEquiv(actual, expected***REMOVED***;
***REMOVED***
}


function objEquiv (a, b***REMOVED*** {
  if (util.isNullOrUndefined(a***REMOVED*** || util.isNullOrUndefined(b***REMOVED******REMOVED***
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype***REMOVED*** return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (util.isArguments(a***REMOVED******REMOVED*** {
    if (!util.isArguments(b***REMOVED******REMOVED*** {
      return false;
  ***REMOVED***
    a = pSlice.call(a***REMOVED***;
    b = pSlice.call(b***REMOVED***;
    return _deepEqual(a, b***REMOVED***;
***REMOVED***
  try{
    var ka = Object.keys(a***REMOVED***,
      kb = Object.keys(b***REMOVED***,
      key, i;
***REMOVED*** catch (e***REMOVED*** {//happens when one is a string literal and the other isn't
    return false;
***REMOVED***
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty***REMOVED***
  if (ka.length != kb.length***REMOVED***
    return false;
  //the same set of keys (although not necessarily the same order***REMOVED***,
  ka.sort(***REMOVED***;
  kb.sort(***REMOVED***;
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--***REMOVED*** {
    if (ka[i] != kb[i]***REMOVED***
      return false;
***REMOVED***
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--***REMOVED*** {
    key = ka[i];
    if (!_deepEqual(a[key], b[key]***REMOVED******REMOVED*** return false;
***REMOVED***
  return true;
}
