(function(e***REMOVED***{if("function"==typeof bootstrap***REMOVED***bootstrap("should",e***REMOVED***;else if("object"==typeof exports***REMOVED***module.exports=e(***REMOVED***;else if("function"==typeof define&&define.amd***REMOVED***define(e***REMOVED***;else if("undefined"!=typeof ses***REMOVED***{if(!ses.ok(***REMOVED******REMOVED***return;ses.makeShould=e}else"undefined"!=typeof window?window.should=e(***REMOVED***:global.should=e(***REMOVED***}***REMOVED***(function(***REMOVED***{var define,ses,bootstrap,module,exports;
return (function e(t,n,r***REMOVED***{function s(o,u***REMOVED***{if(!n[o]***REMOVED***{if(!t[o]***REMOVED***{var a=typeof require=="function"&&require;if(!u&&a***REMOVED***return a(o,!0***REMOVED***;if(i***REMOVED***return i(o,!0***REMOVED***;throw new Error("Cannot find module '"+o+"'"***REMOVED***}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e***REMOVED***{var n=t[o][1][e];return s(n?n:e***REMOVED***},f,f.exports,e,t,n,r***REMOVED***}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++***REMOVED***s(r[o]***REMOVED***;return s}***REMOVED***({1:[function(require,module,exports***REMOVED***{
// Taken from node's assert module, because it sucks
// and exposes next to nothing useful.
var util = require('./util'***REMOVED***;

module.exports = _deepEqual;

var pSlice = Array.prototype.slice;

function _deepEqual(actual, expected***REMOVED*** {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected***REMOVED*** {
    return true;

***REMOVED*** else if (util.isBuffer(actual***REMOVED*** && util.isBuffer(expected***REMOVED******REMOVED*** {
    if (actual.length != expected.length***REMOVED*** return false;

    for (var i = 0; i < actual.length; i++***REMOVED*** {
      if (actual[i] !== expected[i]***REMOVED*** return false;
  ***REMOVED***

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
***REMOVED*** else if (util.isDate(actual***REMOVED*** && util.isDate(expected***REMOVED******REMOVED*** {
    return actual.getTime(***REMOVED*** === expected.getTime(***REMOVED***;

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`***REMOVED***.
***REMOVED*** else if (util.isRegExp(actual***REMOVED*** && util.isRegExp(expected***REMOVED******REMOVED*** {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
***REMOVED*** else if (!util.isObject(actual***REMOVED*** && !util.isObject(expected***REMOVED******REMOVED*** {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call***REMOVED***, the same set of keys
  // (although not necessarily the same order***REMOVED***, equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
***REMOVED*** else {
    return objEquiv(actual, expected***REMOVED***;
***REMOVED***
}


function objEquiv (a, b***REMOVED*** {
  if (util.isNullOrUndefined(a***REMOVED*** || util.isNullOrUndefined(b***REMOVED******REMOVED***
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype***REMOVED*** return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (util.isArguments(a***REMOVED******REMOVED*** {
    if (!util.isArguments(b***REMOVED******REMOVED*** {
      return false;
  ***REMOVED***
    a = pSlice.call(a***REMOVED***;
    b = pSlice.call(b***REMOVED***;
    return _deepEqual(a, b***REMOVED***;
***REMOVED***
  try{
    var ka = Object.keys(a***REMOVED***,
      kb = Object.keys(b***REMOVED***,
      key, i;
***REMOVED*** catch (e***REMOVED*** {//happens when one is a string literal and the other isn't
    return false;
***REMOVED***
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty***REMOVED***
  if (ka.length != kb.length***REMOVED***
    return false;
  //the same set of keys (although not necessarily the same order***REMOVED***,
  ka.sort(***REMOVED***;
  kb.sort(***REMOVED***;
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--***REMOVED*** {
    if (ka[i] != kb[i]***REMOVED***
      return false;
***REMOVED***
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--***REMOVED*** {
    key = ka[i];
    if (!_deepEqual(a[key], b[key]***REMOVED******REMOVED*** return false;
***REMOVED***
  return true;
}

},{"./util":4}],2:[function(require,module,exports***REMOVED***{
//copy of node http module status codes
//https://github.com/joyent/node/blob/master/lib/_http_server.js

var STATUS_CODES = exports.STATUS_CODES = {
  100 : 'Continue',
  101 : 'Switching Protocols',
  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
  200 : 'OK',
  201 : 'Created',
  202 : 'Accepted',
  203 : 'Non-Authoritative Information',
  204 : 'No Content',
  205 : 'Reset Content',
  206 : 'Partial Content',
  207 : 'Multi-Status',               // RFC 4918
  300 : 'Multiple Choices',
  301 : 'Moved Permanently',
  302 : 'Moved Temporarily',
  303 : 'See Other',
  304 : 'Not Modified',
  305 : 'Use Proxy',
  307 : 'Temporary Redirect',
  400 : 'Bad Request',
  401 : 'Unauthorized',
  402 : 'Payment Required',
  403 : 'Forbidden',
  404 : 'Not Found',
  405 : 'Method Not Allowed',
  406 : 'Not Acceptable',
  407 : 'Proxy Authentication Required',
  408 : 'Request Time-out',
  409 : 'Conflict',
  410 : 'Gone',
  411 : 'Length Required',
  412 : 'Precondition Failed',
  413 : 'Request Entity Too Large',
  414 : 'Request-URI Too Large',
  415 : 'Unsupported Media Type',
  416 : 'Requested Range Not Satisfiable',
  417 : 'Expectation Failed',
  418 : 'I\'m a teapot',              // RFC 2324
  422 : 'Unprocessable Entity',       // RFC 4918
  423 : 'Locked',                     // RFC 4918
  424 : 'Failed Dependency',          // RFC 4918
  425 : 'Unordered Collection',       // RFC 4918
  426 : 'Upgrade Required',           // RFC 2817
  428 : 'Precondition Required',      // RFC 6585
  429 : 'Too Many Requests',          // RFC 6585
  431 : 'Request Header Fields Too Large',// RFC 6585
  500 : 'Internal Server Error',
  501 : 'Not Implemented',
  502 : 'Bad Gateway',
  503 : 'Service Unavailable',
  504 : 'Gateway Time-out',
  505 : 'HTTP Version Not Supported',
  506 : 'Variant Also Negotiates',    // RFC 2295
  507 : 'Insufficient Storage',       // RFC 4918
  509 : 'Bandwidth Limit Exceeded',
  510 : 'Not Extended',               // RFC 2774
  511 : 'Network Authentication Required' // RFC 6585
};

module.exports.STATUS_CODES = STATUS_CODES;
},{}],3:[function(require,module,exports***REMOVED***{
/*!
 * Should
 * Copyright(c***REMOVED*** 2010-2012 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var util = require('./util'***REMOVED***
  , assert = require('assert'***REMOVED***
  , AssertionError = assert.AssertionError
  , statusCodes = require('./http'***REMOVED***.STATUS_CODES
  , eql = require('./eql'***REMOVED***
  , inspect = require('util'***REMOVED***.inspect;

/**
 * Our function should
 * @param obj
 * @returns {Assertion}
 */
var should = function(obj***REMOVED*** {
  return new Assertion(util.isWrapperType(obj***REMOVED*** ? obj.valueOf(***REMOVED***: obj***REMOVED***;
};

should.inspect = inspect;

/**
 * Expose assert to should
 *
 * This allows you to do things like below
 * without require(***REMOVED***ing the assert module.
 *
 *    should.equal(foo.bar, undefined***REMOVED***;
 *
 */
util.merge(should, assert***REMOVED***;


/**
 * Assert _obj_ exists, with optional message.
 *
 * @param {*} obj
 * @param {String} [msg]
 * @api public
 */
should.exist = should.exists = function(obj, msg***REMOVED*** {
  if(null == obj***REMOVED*** {
    throw new AssertionError({
      message: msg || ('expected ' + should.inspect(obj***REMOVED*** + ' to exist'***REMOVED***
      , stackStartFunction: should.exist
  ***REMOVED******REMOVED***;
***REMOVED***
};

/**
 * Asserts _obj_ does not exist, with optional message.
 *
 * @param {*} obj
 * @param {String} [msg]
 * @api public
 */

should.not = {};
should.not.exist = should.not.exists = function(obj, msg***REMOVED***{
  if (null != obj***REMOVED*** {
    throw new AssertionError({
      message: msg || ('expected ' + should.inspect(obj***REMOVED*** + ' to not exist'***REMOVED***
      , stackStartFunction: should.not.exist
  ***REMOVED******REMOVED***;
***REMOVED***
};

/**
 * Expose should to external world.
 */
exports = module.exports = should;


/**
 * Expose api via `Object#should`.
 *
 * @api public
 */

Object.defineProperty(Object.prototype, 'should', {
  set: function(***REMOVED***{},
  get: function(***REMOVED***{
    return should(this***REMOVED***;
***REMOVED***,
  configurable: true
}***REMOVED***;

/**
 * Initialize a new `Assertion` with the given _obj_.
 *
 * @param {*} obj
 * @api private
 */

var Assertion = should.Assertion = function Assertion(obj***REMOVED*** {
  this.obj = obj;
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Prototype.
 */

Assertion.prototype = {

  /**
   * Assert _expr_ with the given _msg_ and _negatedMsg_.
   *
   * @param {Boolean} expr
   * @param {function} msg
   * @param {function} negatedMsg
   * @param {Object} [expected]
   * @param {Boolean} [showDiff]
   * @param {String} [description]
   * @api private
   */

  assert: function(expr, msg, negatedMsg, expected, showDiff, description***REMOVED***{
    msg = this.negate ? negatedMsg : msg

    var ok = this.negate ? !expr : expr
      , obj = this.obj;

    if (ok***REMOVED*** return;

    var err = new AssertionError({
        message: msg.call(this***REMOVED***
      , actual: obj
      , expected: expected
      , stackStartFunction: this.assert
      , negated: this.negate
  ***REMOVED******REMOVED***;

    err.showDiff = showDiff;
    err.description = description

    throw err;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get an(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get of(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get a(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get and(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get be(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get have(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Dummy getter.
   *
   * @api public
   */

  get with(***REMOVED*** {
    return this;
***REMOVED***,

  /**
   * Negation modifier.
   *
   * @api public
   */

  get not(***REMOVED*** {
    this.negate = true;
    return this;
***REMOVED***,

  /**
   * Get object inspection string.
   *
   * @return {String}
   * @api private
   */

  get inspect(***REMOVED*** {
    return should.inspect(this.obj***REMOVED***;
***REMOVED***,

  /**
   * Assert instanceof `Arguments`.
   *
   * @api public
   */

  get arguments(***REMOVED*** {
    this.assert(
        util.isArguments(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be arguments' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not be arguments' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert that object is empty.
   *
   * @api public
   */

  get empty(***REMOVED*** {
    var length = this.obj.length;

    if(util.isString(this.obj***REMOVED*** || Array.isArray(this.obj***REMOVED*** || util.isArguments(this.obj***REMOVED******REMOVED*** {
      this.assert(
        0 === length
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be empty' }
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be empty' }***REMOVED***;
  ***REMOVED*** else {
      var ok = true;
      for (var prop in this.obj***REMOVED*** {
        if(hasOwnProperty.call(this.obj, prop***REMOVED******REMOVED*** {
          ok = false;
          break;
      ***REMOVED***
    ***REMOVED***

      this.assert(
        ok
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be empty' }
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be empty' }***REMOVED***;

  ***REMOVED***
    return this;
***REMOVED***,

  /**
   * Assert ok.
   *
   * @api public
   */

  get ok(***REMOVED*** {
    this.assert(
        this.obj
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be truthy' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be falsey' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert true.
   *
   * @api public
   */

  get true(***REMOVED*** {
    this.assert(
        true === this.obj
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be true' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be true' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert false.
   *
   * @api public
   */

  get false(***REMOVED*** {
    this.assert(
        false === this.obj
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be false' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be false' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert NaN.
   *
   * @api public
   */

  get NaN(***REMOVED*** {
    this.assert(
        util.isNumber(this.obj***REMOVED*** && isNaN(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be NaN' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be NaN' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert Infinity.
   *
   * @api public
   */

  get Infinity(***REMOVED*** {
    this.assert(
      util.isNumber(this.obj***REMOVED*** && !isNaN(this.obj***REMOVED*** && !isFinite(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be Infinity' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be Infinity' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert equal.
   *
   * @param {*} val
   * @param {String} description
   * @api public
   */

  eql: function(val, description***REMOVED***{
    this.assert(
        eql(val, this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to equal ' + should.inspect(val***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not equal ' + should.inspect(val***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , val
      , true
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert strict equal.
   *
   * @param {*} val
   * @param {String} description
   * @api public
   */

  equal: function(val, description***REMOVED***{
    this.assert(
        val === this.obj
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to equal ' + should.inspect(val***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not equal ' + should.inspect(val***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , val
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert within start to finish (inclusive***REMOVED***.
   *
   * @param {Number} start
   * @param {Number} finish
   * @param {String} description
   * @api public
   */

  within: function(start, finish, description***REMOVED***{
    var range = start + '..' + finish;
    this.assert(
        this.obj >= start && this.obj <= finish
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be within ' + range + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not be within ' + range + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert within value +- delta (inclusive***REMOVED***.
   *
   * @param {Number} value
   * @param {Number} delta
   * @param {String} description
   * @api public
   */

  approximately: function(value, delta, description***REMOVED*** {
    this.assert(
      Math.abs(this.obj - value***REMOVED*** <= delta
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be approximately ' + value + " +- " + delta + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not be approximately ' + value + " +- " + delta + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert typeof.
   *
   * @param {*} type
   * @param {String} description
   * @api public
   */
  type: function(type, description***REMOVED***{
    this.assert(
        type == typeof this.obj
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to have type ' + type + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to have type ' + type  + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert instanceof.
   *
   * @param {Function} constructor
   * @param {String} description
   * @api public
   */

  instanceof: function(constructor, description***REMOVED***{
    var name = constructor.name;
    this.assert(
        this.obj instanceof constructor
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be an instance of ' + name + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be an instance of ' + name + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert if given object is a function.
   */
  get Function(***REMOVED***{
    this.assert(
      util.isFunction(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be a function' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be a function' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert given object is an object.
   */
  get Object(***REMOVED***{
    this.assert(
      util.isObject(this.obj***REMOVED*** && !Array.isArray(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be an object' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be an object' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert given object is a string
   */
  get String(***REMOVED***{
    this.assert(
      util.isString(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be a string' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be a string' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert given object is an array
   */
  get Array(***REMOVED***{
    this.assert(
      Array.isArray(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be an array' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be an array' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert given object is a number. NaN and Infinity are not numbers.
   */
  get Number(***REMOVED***{
    this.assert(
      util.isNumber(this.obj***REMOVED*** && isFinite(this.obj***REMOVED*** && !isNaN(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be a number' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be a number' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert given object is a boolean
   */
  get Boolean(***REMOVED***{
    this.assert(
      util.isBoolean(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be a boolean' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be a boolean' }***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert given object is an error
   */
  get Error(***REMOVED*** {
    this.assert(
      util.isError(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be an error' }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to be an error' }***REMOVED***;
    return this;
***REMOVED***,
  /**
   * Assert numeric value above _n_.
   *
   * @param {Number} n
   * @param {String} description
   * @api public
   */

  above: function(n, description***REMOVED***{
    this.assert(
        this.obj > n
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be above ' + n + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be below ' + n + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert numeric value below _n_.
   *
   * @param {Number} n
   * @param {String} description
   * @api public
   */

  below: function(n, description***REMOVED***{
    this.assert(
        this.obj < n
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be below ' + n + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to be above ' + n + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert string value matches _regexp_.
   *
   * @param {RegExp} regexp
   * @param {String} description
   * @api public
   */

  match: function(regexp, description***REMOVED***{
    this.assert(
        regexp.exec(this.obj***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to match ' + regexp + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' not to match ' + regexp + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert property "length" exists and has value of _n_.
   *
   * @param {Number} n
   * @param {String} description
   * @api public
   */

  length: function(n, description***REMOVED***{
    this.obj.should.have.property('length'***REMOVED***;
    var len = this.obj.length;
    this.assert(
        n == len
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to have a length of ' + n + ' but got ' + len + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not have a length of ' + len + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert property _name_ exists, with optional _val_.
   *
   * @param {String} name
   * @param {*} [val]
   * @param {String} description
   * @api public
   */

  property: function(name, val, description***REMOVED***{
    if (this.negate && undefined !== val***REMOVED*** {
      if (undefined === this.obj[name]***REMOVED*** {
        throw new Error(this.inspect + ' has no property ' + should.inspect(name***REMOVED*** + (description ? " | " + description : ""***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      this.assert(
          undefined !== this.obj[name]
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to have a property ' + should.inspect(name***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not have a property ' + should.inspect(name***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , void 0
        , void 0
        , description***REMOVED***;
  ***REMOVED***

    if (undefined !== val***REMOVED*** {
      this.assert(
          val === this.obj[name]
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to have a property ' + should.inspect(name***REMOVED***
          + ' of ' + should.inspect(val***REMOVED*** + ', but got ' + should.inspect(this.obj[name]***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not have a property ' + should.inspect(name***REMOVED*** + ' of ' + should.inspect(val***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , void 0
        , void 0
        , description***REMOVED***;
  ***REMOVED***

    this.obj = this.obj[name];
    return this;
***REMOVED***,
  /**
   * Asset have given properties
   * @param {Array|String ...} names
   * @api public
   */
  properties: function(names***REMOVED*** {
    var str
      , ok = true;

    names = names instanceof Array
      ? names
      : Array.prototype.slice.call(arguments***REMOVED***;

    var len = names.length;

    if (!len***REMOVED*** throw new Error('names required'***REMOVED***;

    // make sure they're all present
    ok = names.every(function(name***REMOVED***{
      return this.obj[name] !== undefined;
  ***REMOVED***, this***REMOVED***;

    // key string
    if (len > 1***REMOVED*** {
      names = names.map(function(name***REMOVED***{
        return should.inspect(name***REMOVED***;
    ***REMOVED******REMOVED***;
      var last = names.pop(***REMOVED***;
      str = names.join(', '***REMOVED*** + ', and ' + last;
  ***REMOVED*** else {
      str = should.inspect(names[0]***REMOVED***;
  ***REMOVED***

    // message
    str = 'have ' + (len > 1 ? 'properties ' : 'a property '***REMOVED*** + str;

    this.assert(
      ok
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to ' + str }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not ' + str }***REMOVED***;

    return this;
***REMOVED***,

  /**
   * Assert own property _name_ exists.
   *
   * @param {String} name
   * @param {String} description
   * @api public
   */

  ownProperty: function(name, description***REMOVED***{
    this.assert(
      hasOwnProperty.call(this.obj, name***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to have own property ' + should.inspect(name***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not have own property ' + should.inspect(name***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    this.obj = this.obj[name];
    return this;
***REMOVED***,

  /**
   * Assert that string starts with `str`.
   * @param {String} str
   * @param {String} description
   * @api public
   */

  startWith: function(str, description***REMOVED*** {
    this.assert(0 === this.obj.indexOf(str***REMOVED***
    , function(***REMOVED*** { return 'expected ' + this.inspect + ' to start with ' + should.inspect(str***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
    , function(***REMOVED*** { return 'expected ' + this.inspect + ' to not start with ' + should.inspect(str***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
    , void 0
    , void 0
    , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert that string ends with `str`.
   * @param {String} str
   * @param {String} description
   * @api public
   */

  endWith: function(str, description***REMOVED*** {
    this.assert(-1 !== this.obj.indexOf(str, this.obj.length - str.length***REMOVED***
    , function(***REMOVED*** { return 'expected ' + this.inspect + ' to end with ' + should.inspect(str***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
    , function(***REMOVED*** { return 'expected ' + this.inspect + ' to not end with ' + should.inspect(str***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
    , void 0
    , void 0
    , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert that `obj` is present via `.indexOf(***REMOVED***` or that `obj` contains some sub-object.
   *
   * @param {*} obj
   * @param {String} description
   * @api public
   */

  include: function(obj, description***REMOVED***{
    if (!Array.isArray(this.obj***REMOVED*** && !util.isString(this.obj***REMOVED******REMOVED***{
      var cmp = {};
      for (var key in obj***REMOVED*** cmp[key] = this.obj[key];
      this.assert(
          eql(cmp, obj***REMOVED***
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to include an object equal to ' + should.inspect(obj***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not include an object equal to ' + should.inspect(obj***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , void 0
        , void 0
        , description***REMOVED***;
  ***REMOVED*** else {
      this.assert(
          ~this.obj.indexOf(obj***REMOVED***
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to include ' + should.inspect(obj***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not include ' + should.inspect(obj***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
        , void 0
        , void 0
        , description***REMOVED***;
  ***REMOVED***
    return this;
***REMOVED***,

  /**
   * Assert that an object equal to `obj` is present.
   *
   * @param {Array} obj
   * @param {String} description
   * @api public
   */

  includeEql: function(obj, description***REMOVED***{
    this.assert(
      this.obj.some(function(item***REMOVED*** { return eql(obj, item***REMOVED***; }***REMOVED***
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to include an object equal to ' + should.inspect(obj***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not include an object equal to ' + should.inspect(obj***REMOVED*** + (description ? " | " + description : ""***REMOVED*** }
      , void 0
      , void 0
      , description***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert exact keys or inclusion of keys by using
   * the `.include` modifier.
   *
   * @param {Array|String ...} keys
   * @api public
   */

  keys: function(keys***REMOVED***{
    var str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments***REMOVED***;

    if (!keys.length***REMOVED*** throw new Error('keys required'***REMOVED***;

    var actual = Object.keys(this.obj***REMOVED***
      , len = keys.length;

    // make sure they're all present
    ok = keys.every(function(key***REMOVED***{
      return ~actual.indexOf(key***REMOVED***;
  ***REMOVED******REMOVED***;

    // matching length
    ok = ok && keys.length == actual.length;

    // key string
    if (len > 1***REMOVED*** {
      keys = keys.map(function(key***REMOVED***{
        return should.inspect(key***REMOVED***;
    ***REMOVED******REMOVED***;
      var last = keys.pop(***REMOVED***;
      str = keys.join(', '***REMOVED*** + ', and ' + last;
  ***REMOVED*** else {
      str = should.inspect(keys[0]***REMOVED***;
  ***REMOVED***

    // message
    str = 'have ' + (len > 1 ? 'keys ' : 'key '***REMOVED*** + str;

    this.assert(
        ok
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to ' + str }
      , function(***REMOVED***{ return 'expected ' + this.inspect + ' to not ' + str }***REMOVED***;

    return this;
***REMOVED***,

  /**
   * Assert that header `field` has the given `val`.
   *
   * @param {String} field
   * @param {String} val
   * @return {Assertion} for chaining
   * @api public
   */

  header: function(field, val***REMOVED***{
    this.obj.should
      .have.property('headers'***REMOVED***.and
      .have.property(field.toLowerCase(***REMOVED***, val***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert `.statusCode` of `code`.
   *
   * @param {Number} code
   * @return {Assertion} for chaining
   * @api public
   */

  status:  function(code***REMOVED***{
    this.obj.should.have.property('statusCode'***REMOVED***;
    var status = this.obj.statusCode;

    this.assert(
        code == status
      , function(***REMOVED***{ return 'expected response code of ' + code + ' ' + should.inspect(statusCodes[code]***REMOVED***
        + ', but got ' + status + ' ' + should.inspect(statusCodes[status]***REMOVED*** }
      , function(***REMOVED***{ return 'expected to not respond with ' + code + ' ' + should.inspect(statusCodes[code]***REMOVED*** }***REMOVED***;

    return this;
***REMOVED***,

  /**
   * Assert that this response has content-type: application/json.
   *
   * @return {Assertion} for chaining
   * @api public
   */

  get json(***REMOVED*** {
    this.obj.should.have.property('headers'***REMOVED***;
    this.obj.headers.should.have.property('content-type'***REMOVED***;
    this.obj.headers['content-type'].should.include('application/json'***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert that this response has content-type: text/html.
   *
   * @return {Assertion} for chaining
   * @api public
   */

  get html(***REMOVED*** {
    this.obj.should.have.property('headers'***REMOVED***;
    this.obj.headers.should.have.property('content-type'***REMOVED***;
    this.obj.headers['content-type'].should.include('text/html'***REMOVED***;
    return this;
***REMOVED***,

  /**
   * Assert that this function will or will not
   * throw an exception.
   *
   * @return {Assertion} for chaining
   * @api public
   */

  throw: function(message***REMOVED***{
    var fn = this.obj
      , err = {}
      , errorInfo = ''
      , ok = true;

    try {
      fn(***REMOVED***;
      ok = false;
  ***REMOVED*** catch (e***REMOVED*** {
      err = e;
  ***REMOVED***

    if (ok***REMOVED*** {
      if ('string' == typeof message***REMOVED*** {
        ok = message == err.message;
    ***REMOVED*** else if (message instanceof RegExp***REMOVED*** {
        ok = message.test(err.message***REMOVED***;
    ***REMOVED*** else if ('function' == typeof message***REMOVED*** {
        ok = err instanceof message;
    ***REMOVED***

      if (message && !ok***REMOVED*** {
        if ('string' == typeof message***REMOVED*** {
          errorInfo = " with a message matching '" + message + "', but got '" + err.message + "'";
      ***REMOVED*** else if (message instanceof RegExp***REMOVED*** {
          errorInfo = " with a message matching " + message + ", but got '" + err.message + "'";
      ***REMOVED*** else if ('function' == typeof message***REMOVED*** {
          errorInfo = " of type " + message.name + ", but got " + err.constructor.name;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    this.assert(
        ok
      , function(***REMOVED***{ return 'expected an exception to be thrown' + errorInfo }
      , function(***REMOVED***{ return 'expected no exception to be thrown, got "' + err.message + '"' }***REMOVED***;

    return this;
***REMOVED***
};

/**
 * Aliases.
 */

(function alias(name, as***REMOVED***{
  Assertion.prototype[as] = Assertion.prototype[name];
  return alias;
}***REMOVED***
('instanceof', 'instanceOf'***REMOVED***
('throw', 'throwError'***REMOVED***
('length', 'lengthOf'***REMOVED***
('keys', 'key'***REMOVED***
('ownProperty', 'haveOwnProperty'***REMOVED***
('above', 'greaterThan'***REMOVED***
('below', 'lessThan'***REMOVED***
('include', 'contain'***REMOVED***
('equal', 'exactly'***REMOVED***;


},{"./eql":1,"./http":2,"./util":4,"assert":6,"util":7}],4:[function(require,module,exports***REMOVED***{
/**
 * Check if given obj just a primitive type wrapper
 * @param {Object} obj
 * @returns {boolean}
 * @api private
 */
exports.isWrapperType = function(obj***REMOVED*** {
    return isNumber(obj***REMOVED*** || isString(obj***REMOVED*** || isBoolean(obj***REMOVED***;
}

/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     utils.merge(a, b***REMOVED***;
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api private
 */

exports.merge = function(a, b***REMOVED***{
  if (a && b***REMOVED*** {
    for (var key in b***REMOVED*** {
      a[key] = b[key];
  ***REMOVED***
***REMOVED***
  return a;
};

function isNumber(arg***REMOVED*** {
  return typeof arg === 'number' || arg instanceof Number;
}

exports.isNumber = isNumber;

function isString(arg***REMOVED*** {
  return typeof arg === 'string' || arg instanceof String;
}

function isBoolean(arg***REMOVED*** {
  return typeof arg === 'boolean' || arg instanceof Boolean;
}
exports.isBoolean = isBoolean;

exports.isString = isString;

function isBuffer(arg***REMOVED*** {
  return typeof Buffer !== 'undefined' && arg instanceof Buffer;
}

exports.isBuffer = isBuffer;

function isDate(d***REMOVED*** {
  return isObject(d***REMOVED*** && objectToString(d***REMOVED*** === '[object Date]';
}

exports.isDate = isDate;

function objectToString(o***REMOVED*** {
  return Object.prototype.toString.call(o***REMOVED***;
}

function isObject(arg***REMOVED*** {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isRegExp(re***REMOVED*** {
  return isObject(re***REMOVED*** && objectToString(re***REMOVED*** === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isNullOrUndefined(arg***REMOVED*** {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isArguments(object***REMOVED*** {
  return objectToString(object***REMOVED*** === '[object Arguments]';
}

exports.isArguments = isArguments;

exports.isFunction = function(arg***REMOVED*** {
  return typeof arg === 'function' || arg instanceof Function;
};

function isError(e***REMOVED*** {
  return isObject(e***REMOVED*** && objectToString(e***REMOVED*** === '[object Error]';
}
exports.isError = isError;
},{}],5:[function(require,module,exports***REMOVED***{


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs***REMOVED*** {
  return toString.call(xs***REMOVED*** === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x***REMOVED*** {
  if (xs.indexOf***REMOVED*** return xs.indexOf(x***REMOVED***;
  for (var i = 0; i < xs.length; i++***REMOVED*** {
    if (x === xs[i]***REMOVED*** return i;
***REMOVED***
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn***REMOVED*** {
  if (xs.filter***REMOVED*** return xs.filter(fn***REMOVED***;
  var res = [];
  for (var i = 0; i < xs.length; i++***REMOVED*** {
    if (fn(xs[i], i, xs***REMOVED******REMOVED*** res.push(xs[i]***REMOVED***;
***REMOVED***
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self***REMOVED*** {
  if (xs.forEach***REMOVED*** return xs.forEach(fn, self***REMOVED***;
  for (var i = 0; i < xs.length; i++***REMOVED*** {
    fn.call(self, xs[i], i, xs***REMOVED***;
***REMOVED***
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn***REMOVED*** {
  if (xs.map***REMOVED*** return xs.map(fn***REMOVED***;
  var out = new Array(xs.length***REMOVED***;
  for (var i = 0; i < xs.length; i++***REMOVED*** {
    out[i] = fn(xs[i], i, xs***REMOVED***;
***REMOVED***
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue***REMOVED*** {
  if (array.reduce***REMOVED*** return array.reduce(callback, opt_initialValue***REMOVED***;
  var value, isValueSet = false;

  if (2 < arguments.length***REMOVED*** {
    value = opt_initialValue;
    isValueSet = true;
***REMOVED***
  for (var i = 0, l = array.length; l > i; ++i***REMOVED*** {
    if (array.hasOwnProperty(i***REMOVED******REMOVED*** {
      if (isValueSet***REMOVED*** {
        value = callback(value, array[i], i, array***REMOVED***;
    ***REMOVED***
      else {
        value = array[i];
        isValueSet = true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1***REMOVED*** !== 'b'***REMOVED*** {
  exports.substr = function (str, start, length***REMOVED*** {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0***REMOVED*** start = str.length + start;

    // call the original function
    return str.substr(start, length***REMOVED***;
***REMOVED***;
} else {
  exports.substr = function (str, start, length***REMOVED*** {
    return str.substr(start, length***REMOVED***;
***REMOVED***;
}

// String.prototype.trim is supported in IE9
exports.trim = function (str***REMOVED*** {
  if (str.trim***REMOVED*** return str.trim(***REMOVED***;
  return str.replace(/^\s+|\s+$/g, ''***REMOVED***;
};

// Function.prototype.bind is supported in IE9
exports.bind = function (***REMOVED*** {
  var args = Array.prototype.slice.call(arguments***REMOVED***;
  var fn = args.shift(***REMOVED***;
  if (fn.bind***REMOVED*** return fn.bind.apply(fn, args***REMOVED***;
  var self = args.shift(***REMOVED***;
  return function (***REMOVED*** {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments***REMOVED***]***REMOVED******REMOVED***;
***REMOVED***;
};

// Object.create is supported in IE9
function create(prototype, properties***REMOVED*** {
  var object;
  if (prototype === null***REMOVED*** {
    object = { '__proto__' : null };
***REMOVED***
  else {
    if (typeof prototype !== 'object'***REMOVED*** {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype***REMOVED*** + '] != \'object\''
      ***REMOVED***;
  ***REMOVED***
    var Type = function (***REMOVED*** {};
    Type.prototype = prototype;
    object = new Type(***REMOVED***;
    object.__proto__ = prototype;
***REMOVED***
  if (typeof properties !== 'undefined' && Object.defineProperties***REMOVED*** {
    Object.defineProperties(object, properties***REMOVED***;
***REMOVED***
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object***REMOVED*** {
  return ((typeof object != "object" && typeof object != "function"***REMOVED*** || object === null***REMOVED***;
}

function keysShim(object***REMOVED*** {
  if (notObject(object***REMOVED******REMOVED*** {
    throw new TypeError("Object.keys called on a non-object"***REMOVED***;
***REMOVED***

  var result = [];
  for (var name in object***REMOVED*** {
    if (hasOwnProperty.call(object, name***REMOVED******REMOVED*** {
      result.push(name***REMOVED***;
  ***REMOVED***
***REMOVED***
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object***REMOVED*** {
  if (notObject(object***REMOVED******REMOVED*** {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object"***REMOVED***;
***REMOVED***

  var result = keysShim(object***REMOVED***;
  if (exports.isArray(object***REMOVED*** && exports.indexOf(object, 'length'***REMOVED*** === -1***REMOVED*** {
    result.push('length'***REMOVED***;
***REMOVED***
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error(***REMOVED***.hasOwnProperty('description'***REMOVED******REMOVED*** {
  var ERROR_PROPERTY_FILTER = function (obj, array***REMOVED*** {
    if (toString.call(obj***REMOVED*** === '[object Error]'***REMOVED*** {
      array = exports.filter(array, function (name***REMOVED*** {
        return name !== 'description' && name !== 'number' && name !== 'message';
    ***REMOVED******REMOVED***;
  ***REMOVED***
    return array;
***REMOVED***;

  exports.keys = function (object***REMOVED*** {
    return ERROR_PROPERTY_FILTER(object, keys(object***REMOVED******REMOVED***;
***REMOVED***;
  exports.getOwnPropertyNames = function (object***REMOVED*** {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object***REMOVED******REMOVED***;
***REMOVED***;
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key***REMOVED*** {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function'***REMOVED*** {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a'***REMOVED***;
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
***REMOVED*** catch (e***REMOVED*** {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key***REMOVED*** {
      try {
        return Object.getOwnPropertyDescriptor(value, key***REMOVED***;
    ***REMOVED*** catch (e***REMOVED*** {
        return valueObject(value, key***REMOVED***;
    ***REMOVED***
  ***REMOVED***;
***REMOVED***
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports***REMOVED***{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"***REMOVED***, to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util'***REMOVED***;
var shims = require('_shims'***REMOVED***;
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected }***REMOVED***

assert.AssertionError = function AssertionError(options***REMOVED*** {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this***REMOVED***;
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error***REMOVED***;

function replacer(key, value***REMOVED*** {
  if (util.isUndefined(value***REMOVED******REMOVED*** {
    return '' + value;
***REMOVED***
  if (util.isNumber(value***REMOVED*** && (isNaN(value***REMOVED*** || !isFinite(value***REMOVED******REMOVED******REMOVED*** {
    return value.toString(***REMOVED***;
***REMOVED***
  if (util.isFunction(value***REMOVED*** || util.isRegExp(value***REMOVED******REMOVED*** {
    return value.toString(***REMOVED***;
***REMOVED***
  return value;
}

function truncate(s, n***REMOVED*** {
  if (util.isString(s***REMOVED******REMOVED*** {
    return s.length < n ? s : s.slice(0, n***REMOVED***;
***REMOVED*** else {
    return s;
***REMOVED***
}

function getMessage(self***REMOVED*** {
  return truncate(JSON.stringify(self.actual, replacer***REMOVED***, 128***REMOVED*** + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer***REMOVED***, 128***REMOVED***;
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction***REMOVED*** {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
***REMOVED******REMOVED***;
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt***REMOVED***;
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt***REMOVED***;. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt***REMOVED***;.

function ok(value, message***REMOVED*** {
  if (!value***REMOVED*** fail(value, true, message, '==', assert.ok***REMOVED***;
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt***REMOVED***;

assert.equal = function equal(actual, expected, message***REMOVED*** {
  if (actual != expected***REMOVED*** fail(actual, expected, message, '==', assert.equal***REMOVED***;
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt***REMOVED***;

assert.notEqual = function notEqual(actual, expected, message***REMOVED*** {
  if (actual == expected***REMOVED*** {
    fail(actual, expected, message, '!=', assert.notEqual***REMOVED***;
***REMOVED***
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt***REMOVED***;

assert.deepEqual = function deepEqual(actual, expected, message***REMOVED*** {
  if (!_deepEqual(actual, expected***REMOVED******REMOVED*** {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual***REMOVED***;
***REMOVED***
};

function _deepEqual(actual, expected***REMOVED*** {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected***REMOVED*** {
    return true;

***REMOVED*** else if (util.isBuffer(actual***REMOVED*** && util.isBuffer(expected***REMOVED******REMOVED*** {
    if (actual.length != expected.length***REMOVED*** return false;

    for (var i = 0; i < actual.length; i++***REMOVED*** {
      if (actual[i] !== expected[i]***REMOVED*** return false;
  ***REMOVED***

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
***REMOVED*** else if (util.isDate(actual***REMOVED*** && util.isDate(expected***REMOVED******REMOVED*** {
    return actual.getTime(***REMOVED*** === expected.getTime(***REMOVED***;

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`***REMOVED***.
***REMOVED*** else if (util.isRegExp(actual***REMOVED*** && util.isRegExp(expected***REMOVED******REMOVED*** {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
***REMOVED*** else if (!util.isObject(actual***REMOVED*** && !util.isObject(expected***REMOVED******REMOVED*** {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call***REMOVED***, the same set of keys
  // (although not necessarily the same order***REMOVED***, equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
***REMOVED*** else {
    return objEquiv(actual, expected***REMOVED***;
***REMOVED***
}

function isArguments(object***REMOVED*** {
  return Object.prototype.toString.call(object***REMOVED*** == '[object Arguments]';
}

function objEquiv(a, b***REMOVED*** {
  if (util.isNullOrUndefined(a***REMOVED*** || util.isNullOrUndefined(b***REMOVED******REMOVED***
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype***REMOVED*** return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a***REMOVED******REMOVED*** {
    if (!isArguments(b***REMOVED******REMOVED*** {
      return false;
  ***REMOVED***
    a = pSlice.call(a***REMOVED***;
    b = pSlice.call(b***REMOVED***;
    return _deepEqual(a, b***REMOVED***;
***REMOVED***
  try {
    var ka = shims.keys(a***REMOVED***,
        kb = shims.keys(b***REMOVED***,
        key, i;
***REMOVED*** catch (e***REMOVED*** {//happens when one is a string literal and the other isn't
    return false;
***REMOVED***
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty***REMOVED***
  if (ka.length != kb.length***REMOVED***
    return false;
  //the same set of keys (although not necessarily the same order***REMOVED***,
  ka.sort(***REMOVED***;
  kb.sort(***REMOVED***;
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--***REMOVED*** {
    if (ka[i] != kb[i]***REMOVED***
      return false;
***REMOVED***
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--***REMOVED*** {
    key = ka[i];
    if (!_deepEqual(a[key], b[key]***REMOVED******REMOVED*** return false;
***REMOVED***
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt***REMOVED***;

assert.notDeepEqual = function notDeepEqual(actual, expected, message***REMOVED*** {
  if (_deepEqual(actual, expected***REMOVED******REMOVED*** {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual***REMOVED***;
***REMOVED***
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt***REMOVED***;

assert.strictEqual = function strictEqual(actual, expected, message***REMOVED*** {
  if (actual !== expected***REMOVED*** {
    fail(actual, expected, message, '===', assert.strictEqual***REMOVED***;
***REMOVED***
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt***REMOVED***;

assert.notStrictEqual = function notStrictEqual(actual, expected, message***REMOVED*** {
  if (actual === expected***REMOVED*** {
    fail(actual, expected, message, '!==', assert.notStrictEqual***REMOVED***;
***REMOVED***
};

function expectedException(actual, expected***REMOVED*** {
  if (!actual || !expected***REMOVED*** {
    return false;
***REMOVED***

  if (Object.prototype.toString.call(expected***REMOVED*** == '[object RegExp]'***REMOVED*** {
    return expected.test(actual***REMOVED***;
***REMOVED*** else if (actual instanceof expected***REMOVED*** {
    return true;
***REMOVED*** else if (expected.call({}, actual***REMOVED*** === true***REMOVED*** {
    return true;
***REMOVED***

  return false;
}

function _throws(shouldThrow, block, expected, message***REMOVED*** {
  var actual;

  if (util.isString(expected***REMOVED******REMOVED*** {
    message = expected;
    expected = null;
***REMOVED***

  try {
    block(***REMOVED***;
***REMOVED*** catch (e***REMOVED*** {
    actual = e;
***REMOVED***

  message = (expected && expected.name ? ' (' + expected.name + '***REMOVED***.' : '.'***REMOVED*** +
            (message ? ' ' + message : '.'***REMOVED***;

  if (shouldThrow && !actual***REMOVED*** {
    fail(actual, expected, 'Missing expected exception' + message***REMOVED***;
***REMOVED***

  if (!shouldThrow && expectedException(actual, expected***REMOVED******REMOVED*** {
    fail(actual, expected, 'Got unwanted exception' + message***REMOVED***;
***REMOVED***

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected***REMOVED******REMOVED*** || (!shouldThrow && actual***REMOVED******REMOVED*** {
    throw actual;
***REMOVED***
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt***REMOVED***;

assert.throws = function(block, /*optional*/error, /*optional*/message***REMOVED*** {
  _throws.apply(this, [true].concat(pSlice.call(arguments***REMOVED******REMOVED******REMOVED***;
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message***REMOVED*** {
  _throws.apply(this, [false].concat(pSlice.call(arguments***REMOVED******REMOVED******REMOVED***;
};

assert.ifError = function(err***REMOVED*** { if (err***REMOVED*** {throw err;}};
},{"_shims":5,"util":7}],7:[function(require,module,exports***REMOVED***{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"***REMOVED***, to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims'***REMOVED***;

var formatRegExp = /%[sdj%]/g;
exports.format = function(f***REMOVED*** {
  if (!isString(f***REMOVED******REMOVED*** {
    var objects = [];
    for (var i = 0; i < arguments.length; i++***REMOVED*** {
      objects.push(inspect(arguments[i]***REMOVED******REMOVED***;
  ***REMOVED***
    return objects.join(' '***REMOVED***;
***REMOVED***

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f***REMOVED***.replace(formatRegExp, function(x***REMOVED*** {
    if (x === '%%'***REMOVED*** return '%';
    if (i >= len***REMOVED*** return x;
    switch (x***REMOVED*** {
      case '%s': return String(args[i++]***REMOVED***;
      case '%d': return Number(args[i++]***REMOVED***;
      case '%j':
        try {
          return JSON.stringify(args[i++]***REMOVED***;
      ***REMOVED*** catch (_***REMOVED*** {
          return '[Circular]';
      ***REMOVED***
      default:
        return x;
  ***REMOVED***
***REMOVED******REMOVED***;
  for (var x = args[i]; i < len; x = args[++i]***REMOVED*** {
    if (isNull(x***REMOVED*** || !isObject(x***REMOVED******REMOVED*** {
      str += ' ' + x;
  ***REMOVED*** else {
      str += ' ' + inspect(x***REMOVED***;
  ***REMOVED***
***REMOVED***
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts***REMOVED*** {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
***REMOVED***;
  // legacy...
  if (arguments.length >= 3***REMOVED*** ctx.depth = arguments[2];
  if (arguments.length >= 4***REMOVED*** ctx.colors = arguments[3];
  if (isBoolean(opts***REMOVED******REMOVED*** {
    // legacy...
    ctx.showHidden = opts;
***REMOVED*** else if (opts***REMOVED*** {
    // got an "options" object
    exports._extend(ctx, opts***REMOVED***;
***REMOVED***
  // set default options
  if (isUndefined(ctx.showHidden***REMOVED******REMOVED*** ctx.showHidden = false;
  if (isUndefined(ctx.depth***REMOVED******REMOVED*** ctx.depth = 2;
  if (isUndefined(ctx.colors***REMOVED******REMOVED*** ctx.colors = false;
  if (isUndefined(ctx.customInspect***REMOVED******REMOVED*** ctx.customInspect = true;
  if (ctx.colors***REMOVED*** ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth***REMOVED***;
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType***REMOVED*** {
  var style = inspect.styles[styleType];

  if (style***REMOVED*** {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
***REMOVED*** else {
    return str;
***REMOVED***
}


function stylizeNoColor(str, styleType***REMOVED*** {
  return str;
}


function arrayToHash(array***REMOVED*** {
  var hash = {};

  shims.forEach(array, function(val, idx***REMOVED*** {
    hash[val] = true;
***REMOVED******REMOVED***;

  return hash;
}


function formatValue(ctx, value, recurseTimes***REMOVED*** {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect***REMOVED*** &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value***REMOVED******REMOVED*** {
    var ret = value.inspect(recurseTimes***REMOVED***;
    if (!isString(ret***REMOVED******REMOVED*** {
      ret = formatValue(ctx, ret, recurseTimes***REMOVED***;
  ***REMOVED***
    return ret;
***REMOVED***

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value***REMOVED***;
  if (primitive***REMOVED*** {
    return primitive;
***REMOVED***

  // Look up the keys of the object.
  var keys = shims.keys(value***REMOVED***;
  var visibleKeys = arrayToHash(keys***REMOVED***;

  if (ctx.showHidden***REMOVED*** {
    keys = shims.getOwnPropertyNames(value***REMOVED***;
***REMOVED***

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0***REMOVED*** {
    if (isFunction(value***REMOVED******REMOVED*** {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special'***REMOVED***;
  ***REMOVED***
    if (isRegExp(value***REMOVED******REMOVED*** {
      return ctx.stylize(RegExp.prototype.toString.call(value***REMOVED***, 'regexp'***REMOVED***;
  ***REMOVED***
    if (isDate(value***REMOVED******REMOVED*** {
      return ctx.stylize(Date.prototype.toString.call(value***REMOVED***, 'date'***REMOVED***;
  ***REMOVED***
    if (isError(value***REMOVED******REMOVED*** {
      return formatError(value***REMOVED***;
  ***REMOVED***
***REMOVED***

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value***REMOVED******REMOVED*** {
    array = true;
    braces = ['[', ']'];
***REMOVED***

  // Make functions say that they are functions
  if (isFunction(value***REMOVED******REMOVED*** {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
***REMOVED***

  // Make RegExps say that they are RegExps
  if (isRegExp(value***REMOVED******REMOVED*** {
    base = ' ' + RegExp.prototype.toString.call(value***REMOVED***;
***REMOVED***

  // Make dates with properties first say the date
  if (isDate(value***REMOVED******REMOVED*** {
    base = ' ' + Date.prototype.toUTCString.call(value***REMOVED***;
***REMOVED***

  // Make error with message first say the error
  if (isError(value***REMOVED******REMOVED*** {
    base = ' ' + formatError(value***REMOVED***;
***REMOVED***

  if (keys.length === 0 && (!array || value.length == 0***REMOVED******REMOVED*** {
    return braces[0] + base + braces[1];
***REMOVED***

  if (recurseTimes < 0***REMOVED*** {
    if (isRegExp(value***REMOVED******REMOVED*** {
      return ctx.stylize(RegExp.prototype.toString.call(value***REMOVED***, 'regexp'***REMOVED***;
  ***REMOVED*** else {
      return ctx.stylize('[Object]', 'special'***REMOVED***;
  ***REMOVED***
***REMOVED***

  ctx.seen.push(value***REMOVED***;

  var output;
  if (array***REMOVED*** {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys***REMOVED***;
***REMOVED*** else {
    output = keys.map(function(key***REMOVED*** {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  ctx.seen.pop(***REMOVED***;

  return reduceToSingleString(output, base, braces***REMOVED***;
}


function formatPrimitive(ctx, value***REMOVED*** {
  if (isUndefined(value***REMOVED******REMOVED***
    return ctx.stylize('undefined', 'undefined'***REMOVED***;
  if (isString(value***REMOVED******REMOVED*** {
    var simple = '\'' + JSON.stringify(value***REMOVED***.replace(/^"|"$/g, ''***REMOVED***
                                             .replace(/'/g, "\\'"***REMOVED***
                                             .replace(/\\"/g, '"'***REMOVED*** + '\'';
    return ctx.stylize(simple, 'string'***REMOVED***;
***REMOVED***
  if (isNumber(value***REMOVED******REMOVED***
    return ctx.stylize('' + value, 'number'***REMOVED***;
  if (isBoolean(value***REMOVED******REMOVED***
    return ctx.stylize('' + value, 'boolean'***REMOVED***;
  // For some reason typeof null is "object", so special case here.
  if (isNull(value***REMOVED******REMOVED***
    return ctx.stylize('null', 'null'***REMOVED***;
}


function formatError(value***REMOVED*** {
  return '[' + Error.prototype.toString.call(value***REMOVED*** + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys***REMOVED*** {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i***REMOVED*** {
    if (hasOwnProperty(value, String(i***REMOVED******REMOVED******REMOVED*** {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i***REMOVED***, true***REMOVED******REMOVED***;
  ***REMOVED*** else {
      output.push(''***REMOVED***;
  ***REMOVED***
***REMOVED***

  shims.forEach(keys, function(key***REMOVED*** {
    if (!key.match(/^\d+$/***REMOVED******REMOVED*** {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED******REMOVED***;
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array***REMOVED*** {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key***REMOVED*** || { value: value[key] };
  if (desc.get***REMOVED*** {
    if (desc.set***REMOVED*** {
      str = ctx.stylize('[Getter/Setter]', 'special'***REMOVED***;
  ***REMOVED*** else {
      str = ctx.stylize('[Getter]', 'special'***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    if (desc.set***REMOVED*** {
      str = ctx.stylize('[Setter]', 'special'***REMOVED***;
  ***REMOVED***
***REMOVED***

  if (!hasOwnProperty(visibleKeys, key***REMOVED******REMOVED*** {
    name = '[' + key + ']';
***REMOVED***
  if (!str***REMOVED*** {
    if (shims.indexOf(ctx.seen, desc.value***REMOVED*** < 0***REMOVED*** {
      if (isNull(recurseTimes***REMOVED******REMOVED*** {
        str = formatValue(ctx, desc.value, null***REMOVED***;
    ***REMOVED*** else {
        str = formatValue(ctx, desc.value, recurseTimes - 1***REMOVED***;
    ***REMOVED***
      if (str.indexOf('\n'***REMOVED*** > -1***REMOVED*** {
        if (array***REMOVED*** {
          str = str.split('\n'***REMOVED***.map(function(line***REMOVED*** {
            return '  ' + line;
        ***REMOVED******REMOVED***.join('\n'***REMOVED***.substr(2***REMOVED***;
      ***REMOVED*** else {
          str = '\n' + str.split('\n'***REMOVED***.map(function(line***REMOVED*** {
            return '   ' + line;
        ***REMOVED******REMOVED***.join('\n'***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
      str = ctx.stylize('[Circular]', 'special'***REMOVED***;
  ***REMOVED***
***REMOVED***
  if (isUndefined(name***REMOVED******REMOVED*** {
    if (array && key.match(/^\d+$/***REMOVED******REMOVED*** {
      return str;
  ***REMOVED***
    name = JSON.stringify('' + key***REMOVED***;
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]****REMOVED***"$/***REMOVED******REMOVED*** {
      name = name.substr(1, name.length - 2***REMOVED***;
      name = ctx.stylize(name, 'name'***REMOVED***;
  ***REMOVED*** else {
      name = name.replace(/'/g, "\\'"***REMOVED***
                 .replace(/\\"/g, '"'***REMOVED***
                 .replace(/(^"|"$***REMOVED***/g, "'"***REMOVED***;
      name = ctx.stylize(name, 'string'***REMOVED***;
  ***REMOVED***
***REMOVED***

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces***REMOVED*** {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur***REMOVED*** {
    numLinesEst++;
    if (cur.indexOf('\n'***REMOVED*** >= 0***REMOVED*** numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, ''***REMOVED***.length + 1;
***REMOVED***, 0***REMOVED***;

  if (length > 60***REMOVED*** {
    return braces[0] +
           (base === '' ? '' : base + '\n '***REMOVED*** +
           ' ' +
           output.join(',\n  '***REMOVED*** +
           ' ' +
           braces[1];
***REMOVED***

  return braces[0] + base + ' ' + output.join(', '***REMOVED*** + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create(***REMOVED***`.
function isArray(ar***REMOVED*** {
  return shims.isArray(ar***REMOVED***;
}
exports.isArray = isArray;

function isBoolean(arg***REMOVED*** {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg***REMOVED*** {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg***REMOVED*** {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg***REMOVED*** {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg***REMOVED*** {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg***REMOVED*** {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg***REMOVED*** {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re***REMOVED*** {
  return isObject(re***REMOVED*** && objectToString(re***REMOVED*** === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg***REMOVED*** {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d***REMOVED*** {
  return isObject(d***REMOVED*** && objectToString(d***REMOVED*** === '[object Date]';
}
exports.isDate = isDate;

function isError(e***REMOVED*** {
  return isObject(e***REMOVED*** && objectToString(e***REMOVED*** === '[object Error]';
}
exports.isError = isError;

function isFunction(arg***REMOVED*** {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg***REMOVED*** {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg***REMOVED*** {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o***REMOVED*** {
  return Object.prototype.toString.call(o***REMOVED***;
}


function pad(n***REMOVED*** {
  return n < 10 ? '0' + n.toString(10***REMOVED*** : n.toString(10***REMOVED***;
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp(***REMOVED*** {
  var d = new Date(***REMOVED***;
  var time = [pad(d.getHours(***REMOVED******REMOVED***,
              pad(d.getMinutes(***REMOVED******REMOVED***,
              pad(d.getSeconds(***REMOVED******REMOVED***].join(':'***REMOVED***;
  return [d.getDate(***REMOVED***, months[d.getMonth(***REMOVED***], time].join(' '***REMOVED***;
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function(***REMOVED*** {
  console.log('%s - %s', timestamp(***REMOVED***, exports.format.apply(exports, arguments***REMOVED******REMOVED***;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype***REMOVED***. NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903***REMOVED***.
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor***REMOVED*** {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
  ***REMOVED***
***REMOVED******REMOVED***;
};

exports._extend = function(origin, add***REMOVED*** {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add***REMOVED******REMOVED*** return origin;

  var keys = shims.keys(add***REMOVED***;
  var i = keys.length;
  while (i--***REMOVED*** {
    origin[keys[i]] = add[keys[i]];
***REMOVED***
  return origin;
};

function hasOwnProperty(obj, prop***REMOVED*** {
  return Object.prototype.hasOwnProperty.call(obj, prop***REMOVED***;
}

},{"_shims":5}]},{},[3]***REMOVED***
(3***REMOVED***
}***REMOVED***;
;