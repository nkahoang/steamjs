;(function (***REMOVED*** { // closure for web browsers

if (typeof module === 'object' && module.exports***REMOVED*** {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key***REMOVED*** {
  return Object.prototype.hasOwnProperty.call(obj, key***REMOVED***
}

function naiveLength (***REMOVED*** { return 1 }

function LRUCache (options***REMOVED*** {
  if (!(this instanceof LRUCache***REMOVED******REMOVED***
    return new LRUCache(options***REMOVED***

  if (typeof options === 'number'***REMOVED***
    options = { max: options }

  if (!options***REMOVED***
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number"***REMOVED*** || this._max <= 0 ***REMOVED***
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function"***REMOVED***
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset(***REMOVED***
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL***REMOVED*** {
      if (!mL || !(typeof mL === "number"***REMOVED*** || mL <= 0 ***REMOVED*** mL = Infinity
      this._max = mL
      if (this._length > this._max***REMOVED*** trim(this***REMOVED***
  ***REMOVED***
  , get : function (***REMOVED*** { return this._max }
  , enumerable : true
***REMOVED******REMOVED***

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC***REMOVED*** {
      if (typeof lC !== "function"***REMOVED*** {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache***REMOVED*** {
          this._cache[key].length = 1
      ***REMOVED***
    ***REMOVED*** else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache***REMOVED*** {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value***REMOVED***
          this._length += this._cache[key].length
      ***REMOVED***
    ***REMOVED***

      if (this._length > this._max***REMOVED*** trim(this***REMOVED***
  ***REMOVED***
  , get : function (***REMOVED*** { return this._lengthCalculator }
  , enumerable : true
***REMOVED******REMOVED***

Object.defineProperty(LRUCache.prototype, "length",
  { get : function (***REMOVED*** { return this._length }
  , enumerable : true
***REMOVED******REMOVED***


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function (***REMOVED*** { return this._itemCount }
  , enumerable : true
***REMOVED******REMOVED***

LRUCache.prototype.forEach = function (fn, thisp***REMOVED*** {
  thisp = thisp || this
  var i = 0;
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--***REMOVED*** if (this._lruList[k]***REMOVED*** {
    i++
    var hit = this._lruList[k]
    if (this._maxAge && (Date.now(***REMOVED*** - hit.now > this._maxAge***REMOVED******REMOVED*** {
      del(this, hit***REMOVED***
      if (!this._allowStale***REMOVED*** hit = undefined
  ***REMOVED***
    if (hit***REMOVED*** {
      fn.call(thisp, hit.value, hit.key, this***REMOVED***
  ***REMOVED***
***REMOVED***
}

LRUCache.prototype.keys = function (***REMOVED*** {
  var keys = new Array(this._itemCount***REMOVED***
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--***REMOVED*** if (this._lruList[k]***REMOVED*** {
    var hit = this._lruList[k]
    keys[i++] = hit.key
***REMOVED***
  return keys
}

LRUCache.prototype.values = function (***REMOVED*** {
  var values = new Array(this._itemCount***REMOVED***
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--***REMOVED*** if (this._lruList[k]***REMOVED*** {
    var hit = this._lruList[k]
    values[i++] = hit.value
***REMOVED***
  return values
}

LRUCache.prototype.reset = function (***REMOVED*** {
  if (this._dispose && this._cache***REMOVED*** {
    for (var k in this._cache***REMOVED*** {
      this._dispose(k, this._cache[k].value***REMOVED***
  ***REMOVED***
***REMOVED***

  this._cache = Object.create(null***REMOVED*** // hash of items by key
  this._lruList = Object.create(null***REMOVED*** // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

// Provided for debugging/dev purposes only. No promises whatsoever that
// this API stays stable.
LRUCache.prototype.dump = function (***REMOVED*** {
  return this._cache
}

LRUCache.prototype.dumpLru = function (***REMOVED*** {
  return this._lruList
}

LRUCache.prototype.set = function (key, value***REMOVED*** {
  if (hOP(this._cache, key***REMOVED******REMOVED*** {
    // dispose of the old one before overwriting
    if (this._dispose***REMOVED*** this._dispose(key, this._cache[key].value***REMOVED***
    if (this._maxAge***REMOVED*** this._cache[key].now = Date.now(***REMOVED***
    this._cache[key].value = value
    this.get(key***REMOVED***
    return true
***REMOVED***

  var len = this._lengthCalculator(value***REMOVED***
  var age = this._maxAge ? Date.now(***REMOVED*** : 0
  var hit = new Entry(key, value, this._mru++, len, age***REMOVED***

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max***REMOVED*** {
    if (this._dispose***REMOVED*** this._dispose(key, value***REMOVED***
    return false
***REMOVED***

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max***REMOVED*** trim(this***REMOVED***
  return true
}

LRUCache.prototype.has = function (key***REMOVED*** {
  if (!hOP(this._cache, key***REMOVED******REMOVED*** return false
  var hit = this._cache[key]
  if (this._maxAge && (Date.now(***REMOVED*** - hit.now > this._maxAge***REMOVED******REMOVED*** {
    return false
***REMOVED***
  return true
}

LRUCache.prototype.get = function (key***REMOVED*** {
  return get(this, key, true***REMOVED***
}

LRUCache.prototype.peek = function (key***REMOVED*** {
  return get(this, key, false***REMOVED***
}

LRUCache.prototype.pop = function (***REMOVED*** {
  var hit = this._lruList[this._lru]
  del(this, hit***REMOVED***
  return hit || null
}

LRUCache.prototype.del = function (key***REMOVED*** {
  del(this, this._cache[key]***REMOVED***
}

function get (self, key, doUse***REMOVED*** {
  var hit = self._cache[key]
  if (hit***REMOVED*** {
    if (self._maxAge && (Date.now(***REMOVED*** - hit.now > self._maxAge***REMOVED******REMOVED*** {
      del(self, hit***REMOVED***
      if (!self._allowStale***REMOVED*** hit = undefined
  ***REMOVED*** else {
      if (doUse***REMOVED*** use(self, hit***REMOVED***
  ***REMOVED***
    if (hit***REMOVED*** hit = hit.value
***REMOVED***
  return hit
}

function use (self, hit***REMOVED*** {
  shiftLU(self, hit***REMOVED***
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self***REMOVED*** {
  while (self._lru < self._mru && self._length > self._max***REMOVED***
    del(self, self._lruList[self._lru]***REMOVED***
}

function shiftLU (self, hit***REMOVED*** {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]***REMOVED*** self._lru ++
}

function del (self, hit***REMOVED*** {
  if (hit***REMOVED*** {
    if (self._dispose***REMOVED*** self._dispose(hit.key, hit.value***REMOVED***
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit***REMOVED***
***REMOVED***
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now***REMOVED*** {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
}

}***REMOVED***(***REMOVED***
