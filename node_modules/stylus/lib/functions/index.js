
/*!
 * Stylus - Evaluator - built-in functions
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Compiler = require('../visitor/compiler'***REMOVED***
  , nodes = require('../nodes'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , Image = require('./image'***REMOVED***
  , units = require('../units'***REMOVED***
  , colors = require('../colors'***REMOVED***
  , ***REMOVED***
  , fs = require('fs'***REMOVED***;

/**
 * Color component name map.
 */

var componentMap = {
    red: 'r'
  , green: 'g'
  , blue: 'b'
  , alpha: 'a'
  , hue: 'h'
  , saturation: 's'
  , lightness: 'l'
};

/**
 * Color component unit type map.
 */

var unitMap = {
    hue: 'deg'
  , saturation: '%'
  , lightness: '%'
};

/**
 * Color type map.
 */

var typeMap = {
    red: 'rgba'
  , blue: 'rgba'
  , green: 'rgba'
  , alpha: 'rgba'
  , hue: 'hsla'
  , saturation: 'hsla'
  , lightness: 'hsla'
};

/**
 * Convert the given `color` to an `HSLA` node,
 * or h,s,l,a component values.
 *
 * Examples:
 *
 *    hsla(10deg, 50%, 30%, 0.5***REMOVED***
 *    // => HSLA
 *
 *    hsla(#ffcc00***REMOVED***
 *    // => HSLA
 *
 * @param {RGBA|HSLA|Unit} hue
 * @param {Unit} saturation
 * @param {Unit} lightness
 * @param {Unit} alpha
 * @return {HSLA}
 * @api public
 */

exports.hsla = function hsla(hue, saturation, lightness, alpha***REMOVED***{
  switch (arguments.length***REMOVED*** {
    case 1:
      utils.assertColor(hue***REMOVED***;
      return hue.hsla;
    default:
      utils.assertType(hue, 'unit', 'hue'***REMOVED***;
      utils.assertType(saturation, 'unit', 'saturation'***REMOVED***;
      utils.assertType(lightness, 'unit', 'lightness'***REMOVED***;
      utils.assertType(alpha, 'unit', 'alpha'***REMOVED***;
      if (alpha && '%' == alpha.type***REMOVED*** alpha.val /= 100;
      return new nodes.HSLA(
          hue.val
        , saturation.val
        , lightness.val
        , alpha.val***REMOVED***;
***REMOVED***
};

/**
 * Convert the given `color` to an `HSLA` node,
 * or h,s,l component values.
 *
 * Examples:
 *
 *    hsl(10, 50, 30***REMOVED***
 *    // => HSLA
 *
 *    hsl(#ffcc00***REMOVED***
 *    // => HSLA
 *
 * @param {Unit|HSLA|RGBA} hue
 * @param {Unit} saturation
 * @param {Unit} lightness
 * @return {HSLA}
 * @api public
 */

exports.hsl = function hsl(hue, saturation, lightness***REMOVED***{
  if (1 == arguments.length***REMOVED*** {
    utils.assertColor(hue, 'color'***REMOVED***;
    return hue.hsla;
***REMOVED*** else {
    return exports.hsla(
        hue
      , saturation
      , lightness
      , new nodes.Unit(1***REMOVED******REMOVED***;
***REMOVED***
};

/**
 * Return type of `node`.
 *
 * Examples:
 * 
 *    type(12***REMOVED***
 *    // => 'unit'
 *
 *    type(#fff***REMOVED***
 *    // => 'color'
 *
 *    type(type***REMOVED***
 *    // => 'function'
 *
 *    type(unbound***REMOVED***
 *    typeof(unbound***REMOVED***
 *    type-of(unbound***REMOVED***
 *    // => 'ident'
 *
 * @param {Node} node
 * @return {String}
 * @api public
 */

exports.type =
exports.typeof =
exports['type-of'] = function type(node***REMOVED***{
  utils.assertPresent(node, 'expression'***REMOVED***;
  return node.nodeName;
};

/**
 * Return component `name` for the given `color`.
 *
 * @param {RGBA|HSLA} color
 * @param {String} name
 * @return {Unit}
 * @api public
 */

exports.component = function component(color, name***REMOVED*** {
  utils.assertColor(color, 'color'***REMOVED***;
  utils.assertString(name, 'name'***REMOVED***;
  var name = name.string
    , unit = unitMap[name]
    , type = typeMap[name]
    , name = componentMap[name];
  if (!name***REMOVED*** throw new Error('invalid color component "' + name + '"'***REMOVED***;
  return new nodes.Unit(color[type][name], unit***REMOVED***;
};

/**
 * Return the basename of `path`.
 *
 * @param {String} path
 * @return {String}
 * @api public
 */

exports.basename = function basename(p, ext***REMOVED***{
  utils.assertString(p, 'path'***REMOVED***;
  return path.basename(p.val, ext && ext.val***REMOVED***;
};

/**
 * Return the dirname of `path`.
 *
 * @param {String} path
 * @return {String}
 * @api public
 */

exports.dirname = function dirname(p***REMOVED***{
  utils.assertString(p, 'path'***REMOVED***;
  return path.dirname(p.val***REMOVED***;
};

/**
 * Return the extname of `path`.
 *
 * @param {String} path
 * @return {String}
 * @api public
 */

exports.extname = function extname(p***REMOVED***{
  utils.assertString(p, 'path'***REMOVED***;
  return path.extname(p.val***REMOVED***;
};

/**
 * Peform a path join.
 *
 * @param {String} path
 * @return {String}
 * @api public
 */

(exports.pathjoin = function pathjoin(***REMOVED***{
  var paths = [].slice.call(arguments***REMOVED***.map(function(path***REMOVED***{
    return path.first.string;
***REMOVED******REMOVED***;
  return path.join.apply(null, paths***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Return the red component of the given `color`.
 *
 * Examples:
 *
 *    red(#c00***REMOVED***
 *    // => 204
 *
 * @param {RGBA|HSLA} color
 * @return {Unit}
 * @api public
 */

exports.red = function red(color***REMOVED***{
  return exports.component(color, new nodes.String('red'***REMOVED******REMOVED***;
};

/**
 * Return the green component of the given `color`.
 *
 * Examples:
 *
 *    green(#0c0***REMOVED***
 *    // => 204
 *
 * @param {RGBA|HSLA} color
 * @return {Unit}
 * @api public
 */

exports.green = function green(color***REMOVED***{
  return exports.component(color, new nodes.String('green'***REMOVED******REMOVED***;
};

/**
 * Return the blue component of the given `color`.
 *
 * Examples:
 *
 *    blue(#00c***REMOVED***
 *    // => 204
 *
 * @param {RGBA|HSLA} color
 * @return {Unit}
 * @api public
 */

exports.blue = function blue(color***REMOVED***{
  return exports.component(color, new nodes.String('blue'***REMOVED******REMOVED***;
};

/**
 * Return a `RGBA` from the r,g,b,a channels.
 *
 * Examples:
 *
 *    rgba(255,0,0,0.5***REMOVED***
 *    // => rgba(255,0,0,0.5***REMOVED***
 *
 *    rgba(255,0,0,1***REMOVED***
 *    // => #ff0000
 *
 *    rgba(#ffcc00, 50%***REMOVED***
 *    // rgba(255,204,0,0.5***REMOVED***
 *
 * @param {Unit|RGBA|HSLA} red
 * @param {Unit} green
 * @param {Unit} blue
 * @param {Unit} alpha
 * @return {RGBA}
 * @api public
 */

exports.rgba = function rgba(red, green, blue, alpha***REMOVED***{
  switch (arguments.length***REMOVED*** {
    case 1:
      utils.assertColor(red***REMOVED***;
      var color = red.rgba;
      return new nodes.RGBA(
          color.r
        , color.g
        , color.b
        , color.a***REMOVED***;
    case 2:
      utils.assertColor(red***REMOVED***;
      var color = red.rgba;
      utils.assertType(green, 'unit', 'alpha'***REMOVED***;
      if ('%' == green.type***REMOVED*** green.val /= 100;
      return new nodes.RGBA(
          color.r
        , color.g
        , color.b
        , green.val***REMOVED***;
    default:
      utils.assertType(red, 'unit', 'red'***REMOVED***;
      utils.assertType(green, 'unit', 'green'***REMOVED***;
      utils.assertType(blue, 'unit', 'blue'***REMOVED***;
      utils.assertType(alpha, 'unit', 'alpha'***REMOVED***;
      var r = '%' == red.type ? Math.round(red.val * 2.55***REMOVED*** : red.val;
      var g = '%' == green.type ? Math.round(green.val * 2.55***REMOVED*** : green.val;
      var b = '%' == blue.type ? Math.round(blue.val * 2.55***REMOVED*** : blue.val;
      if (alpha && '%' == alpha.type***REMOVED*** alpha.val /= 100;
      return new nodes.RGBA(
          r
        , g
        , b
        , alpha.val***REMOVED***;
***REMOVED***
};

/**
 * Return a `RGBA` from the r,g,b channels.
 *
 * Examples:
 *
 *    rgb(255,204,0***REMOVED***
 *    // => #ffcc00
 *
 *    rgb(#fff***REMOVED***
 *    // => #fff
 *
 * @param {Unit|RGBA|HSLA} red
 * @param {Unit} green
 * @param {Unit} blue
 * @return {RGBA}
 * @api public
 */

exports.rgb = function rgb(red, green, blue***REMOVED***{
  switch (arguments.length***REMOVED*** {
    case 1:
      utils.assertColor(red***REMOVED***;
      var color = red.rgba;
      return new nodes.RGBA(
          color.r
        , color.g
        , color.b
        , 1***REMOVED***;
    default:
      return exports.rgba(
          red
        , green
        , blue
        , new nodes.Unit(1***REMOVED******REMOVED***;
***REMOVED***
};

/**
 * Convert a .json file into stylus variables or object.
 * Nested variable object keys are joined with a dash (-***REMOVED***
 *
 * Given this sample media-queries.json file:
 * {
 *   "small": "screen and (max-width:400px***REMOVED***",
 *   "tablet": {
 *     "landscape": "screen and (min-width:600px***REMOVED*** and (orientation:landscape***REMOVED***",
 *     "portrait": "screen and (min-width:600px***REMOVED*** and (orientation:portrait***REMOVED***"
 * ***REMOVED***
 * }
 *
 * Examples:
 *
 *    json('media-queries.json'***REMOVED***
 *
 *    @media small
 *    // => @media screen and (max-width:400px***REMOVED***
 *
 *    @media tablet-landscape
 *    // => @media screen and (min-width:600px***REMOVED*** and (orientation:landscape***REMOVED***
 *
 *    vars = json('vars.json', { hash: true }***REMOVED***
 *    body
 *      width: vars.width
 *
 * @param {String} path
 * @param {Boolean} [local]
 * @param {String} [namePrefix]
 * @api public
*/

exports.json = function(path, local, namePrefix***REMOVED***{
  utils.assertString(path, 'path'***REMOVED***;

  // lookup
  path = path.string;
  var found = utils.lookup(path, this.options.paths, this.options.filename***REMOVED***;
  if (!found***REMOVED*** throw new Error('failed to locate .json file ' + path***REMOVED***;

  // read
  var json = JSON.parse(fs.readFileSync(found, 'utf8'***REMOVED******REMOVED***;

  if (local && 'object' == local.nodeName***REMOVED*** {
    return convert(json***REMOVED***;
***REMOVED*** else {
    exports['-old-json'].call(this, json, local, namePrefix***REMOVED***;
***REMOVED***

  function convert(obj***REMOVED***{
    var ret = new nodes.Object(***REMOVED***;
    for (var key in obj***REMOVED*** {
      var val = obj[key];
      if ('object' == typeof val***REMOVED*** {
        ret.set(key, convert(val***REMOVED******REMOVED***;
    ***REMOVED*** else {
        val = utils.coerce(val***REMOVED***;
        if ('string' == val.nodeName***REMOVED*** val = parseString(val.string***REMOVED***;
        ret.set(key, val***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    return ret;
***REMOVED***
};

/**
 * Old `json` BIF.
 *
 * @api private
 */

exports['-old-json'] = function(json, local, namePrefix***REMOVED***{
  if (namePrefix***REMOVED*** {
    utils.assertString(namePrefix, 'namePrefix'***REMOVED***;
    namePrefix = namePrefix.val;
***REMOVED*** else {
    namePrefix = '';
***REMOVED***
  local = local ? local.toBoolean(***REMOVED*** : new nodes.Boolean(local***REMOVED***;
  var scope = local.isTrue ? this.currentScope : this.global.scope;

  convert(json***REMOVED***;
  return;

  function convert(obj, prefix***REMOVED***{
    prefix = prefix ? prefix + '-' : '';
    for (var key in obj***REMOVED***{
      var val = obj[key];
      var name = prefix + key;
      if ('object' == typeof val***REMOVED*** {
        convert(val, name***REMOVED***;
    ***REMOVED*** else {
        val = utils.coerce(val***REMOVED***;
        if ('string' == val.nodeName***REMOVED*** val = parseString(val.string***REMOVED***;
        scope.add({ name: namePrefix + name, val: val }***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
};

/**
*  Use the given `plugin`
*  
*  Examples:
*
*     use("plugins/add.js"***REMOVED***
*
*     width add(10, 100***REMOVED***
*     // => width: 110
*/

exports.use = function(plugin, options***REMOVED***{
  utils.assertString(plugin, 'plugin'***REMOVED***;

  if (options***REMOVED*** {
    utils.assertType(options, 'object', 'options'***REMOVED***;
    options = parseObject(options***REMOVED***;
***REMOVED***

  // lookup
  plugin = plugin.string;
  var found = utils.lookup(plugin, this.options.paths, this.options.filename***REMOVED***;
  if (!found***REMOVED*** throw new Error('failed to locate plugin file "' + plugin + '"'***REMOVED***;

  // use
  var fn = require(path.resolve(found***REMOVED******REMOVED***;
  if ('function' != typeof fn***REMOVED*** {
    throw new Error('plugin "' + plugin + '" does not export a function'***REMOVED***;
***REMOVED***
  this.renderer.use(fn(options || this.options***REMOVED******REMOVED***;
}

/**
 * Unquote the given `str`.
 *
 * Examples:
 *
 *    unquote("sans-serif"***REMOVED***
 *    // => sans-serif
 *
 *    unquote(sans-serif***REMOVED***
 *    // => sans-serif
 *
 * @param {String|Ident} string
 * @return {Literal}
 * @api public
 */

exports.unquote = function unquote(string***REMOVED***{
  utils.assertString(string, 'string'***REMOVED***;
  return new nodes.Literal(string.string***REMOVED***;
};

/**
 * Assign `type` to the given `unit` or return `unit`'s type.
 *
 * @param {Unit} unit
 * @param {String|Ident} type
 * @return {Unit}
 * @api public
 */

exports.unit = function unit(unit, type***REMOVED***{
  utils.assertType(unit, 'unit', 'unit'***REMOVED***;

  // Assign
  if (type***REMOVED*** {
    utils.assertString(type, 'type'***REMOVED***;
    return new nodes.Unit(unit.val, type.string***REMOVED***;
***REMOVED*** else {
    return unit.type || '';
***REMOVED***
};

/**
 * Lookup variable `name` or return Null.
 *
 * @param {String} name
 * @return {Mixed}
 * @api public
 */

exports.lookup = function lookup(name***REMOVED***{
  utils.assertType(name, 'string', 'name'***REMOVED***;
  var node = this.lookup(name.val***REMOVED***;
  if (!node***REMOVED*** return nodes.null;
  return this.visit(node***REMOVED***;
};

/**
 * Set a variable `name` on current scope.
 *
 * @param {String} name
 * @param {Expression} expr
 * @api public
 */

exports.define = function define(name, expr***REMOVED***{
  utils.assertType(name, 'string', 'name'***REMOVED***;
  expr = utils.unwrap(expr***REMOVED***;
  var scope = this.currentScope;
  var node = new nodes.Ident(name.val, expr***REMOVED***;
  scope.add(node***REMOVED***;
  return nodes.null;
};

/**
 * Perform `op` on the `left` and `right` operands.
 *
 * @param {String} op
 * @param {Node} left
 * @param {Node} right
 * @return {Node}
 * @api public
 */

exports.operate = function operate(op, left, right***REMOVED***{
  utils.assertType(op, 'string', 'op'***REMOVED***;
  utils.assertPresent(left, 'left'***REMOVED***;
  utils.assertPresent(right, 'right'***REMOVED***;
  return left.operate(op.val, right***REMOVED***;
};

/**
 * Test if `val` matches the given `pattern`.
 *
 * Examples:
 *
 *     match('^foo(bar***REMOVED***?', foo***REMOVED***
 *     match('^foo(bar***REMOVED***?', foobar***REMOVED***
 *     match('^foo(bar***REMOVED***?', 'foo'***REMOVED***
 *     match('^foo(bar***REMOVED***?', 'foobar'***REMOVED***
 *     // => true
 *
 *     match('^foo(bar***REMOVED***?', 'bar'***REMOVED***
 *     // => false
 *
 * @param {String} pattern
 * @param {String|Ident} val
 * @return {Boolean}
 * @api public
 */

exports.match = function match(pattern, val***REMOVED***{
  utils.assertType(pattern, 'string', 'pattern'***REMOVED***;
  utils.assertString(val, 'val'***REMOVED***;
  var re = new RegExp(pattern.val***REMOVED***;
  return new nodes.Boolean(re.test(val.string***REMOVED******REMOVED***;
};

/**
 * Returns substring of the given `val`.
 *
 * @param {String|Ident} val
 * @param {Number} start
 * @param {Number} [length]
 * @return {String|Ident}
 * @api public
 */

(exports.substr = function substr(val, start, length***REMOVED***{
  utils.assertPresent(val, 'string'***REMOVED***;
  utils.assertPresent(start, 'start'***REMOVED***;
  var valNode = utils.unwrap(val***REMOVED***.nodes[0];
  start = utils.unwrap(start***REMOVED***.nodes[0].val;
  if (length***REMOVED*** {
    length = utils.unwrap(length***REMOVED***.nodes[0].val;
***REMOVED***
  var res = valNode.string.substr(start, length***REMOVED***;
  return valNode instanceof nodes.Ident
      ? new nodes.Ident(res***REMOVED***
      : new nodes.String(res***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Returns string with all matches of `pattern` replaced by `replacement` in given `val`
 *
 * @param {String} pattern
 * @param {String} replacement
 * @param {String|Ident} val
 * @return {String|Ident}
 * @api public
 */

(exports.replace = function replace(pattern, replacement, val***REMOVED***{
  utils.assertPresent(pattern, 'pattern'***REMOVED***;
  utils.assertPresent(replacement, 'replacement'***REMOVED***;
  utils.assertPresent(val, 'val'***REMOVED***;
  pattern = new RegExp(utils.unwrap(pattern***REMOVED***.nodes[0].string, 'g'***REMOVED***;
  replacement = utils.unwrap(replacement***REMOVED***.nodes[0].string;
  var valNode = utils.unwrap(val***REMOVED***.nodes[0];
  var res = valNode.string.replace(pattern, replacement***REMOVED***;
  return valNode instanceof nodes.Ident
    ? new nodes.Ident(res***REMOVED***
    : new nodes.String(res***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Splits the given `val` by `delim`
 *
 * @param {String} delim
 * @param {String|Ident} val
 * @return {Expression}
 * @api public
 */
(exports.split = function split(delim, val***REMOVED***{
  utils.assertPresent(delim, 'delimiter'***REMOVED***;
  utils.assertPresent(val, 'val'***REMOVED***;
  delim = utils.unwrap(delim***REMOVED***.nodes[0].string;
  var valNode = utils.unwrap(val***REMOVED***.nodes[0];
  var splitted = valNode.string.split(delim***REMOVED***;
  var expr = new nodes.Expression(***REMOVED***;
  var ItemNode = valNode instanceof nodes.Ident
    ? nodes.Ident
    : nodes.String;
  for (var i = 0, len = splitted.length; i < len; ++i***REMOVED*** {
    expr.nodes.push(new ItemNode(splitted[i]***REMOVED******REMOVED***;
***REMOVED***
  return expr;
}***REMOVED***.raw = true;

/**
 * Return length of the given `expr`.
 *
 * @param {Expression} expr
 * @return {Unit}
 * @api public
 */

(exports.length = function length(expr***REMOVED***{
  if (expr***REMOVED*** {
    if (expr.nodes***REMOVED*** {
      var nodes = utils.unwrap(expr***REMOVED***.nodes;
      if (1 == nodes.length && 'object' == nodes[0].nodeName***REMOVED*** {
        return nodes[0].length;
    ***REMOVED*** else {
        return nodes.length;
    ***REMOVED***
  ***REMOVED*** else {
      return 1;
  ***REMOVED***
***REMOVED***
  return 0;
}***REMOVED***.raw = true;

/**
 * Inspect the given `expr`.
 *
 * @param {Expression} expr
 * @api public
 */

(exports.p = function p(***REMOVED***{
  [].slice.call(arguments***REMOVED***.forEach(function(expr***REMOVED***{
    expr = utils.unwrap(expr***REMOVED***;
    if (!expr.nodes.length***REMOVED*** return;
    console.log('\033[90minspect:\033[0m %s', expr.toString(***REMOVED***.replace(/^\(|\***REMOVED***$/g, ''***REMOVED******REMOVED***;
***REMOVED******REMOVED***
  return nodes.null;
}***REMOVED***.raw = true;

/**
 * Throw an error with the given `msg`.
 *
 * @param {String} msg
 * @api public
 */

exports.error = function error(msg***REMOVED***{
  utils.assertType(msg, 'string', 'msg'***REMOVED***;
  throw new Error(msg.val***REMOVED***;
};

/**
 * Warn with the given `msg` prefixed by "Warning: ".
 *
 * @param {String} msg
 * @api public
 */

exports.warn = function warn(msg***REMOVED***{
  utils.assertType(msg, 'string', 'msg'***REMOVED***;
  console.warn('Warning: %s', msg.val***REMOVED***;
  return nodes.null;
};

/**
 * Output stack trace.
 *
 * @api public
 */

exports.trace = function trace(***REMOVED***{
  console.log(this.stack***REMOVED***;
  return nodes.null;
};

/**
 * Push the given args to `expr`.
 *
 * @param {Expression} expr
 * @param {Node} ...
 * @return {Unit}
 * @api public
 */

(exports.push = exports.append = function(expr***REMOVED***{
  expr = utils.unwrap(expr***REMOVED***;
  for (var i = 1, len = arguments.length; i < len; ++i***REMOVED*** {
    expr.nodes.push(utils.unwrap(arguments[i]***REMOVED***.clone(***REMOVED******REMOVED***;
***REMOVED***
  return expr.nodes.length;
}***REMOVED***.raw = true;

/**
 * Pop a value from `expr`.
 *
 * @param {Expression} expr
 * @return {Node}
 * @api public
 */

(exports.pop = function pop(expr***REMOVED*** {
  expr = utils.unwrap(expr***REMOVED***;
  return expr.nodes.pop(***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Unshift the given args to `expr`.
 *
 * @param {Expression} expr
 * @param {Node} ...
 * @return {Unit}
 * @api public
 */

(exports.unshift = exports.prepend = function(expr***REMOVED***{
  expr = utils.unwrap(expr***REMOVED***;
  for (var i = 1, len = arguments.length; i < len; ++i***REMOVED*** {
    expr.nodes.unshift(utils.unwrap(arguments[i]***REMOVED******REMOVED***;
***REMOVED***
  return expr.nodes.length;
}***REMOVED***.raw = true;

/**
 * Shift an element from `expr`.
 *
 * @param {Expression} expr
 * @return {Node}
 * @api public
 */

 (exports.shift = function(expr***REMOVED***{
   expr = utils.unwrap(expr***REMOVED***;
   return expr.nodes.shift(***REMOVED***;
 }***REMOVED***.raw = true;

/**
 * Return a `Literal` with the given `fmt`, and
 * variable number of arguments.
 *
 * @param {String} fmt
 * @param {Node} ...
 * @return {Literal}
 * @api public
 */

(exports.s = function s(fmt***REMOVED***{
  fmt = utils.unwrap(fmt***REMOVED***.nodes[0];
  utils.assertString(fmt***REMOVED***;
  var self = this
    , str = fmt.string
    , args = arguments
    , i = 1;

  // format
  str = str.replace(/%(s|d***REMOVED***/g, function(_, specifier***REMOVED***{
    var arg = args[i++] || nodes.null;
    switch (specifier***REMOVED*** {
      case 's':
        return new Compiler(arg, self.options***REMOVED***.compile(***REMOVED***;
      case 'd':
        arg = utils.unwrap(arg***REMOVED***.first;
        if ('unit' != arg.nodeName***REMOVED*** throw new Error('%d requires a unit'***REMOVED***;
        return arg.val;
  ***REMOVED***
***REMOVED******REMOVED***;

  return new nodes.Literal(str***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Return a `Literal` `num` converted to the provided `base`, padded to `width`
 * with zeroes (default width is 2***REMOVED***
 *
 * @param {Number} num
 * @param {Number} base
 * @param {Number} width
 * @return {Literal}
 * @api public
 */

(exports['base-convert'] = function(num, base, width***REMOVED*** {
  utils.assertPresent(num, 'number'***REMOVED***;
  utils.assertPresent(base, 'base'***REMOVED***;
  num = utils.unwrap(num***REMOVED***.nodes[0].val;
  base = utils.unwrap(base***REMOVED***.nodes[0].val;
  width = (width && utils.unwrap(width***REMOVED***.nodes[0].val***REMOVED*** || 2;
  var result = Number(num***REMOVED***.toString(base***REMOVED***;
  while (result.length < width***REMOVED*** {
    result = "0" + result;
***REMOVED***
  return new nodes.Literal(result***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Return the opposites of the given `positions`.
 *
 * Examples:
 *
 *    opposite-position(top left***REMOVED***
 *    // => bottom right
 *
 * @param {Expression} positions
 * @return {Expression}
 * @api public
 */

(exports['opposite-position'] = function oppositePosition(positions***REMOVED***{
  var expr = [];
  utils.unwrap(positions***REMOVED***.nodes.forEach(function(pos, i***REMOVED***{
    utils.assertString(pos, 'position ' + i***REMOVED***;
    pos = (function(***REMOVED***{ switch (pos.string***REMOVED*** {
      case 'top': return 'bottom';
      case 'bottom': return 'top';
      case 'left': return 'right';
      case 'right': return 'left';
      case 'center': return 'center';
      default: throw new Error('invalid position ' + pos***REMOVED***;
  ***REMOVED***}***REMOVED***(***REMOVED***;
    expr.push(new nodes.Literal(pos***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
  return expr;
}***REMOVED***.raw = true;

/**
 * Return the width and height of the given `img` path.
 *
 * Examples:
 *
 *    image-size('foo.png'***REMOVED***
 *    // => 200px 100px
 *
 *    image-size('foo.png'***REMOVED***[0]
 *    // => 200px
 *
 *    image-size('foo.png'***REMOVED***[1]
 *    // => 100px
 *
 * Can be used to test if the image exists,
 * using an optional argument set to `true`
 * (without this argument this function throws error
 * if there is no such image***REMOVED***.
 *
 * Example:
 *
 *    image-size('nosuchimage.png', true***REMOVED***[0]
 *    // => 0
 *
 * @param {String} img
 * @param {Boolean} ignoreErr
 * @return {Expression}
 * @api public
 */

exports['image-size'] = function imageSize(img, ignoreErr***REMOVED*** {
  utils.assertType(img, 'string', 'img'***REMOVED***;
  try {
    var img = new Image(this, img.string***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    if (ignoreErr***REMOVED*** {
      return [new nodes.Unit(0***REMOVED***, new nodes.Unit(0***REMOVED***];
  ***REMOVED*** else {
      throw err;
  ***REMOVED***
***REMOVED***

  // Read size
  img.open(***REMOVED***;
  var size = img.size(***REMOVED***;
  img.close(***REMOVED***;

  // Return (w h***REMOVED***
  var expr = [];
  expr.push(new nodes.Unit(size[0], 'px'***REMOVED******REMOVED***;
  expr.push(new nodes.Unit(size[1], 'px'***REMOVED******REMOVED***;

  return expr;
};

/**
 * Return the tangent of the given `angle`.
 *
 * @param {Unit} angle
 * @return {Unit}
 * @api public
 */
exports.tan = function tan(angle***REMOVED*** {
  utils.assertType(angle, 'unit', 'angle'***REMOVED***;

  var radians = angle.val;

  if (angle.type === 'deg'***REMOVED*** {
    radians *= Math.PI / 180;
***REMOVED***

  var m = Math.pow(10, 9***REMOVED***;

  var sin = Math.round(Math.sin(radians***REMOVED*** * m***REMOVED*** / m
    , cos = Math.round(Math.cos(radians***REMOVED*** * m***REMOVED*** / m
    , tan = Math.round(m * sin / cos ***REMOVED*** / m;

  return new nodes.Unit(tan, ''***REMOVED***;
}

/**
 * Apply Math `fn` to `n`.
 *
 * @param {Unit} n
 * @param {String} fn
 * @return {Unit}
 * @api private
 */

exports['-math'] = function math(n, fn***REMOVED***{
  return new nodes.Unit(Math[fn.string](n.val***REMOVED***, n.type***REMOVED***;
};

/**
 * Get Math `prop`.
 *
 * @param {String} prop
 * @return {Unit}
 * @api private
 */

exports['-math-prop'] = function math(prop***REMOVED***{
  return new nodes.Unit(Math[prop.string]***REMOVED***;
};

/**
 * Buffer the given js `str`.
 *
 * @param {String} str
 * @return {JSLiteral}
 * @api private
 */

exports.js = function js(str***REMOVED***{
  utils.assertString(str, 'str'***REMOVED***;
  return new nodes.JSLiteral(str.val***REMOVED***;
};

/**
 * Adjust HSL `color` `prop` by `amount`.
 *
 * @param {RGBA|HSLA} color
 * @param {String} prop
 * @param {Unit} amount
 * @return {RGBA}
 * @api private
 */

exports['-adjust'] = function adjust(color, prop, amount***REMOVED***{
  var hsl = color.hsla.clone(***REMOVED***;
  prop = { hue: 'h', saturation: 's', lightness: 'l' }[prop.string];
  if (!prop***REMOVED*** throw new Error('invalid adjustment property'***REMOVED***;
  var val = amount.val;
  if ('%' == amount.type***REMOVED***{
    val = 'l' == prop && val > 0
      ? (100 - hsl[prop]***REMOVED*** * val / 100
      : hsl[prop] * (val / 100***REMOVED***;
***REMOVED***
  hsl[prop] += val;
  return hsl.rgba;
};

/**
 * Return a clone of the given `expr`.
 *
 * @param {Expression} expr
 * @return {Node}
 * @api public
 */

(exports.clone = function clone(expr***REMOVED***{
  utils.assertPresent(expr, 'expr'***REMOVED***;
  return expr.clone(***REMOVED***;
}***REMOVED***.raw = true;

/**
 * Add property `name` with the given `expr`
 * to the mixin-able block.
 *
 * @param {String|Ident|Literal} name
 * @param {Expression} expr
 * @return {Property}
 * @api public
 */

(exports['add-property'] = function addProperty(name, expr***REMOVED***{
  utils.assertType(name, 'expression', 'name'***REMOVED***;
  name = utils.unwrap(name***REMOVED***.first;
  utils.assertString(name, 'name'***REMOVED***;
  utils.assertType(expr, 'expression', 'expr'***REMOVED***;
  var prop = new nodes.Property([name], expr***REMOVED***;
  var block = this.closestBlock;

  var len = block.nodes.length
    , head = block.nodes.slice(0, block.index***REMOVED***
    , tail = block.nodes.slice(block.index++, len***REMOVED***;
  head.push(prop***REMOVED***;
  block.nodes = head.concat(tail***REMOVED***;
  
  return prop;
}***REMOVED***.raw = true;

/**
 * Merge the object `dest` with the given args.
 *
 * @param {Object} dest
 * @param {Object} ...
 * @return {Object} dest
 * @api public
 */

(exports.merge = exports.extend = function merge(dest***REMOVED***{
  utils.assertPresent(dest, 'dest'***REMOVED***;
  dest = utils.unwrap(dest***REMOVED***.first;
  utils.assertType(dest, 'object', 'dest'***REMOVED***;
  for (var i = 1, len = arguments.length; i < len; ++i***REMOVED*** {
    utils.merge(dest.vals, utils.unwrap(arguments[i]***REMOVED***.first.vals***REMOVED***;
***REMOVED***
  return dest;
}***REMOVED***.raw = true;

/**
 * Return the current selector or compile `sel` selector.
 *
 * @param {String} [sel]
 * @return {String}
 * @api public
 */

exports.selector = function selector(sel***REMOVED***{
  var stack = this.selectorStack
    , group;
  if (sel && 'string' == sel.nodeName***REMOVED*** {
    if (!~sel.val.indexOf('&'***REMOVED*** && '/' !== sel.val.charAt(0***REMOVED******REMOVED*** return sel.val;
    group = new nodes.Group;
    sel = new nodes.Selector([sel.val]***REMOVED***;
    sel.val = sel.segments.join(''***REMOVED***;
    group.push(sel***REMOVED***;
    stack.push(group.nodes***REMOVED***;
***REMOVED***
  return stack.length ? utils.compileSelectors(stack***REMOVED***.join(','***REMOVED*** : '&';
};

/**
 * Prefix css classes in a block
 *
 * @param {String} prefix
 * @param {Block} block
 * @return {Block}
 * @api private
 */

exports['-prefix-classes'] = function prefixClasses(prefix, block***REMOVED***{
  utils.assertString(prefix, 'prefix'***REMOVED***;
  utils.assertType(block, 'block', 'block'***REMOVED***;

  var _prefix = this.prefix;

  this.prefix = prefix.string;
  block = this.visit(block***REMOVED***;
  this.prefix = _prefix;
  return block;
};

/**
 * Attempt to parse unit `str`.
 *
 * @param {String} str
 * @return {Unit}
 * @api private
 */

function parseUnit(str***REMOVED***{
  var m = str.match(/^(\d+***REMOVED***(.****REMOVED***/***REMOVED***;
  if (!m***REMOVED*** return;
  var n = parseInt(m[1], 10***REMOVED***;
  var type = m[2];
  return new nodes.Unit(n, type***REMOVED***;
}

/**
 * Attempt to parse color.
 *
 * @param {String} str
 * @return {RGBA}
 * @api private
 */

function parseColor(str***REMOVED***{
  if (str.substr(0,1***REMOVED*** === '#'***REMOVED*** {
    // Handle color shorthands (like #abc***REMOVED***
    var shorthand = str.length === 4,
        m = str.match(shorthand ? /\w/g : /\w{2}/g***REMOVED***;

    if (!m***REMOVED*** return;
    m = m.map(function(s***REMOVED*** { return parseInt(shorthand ? s+s : s, 16***REMOVED*** }***REMOVED***;
    return new nodes.RGBA(m[0],m[1],m[2],1***REMOVED***;
***REMOVED***
  else if (str.substr(0,3***REMOVED*** === 'rgb'***REMOVED***{
    var m = str.match(/([0-9]*\.?[0-9]+***REMOVED***/g***REMOVED***;
    if (!m***REMOVED*** return;
    m = m.map(function(s***REMOVED***{return parseFloat(s, 10***REMOVED***}***REMOVED***;
    return new nodes.RGBA(m[0], m[1], m[2], m[3] || 1***REMOVED***;
***REMOVED***
  else {
    var rgb = colors[str];
    if (!rgb***REMOVED*** return;
    return new nodes.RGBA(rgb[0], rgb[1], rgb[2], 1***REMOVED***;
***REMOVED***
}

/**
 * Attempt to parse string.
 *
 * @param {String} str
 * @return {Unit|RGBA|Literal}
 * @api private
 */

function parseString(str***REMOVED***{
  return parseUnit(str***REMOVED*** || parseColor(str***REMOVED*** || new nodes.Literal(str***REMOVED***;
}

/**
 * Attempt to parse object node to the javascript object.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function parseObject(obj***REMOVED***{
  obj = obj.vals;
  for (var key in obj***REMOVED*** {
    var nodes = obj[key].nodes[0].nodes;
    if (nodes && nodes.length***REMOVED*** {
      obj[key] = [];
      for (var i = 0, len = nodes.length; i < len; ++i***REMOVED*** {
        obj[key].push(convert(nodes[i]***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** else {
      obj[key] = convert(obj[key].first***REMOVED***;
  ***REMOVED***
***REMOVED***
  return obj;

  function convert(node***REMOVED***{
    switch (node.nodeName***REMOVED*** {
      case 'object':
        return parseObject(node***REMOVED***;
      case 'boolean':
        return node.isTrue;
      case 'unit':
        return node.type ? node.toString(***REMOVED*** : +node.val;
      case 'string':
      case 'literal':
        return node.val;
      default:
        return node.toString(***REMOVED***;
  ***REMOVED***
***REMOVED***
}
