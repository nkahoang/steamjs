
/*!
 * Stylus - Expression
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node'***REMOVED***
  , nodes = require('../nodes'***REMOVED***
  , utils = require('../utils'***REMOVED***;

/**
 * Initialize a new `Expression`.
 *
 * @param {Boolean} isList
 * @api public
 */

var Expression = module.exports = function Expression(isList***REMOVED***{
  Node.call(this***REMOVED***;
  this.nodes = [];
  this.isList = isList;
};

/**
 * Check if the variable has a value.
 *
 * @return {Boolean}
 * @api public
 */

Expression.prototype.__defineGetter__('isEmpty', function(***REMOVED***{
  return !this.nodes.length;
}***REMOVED***;

/**
 * Return the first node in this expression.
 *
 * @return {Node}
 * @api public
 */

Expression.prototype.__defineGetter__('first', function(***REMOVED***{
  return this.nodes[0]
    ? this.nodes[0].first
    : nodes.null;
}***REMOVED***;

/**
 * Hash all the nodes in order.
 *
 * @return {String}
 * @api public
 */

Expression.prototype.__defineGetter__('hash', function(***REMOVED***{
  return this.nodes.map(function(node***REMOVED***{
    return node.hash;
***REMOVED******REMOVED***.join('::'***REMOVED***;
}***REMOVED***;

/**
 * Inherit from `Node.prototype`.
 */

Expression.prototype.__proto__ = Node.prototype;

/**
 * Return a clone of this node.
 * 
 * @return {Node}
 * @api public
 */

Expression.prototype.clone = function(***REMOVED***{
  var clone = new this.constructor(this.isList***REMOVED***;
  clone.preserve = this.preserve;
  clone.lineno = this.lineno;
  clone.filename = this.filename;
  for (var i = 0; i < this.nodes.length; ++i***REMOVED*** {
    clone.push(this.nodes[i].clone(***REMOVED******REMOVED***;
***REMOVED***
  return clone;
};

/**
 * Push the given `node`.
 *
 * @param {Node} node
 * @api public
 */

Expression.prototype.push = function(node***REMOVED***{
  this.nodes.push(node***REMOVED***;
};

/**
 * Operate on `right` with the given `op`.
 *
 * @param {String} op
 * @param {Node} right
 * @return {Node}
 * @api public
 */

Expression.prototype.operate = function(op, right, val***REMOVED***{
  switch (op***REMOVED*** {
    case '[]=':
      var self = this
        , range = utils.unwrap(right***REMOVED***.nodes
        , val = utils.unwrap(val***REMOVED***
        , len
        , node;
      range.forEach(function(unit***REMOVED***{
        len = self.nodes.length;
        if ('unit' == unit.nodeName***REMOVED*** {
          var i = unit.val;
          while (i-- > len***REMOVED*** self.nodes[i] = nodes.null;
          self.nodes[unit.val] = val;
      ***REMOVED*** else if ('string' == unit.nodeName***REMOVED*** {
          node = self.nodes[0];
          if (node && 'object' == node.nodeName***REMOVED*** node.set(unit.val, val.clone(***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
      return val;
    case '[]':
      var expr = new nodes.Expression
        , vals = utils.unwrap(this***REMOVED***.nodes
        , range = utils.unwrap(right***REMOVED***.nodes
        , node;
      range.forEach(function(unit***REMOVED***{
        if ('unit' == unit.nodeName***REMOVED*** {
          node = vals[unit.val];
      ***REMOVED*** else if ('string' == unit.nodeName && 'object' == vals[0].nodeName***REMOVED*** {
          node = vals[0].get(unit.val***REMOVED***;
      ***REMOVED***
        if (node***REMOVED*** expr.push(node***REMOVED***;
    ***REMOVED******REMOVED***;
      return expr.isEmpty
        ? nodes.null
        : utils.unwrap(expr***REMOVED***;
    case '||':
      return this.toBoolean(***REMOVED***.isTrue
        ? this
        : right;
    case 'in':
      return Node.prototype.operate.call(this, op, right***REMOVED***;
    case '!=':
      return this.operate('==', right, val***REMOVED***.negate(***REMOVED***;
    case '==':
      var len = this.nodes.length
        , right = right.toExpression(***REMOVED***
        , a
        , b;
      if (len != right.nodes.length***REMOVED*** return nodes.false;
      for (var i = 0; i < len; ++i***REMOVED*** {
        a = this.nodes[i];
        b = right.nodes[i];
        if (a.operate(op, b***REMOVED***.isTrue***REMOVED*** continue;
        return nodes.false;
    ***REMOVED***
      return nodes.true;
      break;
    default:
      return this.first.operate(op, right, val***REMOVED***;
***REMOVED***
};

/**
 * Expressions with length > 1 are truthy,
 * otherwise the first value's toBoolean(***REMOVED***
 * method is invoked.
 *
 * @return {Boolean}
 * @api public
 */

Expression.prototype.toBoolean = function(***REMOVED***{
  if (this.nodes.length > 1***REMOVED*** return nodes.true;
  return this.first.toBoolean(***REMOVED***;
};

/**
 * Return "<a> <b> <c>" or "<a>, <b>, <c>" if
 * the expression represents a list.
 *
 * @return {String}
 * @api public
 */

Expression.prototype.toString = function(***REMOVED***{
  return '(' + this.nodes.map(function(node***REMOVED***{
    return node.toString(***REMOVED***;
***REMOVED******REMOVED***.join(this.isList ? ', ' : ' '***REMOVED*** + '***REMOVED***';
};

