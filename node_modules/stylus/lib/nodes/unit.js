
/*!
 * Stylus - Unit
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node'***REMOVED***
  , nodes = require('./'***REMOVED***;

/**
 * Initialize a new `Unit` with the given `val` and unit `type`
 * such as "px", "pt", "in", etc.
 *
 * @param {String} val
 * @param {String} type
 * @api public
 */

var Unit = module.exports = function Unit(val, type***REMOVED***{
  Node.call(this***REMOVED***;
  this.val = parseFloat( val.toFixed( 15 ***REMOVED*** ***REMOVED***;
  this.type = type;
};

/**
 * Inherit from `Node.prototype`.
 */

Unit.prototype.__proto__ = Node.prototype;

/**
 * Return Boolean based on the unit value.
 *
 * @return {Boolean}
 * @api public
 */

Unit.prototype.toBoolean = function(***REMOVED***{
  return nodes.Boolean(this.type
      ? true
      : this.val***REMOVED***;
};

/**
 * Return unit string.
 *
 * @return {String}
 * @api public
 */

Unit.prototype.toString = function(***REMOVED***{
  var n = this.val;
  if ('px' == this.type***REMOVED*** n = n.toFixed(0***REMOVED***;
  return n + (this.type || ''***REMOVED***;
};

/**
 * Return a clone of this node.
 *
 * @return {Node}
 * @api public
 */

Unit.prototype.clone = function(***REMOVED***{
  var clone = new Unit(this.val, this.type***REMOVED***;
  clone.lineno = this.lineno;
  clone.filename = this.filename;
  return clone;
};

/**
 * Operate on `right` with the given `op`.
 *
 * @param {String} op
 * @param {Node} right
 * @return {Node}
 * @api public
 */

Unit.prototype.operate = function(op, right***REMOVED***{
  var type = this.type || right.first.type;

  // swap color
  if ('rgba' == right.nodeName || 'hsla' == right.nodeName***REMOVED*** {
    return right.operate(op, this***REMOVED***;
***REMOVED***

  // operate
  if (this.shouldCoerce(op***REMOVED******REMOVED*** {
    right = right.first;
    // percentages
    if (('-' == op || '+' == op***REMOVED*** && '%' == right.type***REMOVED*** {
      right = new Unit(this.val * (right.val / 100***REMOVED***, '%'***REMOVED***;
  ***REMOVED*** else {
      right = this.coerce(right***REMOVED***;
  ***REMOVED***

    switch (op***REMOVED*** {
      case '-':
        return new Unit(this.val - right.val, type***REMOVED***;
      case '+':
        return new Unit(this.val + right.val, type***REMOVED***;
      case '/':
        return new Unit(this.val / right.val, type***REMOVED***;
      case '*':
        return new Unit(this.val * right.val, type***REMOVED***;
      case '%':
        return new Unit(this.val % right.val, type***REMOVED***;
      case '**':
        return new Unit(Math.pow(this.val, right.val***REMOVED***, type***REMOVED***;
      case '..':
      case '...':
        var start = this.val
          , end = right.val
          , expr = new nodes.Expression
          , inclusive = '..' == op;
        if (start < end***REMOVED*** {
          do {
            expr.push(new nodes.Unit(start***REMOVED******REMOVED***;
        ***REMOVED*** while (inclusive ? ++start <= end : ++start < end***REMOVED***;
      ***REMOVED*** else {
          do {
            expr.push(new nodes.Unit(start***REMOVED******REMOVED***;
        ***REMOVED*** while (inclusive ? --start >= end : --start > end***REMOVED***;
      ***REMOVED***
        return expr;
  ***REMOVED***
***REMOVED***

  return Node.prototype.operate.call(this, op, right***REMOVED***;
};

/**
 * Coerce `other` unit to the same type as `this` unit.
 *
 * Supports:
 *
 *    mm -> cm | in
 *    cm -> mm | in
 *    in -> mm | cm
 *
 *    ms -> s
 *    s  -> ms
 *
 *    Hz  -> kHz
 *    kHz -> Hz
 *
 * @param {Unit} other
 * @return {Unit}
 * @api public
 */

Unit.prototype.coerce = function(other***REMOVED***{
  if ('unit' == other.nodeName***REMOVED*** {
    var a = this
      , b = other
      , factorA = factor(a***REMOVED***
      , factorB = factor(b***REMOVED***;

    if (factorA && factorB && (factorA.label == factorB.label***REMOVED******REMOVED*** {
      var bVal = b.val * (factorB.val / factorA.val***REMOVED***;
      return new nodes.Unit(bVal, a.type***REMOVED***;
  ***REMOVED*** else {
      return new nodes.Unit(b.val, a.type***REMOVED***;
  ***REMOVED***
***REMOVED*** else if ('string' == other.nodeName***REMOVED*** {
    var val = parseFloat(other.val***REMOVED***;
    if (isNaN(val***REMOVED******REMOVED*** Node.prototype.coerce.call(this, other***REMOVED***;
    return new nodes.Unit(val***REMOVED***;
***REMOVED*** else {
    return Node.prototype.coerce.call(this, other***REMOVED***;
***REMOVED***
};


/**
 *  Convert a unit to base unit
 */
function factor(unit***REMOVED*** {
  var factorTable = {
    'mm': {val: 1, label: 'mm'},
    'cm': {val: 10, label: 'mm'},
    'in': {val: 25.4, label: 'mm'},
    'ms': {val: 1, label: 'ms'},
    's': {val: 1000, label: 'ms'},
    'Hz': {val: 1, label: 'Hz'},
    'kHz': {val: 1000, label: 'Hz'}
***REMOVED***;

  return factorTable[unit.type];
};

