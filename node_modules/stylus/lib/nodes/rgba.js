
/*!
 * Stylus - RGBA
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = require('./node'***REMOVED***
  , HSLA = require('./hsla'***REMOVED***
  , functions = require('../functions'***REMOVED***
  , adjust = functions['-adjust']
  , nodes = require('./'***REMOVED***;

/**
 * Initialize a new `RGBA` with the given r,g,b,a component values.
 *
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a
 * @api public
 */

var RGBA = exports = module.exports = function RGBA(r,g,b,a***REMOVED***{
  Node.call(this***REMOVED***;
  this.r = clamp(r***REMOVED***;
  this.g = clamp(g***REMOVED***;
  this.b = clamp(b***REMOVED***;
  this.a = clampAlpha(a***REMOVED***;
  this.rgba = this;
};

/**
 * Inherit from `Node.prototype`.
 */

RGBA.prototype.__proto__ = Node.prototype;

/**
 * Return an `RGBA` without clamping values.
 * 
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a
 * @return {RGBA}
 * @api public
 */

RGBA.withoutClamping = function(r,g,b,a***REMOVED***{
  var rgba = new RGBA(0,0,0,0***REMOVED***;
  rgba.r = r;
  rgba.g = g;
  rgba.b = b;
  rgba.a = a;
  return rgba;
};

/**
 * Return a clone of this node.
 * 
 * @return {Node}
 * @api public
 */

RGBA.prototype.clone = function(***REMOVED***{
  var clone = new RGBA(
      this.r
    , this.g
    , this.b
    , this.a***REMOVED***;
  clone.lineno = this.lineno;
  clone.filename = this.filename;
  return clone;
};

/**
 * Return true.
 *
 * @return {Boolean}
 * @api public
 */

RGBA.prototype.toBoolean = function(***REMOVED***{
  return nodes.true;
};

/**
 * Return `HSLA` representation.
 *
 * @return {HSLA}
 * @api public
 */

RGBA.prototype.__defineGetter__('hsla', function(***REMOVED***{
  return HSLA.fromRGBA(this***REMOVED***;
}***REMOVED***;

/**
 * Return hash.
 *
 * @return {String}
 * @api public
 */

RGBA.prototype.__defineGetter__('hash', function(***REMOVED***{
  return this.toString(***REMOVED***;
}***REMOVED***;

/**
 * Add r,g,b,a to the current component values.
 *
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a
 * @return {RGBA} new node
 * @api public
 */

RGBA.prototype.add = function(r,g,b,a***REMOVED***{
  return new RGBA(
      this.r + r
    , this.g + g
    , this.b + b
    , this.a + a***REMOVED***;
};

/**
 * Subtract r,g,b,a from the current component values.
 *
 * @param {Number} r
 * @param {Number} g
 * @param {Number} b
 * @param {Number} a
 * @return {RGBA} new node
 * @api public
 */

RGBA.prototype.sub = function(r,g,b,a***REMOVED***{
  return new RGBA(
      this.r - r
    , this.g - g
    , this.b - b
    , a == 1 ? this.a : this.a - a***REMOVED***;
};

/**
 * Multiply rgb components by `n`.
 *
 * @param {String} n
 * @return {RGBA} new node
 * @api public
 */

RGBA.prototype.multiply = function(n***REMOVED***{
  return new RGBA(
      this.r * n
    , this.g * n
    , this.b * n
    , this.a***REMOVED***; 
};

/**
 * Divide rgb components by `n`.
 *
 * @param {String} n
 * @return {RGBA} new node
 * @api public
 */

RGBA.prototype.divide = function(n***REMOVED***{
  return new RGBA(
      this.r / n
    , this.g / n
    , this.b / n
    , this.a***REMOVED***; 
};

/**
 * Operate on `right` with the given `op`.
 *
 * @param {String} op
 * @param {Node} right
 * @return {Node}
 * @api public
 */

RGBA.prototype.operate = function(op, right***REMOVED***{
  if ('in' != op***REMOVED*** right = right.first

  switch (op***REMOVED*** {
    case 'is a':
      if ('string' == right.nodeName && 'color' == right.string***REMOVED*** {
        return nodes.true;
    ***REMOVED***
      break;
    case '+':
      switch (right.nodeName***REMOVED*** {
        case 'unit':
          var n = right.val;
          switch (right.type***REMOVED*** {
            case '%': return adjust(this, new nodes.String('lightness'***REMOVED***, right***REMOVED***;
            case 'deg': return this.hsla.adjustHue(n***REMOVED***.rgba;
            default: return this.add(n,n,n,0***REMOVED***;
        ***REMOVED***
        case 'rgba':
          return this.add(right.r, right.g, right.b, right.a***REMOVED***;
        case 'hsla':
          return this.hsla.add(right.h, right.s, right.l***REMOVED***;
    ***REMOVED***
      break;
    case '-':
      switch (right.nodeName***REMOVED*** {
        case 'unit':
          var n = right.val;
          switch (right.type***REMOVED*** {
            case '%': return adjust(this, new nodes.String('lightness'***REMOVED***, new nodes.Unit(-n, '%'***REMOVED******REMOVED***;
            case 'deg': return this.hsla.adjustHue(-n***REMOVED***.rgba;
            default: return this.sub(n,n,n,0***REMOVED***;
        ***REMOVED***
        case 'rgba':
          return this.sub(right.r, right.g, right.b, right.a***REMOVED***;
        case 'hsla':
          return this.hsla.sub(right.h, right.s, right.l***REMOVED***;
    ***REMOVED***
      break;
    case '*':
      switch (right.nodeName***REMOVED*** {
        case 'unit':
          return this.multiply(right.val***REMOVED***;
    ***REMOVED***
      break;
    case '/':
      switch (right.nodeName***REMOVED*** {
        case 'unit':
          return this.divide(right.val***REMOVED***;
    ***REMOVED***
      break;
***REMOVED***
  return Node.prototype.operate.call(this, op, right***REMOVED***;
};

/**
 * Return #nnnnnn, #nnn, or rgba(n,n,n,n***REMOVED*** string representation of the color.
 *
 * @return {String}
 * @api public
 */

RGBA.prototype.toString = function(***REMOVED***{
  function pad(n***REMOVED*** {
    return n < 16
      ? '0' + n.toString(16***REMOVED***
      : n.toString(16***REMOVED***;
***REMOVED***

  if (1 == this.a***REMOVED*** {
    var r = pad(this.r***REMOVED***
      , g = pad(this.g***REMOVED***
      , b = pad(this.b***REMOVED***;

    // Compress
    if (r[0] == r[1] && g[0] == g[1] && b[0] == b[1]***REMOVED*** {
      return '#' + r[0] + g[0] + b[0];
  ***REMOVED*** else {
      return '#' + r + g + b;
  ***REMOVED***
***REMOVED*** else {
    return 'rgba('
      + this.r + ','
      + this.g + ','
      + this.b + ','
      + (+this.a.toFixed(3***REMOVED******REMOVED*** + '***REMOVED***';
***REMOVED***
};

/**
 * Return a `RGBA` from the given `hsla`.
 *
 * @param {HSLA} hsla
 * @return {RGBA}
 * @api public
 */

exports.fromHSLA = function(hsla***REMOVED***{
  var h = hsla.h / 360
    , s = hsla.s / 100
    , l = hsla.l / 100
    , a = hsla.a;

  var m2 = l <= .5 ? l * (s + 1***REMOVED*** : l + s - l * s
    , m1 = l * 2 - m2;

  var r = hue(h + 1/3***REMOVED*** * 0xff
    , g = hue(h***REMOVED*** * 0xff
    , b = hue(h - 1/3***REMOVED*** * 0xff;

  function hue(h***REMOVED*** {
    if (h < 0***REMOVED*** ++h;
    if (h > 1***REMOVED*** --h;
    if (h * 6 < 1***REMOVED*** return m1 + (m2 - m1***REMOVED*** * h * 6;
    if (h * 2 < 1***REMOVED*** return m2;
    if (h * 3 < 2***REMOVED*** return m1 + (m2 - m1***REMOVED*** * (2/3 - h***REMOVED*** * 6;
    return m1;
***REMOVED***
  
  return new RGBA(r,g,b,a***REMOVED***;
};

/**
 * Clamp `n` >= 0 and <= 255.
 *
 * @param {Number} n
 * @return {Number}
 * @api private
 */

function clamp(n***REMOVED*** {
  return Math.max(0, Math.min(n.toFixed(0***REMOVED***, 255***REMOVED******REMOVED***;
}

/**
 * Clamp alpha `n` >= 0 and <= 1.
 *
 * @param {Number} n
 * @return {Number}
 * @api private
 */

function clampAlpha(n***REMOVED*** {
  return Math.max(0, Math.min(n, 1***REMOVED******REMOVED***;
}
