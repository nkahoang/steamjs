
/*!
 * Stylus - Node
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Evaluator = require('../visitor/evaluator'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , nodes = require('./'***REMOVED***;

/**
 * Node constructor.
 *
 * @api public
 */

var Node = module.exports = function Node(***REMOVED***{
  this.lineno = nodes.lineno;
  Object.defineProperty(this, 'filename', { writable: true, value: nodes.filename }***REMOVED***;
};

/**
 * Return this node.
 *
 * @return {Node}
 * @api public
 */

Node.prototype.__defineGetter__('first', function(***REMOVED***{
  return this;
}***REMOVED***;

/**
 * Return hash.
 *
 * @return {String}
 * @api public
 */

Node.prototype.__defineGetter__('hash', function(***REMOVED***{
  return this.val;
}***REMOVED***;

/**
 * Return node name.
 *
 * @return {String}
 * @api public
 */

Node.prototype.__defineGetter__('nodeName', function(***REMOVED***{
  return this.constructor.name.toLowerCase(***REMOVED***;
}***REMOVED***;

/**
 * Return this node.
 * 
 * @return {Node}
 * @api public
 */

Node.prototype.clone = function(***REMOVED***{
  return this;
};

/**
 * Nodes by default evaluate to themselves.
 *
 * @return {Node}
 * @api public
 */

Node.prototype.eval = function(***REMOVED***{
  return new Evaluator(this***REMOVED***.evaluate(***REMOVED***;
};

/**
 * Return true.
 *
 * @return {Boolean}
 * @api public
 */

Node.prototype.toBoolean = function(***REMOVED***{
  return nodes.true;
};

/**
 * Return the expression, or wrap this node in an expression.
 *
 * @return {Expression}
 * @api public
 */

Node.prototype.toExpression = function(***REMOVED***{
  if ('expression' == this.nodeName***REMOVED*** return this;
  var expr = new nodes.Expression;
  expr.push(this***REMOVED***;
  return expr;
};

/**
 * Return false if `op` is generally not coerced.
 *
 * @param {String} op
 * @return {Boolean}
 * @api private
 */

Node.prototype.shouldCoerce = function(op***REMOVED***{
  switch (op***REMOVED*** {
    case 'is a':
    case 'in':
    case '||':
    case '&&':
      return false;
    default:
      return true;
***REMOVED***
};

/**
 * Operate on `right` with the given `op`.
 *
 * @param {String} op
 * @param {Node} right
 * @return {Node}
 * @api public
 */

Node.prototype.operate = function(op, right***REMOVED***{
  switch (op***REMOVED*** {
    case 'is a':
      if ('string' == right.nodeName***REMOVED*** {
        return nodes.Boolean(this.nodeName == right.val***REMOVED***;
    ***REMOVED*** else {
        throw new Error('"is a" expects a string, got ' + right.toString(***REMOVED******REMOVED***;
    ***REMOVED***
    case '==':
      return nodes.Boolean(this.hash == right.hash***REMOVED***;
    case '!=':
      return nodes.Boolean(this.hash != right.hash***REMOVED***;
    case '>=':
      return nodes.Boolean(this.hash >= right.hash***REMOVED***;
    case '<=':
      return nodes.Boolean(this.hash <= right.hash***REMOVED***;
    case '>':
      return nodes.Boolean(this.hash > right.hash***REMOVED***;
    case '<':
      return nodes.Boolean(this.hash < right.hash***REMOVED***;
    case '||':
      return this.toBoolean(***REMOVED***.isTrue
        ? this
        : right;
    case 'in':
      var vals = utils.unwrap(right***REMOVED***.nodes
        , len = vals.length
        , hash = this.hash;
      if (!vals***REMOVED*** throw new Error('"in" given invalid right-hand operand, expecting an expression'***REMOVED***;

      // 'prop' in obj
      if (1 == len && 'object' == vals[0].nodeName***REMOVED*** {
        return nodes.Boolean(vals[0].has(this.hash***REMOVED******REMOVED***;
    ***REMOVED***

      for (var i = 0; i < len; ++i***REMOVED*** {
        if (hash == vals[i].hash***REMOVED*** {
          return nodes.true;
      ***REMOVED***
    ***REMOVED***
      return nodes.false;
    case '&&':
      var a = this.toBoolean(***REMOVED***
        , b = right.toBoolean(***REMOVED***;
      return a.isTrue && b.isTrue
        ? right
        : a.isFalse
          ? this
          : right;
    default:
      if ('[]' == op***REMOVED*** {
        var msg = 'cannot perform '
          + this
          + '[' + right + ']';
    ***REMOVED*** else {
        var msg = 'cannot perform'
          + ' ' + this
          + ' ' + op
          + ' ' + right;
    ***REMOVED***
      throw new Error(msg***REMOVED***;
***REMOVED***
};

/**
 * Initialize a new `CoercionError` with the given `msg`.
 *
 * @param {String} msg
 * @api private
 */

function CoercionError(msg***REMOVED*** {
  this.name = 'CoercionError'
  this.message = msg
  Error.captureStackTrace(this, CoercionError***REMOVED***;
}

/**
 * Inherit from `Error.prototype`.
 */

CoercionError.prototype.__proto__ = Error.prototype;

/**
 * Default coercion throws.
 *
 * @param {Node} other
 * @return {Node}
 * @api public
 */

Node.prototype.coerce = function(other***REMOVED***{
  if (other.nodeName == this.nodeName***REMOVED*** return other;
  throw new CoercionError('cannot coerce ' + other + ' to ' + this.nodeName***REMOVED***;
};
