
/*!
 * Stylus - Renderer
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Parser = require('./parser'***REMOVED***
  , EventEmitter = require('events'***REMOVED***.EventEmitter
  , Compiler = require('./visitor/compiler'***REMOVED***
  , Evaluator = require('./visitor/evaluator'***REMOVED***
  , Normalizer = require('./visitor/normalizer'***REMOVED***
  , events = new EventEmitter
  , utils = require('./utils'***REMOVED***
  , nodes = require('./nodes'***REMOVED***
  , ***REMOVED***
  , join = path.join;

/**
 * Expose `Renderer`.
 */

module.exports = Renderer;

/**
 * Initialize a new `Renderer` with the given `str` and `options`.
 *
 * @param {String} str
 * @param {Object} options
 * @api public
 */

function Renderer(str, options***REMOVED*** {
  options = options || {};
  options.globals = {};
  options.functions = {};
  options.imports = [join(__dirname, 'functions'***REMOVED***];
  options.paths = options.paths || [];
  options.filename = options.filename || 'stylus';
  options.Evaluator = options.Evaluator || Evaluator;
  this.options = options;
  this.str = str;
  this.events = events;
};

/**
 * Inherit from `EventEmitter.prototype`.
 */

Renderer.prototype.__proto__ = EventEmitter.prototype;

/**
 * Expose events explicitly.
 */

module.exports.events = events;

/**
 * Parse and evaluate AST, then callback `fn(err, css, js***REMOVED***`.
 *
 * @param {Function} fn
 * @api public
 */

Renderer.prototype.render = function(fn***REMOVED***{
  var parser = this.parser = new Parser(this.str, this.options***REMOVED***;
  try {
    nodes.filename = this.options.filename;
    // parse
    var ast = parser.parse(***REMOVED***;

    // evaluate
    this.evaluator = new this.options.Evaluator(ast, this.options***REMOVED***;
    this.nodes = nodes;
    this.evaluator.renderer = this;
    ast = this.evaluator.evaluate(***REMOVED***;

    // normalize
    var normalizer = new Normalizer(ast, this.options***REMOVED***;
    ast = normalizer.normalize(***REMOVED***;

    // compile
    var compiler = new Compiler(ast, this.options***REMOVED***
      , css = compiler.compile(***REMOVED***;

    var listeners = this.listeners('end'***REMOVED***;
    if (fn***REMOVED*** listeners.push(fn***REMOVED***;
    for (var i = 0, len = listeners.length; i < len; i++***REMOVED*** {
      var ret = listeners[i](null, css***REMOVED***;
      if (ret***REMOVED*** css = ret;
  ***REMOVED***
    if (!fn***REMOVED*** return css;
***REMOVED*** catch (err***REMOVED*** {
    var options = {};
    options.input = err.input || this.str;
    options.filename = err.filename || this.options.filename;
    options.lineno = err.lineno || parser.lexer.lineno;
    if (!fn***REMOVED*** throw utils.formatException(err, options***REMOVED***;
    fn(utils.formatException(err, options***REMOVED******REMOVED***;
***REMOVED***
};

/**
 * Get dependencies of the compiled file.
 *
 * @param {String} [filename]
 * @return {Array}
 * @api public
 */

Renderer.prototype.deps = function(filename***REMOVED***{
  if (filename***REMOVED*** this.options.filename = filename;

  var DepsResolver = require('./visitor/deps-resolver'***REMOVED***
    , parser = new Parser(this.str, this.options***REMOVED***;

  try {
    nodes.filename = this.options.filename;
    // parse
    var ast = parser.parse(***REMOVED***
      , resolver = new DepsResolver(ast, this.options***REMOVED***;

    // resolve dependencies
    return resolver.resolve(***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    var options = {};
    options.input = err.input || this.str;
    options.filename = err.filename || this.options.filename;
    options.lineno = err.lineno || parser.lexer.lineno;
    throw utils.formatException(err, options***REMOVED***;
***REMOVED***
};

/**
 * Set option `key` to `val`.
 *
 * @param {String} key
 * @param {Mixed} val
 * @return {Renderer} for chaining
 * @api public
 */

Renderer.prototype.set = function(key, val***REMOVED***{
  this.options[key] = val;
  return this;
};

/**
 * Get option `key`.
 *
 * @param {String} key
 * @return {Mixed} val
 * @api public
 */

Renderer.prototype.get = function(key***REMOVED***{
  return this.options[key];
};

/**
 * Include the given `path` to the lookup paths array.
 *
 * @param {String} path
 * @return {Renderer} for chaining
 * @api public
 */

Renderer.prototype.include = function(path***REMOVED***{
  this.options.paths.push(path***REMOVED***;
  return this;
};

/**
 * Use the given `fn`.
 *
 * This allows for plugins to alter the renderer in
 * any way they wish, exposing paths etc.
 *
 * @param {Function}
 * @return {Renderer} for chaining
 * @api public
 */

Renderer.prototype.use = function(fn***REMOVED***{
  fn.call(this, this***REMOVED***;
  return this;
};

/**
 * Define function or global var with the given `name`. Optionally
 * the function may accept full expressions, by setting `raw`
 * to `true`.
 *
 * @param {String} name
 * @param {Function|Node} fn
 * @return {Renderer} for chaining
 * @api public
 */

Renderer.prototype.define = function(name, fn, raw***REMOVED***{
  fn = utils.coerce(fn, raw***REMOVED***;

  if (fn.nodeName***REMOVED*** {
    this.options.globals[name] = fn;
    return this;
***REMOVED***

  // function
  this.options.functions[name] = fn;
  if (undefined != raw***REMOVED*** fn.raw = raw;
  return this;
};

/**
 * Import the given `file`.
 *
 * @param {String} file
 * @return {Renderer} for chaining
 * @api public
 */

Renderer.prototype.import = function(file***REMOVED***{
  this.options.imports.push(file***REMOVED***;
  return this;
};


