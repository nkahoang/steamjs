
/*!
 * Stylus - utils
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var nodes = require('./nodes'***REMOVED***
  , basename = require('path'***REMOVED***.basename
  , relative = require('path'***REMOVED***.relative
  , join = require('path'***REMOVED***.join
  , resolve = require('path'***REMOVED***.resolve
  , glob = require('glob'***REMOVED***
  , fs = require('fs'***REMOVED***;

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.absolute = function(path***REMOVED***{
  // On Windows the path could start with a drive letter, i.e. a:\\ or two leading backslashes
  return path.substr(0, 2***REMOVED*** == '\\\\' || '/' === path.charAt(0***REMOVED*** || /^[a-z]:\\/i.test(path***REMOVED***;
};

/**
 * Attempt to lookup `path` within `paths` from tail to head.
 * Optionally a path to `ignore` may be passed.
 *
 * @param {String} path
 * @param {String} paths
 * @param {String} ignore
 * @param {Boolean} resolveURL
 * @return {String}
 * @api private
 */

exports.lookup = function(path, paths, ignore, resolveURL***REMOVED***{
  var lookup
    , method = resolveURL ? resolve : join
    , i = paths.length;

  // Absolute
  if (exports.absolute(path***REMOVED******REMOVED*** {
    try {
      fs.statSync(path***REMOVED***;
      return path;
  ***REMOVED*** catch (err***REMOVED*** {
      // Ignore, continue on
      // to trying relative lookup.
      // Needed for url(/images/foo.png***REMOVED***
      // for example
  ***REMOVED***
***REMOVED***

  // Relative
  while (i--***REMOVED*** {
    try {
      lookup = method(paths[i], path***REMOVED***;
      if (ignore == lookup***REMOVED*** continue;
      fs.statSync(lookup***REMOVED***;
      return lookup;
  ***REMOVED*** catch (err***REMOVED*** {
      // Ignore
  ***REMOVED***
***REMOVED***
};

/**
 * Like `utils.lookup` but uses `glob` to find files.
 *
 * @param {String} path
 * @param {String} paths
 * @param {String} ignore
 * @return {Array}
 * @api private
 */
exports.find = function(path, paths, ignore***REMOVED*** {
  var lookup
    , found
    , i = paths.length;

  // Absolute
  if (exports.absolute(path***REMOVED******REMOVED*** {
    if ((found = glob.sync(path***REMOVED******REMOVED***.length***REMOVED*** {
      return found;
  ***REMOVED***
***REMOVED***

  // Relative
  while (i--***REMOVED*** {
    lookup = join(paths[i], path***REMOVED***;
    if (ignore == lookup***REMOVED*** continue;
    if ((found = glob.sync(lookup***REMOVED******REMOVED***.length***REMOVED*** {
      return found;
  ***REMOVED***
***REMOVED***
};

/**
 * Lookup index file inside dir with given `name`.
 *
 * @param {String} name
 * @return {Array}
 * @api private
 */

exports.lookupIndex = function(name, paths, filename***REMOVED***{
  // foo/index.styl
  var found = exports.find(join(name, 'index.styl'***REMOVED***, paths, filename***REMOVED***;
  if (!found***REMOVED*** {
    // foo/foo.styl
    found = exports.find(join(name, basename(name***REMOVED***.replace(/\.styl/i, ''***REMOVED*** + '.styl'***REMOVED***, paths, filename***REMOVED***;
***REMOVED***
  if (!found && !~name.indexOf('node_modules'***REMOVED******REMOVED*** {
    // node_modules/foo/.. or node_modules/foo.styl/..
    found = lookupPackage(join('node_modules', name***REMOVED******REMOVED***;
***REMOVED***
  return found;

  function lookupPackage(dir***REMOVED*** {
    var package = exports.lookup(join(dir, 'package.json'***REMOVED***, paths, filename***REMOVED***;
    if (!package***REMOVED*** {
      return /\.styl$/i.test(dir***REMOVED*** ? exports.lookupIndex(dir, paths, filename***REMOVED*** : lookupPackage(dir + '.styl'***REMOVED***;
  ***REMOVED***
    var main = require(relative(__dirname, package***REMOVED******REMOVED***.main;
    if (main***REMOVED*** {
      found = exports.find(join(dir, main***REMOVED***, paths, filename***REMOVED***;
  ***REMOVED*** else {
      found = exports.lookupIndex(dir, paths, filename***REMOVED***;
  ***REMOVED***
    return found;
***REMOVED***
};

/**
 * Format the given `err` with the given `options`.
 *
 * Options:
 *
 *   - `filename`   context filename
 *   - `context`    context line count [8]
 *   - `lineno`     context line number
 *   - `input`        input string
 *
 * @param {Error} err
 * @param {Object} options
 * @return {Error}
 * @api private
 */

exports.formatException = function(err, options***REMOVED***{
  var lineno = options.lineno
    , filename = options.filename
    , str = options.input
    , context = options.context || 8
    , context = context / 2
    , lines = ('\n' + str***REMOVED***.split('\n'***REMOVED***
    , start = Math.max(lineno - context, 1***REMOVED***
    , end = Math.min(lines.length, lineno + context***REMOVED***
    , pad = end.toString(***REMOVED***.length;

  var context = lines.slice(start, end***REMOVED***.map(function(line, i***REMOVED***{
    var curr = i + start;
    return (curr == lineno ? ' > ' : '   '***REMOVED***
      + Array(pad - curr.toString(***REMOVED***.length + 1***REMOVED***.join(' '***REMOVED***
      + curr
      + '| '
      + line;
***REMOVED******REMOVED***.join('\n'***REMOVED***;

  err.message = filename
    + ':' + lineno
    + '\n' + context
    + '\n\n' + err.message + '\n'
    + (err.stylusStack ? err.stylusStack + '\n' : ''***REMOVED***;

  return err;
};

/**
 * Assert that `node` is of the given `type`, or throw.
 *
 * @param {Node} node
 * @param {Function} type
 * @param {String} param
 * @api public
 */

exports.assertType = function(node, type, param***REMOVED***{
  exports.assertPresent(node, param***REMOVED***;
  if (node.nodeName == type***REMOVED*** return;
  var actual = node.nodeName
    , msg = 'expected "'
      + param + '" to be a '
      + type + ', but got '
      + actual + ':' + node;
  throw new Error('TypeError: ' + msg***REMOVED***;
};

/**
 * Assert that `node` is a `String` or `Ident`.
 *
 * @param {Node} node
 * @param {String} param
 * @api public
 */

exports.assertString = function(node, param***REMOVED***{
  exports.assertPresent(node, param***REMOVED***;
  switch (node.nodeName***REMOVED*** {
    case 'string':
    case 'ident':
    case 'literal':
      return;
    default:
      var actual = node.nodeName
        , msg = 'expected string, ident or literal, but got ' + actual + ':' + node;
      throw new Error('TypeError: ' + msg***REMOVED***;
***REMOVED***
};

/**
 * Assert that `node` is a `RGBA` or `HSLA`.
 *
 * @param {Node} node
 * @param {String} param
 * @api public
 */

exports.assertColor = function(node, param***REMOVED***{
  exports.assertPresent(node, param***REMOVED***;
  switch (node.nodeName***REMOVED*** {
    case 'rgba':
    case 'hsla':
      return;
    default:
      var actual = node.nodeName
        , msg = 'expected rgba or hsla, but got ' + actual + ':' + node;
      throw new Error('TypeError: ' + msg***REMOVED***;
***REMOVED***
};

/**
 * Assert that param `name` is given, aka the `node` is passed.
 *
 * @param {Node} node
 * @param {String} name
 * @api public
 */

exports.assertPresent = function(node, name***REMOVED***{
  if (node***REMOVED*** return;
  if (name***REMOVED*** throw new Error('"' + name + '" argument required'***REMOVED***;
  throw new Error('argument missing'***REMOVED***;
};

/**
 * Unwrap `expr`.
 *
 * Takes an expressions with length of 1
 * such as `((1 2 3***REMOVED******REMOVED***` and unwraps it to `(1 2 3***REMOVED***`.
 *
 * @param {Expression} expr
 * @return {Node}
 * @api public
 */

exports.unwrap = function(expr***REMOVED***{
  // explicitly preserve the expression
  if (expr.preserve***REMOVED*** return expr;
  if ('arguments' != expr.nodeName && 'expression' != expr.nodeName***REMOVED*** return expr;
  if (1 != expr.nodes.length***REMOVED*** return expr;
  if ('arguments' != expr.nodes[0].nodeName && 'expression' != expr.nodes[0].nodeName***REMOVED*** return expr;
  return exports.unwrap(expr.nodes[0]***REMOVED***;
};

/**
 * Coerce JavaScript values to their Stylus equivalents.
 *
 * @param {Mixed} val
 * @param {Boolean} [raw]
 * @return {Node}
 * @api public
 */

exports.coerce = function(val, raw***REMOVED***{
  switch (typeof val***REMOVED*** {
    case 'function':
      return val;
    case 'string':
      return new nodes.String(val***REMOVED***;
    case 'boolean':
      return new nodes.Boolean(val***REMOVED***;
    case 'number':
      return new nodes.Unit(val***REMOVED***;
    default:
      if (null == val***REMOVED*** return nodes.null;
      if (Array.isArray(val***REMOVED******REMOVED*** return exports.coerceArray(val, raw***REMOVED***;
      if (val.nodeName***REMOVED*** return val;
      return exports.coerceObject(val, raw***REMOVED***;
***REMOVED***
};

/**
 * Coerce a javascript `Array` to a Stylus `Expression`.
 *
 * @param {Array} val
 * @param {Boolean} [raw]
 * @return {Expression}
 * @api private
 */

exports.coerceArray = function(val, raw***REMOVED***{
  var expr = new nodes.Expression;
  val.forEach(function(val***REMOVED***{
    expr.push(exports.coerce(val, raw***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
  return expr;
};

/**
 * Coerce a javascript object to a Stylus `Expression` or `Object`.
 *
 * For example `{ foo: 'bar', bar: 'baz' }` would become
 * the expression `(foo 'bar'***REMOVED*** (bar 'baz'***REMOVED***`. If `raw` is true
 * given `obj` would become a Stylus hash object.
 *
 * @param {Object} obj
 * @param {Boolean} [raw]
 * @return {Expression|Object}
 * @api public
 */

exports.coerceObject = function(obj, raw***REMOVED***{
  var node = raw ? new nodes.Object : new nodes.Expression
    , val;

  for (var key in obj***REMOVED*** {
    val = exports.coerce(obj[key], raw***REMOVED***;
    key = new nodes.Ident(key***REMOVED***;
    if (raw***REMOVED*** {
      node.set(key, val***REMOVED***;
  ***REMOVED*** else {
      node.push(exports.coerceArray([key, val]***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***

  return node;
};

/**
 * Return param names for `fn`.
 *
 * @param {Function} fn
 * @return {Array}
 * @api private
 */

exports.params = function(fn***REMOVED***{
  return fn
    .toString(***REMOVED***
    .match(/\(([^***REMOVED***]****REMOVED***\***REMOVED***/***REMOVED***[1].split(/ *, */***REMOVED***;
};

/**
 * Merge object `b` with `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function(a, b***REMOVED***{
  for (var k in b***REMOVED*** a[k] = b[k];
  return a;
};

/**
 * Returns an array with unique values.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.uniq = function(arr***REMOVED***{
  var obj = {}
    , ret = [];

  for (var i = 0, len = arr.length; i < len; ++i***REMOVED*** {
    if (arr[i] in obj***REMOVED*** continue;

    obj[arr[i]] = true;
    ret.push(arr[i]***REMOVED***;
***REMOVED***
  return ret;
};

/**
 * Compile selector strings in `arr` from the bottom-up
 * to produce the selector combinations. For example
 * the following Stylus:
 *
 *    ul
 *      li
 *      p
 *        a
 *          color: red
 *
 * Would return:
 *
 *      [ 'ul li a', 'ul p a' ]
 *
 * @param {Array} arr
 * @param {Boolean} leaveHidden
 * @return {Array}
 * @api private
 */

exports.compileSelectors = function(arr, leaveHidden***REMOVED***{
  var self = this
    , selectors = []
    , buf = []
    , hiddenSelectorRegexp = /^\s*\/?\$/;

  function interpolateParent(selector, buf***REMOVED*** {
    var str = selector.val.replace(/^\//g, ''***REMOVED***.trim(***REMOVED***;
    if (buf.length***REMOVED*** {
      for (var i = 0, len = buf.length; i < len; ++i***REMOVED*** {
        if (~buf[i].indexOf('&'***REMOVED*** || '/' === buf[i].charAt(0***REMOVED******REMOVED*** {
          str = buf[i].replace(/&/g, str***REMOVED***.replace(/^\//g, ''***REMOVED***.trim(***REMOVED***;
      ***REMOVED*** else {
          str += ' ' + buf[i].trim(***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return str.trim(***REMOVED***;
***REMOVED***

  function compile(arr, i***REMOVED*** {
    if (i***REMOVED*** {
      arr[i].forEach(function(selector***REMOVED***{
        if (!leaveHidden && selector.val.match(hiddenSelectorRegexp***REMOVED******REMOVED*** return;
        if (selector.inherits***REMOVED*** {
          buf.unshift(selector.val***REMOVED***;
          compile(arr, i - 1***REMOVED***;
          buf.shift(***REMOVED***;
      ***REMOVED*** else {
          selectors.push(interpolateParent(selector, buf***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED*** else {
      arr[0].forEach(function(selector***REMOVED***{
        if (!leaveHidden && selector.val.match(hiddenSelectorRegexp***REMOVED******REMOVED*** return;
        var str = interpolateParent(selector, buf***REMOVED***;
        if (~str.indexOf('&'***REMOVED******REMOVED*** str = str.replace(/&/g, ''***REMOVED***.trim(***REMOVED***;
        if (!str.length***REMOVED*** return;
        selectors.push((self.indent || ''***REMOVED*** + str.trimRight(***REMOVED******REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***

  compile(arr, arr.length - 1***REMOVED***;

  // Return the list with unique selectors only
  return selectors.filter(function(value, index, self***REMOVED***{
    return self.indexOf(value***REMOVED*** === index;
***REMOVED******REMOVED***;
};
