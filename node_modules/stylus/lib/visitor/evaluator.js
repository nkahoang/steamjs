
/*!
 * Stylus - Evaluator
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Visitor = require('./'***REMOVED***
  , units = require('../units'***REMOVED***
  , nodes = require('../nodes'***REMOVED***
  , Stack = require('../stack'***REMOVED***
  , Frame = require('../stack/frame'***REMOVED***
  , Scope = require('../stack/scope'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , bifs = require('../functions'***REMOVED***
  , dirname = require('path'***REMOVED***.dirname
  , colors = require('../colors'***REMOVED***
  , debug = require('debug'***REMOVED***('stylus:evaluator'***REMOVED***
  , fs = require('fs'***REMOVED***;

/**
 * Clone the block node within the each loop so we don't keep
 * extending the same block in multiple contexts
 *
 * @param {Node}
 * @return {Node}
 */
function cloneNode (node***REMOVED*** {
  if (node.block && node.block.node***REMOVED*** {
    node.block.node = node.block.node.clone(***REMOVED***;
***REMOVED***
  if (node.nodes && node.nodes.length***REMOVED*** {
    node.nodes.map(cloneNode***REMOVED***;
***REMOVED***
  return node;
}

/**
 * Import `file` and return Block node.
 *
 * @api private
 */
function importFile(node, file, literal, index***REMOVED*** {
  var importStack = this.importStack
    , Parser = require('../parser'***REMOVED***
    , stat;

  // Handling the `require`
  if (node.once***REMOVED*** {
    if (this.requireHistory[file]***REMOVED*** return nodes.null;
    this.requireHistory[file] = true;

    if (literal && !this.includeCSS***REMOVED*** {
      return node;
  ***REMOVED***
***REMOVED***

  // Expose imports
  node.path = file;
  node.dirname = dirname(file***REMOVED***;
  // Store the modified time
  stat = fs.statSync(file***REMOVED***;
  node.mtime = stat.mtime;
  this.paths.push(node.dirname***REMOVED***;

  // Avoid overflows from importing the same file over again
  if (file === importStack[importStack.length - 1]***REMOVED*** return nodes.null;

  if (this.options._imports***REMOVED*** this.options._imports.push(node.clone(***REMOVED******REMOVED***;

  // Parse the file
  importStack.push(file***REMOVED***;
  nodes.filename = file;

  var str = fs.readFileSync(file, 'utf8'***REMOVED***;
  if (literal && !this.resolveURL***REMOVED*** return new nodes.Literal(str.replace(/\r\n?/g, '\n'***REMOVED******REMOVED***;

  // parse
  var block = new nodes.Block
    , parser = new Parser(str, utils.merge({ root: block }, this.options***REMOVED******REMOVED***;

  try {
    block = parser.parse(***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    err.filename = file;
    err.lineno = parser.lexer.lineno;
    err.input = str;
    throw err;
***REMOVED***

  // Evaluate imported "root"
  block.parent = this.root;
  block.scope = false;
  var ret = this.visit(block***REMOVED***;
  importStack.pop(***REMOVED***;
  if (importStack.length || index***REMOVED*** this.paths.pop(***REMOVED***;

  return ret;
}

/**
 * Initialize a new `Evaluator` with the given `root` Node
 * and the following `options`.
 *
 * Options:
 *
 *   - `compress`  Compress the css output, defaults to false
 *   - `warn`  Warn the user of duplicate function definitions etc
 *
 * @param {Node} root
 * @api private
 */

var Evaluator = module.exports = function Evaluator(root, options***REMOVED*** {
  options = options || {};
  Visitor.call(this, root***REMOVED***;
  this.stack = new Stack;
  this.imports = options.imports || [];
  this.functions = options.functions || {};
  this.globals = options.globals || {};
  this.paths = options.paths || [];
  this.prefix = options.prefix || '';
  this.filename = options.filename;
  this.includeCSS = options['include css'];
  this.resolveURL = options['resolve url'];
  this.paths.push(dirname(options.filename || '.'***REMOVED******REMOVED***;
  this.stack.push(this.global = new Frame(root***REMOVED******REMOVED***;
  this.warnings = options.warn;
  this.options = options;
  this.calling = []; // TODO: remove, use stack
  this.importStack = [];
  this.requireHistory = {};
  this.return = 0;
};

/**
 * Inherit from `Visitor.prototype`.
 */

Evaluator.prototype.__proto__ = Visitor.prototype;

/**
 * Proxy visit to expose node line numbers.
 *
 * @param {Node} node
 * @return {Node}
 * @api private
 */

var visit = Visitor.prototype.visit;
Evaluator.prototype.visit = function(node***REMOVED***{
  try {
    return visit.call(this, node***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    if (err.filename***REMOVED*** throw err;
    err.lineno = node.lineno;
    err.filename = node.filename;
    err.stylusStack = this.stack.toString(***REMOVED***;
    try {
      err.input = fs.readFileSync(err.filename, 'utf8'***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
      // ignore
  ***REMOVED***
    throw err;
***REMOVED***
};

/**
 * Perform evaluation setup:
 *
 *   - populate global scope
 *   - iterate imports
 *
 * @api private
 */

Evaluator.prototype.setup = function(***REMOVED***{
  var root = this.root;
  var imports = [];

  this.populateGlobalScope(***REMOVED***;
  this.imports.forEach(function(file***REMOVED***{
    var expr = new nodes.Expression;
    expr.push(new nodes.String(file***REMOVED******REMOVED***;
    imports.push(new nodes.Import(expr***REMOVED******REMOVED***;
***REMOVED***, this***REMOVED***;

  root.nodes = imports.concat(root.nodes***REMOVED***;
};

/**
 * Populate the global scope with:
 *
 *   - css colors
 *   - user-defined globals
 *
 * @api private
 */

Evaluator.prototype.populateGlobalScope = function(***REMOVED***{
  var scope = this.global.scope;

  // colors
  Object.keys(colors***REMOVED***.forEach(function(name***REMOVED***{
    var rgb = colors[name]
      , rgba = new nodes.RGBA(rgb[0], rgb[1], rgb[2], 1***REMOVED***
      , node = new nodes.Ident(name, rgba***REMOVED***;
    scope.add(node***REMOVED***;
***REMOVED******REMOVED***;

  // user-defined globals
  var globals = this.globals;
  Object.keys(globals***REMOVED***.forEach(function(name***REMOVED***{
    scope.add(new nodes.Ident(name, globals[name]***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
};

/**
 * Evaluate the tree.
 *
 * @return {Node}
 * @api private
 */

Evaluator.prototype.evaluate = function(***REMOVED***{
  debug('eval %s', this.filename***REMOVED***;
  this.setup(***REMOVED***;
  return this.visit(this.root***REMOVED***;
};

/**
 * Visit Group.
 */

Evaluator.prototype.visitGroup = function(group***REMOVED***{
  group.nodes = group.nodes.map(function(selector***REMOVED***{
    selector.val = this.interpolate(selector***REMOVED***;
    debug('ruleset %s', selector.val***REMOVED***;
    return selector;
***REMOVED***, this***REMOVED***;

  group.block = this.visit(group.block***REMOVED***;
  return group;
};

/**
 * Visit Charset.
 */

Evaluator.prototype.visitCharset = function(charset***REMOVED***{
  return charset;
};

/**
 * Visit Return.
 */

Evaluator.prototype.visitReturn = function(ret***REMOVED***{
  ret.expr = this.visit(ret.expr***REMOVED***;
  throw ret;
};

/**
 * Visit Media.
 */

Evaluator.prototype.visitMedia = function(media***REMOVED***{
  media.block = this.visit(media.block***REMOVED***;
  media.val = this.visit(media.val***REMOVED***;
  return media;
};

/**
 * Visit QueryList.
 */

Evaluator.prototype.visitQueryList = function(queries***REMOVED***{
  queries.nodes.forEach(this.visit, this***REMOVED***;
  return queries;
};

/**
 * Visit Query.
 */

Evaluator.prototype.visitQuery = function(node***REMOVED***{
  node.predicate = this.visit(node.predicate***REMOVED***;
  node.nodes.forEach(this.visit, this***REMOVED***;
  return node;
};

/**
 * Visit QueryExpr.
 */

Evaluator.prototype.visitQueryExpr = function(node***REMOVED***{
  var val;
  node.name = node.name || this.interpolate(node***REMOVED***;
  if (node.expr***REMOVED*** node.expr = this.visit(node.expr***REMOVED***;
  if (val = this.lookup(node.name***REMOVED******REMOVED*** {
    node.name = new nodes.Literal(val.first.string || val.first.name***REMOVED***;
***REMOVED***
  return node;
};

/**
 * Visit MozDocument.
 */

Evaluator.prototype.visitMozDocument = function(mozdocument***REMOVED***{
  mozdocument.block = this.visit(mozdocument.block***REMOVED***;
  return mozdocument;
};

/**
 * Visit FontFace.
 */

Evaluator.prototype.visitFontFace = function(face***REMOVED***{
  face.block = this.visit(face.block***REMOVED***;
  return face;
};

/**
 * Visit FontFace.
 */

Evaluator.prototype.visitPage = function(page***REMOVED***{
  page.block = this.visit(page.block***REMOVED***;
  return page;
};

/**
 * Visit Object.
 */

Evaluator.prototype.visitObject = function(obj***REMOVED***{
  for (var key in obj.vals***REMOVED*** {
    obj.vals[key] = this.visit(obj.vals[key]***REMOVED***;
***REMOVED***
  return obj;
};

/**
 * Visit Member.
 */

Evaluator.prototype.visitMember = function(node***REMOVED***{
  var left = node.left
    , right = node.right
    , obj = this.visit(left***REMOVED***.first;

  if ('object' != obj.nodeName***REMOVED*** {
    throw new Error(left.toString(***REMOVED*** + ' has no property .' + right***REMOVED***;
***REMOVED***
  if (node.val***REMOVED*** obj.set(right.name, this.visit(node.val***REMOVED******REMOVED***;
  return obj.get(right.name***REMOVED***;
};

/**
 * Visit Keyframes.
 */

Evaluator.prototype.visitKeyframes = function(keyframes***REMOVED***{
  if (keyframes.fabricated***REMOVED*** return keyframes;
  keyframes.name = this.visit(keyframes.name***REMOVED***.first.name;

  keyframes.frames = keyframes.frames.map(function(frame***REMOVED***{
    frame.block = this.visit(frame.block***REMOVED***;
    return frame;
***REMOVED***, this***REMOVED***;

  if ('official' != keyframes.prefix***REMOVED*** return keyframes;

  this.vendors.forEach(function(prefix***REMOVED***{
    var node = keyframes.clone(***REMOVED***;
    node.prefix = prefix;
    node.fabricated = true;
    this.currentBlock.push(node***REMOVED***;
***REMOVED***, this***REMOVED***;

  return nodes.null;
};

/**
 * Visit Function.
 */

Evaluator.prototype.visitFunction = function(fn***REMOVED***{
  // check local
  var local = this.stack.currentFrame.scope.lookup(fn.name***REMOVED***;
  if (local***REMOVED*** this.warn('local ' + local.nodeName + ' "' + fn.name + '" previously defined in this scope'***REMOVED***;

  // user-defined
  var user = this.functions[fn.name];
  if (user***REMOVED*** this.warn('user-defined function "' + fn.name + '" is already defined'***REMOVED***;

  // BIF
  var bif = bifs[fn.name];
  if (bif***REMOVED*** this.warn('built-in function "' + fn.name + '" is already defined'***REMOVED***;

  return fn;
};

/**
 * Visit Each.
 */

Evaluator.prototype.visitEach = function(each***REMOVED***{
  this.return++;
  var expr = utils.unwrap(this.visit(utils.unwrap(each.expr***REMOVED******REMOVED******REMOVED***
    , len = expr.nodes.length
    , val = new nodes.Ident(each.val***REMOVED***
    , key = new nodes.Ident(each.key || '__index__'***REMOVED***
    , scope = this.currentScope
    , block = this.currentBlock
    , vals = []
    , self = this
    , body
    , obj;
  this.return--;

  each.block.scope = false;

  function visitBody(body***REMOVED*** {
    body = each.block.clone(***REMOVED***;
    body.nodes.map(cloneNode***REMOVED***;
    body = self.visit(body***REMOVED***;
    vals = vals.concat(body.nodes***REMOVED***;
***REMOVED***

  // for prop in obj
  if (1 == len && 'object' == expr.nodes[0].nodeName***REMOVED*** {
    obj = expr.nodes[0];
    for (var prop in obj.vals***REMOVED*** {
      val.val = new nodes.String(prop***REMOVED***;
      key.val = obj.get(prop***REMOVED***;
      scope.add(val***REMOVED***;
      scope.add(key***REMOVED***;
      visitBody(body***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    for (var i = 0; i < len; ++i***REMOVED*** {
      val.val = expr.nodes[i];
      key.val = new nodes.Unit(i***REMOVED***;
      scope.add(val***REMOVED***;
      scope.add(key***REMOVED***;
      visitBody(body***REMOVED***;
  ***REMOVED***
***REMOVED***

  this.mixin(vals, block***REMOVED***;
  return vals[vals.length - 1] || nodes.null;
};

/**
 * Visit Call.
 */

Evaluator.prototype.visitCall = function(call***REMOVED***{
  debug('call %s', call***REMOVED***;
  var fn = this.lookup(call.name***REMOVED***
    , literal
    , ret;

  // url(***REMOVED***
  this.ignoreColors = 'url' == call.name;

  // Variable function
  if (fn && 'expression' == fn.nodeName***REMOVED*** {
    fn = fn.nodes[0];
***REMOVED***

  // Not a function? try user-defined or built-ins
  if (fn && 'function' != fn.nodeName***REMOVED*** {
    fn = this.lookupFunction(call.name***REMOVED***;
***REMOVED***

  // Undefined function? render literal CSS
  if (!fn || fn.nodeName != 'function'***REMOVED*** {
    debug('%s is undefined', call***REMOVED***;
    // Special case for `calc`
    if ('calc' == this.unvendorize(call.name***REMOVED******REMOVED*** {
      literal = call.args.nodes && call.args.nodes[0];
      if (literal***REMOVED*** ret = new nodes.Literal(call.name + literal***REMOVED***;
  ***REMOVED*** else {
      ret = this.literalCall(call***REMOVED***;
  ***REMOVED***
    this.ignoreColors = false;
    return ret;
***REMOVED***

  this.calling.push(call.name***REMOVED***;

  // Massive stack
  if (this.calling.length > 200***REMOVED*** {
    throw new RangeError('Maximum stylus call stack size exceeded'***REMOVED***;
***REMOVED***

  // First node in expression
  if ('expression' == fn.nodeName***REMOVED*** fn = fn.first;

  // Evaluate arguments
  this.return++;
  var args = this.visit(call.args***REMOVED***
    , mapCopy = {};

  for (var key in args.map***REMOVED*** {
    mapCopy[key] = args.map[key];
    args.map[key] = this.visit(mapCopy[key].clone(***REMOVED******REMOVED***;
***REMOVED***
  this.return--;

  // Built-in
  if (fn.fn***REMOVED*** {
    debug('%s is built-in', call***REMOVED***;
    ret = this.invokeBuiltin(fn.fn, args***REMOVED***;
  // User-defined
***REMOVED*** else if ('function' == fn.nodeName***REMOVED*** {
    debug('%s is user-defined', call***REMOVED***;
    // Evaluate mixin block
    if (call.block***REMOVED*** call.block = this.visit(call.block***REMOVED***;
    ret = this.invokeFunction(fn, args, call.block***REMOVED***;
***REMOVED***

  // restore kwargs
  for (key in mapCopy***REMOVED*** {
    args.map[key] = mapCopy[key];
***REMOVED***

  this.calling.pop(***REMOVED***;
  this.ignoreColors = false;
  return ret;
};

/**
 * Visit Ident.
 */

Evaluator.prototype.visitIdent = function(ident***REMOVED***{
  var prop;
  // Property lookup
  if (ident.property***REMOVED*** {
    if (prop = this.lookupProperty(ident.name***REMOVED******REMOVED*** {
      return this.visit(prop.expr.clone(***REMOVED******REMOVED***;
  ***REMOVED***
    return nodes.null;
  // Lookup
***REMOVED*** else if (ident.val.isNull***REMOVED*** {
    var val = this.lookup(ident.name***REMOVED***;
    // Object or Block mixin
    if (val && ident.mixin***REMOVED*** this.mixinNode(val***REMOVED***;
    return val ? this.visit(val***REMOVED*** : ident;
  // Assign
***REMOVED*** else {
    this.return++;
    ident.val = this.visit(ident.val***REMOVED***;
    this.return--;
    this.currentScope.add(ident***REMOVED***;
    return ident.val;
***REMOVED***
};

/**
 * Visit BinOp.
 */

Evaluator.prototype.visitBinOp = function(binop***REMOVED***{
  // Special-case "is defined" pseudo binop
  if ('is defined' == binop.op***REMOVED*** return this.isDefined(binop.left***REMOVED***;

  this.return++;
  // Visit operands
  var op = binop.op
    , left = this.visit(binop.left***REMOVED***
    , right = this.visit(binop.right***REMOVED***;

  // HACK: ternary
  var val = binop.val
    ? this.visit(binop.val***REMOVED***
    : null;
  this.return--;

  // Operate
  try {
    return this.visit(left.operate(op, right, val***REMOVED******REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    // disregard coercion issues in equality
    // checks, and simply return false
    if ('CoercionError' == err.name***REMOVED*** {
      switch (op***REMOVED*** {
        case '==':
          return nodes.false;
        case '!=':
          return nodes.true;
    ***REMOVED***
  ***REMOVED***
    throw err;
***REMOVED***
};

/**
 * Visit UnaryOp.
 */

Evaluator.prototype.visitUnaryOp = function(unary***REMOVED***{
  var op = unary.op
    , node = this.visit(unary.expr***REMOVED***;

  if ('!' != op***REMOVED*** {
    node = node.first.clone(***REMOVED***;
    utils.assertType(node, 'unit'***REMOVED***;
***REMOVED***

  switch (op***REMOVED*** {
    case '-':
      node.val = -node.val;
      break;
    case '+':
      node.val = +node.val;
      break;
    case '~':
      node.val = ~node.val;
      break;
    case '!':
      return node.toBoolean(***REMOVED***.negate(***REMOVED***;
***REMOVED***

  return node;
};

/**
 * Visit TernaryOp.
 */

Evaluator.prototype.visitTernary = function(ternary***REMOVED***{
  var ok = this.visit(ternary.cond***REMOVED***.toBoolean(***REMOVED***;
  return ok.isTrue
    ? this.visit(ternary.trueExpr***REMOVED***
    : this.visit(ternary.falseExpr***REMOVED***;
};

/**
 * Visit Expression.
 */

Evaluator.prototype.visitExpression = function(expr***REMOVED***{
  for (var i = 0, len = expr.nodes.length; i < len; ++i***REMOVED*** {
    expr.nodes[i] = this.visit(expr.nodes[i]***REMOVED***;
***REMOVED***

  // support (n * 5***REMOVED***px etc
  if (this.castable(expr***REMOVED******REMOVED*** expr = this.cast(expr***REMOVED***;

  return expr;
};

/**
 * Visit Arguments.
 */

Evaluator.prototype.visitArguments = Evaluator.prototype.visitExpression;

/**
 * Visit Property.
 */

Evaluator.prototype.visitProperty = function(prop***REMOVED***{
  var name = this.interpolate(prop***REMOVED***
    , fn = this.lookup(name***REMOVED***
    , call = fn && 'function' == fn.nodeName
    , literal = ~this.calling.indexOf(name***REMOVED***;

  // Function of the same name
  if (call && !literal && !prop.literal***REMOVED*** {
    var args = nodes.Arguments.fromExpression(utils.unwrap(prop.expr***REMOVED******REMOVED***;
    prop.name = name;
    this.property = prop;
    var ret = this.visit(new nodes.Call(name, args***REMOVED******REMOVED***;
    delete this.property;
    return ret;
  // Regular property
***REMOVED*** else {
    this.return++;
    prop.name = name;
    prop.literal = true;
    this.property = prop;
    prop.expr = this.visit(prop.expr***REMOVED***;
    delete this.property;
    this.return--;
    return prop;
***REMOVED***
};

/**
 * Visit Root.
 */

Evaluator.prototype.visitRoot = function(block***REMOVED***{
  for (var i = 0; i < block.nodes.length; ++i***REMOVED*** {
    block.index = this.rootIndex = i;
    block.nodes[i] = this.visit(block.nodes[i]***REMOVED***;
***REMOVED***
  return block;
};

/**
 * Visit Block.
 */

Evaluator.prototype.visitBlock = function(block***REMOVED***{
  this.stack.push(new Frame(block***REMOVED******REMOVED***;
  for (block.index = 0; block.index < block.nodes.length; ++block.index***REMOVED*** {
    try {
      block.nodes[block.index] = this.visit(block.nodes[block.index]***REMOVED***;
  ***REMOVED*** catch (err***REMOVED*** {
      if ('return' == err.nodeName***REMOVED*** {
        if (this.return***REMOVED*** {
          this.stack.pop(***REMOVED***;
          throw err;
      ***REMOVED*** else {
          block.nodes[block.index] = err;
          break;
      ***REMOVED***
    ***REMOVED*** else {
        throw err;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  this.stack.pop(***REMOVED***;
  return block;
};

/**
 * Visit Atblock.
 */

Evaluator.prototype.visitAtblock = function(atblock***REMOVED***{
  atblock.block = this.visit(atblock.block***REMOVED***;
  return atblock;
};

/**
 * Visit If.
 */

Evaluator.prototype.visitIf = function(node***REMOVED***{
  var ret
    , block = this.currentBlock
    , negate = node.negate;

  this.return++;
  var ok = this.visit(node.cond***REMOVED***.first.toBoolean(***REMOVED***;
  this.return--;

  node.block.scope = node.block.hasMedia;

  // Evaluate body
  if (negate***REMOVED*** {
    // unless
    if (ok.isFalse***REMOVED*** {
      ret = this.visit(node.block***REMOVED***;
  ***REMOVED***
***REMOVED*** else {
    // if
    if (ok.isTrue***REMOVED*** {
      ret = this.visit(node.block***REMOVED***;
    // else
  ***REMOVED*** else if (node.elses.length***REMOVED*** {
      var elses = node.elses
        , len = elses.length
        , cond;
      for (var i = 0; i < len; ++i***REMOVED*** {
        // else if
        if (elses[i].cond***REMOVED*** {
          elses[i].block.scope = elses[i].block.hasMedia;
          this.return++;
          cond = this.visit(elses[i].cond***REMOVED***.first.toBoolean(***REMOVED***;
          this.return--;
          if (cond.isTrue***REMOVED*** {
            ret = this.visit(elses[i].block***REMOVED***;
            break;
        ***REMOVED***
        // else
      ***REMOVED*** else {
          elses[i].scope = elses[i].hasMedia;
          ret = this.visit(elses[i]***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  // mixin conditional statements within
  // a selector group, @font-face block or @page block
  if (ret && !node.postfix && block.node
    && ~['group', 'fontface', 'page'].indexOf(block.node.nodeName***REMOVED******REMOVED*** {
    this.mixin(ret.nodes, block***REMOVED***;
    return nodes.null;
***REMOVED***

  return ret || nodes.null;
};

/**
 * Visit Extend.
 */

Evaluator.prototype.visitExtend = function(extend***REMOVED***{
  var block = this.currentBlock;
  if ('group' != block.node.nodeName***REMOVED*** block = this.closestGroup;
  extend.selectors.forEach(function(selector***REMOVED***{
    // Cloning the selector for when we are in a loop and don't want it to affect
    // the selector nodes and cause the values to be different to expected
    selector = this.interpolate(selector.clone(***REMOVED******REMOVED***.trim(***REMOVED***;
    block.node.extends.push(selector***REMOVED***;
***REMOVED***, this***REMOVED***;
  return nodes.null;
};

/**
 * Visit Import.
 */

Evaluator.prototype.visitImport = function(imported***REMOVED***{
  this.return++;

  var path = this.visit(imported.path***REMOVED***.first
    , nodeName = imported.once ? 'require' : 'import'
    , found
    , literal
    , index;

  this.return--;
  debug('import %s', path***REMOVED***;

  // url(***REMOVED*** passed
  if ('url' == path.name***REMOVED*** {
    if (imported.once***REMOVED*** throw new Error('You cannot @require a url'***REMOVED***;

    return imported;
***REMOVED***

  // Ensure string
  if (!path.string***REMOVED*** throw new Error('@' + nodeName + ' string expected'***REMOVED***;

  var name = path = path.string;

  // Absolute URL
  if (/url\s*\(\s*['"]?(?:https?:***REMOVED***?\/\//i.test(path***REMOVED******REMOVED*** {
    if (imported.once***REMOVED*** throw new Error('You cannot @require a url'***REMOVED***;
    return imported;
***REMOVED***

  // Literal
  if (/\.css(?:"|$***REMOVED***/.test(path***REMOVED******REMOVED*** {
    literal = true;
    if (!imported.once && !this.includeCSS***REMOVED*** {
      return imported;
  ***REMOVED***
***REMOVED***

  // support optional .styl
  if (!literal && !/\.styl$/i.test(path***REMOVED******REMOVED*** path += '.styl';

  // Lookup
  found = utils.find(path, this.paths, this.filename***REMOVED***;
  if (!found***REMOVED*** {
    found = utils.lookupIndex(name, this.paths, this.filename***REMOVED***;
    index = true;
***REMOVED***

  // Throw if import failed
  if (!found***REMOVED*** throw new Error('failed to locate @' + nodeName + ' file ' + path***REMOVED***;
  
  var block = new nodes.Block;

  for (var i = 0, len = found.length; i < len; ++i***REMOVED*** {
    block.push(importFile.call(this, imported, found[i], literal, index***REMOVED******REMOVED***;
***REMOVED***

  return block;
};

/**
 * Invoke `fn` with `args`.
 *
 * @param {Function} fn
 * @param {Array} args
 * @return {Node}
 * @api private
 */

Evaluator.prototype.invokeFunction = function(fn, args, content***REMOVED***{
  var block = new nodes.Block(fn.block.parent***REMOVED***;
  fn.block.parent = block;

  // Clone the function body
  // to prevent mutation of subsequent calls
  var body = fn.block.clone(***REMOVED***;
  body.scope = fn.block.hasMedia;

  // mixin block
  var mixinBlock = this.stack.currentFrame.block;

  // new block scope
  this.stack.push(new Frame(block***REMOVED******REMOVED***;
  var scope = this.currentScope;

  // normalize arguments
  if ('arguments' != args.nodeName***REMOVED*** {
    var expr = new nodes.Expression;
    expr.push(args***REMOVED***;
    args = nodes.Arguments.fromExpression(expr***REMOVED***;
***REMOVED***

  // arguments local
  scope.add(new nodes.Ident('arguments', args***REMOVED******REMOVED***;

  // mixin scope introspection
  scope.add(new nodes.Ident('mixin', this.return
    ? nodes.false
    : new nodes.String(mixinBlock.nodeName***REMOVED******REMOVED******REMOVED***;

  // current property
  if (this.property***REMOVED*** {
    var prop = this.propertyExpression(this.property, fn.name***REMOVED***;
    scope.add(new nodes.Ident('current-property', prop***REMOVED******REMOVED***;
***REMOVED*** else {
    scope.add(new nodes.Ident('current-property', nodes.null***REMOVED******REMOVED***;
***REMOVED***

  // inject arguments as locals
  var i = 0
    , len = args.nodes.length;
  fn.params.nodes.forEach(function(node***REMOVED***{
    // rest param support
    if (node.rest***REMOVED*** {
      node.val = new nodes.Expression;
      for (; i < len; ++i***REMOVED*** node.val.push(args.nodes[i]***REMOVED***;
      node.val.preserve = true;
    // argument default support
  ***REMOVED*** else {
      var arg = args.map[node.name] || args.nodes[i++];
      node = node.clone(***REMOVED***;
      if (arg***REMOVED*** {
        arg.isEmpty ? args.nodes[i - 1] = node.val : node.val = arg;
    ***REMOVED*** else {
        args.push(node.val***REMOVED***;
    ***REMOVED***

      // required argument not satisfied
      if (node.val.isNull***REMOVED*** {
        throw new Error('argument "' + node + '" required for ' + fn***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    scope.add(node***REMOVED***;
***REMOVED******REMOVED***;

  // mixin block
  if (content***REMOVED*** scope.add(new nodes.Ident('block', content, true***REMOVED******REMOVED***;

  // invoke
  return this.invoke(body, true, fn.filename***REMOVED***;
};

/**
 * Invoke built-in `fn` with `args`.
 *
 * @param {Function} fn
 * @param {Array} args
 * @return {Node}
 * @api private
 */

Evaluator.prototype.invokeBuiltin = function(fn, args***REMOVED***{
  // Map arguments to first node
  // providing a nicer js api for
  // BIFs. Functions may specify that
  // they wish to accept full expressions
  // via .raw
  if (fn.raw***REMOVED*** {
    args = args.nodes;
***REMOVED*** else {
    args = utils.params(fn***REMOVED***.reduce(function(ret, param***REMOVED***{
      var arg = args.map[param] || args.nodes.shift(***REMOVED***;
      if (arg***REMOVED*** ret.push(arg.first***REMOVED***;
      return ret;
  ***REMOVED***, []***REMOVED***;
***REMOVED***

  // Invoke the BIF
  var body = utils.coerce(fn.apply(this, args***REMOVED******REMOVED***;

  // Always wrapping allows js functions
  // to return several values with a single
  // Expression node
  var expr = new nodes.Expression;
  expr.push(body***REMOVED***;
  body = expr;

  // Invoke
  return this.invoke(body***REMOVED***;
};

/**
 * Invoke the given function `body`.
 *
 * @param {Block} body
 * @return {Node}
 * @api private
 */

Evaluator.prototype.invoke = function(body, stack, filename***REMOVED***{
  var self = this
    , ret;

  if (filename***REMOVED*** this.paths.push(dirname(filename***REMOVED******REMOVED***;

  // Return
  if (this.return***REMOVED*** {
    ret = this.eval(body.nodes***REMOVED***;
    if (stack***REMOVED*** this.stack.pop(***REMOVED***;
  // Mixin
***REMOVED*** else {
    body = this.visit(body***REMOVED***;
    if (stack***REMOVED*** this.stack.pop(***REMOVED***;
    this.mixin(body.nodes, this.currentBlock***REMOVED***;
    ret = nodes.null;
***REMOVED***

  if (filename***REMOVED*** this.paths.pop(***REMOVED***;

  return ret;
};

/**
 * Mixin the given `nodes` to the given `block`.
 *
 * @param {Array} nodes
 * @param {Block} block
 * @api private
 */

Evaluator.prototype.mixin = function(nodes, block***REMOVED***{
  var len = block.nodes.length
    , head = block.nodes.slice(0, block.index***REMOVED***
    , tail = block.nodes.slice(block.index + 1, len***REMOVED***;
  this._mixin(nodes, head***REMOVED***;
  block.nodes = head.concat(tail***REMOVED***;
};

/**
 * Mixin the given `nodes` to the `dest` array.
 *
 * @param {Array} nodes
 * @param {Array} dest
 * @api private
 */

Evaluator.prototype._mixin = function(nodes, dest***REMOVED***{
  var node
    , len = nodes.length;
  for (var i = 0; i < len; ++i***REMOVED*** {
    switch ((node = nodes[i]***REMOVED***.nodeName***REMOVED*** {
      case 'return':
        return;
      case 'block':
        this._mixin(node.nodes, dest***REMOVED***;
        break;
      default:
        dest.push(node***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Mixin the given `node` to the current block.
 *
 * @param {Node} node
 * @api private
 */

Evaluator.prototype.mixinNode = function(node***REMOVED***{
  node = this.visit(node.first***REMOVED***;
  switch (node.nodeName***REMOVED*** {
    case 'object':
      this.mixinObject(node***REMOVED***;
      return nodes.null;
    case 'block':
    case 'atblock':
      this.mixin(node.nodes, this.currentBlock***REMOVED***;
      return nodes.null;
***REMOVED***
};

/**
 * Mixin the given `object` to the current block.
 *
 * @param {Object} object
 * @api private
 */

Evaluator.prototype.mixinObject = function(object***REMOVED***{
  var Parser = require('../parser'***REMOVED***
    , root = this.root
    , str = '$block ' + object.toBlock(***REMOVED***
    , parser = new Parser(str, utils.merge({ root: block }, this.options***REMOVED******REMOVED***
    , block;

  try {
    block = parser.parse(***REMOVED***;
***REMOVED*** catch (err***REMOVED*** {
    err.filename = this.filename;
    err.lineno = parser.lexer.lineno;
    err.input = str;
    throw err;
***REMOVED***

  block.parent = root;
  block.scope = false;
  var ret = this.visit(block***REMOVED***
    , vals = ret.first.nodes;
  for (var i = 0, len = vals.length; i < len; ++i***REMOVED*** {
    if (vals[i].block***REMOVED*** {
      this.mixin(vals[i].block.nodes, this.currentBlock***REMOVED***;
      break;
  ***REMOVED***
***REMOVED***
};

/**
 * Evaluate the given `vals`.
 *
 * @param {Array} vals
 * @return {Node}
 * @api private
 */

Evaluator.prototype.eval = function(vals***REMOVED***{
  if (!vals***REMOVED*** return nodes.null;
  var len = vals.length
    , node = nodes.null;

  try {
    for (var i = 0; i < len; ++i***REMOVED*** {
      node = vals[i];
      switch (node.nodeName***REMOVED*** {
        case 'if':
          if ('block' != node.block.nodeName***REMOVED*** {
            node = this.visit(node***REMOVED***;
            break;
        ***REMOVED***
        case 'each':
        case 'block':
          node = this.visit(node***REMOVED***;
          if (node.nodes***REMOVED*** node = this.eval(node.nodes***REMOVED***;
          break;
        default:
          node = this.visit(node***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** catch (err***REMOVED*** {
    if ('return' == err.nodeName***REMOVED*** {
      return err.expr;
  ***REMOVED*** else {
      throw err;
  ***REMOVED***
***REMOVED***

  return node;
};

/**
 * Literal function `call`.
 *
 * @param {Call} call
 * @return {call}
 * @api private
 */

Evaluator.prototype.literalCall = function(call***REMOVED***{
  call.args = this.visit(call.args***REMOVED***;
  return call;
};

/**
 * Lookup property `name`.
 *
 * @param {String} name
 * @return {Property}
 * @api private
 */

Evaluator.prototype.lookupProperty = function(name***REMOVED***{
  var i = this.stack.length
    , index = this.currentBlock.index
    , top = i
    , nodes
    , block
    , len
    , other;

  while (i--***REMOVED*** {
    block = this.stack[i].block;
    if (!block.node***REMOVED*** continue;
    switch (block.node.nodeName***REMOVED*** {
      case 'group':
      case 'function':
      case 'if':
      case 'each':
      case 'fontface':
      case 'media':
      case 'atblock':
      case 'page':
        nodes = block.nodes;
        // scan siblings from the property index up
        if (i + 1 == top***REMOVED*** {
          while (index--***REMOVED*** {
            other = this.interpolate(nodes[index]***REMOVED***;
            if (name == other***REMOVED*** return nodes[index].clone(***REMOVED***;
        ***REMOVED***
        // sequential lookup for non-siblings (for now***REMOVED***
      ***REMOVED*** else {
          len = nodes.length;
          while (len--***REMOVED*** {
            if ('property' != nodes[len].nodeName***REMOVED*** continue;
            other = this.interpolate(nodes[len]***REMOVED***;
            if (name == other***REMOVED*** return nodes[len].clone(***REMOVED***;
        ***REMOVED***
      ***REMOVED***
        break;
  ***REMOVED***
***REMOVED***

  return nodes.null;
};

/**
 * Return the closest mixin-able `Block`.
 *
 * @return {Block}
 * @api private
 */

Evaluator.prototype.__defineGetter__('closestBlock', function(***REMOVED***{
  var i = this.stack.length
    , block;
  while (i--***REMOVED*** {
    block = this.stack[i].block;
    if (block.node***REMOVED*** {
      switch (block.node.nodeName***REMOVED*** {
        case 'group':
        case 'keyframes':
        case 'page':
        case 'fontface':
        case 'atblock':
        case 'media':
          return block;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
}***REMOVED***;

/**
 * Return the closest group block.
 *
 * @return {Block}
 * @api private
 */

Evaluator.prototype.__defineGetter__('closestGroup', function(***REMOVED***{
  var i = this.stack.length
    , block;
  while (i--***REMOVED*** {
    block = this.stack[i].block;
    if (block.node && 'group' == block.node.nodeName***REMOVED*** {
      return block;
  ***REMOVED***
***REMOVED***
}***REMOVED***;

/**
 * Return the current selectors stack.
 *
 * @return {Array}
 * @api private
 */

Evaluator.prototype.__defineGetter__('selectorStack', function(***REMOVED***{
  var block
    , stack = [];
  for (var i = 0, len = this.stack.length; i < len; ++i***REMOVED*** {
    block = this.stack[i].block;
    if (block.node && 'group' == block.node.nodeName***REMOVED*** {
      block.node.nodes.forEach(function(selector***REMOVED*** {
        if (!selector.val***REMOVED*** selector.val = this.interpolate(selector***REMOVED***;
    ***REMOVED***, this***REMOVED***;
      stack.push(block.node.nodes***REMOVED***;
  ***REMOVED***
***REMOVED***
  return stack;
}***REMOVED***;

/**
 * Lookup `name`, with support for JavaScript
 * functions, and BIFs.
 *
 * @param {String} name
 * @return {Node}
 * @api private
 */

Evaluator.prototype.lookup = function(name***REMOVED***{
  var val;
  if (this.ignoreColors && name in colors***REMOVED*** return;
  if (val = this.stack.lookup(name***REMOVED******REMOVED*** {
    return utils.unwrap(val***REMOVED***;
***REMOVED*** else {
    return this.lookupFunction(name***REMOVED***;
***REMOVED***
};

/**
 * Map segments in `node` returning a string.
 *
 * @param {Node} node
 * @return {String}
 * @api private
 */

Evaluator.prototype.interpolate = function(node***REMOVED***{
  var self = this
    , isSelector = ('selector' == node.nodeName***REMOVED***;
  function toString(node***REMOVED*** {
    switch (node.nodeName***REMOVED*** {
      case 'function':
      case 'ident':
        return node.name;
      case 'literal':
      case 'string':
        if (self.prefix && !node.prefixed && !node.val.nodeName***REMOVED*** {
          node.val = node.val.replace(/\./g, '.' + self.prefix***REMOVED***;
          node.prefixed = true;
      ***REMOVED***
        return node.val;
      case 'unit':
        return node.val;
      case 'expression':
        // Prevent cyclic `selector(***REMOVED***` calls.
        if (self.calling && ~self.calling.indexOf('selector'***REMOVED*** && self._selector***REMOVED*** return self._selector;
        self.return++;
        var ret = toString(self.visit(node***REMOVED***.first***REMOVED***;
        self.return--;
        if (isSelector***REMOVED*** self._selector = ret;
        return ret;
  ***REMOVED***
***REMOVED***

  if (node.segments***REMOVED*** {
    return node.segments.map(toString***REMOVED***.join(''***REMOVED***;
***REMOVED*** else {
    return toString(node***REMOVED***;
***REMOVED***
};

/**
 * Lookup JavaScript user-defined or built-in function.
 *
 * @param {String} name
 * @return {Function}
 * @api private
 */

Evaluator.prototype.lookupFunction = function(name***REMOVED***{
  var fn = this.functions[name] || bifs[name];
  if (fn***REMOVED*** return new nodes.Function(name, fn***REMOVED***;
};

/**
 * Check if the given `node` is an ident, and if it is defined.
 *
 * @param {Node} node
 * @return {Boolean}
 * @api private
 */

Evaluator.prototype.isDefined = function(node***REMOVED***{
  if ('ident' == node.nodeName***REMOVED*** {
    return nodes.Boolean(this.lookup(node.name***REMOVED******REMOVED***;
***REMOVED*** else {
    throw new Error('invalid "is defined" check on non-variable ' + node***REMOVED***;
***REMOVED***
};

/**
 * Return `Expression` based on the given `prop`,
 * replacing cyclic calls to the given function `name`
 * with "__CALL__".
 *
 * @param {Property} prop
 * @param {String} name
 * @return {Expression}
 * @api private
 */

Evaluator.prototype.propertyExpression = function(prop, name***REMOVED***{
  var expr = new nodes.Expression
    , val = prop.expr.clone(***REMOVED***;

  // name
  expr.push(new nodes.String(prop.name***REMOVED******REMOVED***;

  // replace cyclic call with __CALL__
  function replace(node***REMOVED*** {
    if ('call' == node.nodeName && name == node.name***REMOVED*** {
      return new nodes.Literal('__CALL__'***REMOVED***;
  ***REMOVED***

    if (node.nodes***REMOVED*** node.nodes = node.nodes.map(replace***REMOVED***;
    return node;
***REMOVED***

  replace(val***REMOVED***;
  expr.push(val***REMOVED***;
  return expr;
};

/**
 * Cast `expr` to the trailing ident.
 *
 * @param {Expression} expr
 * @return {Unit}
 * @api private
 */

Evaluator.prototype.cast = function(expr***REMOVED***{
  return new nodes.Unit(expr.first.val, expr.nodes[1].name***REMOVED***;
};

/**
 * Check if `expr` is castable.
 *
 * @param {Expression} expr
 * @return {Boolean}
 * @api private
 */

Evaluator.prototype.castable = function(expr***REMOVED***{
  return 2 == expr.nodes.length
    && 'unit' == expr.first.nodeName
    && ~units.indexOf(expr.nodes[1].name***REMOVED***;
};

/**
 * Warn with the given `msg`.
 *
 * @param {String} msg
 * @api private
 */

Evaluator.prototype.warn = function(msg***REMOVED***{
  if (!this.warnings***REMOVED*** return;
  console.warn('\033[33mWarning:\033[0m ' + msg***REMOVED***;
};

/**
 * Return the current `Block`.
 *
 * @return {Block}
 * @api private
 */

Evaluator.prototype.__defineGetter__('currentBlock', function(***REMOVED***{
  return this.stack.currentFrame.block;
}***REMOVED***;

/**
 * Return an array of vendor names.
 *
 * @return {Array}
 * @api private
 */

Evaluator.prototype.__defineGetter__('vendors', function(***REMOVED***{
  return this.lookup('vendors'***REMOVED***.nodes.map(function(node***REMOVED***{
    return node.string;
***REMOVED******REMOVED***;
}***REMOVED***;

/**
 * Return the property name without vendor prefix.
 *
 * @param {String} prop
 * @return {String}
 * @api public
 */

Evaluator.prototype.unvendorize = function(prop***REMOVED***{
  for (var i = 0, len = this.vendors.length; i < len; i++***REMOVED*** {
    if ('official' != this.vendors[i]***REMOVED*** {
      var vendor = '-' + this.vendors[i] + '-';
      if (~prop.indexOf(vendor***REMOVED******REMOVED*** return prop.replace(vendor, ''***REMOVED***;
  ***REMOVED***
***REMOVED***
  return prop;
};

/**
 * Return the current frame `Scope`.
 *
 * @return {Scope}
 * @api private
 */

Evaluator.prototype.__defineGetter__('currentScope', function(***REMOVED***{
  return this.stack.currentFrame.scope;
}***REMOVED***;

/**
 * Return the current `Frame`.
 *
 * @return {Frame}
 * @api private
 */

Evaluator.prototype.__defineGetter__('currentFrame', function(***REMOVED***{
  return this.stack.currentFrame;
}***REMOVED***;
