
/*!
 * Stylus - Normalizer
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Visitor = require('./'***REMOVED***
  , nodes = require('../nodes'***REMOVED***
  , utils = require('../utils'***REMOVED***
  , fs = require('fs'***REMOVED***;

/**
 * Initialize a new `Normalizer` with the given `root` Node.
 *
 * This visitor implements the first stage of the duel-stage
 * compiler, tasked with stripping the "garbage" from
 * the evaluated nodes, ditching null rules, resolving
 * ruleset selectors etc. This step performs the logic
 * necessary to facilitate the "@extend" functionality,
 * as these must be resolved _before_ buffering output.
 *
 * @param {Node} root
 * @api public
 */

var Normalizer = module.exports = function Normalizer(root, options***REMOVED*** {
  options = options || {};
  Visitor.call(this, root***REMOVED***;
  this.stack = [];
  this.extends = {};
  this.map = {};
};

/**
 * Inherit from `Visitor.prototype`.
 */

Normalizer.prototype.__proto__ = Visitor.prototype;

/**
 * Normalize the node tree.
 *
 * @return {Node}
 * @api private
 */

Normalizer.prototype.normalize = function(***REMOVED***{
  return this.visit(this.root***REMOVED***;
};

/**
 * Visit Root.
 */

Normalizer.prototype.visitRoot = function(block***REMOVED***{
  var ret = new nodes.Root
    , node;

  for (var i = 0, len = block.nodes.length; i < len; ++i***REMOVED*** {
    node = block.nodes[i];
    switch (node.nodeName***REMOVED*** {
      case 'null':
      case 'expression':
      case 'function':
      case 'jsliteral':
      case 'unit':
      case 'atblock':
        continue;
      default:
        ret.push(this.visit(node***REMOVED******REMOVED***;
  ***REMOVED***
***REMOVED***

  return ret;
};

/**
 * Visit Block.
 */

Normalizer.prototype.visitBlock = function(block***REMOVED***{
  var ret = new nodes.Block
    , node;

  if (block.hasProperties***REMOVED*** {
    for (var i = 0, len = block.nodes.length; i < len; ++i***REMOVED*** {
      this.last = len - 1 == i;
      node = block.nodes[i];
      switch (node.nodeName***REMOVED*** {
        case 'null':
        case 'expression':
        case 'function':
        case 'jsliteral':
        case 'group':
        case 'unit':
        case 'atblock':
          continue;
        default:
          ret.push(this.visit(node***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  // nesting
  for (var i = 0, len = block.nodes.length; i < len; ++i***REMOVED*** {
    node = block.nodes[i];
    ret.push(this.visit(node***REMOVED******REMOVED***;
***REMOVED***

  return block;
};

/**
 * Visit Group.
 */

Normalizer.prototype.visitGroup = function(group***REMOVED***{
  var stack = this.stack
    , map = this.map;

  stack.push(group.nodes***REMOVED***;

  var selectors = utils.compileSelectors(stack, true***REMOVED***;

  // map for extension lookup
  selectors.forEach(function(selector***REMOVED***{
    map[selector] = map[selector] || [];
    map[selector].push(group***REMOVED***;
***REMOVED******REMOVED***;

  // extensions
  this.extend(group, selectors***REMOVED***;

  group.block = this.visit(group.block***REMOVED***;
  stack.pop(***REMOVED***;
  return group;
};

/**
 * Visit Media.
 */

Normalizer.prototype.visitMedia = function(media***REMOVED***{
  var props = []
    , other = [];

  media.block.nodes.forEach(function(node, i***REMOVED*** {
    node = this.visit(node***REMOVED***;

    if ('property' == node.nodeName***REMOVED*** {
      props.push(node***REMOVED***;
  ***REMOVED*** else {
      other.push(node***REMOVED***;
  ***REMOVED***
***REMOVED***, this***REMOVED***;

  // Fake self-referencing group to contain
  // any props that are floating
  // directly on the @media declaration
  if (props.length***REMOVED*** {
    var selfLiteral = new nodes.Literal('&'***REMOVED***;
    selfLiteral.lineno = media.lineno;
    selfLiteral.filename = media.filename;

    var selfSelector = new nodes.Selector([selfLiteral]***REMOVED***;
    selfSelector.lineno = media.lineno;
    selfSelector.filename = media.filename;
    selfSelector.val = selfLiteral.val;

    var propertyGroup = new nodes.Group;
    propertyGroup.lineno = media.lineno;
    propertyGroup.filename = media.filename;

    var propertyBlock = new nodes.Block(media.block, propertyGroup***REMOVED***;
    propertyBlock.lineno = media.lineno;
    propertyBlock.filename = media.filename;

    props.forEach(function(prop***REMOVED***{
      propertyBlock.push(prop***REMOVED***;
  ***REMOVED******REMOVED***;

    propertyGroup.push(selfSelector***REMOVED***;
    propertyGroup.block = propertyBlock;

    media.block.nodes = [];
    media.block.push(propertyGroup***REMOVED***;
    other.forEach(function(node***REMOVED***{
      media.block.push(node***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED***

  return media;
}

/**
 * Visit Keyframes.
 */

Normalizer.prototype.visitKeyframes = function(node***REMOVED***{
  node.frames = node.frames.filter(function(frame***REMOVED***{
    return frame.block.hasProperties;
***REMOVED******REMOVED***;
  return node.frames.length ? node : nodes.null;
};

/**
 * Apply `group` extensions.
 *
 * @param {Group} group
 * @param {Array} selectors
 * @api private
 */

Normalizer.prototype.extend = function(group, selectors***REMOVED***{
  var map = this.map
    , self = this;

  group.block.node.extends.forEach(function(extend***REMOVED***{
    var groups = map[extend];
    if (!groups***REMOVED*** throw new Error('Failed to @extend "' + extend + '"'***REMOVED***;
    selectors.forEach(function(selector***REMOVED***{
      var node = new nodes.Selector;
      node.val = selector;
      node.inherits = false;
      groups.forEach(function(group***REMOVED***{
        if (!group.nodes.some(function(n***REMOVED***{ return n.val == selector }***REMOVED******REMOVED*** {
          self.extend(group, selectors***REMOVED***;
          group.push(node***REMOVED***;
      ***REMOVED***
    ***REMOVED******REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
};
