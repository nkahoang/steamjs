
/*!
 * Stylus - Stack
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Frame = require('./frame'***REMOVED***;

/**
 * Initialize a new `Stack`.
 *
 * @api private
 */

var Stack = module.exports = function Stack(***REMOVED*** {
  Array.apply(this, arguments***REMOVED***;
};

/**
 * Inherit from `Array.prototype`.
 */

Stack.prototype.__proto__ = Array.prototype;

/**
 * Push the given `frame`.
 *
 * @param {Frame} frame
 * @api public
 */

Stack.prototype.push = function(frame***REMOVED***{
  frame.stack = this;
  frame.parent = this.currentFrame;
  return [].push.apply(this, arguments***REMOVED***;
};

/**
 * Return the current stack `Frame`.
 *
 * @return {Frame}
 * @api private
 */

Stack.prototype.__defineGetter__('currentFrame', function(***REMOVED***{
  return this[this.length - 1];
}***REMOVED***;

/**
 * Lookup stack frame for the given `block`.
 *
 * @param {Block} block
 * @return {Frame}
 * @api private
 */

Stack.prototype.getBlockFrame = function(block***REMOVED***{
  for (var i = 0; i < this.length; ++i***REMOVED*** {
    if (block == this[i].block***REMOVED*** {
      return this[i];
  ***REMOVED***
***REMOVED***
};

/**
 * Lookup the given local variable `name`, relative
 * to the lexical scope of the current frame's `Block`.
 *
 * When the result of a lookup is an identifier
 * a recursive lookup is performed, defaulting to
 * returning the identifier itself.
 *
 * @param {String} name
 * @return {Node}
 * @api private
 */

Stack.prototype.lookup = function(name***REMOVED***{
  var block = this.currentFrame.block
    , val
    , ret;

  do {
    var frame = this.getBlockFrame(block***REMOVED***;
    if (frame && (val = frame.lookup(name***REMOVED******REMOVED******REMOVED*** {
      return val;
  ***REMOVED***
***REMOVED*** while (block = block.parent***REMOVED***;
};

/**
 * Custom inspect.
 *
 * @return {String}
 * @api private
 */

Stack.prototype.inspect = function(***REMOVED***{
  return this.reverse(***REMOVED***.map(function(frame***REMOVED***{
    return frame.inspect(***REMOVED***;
***REMOVED******REMOVED***.join('\n'***REMOVED***;
};

/**
 * Return stack string formatted as:
 *
 *   at <context> (<filename>:<lineno>***REMOVED***
 *
 * @return {String}
 * @api private
 */

Stack.prototype.toString = function(***REMOVED***{
  var block
    , node
    , buf = []
    , location
    , len = this.length;

  while (len--***REMOVED*** {
    block = this[len].block;
    if (node = block.node***REMOVED*** {
      location = '(' + node.filename + ':' + (node.lineno + 1***REMOVED*** + '***REMOVED***';
      switch (node.nodeName***REMOVED*** {
        case 'function':
          buf.push('    at ' + node.name + '(***REMOVED*** ' + location***REMOVED***;
          break;
        case 'group':
          buf.push('    at "' + node.nodes[0].val + '" ' + location***REMOVED***;
          break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  return buf.join('\n'***REMOVED***;
};
