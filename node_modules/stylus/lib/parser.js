
/*!
 * Stylus - Parser
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Lexer = require('./lexer'***REMOVED***
  , nodes = require('./nodes'***REMOVED***
  , Token = require('./token'***REMOVED***
  , inspect = require('util'***REMOVED***.inspect
  , errors = require('./errors'***REMOVED***;

// debuggers

var debug = {
    lexer: require('debug'***REMOVED***('stylus:lexer'***REMOVED***
  , selector: require('debug'***REMOVED***('stylus:parser:selector'***REMOVED***
};

/**
 * Selector composite tokens.
 */

var selectorTokens = [
    'ident'
  , 'string'
  , 'selector'
  , 'function'
  , 'comment'
  , 'boolean'
  , 'space'
  , 'color'
  , 'unit'
  , 'for'
  , 'in'
  , '['
  , ']'
  , '('
  , '***REMOVED***'
  , '+'
  , '-'
  , '*'
  , '*='
  , '<'
  , '>'
  , '='
  , ':'
  , '&'
  , '~'
  , '{'
  , '}'
  , '.'
  , '/'
];

/**
 * CSS pseudo-classes and pseudo-elements.
 * See http://dev.w3.org/csswg/selectors4/
 */

var pseudoSelectors = [
  // Logical Combinations
    'matches'
  , 'not'

  // Linguistic Pseudo-classes
  , 'dir'
  , 'lang'

  // Location Pseudo-classes
  , 'any-link'
  , 'link'
  , 'visited'
  , 'local-link'
  , 'target'
  , 'scope'

  // User Action Pseudo-classes
  , 'hover'
  , 'active'
  , 'focus'
  , 'drop'

  // Time-dimensional Pseudo-classes
  , 'current'
  , 'past'
  , 'future'

  // The Input Pseudo-classes
  , 'enabled'
  , 'disabled'
  , 'read-only'
  , 'read-write'
  , 'placeholder-shown'
  , 'checked'
  , 'indeterminate'
  , 'valid'
  , 'invalid'
  , 'in-range'
  , 'out-of-range'
  , 'required'
  , 'optional'
  , 'user-error'

  // Tree-Structural pseudo-classes
  , 'root'
  , 'empty'
  , 'blank'
  , 'nth-child'
  , 'nth-last-child'
  , 'first-child'
  , 'last-child'
  , 'only-child'
  , 'nth-of-type'
  , 'nth-last-of-type'
  , 'first-of-type'
  , 'last-of-type'
  , 'only-of-type'
  , 'nth-match'
  , 'nth-last-match'

  // Grid-Structural Selectors
  , 'nth-column'
  , 'nth-last-column'

  // Pseudo-elements
  , 'first-line'
  , 'first-letter'
  , 'before'
  , 'after'

  // Non-standard
  , 'selection'
];

/**
 * Initialize a new `Parser` with the given `str` and `options`.
 *
 * @param {String} str
 * @param {Object} options
 * @api private
 */

var Parser = module.exports = function Parser(str, options***REMOVED*** {
  var self = this;
  options = options || {};
  this.lexer = new Lexer(str, options***REMOVED***;
  this.prefix = options.prefix || '';
  this.root = options.root || new nodes.Root;
  this.state = ['root'];
  this.stash = [];
  this.parens = 0;
  this.css = 0;
  this.state.pop = function(***REMOVED***{
    self.prevState = [].pop.call(this***REMOVED***;
***REMOVED***;
};

/**
 * Parser prototype.
 */

Parser.prototype = {

  /**
   * Constructor.
   */

  constructor: Parser,

  /**
   * Return current state.
   *
   * @return {String}
   * @api private
   */

  currentState: function(***REMOVED*** {
    return this.state[this.state.length - 1];
***REMOVED***,

  /**
   * Return previous state.
   *
   * @return {String}
   * @api private
   */

  previousState: function(***REMOVED*** {
    return this.state[this.state.length - 2];
***REMOVED***,

  /**
   * Parse the input, then return the root node.
   *
   * @return {Node}
   * @api private
   */

  parse: function(***REMOVED***{
    var block = this.parent = this.root;
    while ('eos' != this.peek(***REMOVED***.type***REMOVED*** {
      if (this.accept('newline'***REMOVED******REMOVED*** continue;
      var stmt = this.statement(***REMOVED***;
      this.accept(';'***REMOVED***;
      if (!stmt***REMOVED*** this.error('unexpected token {peek}, not allowed at the root level'***REMOVED***;
      block.push(stmt***REMOVED***;
  ***REMOVED***
    return block;
***REMOVED***,

  /**
   * Throw an `Error` with the given `msg`.
   *
   * @param {String} msg
   * @api private
   */

  error: function(msg***REMOVED***{
    var type = this.peek(***REMOVED***.type
      , val = undefined == this.peek(***REMOVED***.val
        ? ''
        : ' ' + this.peek(***REMOVED***.toString(***REMOVED***;
    if (val.trim(***REMOVED*** == type.trim(***REMOVED******REMOVED*** val = '';
    throw new errors.ParseError(msg.replace('{peek}', '"' + type + val + '"'***REMOVED******REMOVED***;
***REMOVED***,

  /**
   * Accept the given token `type`, and return it,
   * otherwise return `undefined`.
   *
   * @param {String} type
   * @return {Token}
   * @api private
   */

  accept: function(type***REMOVED***{
    if (type == this.peek(***REMOVED***.type***REMOVED*** {
      return this.next(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Expect token `type` and return it, throw otherwise.
   *
   * @param {String} type
   * @return {Token}
   * @api private
   */

  expect: function(type***REMOVED***{
    if (type != this.peek(***REMOVED***.type***REMOVED*** {
      this.error('expected "' + type + '", got {peek}'***REMOVED***;
  ***REMOVED***
    return this.next(***REMOVED***;
***REMOVED***,

  /**
   * Get the next token.
   *
   * @return {Token}
   * @api private
   */

  next: function(***REMOVED*** {
    var tok = this.stash.length
      ? this.stash.pop(***REMOVED***
      : this.lexer.next(***REMOVED***;
    nodes.lineno = tok.lineno;
    debug.lexer('%s %s', tok.type, tok.val || ''***REMOVED***;
    return tok;
***REMOVED***,

  /**
   * Peek with lookahead(1***REMOVED***.
   *
   * @return {Token}
   * @api private
   */

  peek: function(***REMOVED*** {
    return this.lexer.peek(***REMOVED***;
***REMOVED***,

  /**
   * Lookahead `n` tokens.
   *
   * @param {Number} n
   * @return {Token}
   * @api private
   */

  lookahead: function(n***REMOVED***{
    return this.lexer.lookahead(n***REMOVED***;
***REMOVED***,

  /**
   * Check if the token at `n` is a valid selector token.
   *
   * @param {Number} n
   * @return {Boolean}
   * @api private
   */

  isSelectorToken: function(n***REMOVED*** {
    var la = this.lookahead(n***REMOVED***.type;
    switch (la***REMOVED*** {
      case 'for':
        return this.bracketed;
      case '[':
        this.bracketed = true;
        return true;
      case ']':
        this.bracketed = false;
        return true;
      default:
        return ~selectorTokens.indexOf(la***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Check if the token at `n` is a pseudo selector.
   *
   * @param {Number} n
   * @return {Boolean}
   * @api private
   */

  isPseudoSelector: function(n***REMOVED***{
    return ~pseudoSelectors.indexOf(this.lookahead(n***REMOVED***.val.name***REMOVED***;
***REMOVED***,

  /**
   * Check if the current line contains `type`.
   *
   * @param {String} type
   * @return {Boolean}
   * @api private
   */

  lineContains: function(type***REMOVED***{
    var i = 1
      , la;

    while (la = this.lookahead(i++***REMOVED******REMOVED*** {
      if (~['indent', 'outdent', 'newline', 'eos'].indexOf(la.type***REMOVED******REMOVED*** return;
      if (type == la.type***REMOVED*** return true;
  ***REMOVED***
***REMOVED***,

  /**
   * Valid selector tokens.
   */

  selectorToken: function(***REMOVED*** {
    if (this.isSelectorToken(1***REMOVED******REMOVED*** {
      if ('{' == this.peek(***REMOVED***.type***REMOVED*** {
        // unclosed, must be a block
        if (!this.lineContains('}'***REMOVED******REMOVED*** return;
        // check if ':' is within the braces.
        // though not required by Stylus, chances
        // are if someone is using {} they will
        // use CSS-style props, helping us with
        // the ambiguity in this case
        var i = 0
          , la;
        while (la = this.lookahead(++i***REMOVED******REMOVED*** {
          if ('}' == la.type***REMOVED*** {
            // Check empty block.
            if (i == 2 || (i == 3 && this.lookahead(i - 1***REMOVED***.type == 'space'***REMOVED******REMOVED***
              return;
            break;
        ***REMOVED***
          if (':' == la.type***REMOVED*** return;
      ***REMOVED***
    ***REMOVED***
      return this.next(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * Consume whitespace.
   */

  skipWhitespace: function(***REMOVED*** {
    while (~['space', 'indent', 'outdent', 'newline'].indexOf(this.peek(***REMOVED***.type***REMOVED******REMOVED***
      this.next(***REMOVED***;
***REMOVED***,

  /**
   * Consume newlines.
   */

  skipNewlines: function(***REMOVED*** {
    while ('newline' == this.peek(***REMOVED***.type***REMOVED***
      this.next(***REMOVED***;
***REMOVED***,

  /**
   * Consume spaces.
   */

  skipSpaces: function(***REMOVED*** {
    while ('space' == this.peek(***REMOVED***.type***REMOVED***
      this.next(***REMOVED***;
***REMOVED***,

  /**
   * Consume spaces and comments.
   */

  skipSpacesAndComments: function(***REMOVED*** {
    while ('space' == this.peek(***REMOVED***.type
      || 'comment' == this.peek(***REMOVED***.type***REMOVED***
      this.next(***REMOVED***;
***REMOVED***,

  /**
   * Check if the following sequence of tokens
   * forms a function definition, ie trailing
   * `{` or indentation.
   */

  looksLikeFunctionDefinition: function(i***REMOVED*** {
    return 'indent' == this.lookahead(i***REMOVED***.type
      || '{' == this.lookahead(i***REMOVED***.type;
***REMOVED***,

  /**
   * Check if the following sequence of tokens
   * forms a selector.
   */

  looksLikeSelector: function(***REMOVED*** {
    var i = 1
      , brace;

    // Assume selector when an ident is
    // followed by a selector
    while ('ident' == this.lookahead(i***REMOVED***.type
      && 'newline' == this.lookahead(i + 1***REMOVED***.type***REMOVED*** i += 2;

    while (this.isSelectorToken(i***REMOVED***
      || ',' == this.lookahead(i***REMOVED***.type***REMOVED*** {

      if ('selector' == this.lookahead(i***REMOVED***.type***REMOVED***
        return true;

      if ('.' == this.lookahead(i***REMOVED***.type && 'ident' == this.lookahead(i + 1***REMOVED***.type***REMOVED***
        return true;

      if (this.looksLikeAttributeSelector(i***REMOVED******REMOVED***
        return true;

      if (('=' == this.lookahead(i***REMOVED***.type || 'function' == this.lookahead(i***REMOVED***.type***REMOVED***
        && '{' == this.lookahead(i + 1***REMOVED***.type***REMOVED***
        return false;

      if (':' == this.lookahead(i***REMOVED***.type
        && ':' != this.lookahead(i + 1***REMOVED***.type && !this.isPseudoSelector(i + 1***REMOVED***
        && this.lineContains('.'***REMOVED******REMOVED***
        return false;

      // the ':' token within braces signifies
      // a selector. ex: "foo{bar:'baz'}"
      if ('{' == this.lookahead(i***REMOVED***.type***REMOVED*** brace = true;
      else if ('}' == this.lookahead(i***REMOVED***.type***REMOVED*** brace = false;
      if (brace && ':' == this.lookahead(i***REMOVED***.type***REMOVED*** return true;

      // '}' preceded by a space is considered a selector.
      // for example "foo{bar}{baz}" may be a property,
      // however "foo{bar} {baz}" is a selector
      if ('space' == this.lookahead(i***REMOVED***.type
        && '{' == this.lookahead(i + 1***REMOVED***.type***REMOVED***
        return true;

      // Assume pseudo selectors are NOT properties
      // as 'td:th-child(1***REMOVED***' may look like a property
      // and function call to the parser otherwise
      if (':' == this.lookahead(i++***REMOVED***.type
        && !this.lookahead(i-1***REMOVED***.space
        && this.isPseudoSelector(i***REMOVED******REMOVED***
        return true;

      if (',' == this.lookahead(i***REMOVED***.type
        && 'newline' == this.lookahead(i + 1***REMOVED***.type***REMOVED***
        return true;
  ***REMOVED***

    // Trailing comma
    if (',' == this.lookahead(i***REMOVED***.type
      && 'newline' == this.lookahead(i + 1***REMOVED***.type***REMOVED***
      return true;

    // Trailing brace
    if ('{' == this.lookahead(i***REMOVED***.type
      && 'newline' == this.lookahead(i + 1***REMOVED***.type***REMOVED***
      return true;

    // css-style mode, false on ; }
    if (this.css***REMOVED*** {
      if (';' == this.lookahead(i***REMOVED*** ||
          '}' == this.lookahead(i***REMOVED******REMOVED***
        return false;
  ***REMOVED***

    // Trailing separators
    while (!~[
        'indent'
      , 'outdent'
      , 'newline'
      , 'for'
      , 'if'
      , ';'
      , '}'
      , 'eos'].indexOf(this.lookahead(i***REMOVED***.type***REMOVED******REMOVED***
      ++i;

    if ('indent' == this.lookahead(i***REMOVED***.type***REMOVED***
      return true;
***REMOVED***,

  /**
   * Check if the following sequence of tokens
   * forms an attribute selector.
   */

  looksLikeAttributeSelector: function(n***REMOVED*** {
    var type = this.lookahead(n***REMOVED***.type;
    if ('=' == type && this.bracketed***REMOVED*** return true;
    return ('ident' == type || 'string' == type***REMOVED***
      && ']' == this.lookahead(n + 1***REMOVED***.type
      && ('newline' == this.lookahead(n + 2***REMOVED***.type || this.isSelectorToken(n + 2***REMOVED******REMOVED***
      && !this.lineContains(':'***REMOVED***
      && !this.lineContains('='***REMOVED***;
***REMOVED***,

  /**
   * Check if the current state allows object literal.
   */

  stateAllowsObject: function(***REMOVED*** {
    switch (this.previousState(***REMOVED******REMOVED*** {
      case 'conditional':
      case 'for':
        return false;
      // if a == 1 {
      // if a = 1 {
      case 'expression':
      case 'assignment':
        return !this.cond;
  ***REMOVED***
    return true;
***REMOVED***,

  /**
   * Check if the current state supports selectors.
   */

  stateAllowsSelector: function(***REMOVED*** {
    switch (this.currentState(***REMOVED******REMOVED*** {
      case 'root':
      case 'atblock':
      case 'selector':
      case 'conditional':
      case 'keyframe':
      case 'function':
      case 'font-face':
      case 'media':
      case '-moz-document':
      case 'for':
        return true;
  ***REMOVED***
***REMOVED***,

  /**
   * Try to assign @block to the node.
   *
   * @param {Expression} expr
   * @private
   */

  assignAtblock: function(expr***REMOVED*** {
    try {
      expr.push(this.atblock(expr***REMOVED******REMOVED***;
  ***REMOVED*** catch(err***REMOVED*** {
      this.error('invalid right-hand side operand in assignment, got {peek}'***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   *   statement
   * | statement 'if' expression
   * | statement 'unless' expression
   */

  statement: function(***REMOVED*** {
    var stmt = this.stmt(***REMOVED***
      , state = this.prevState
      , block
      , op;

    // special-case statements since it
    // is not an expression. We could
    // implement postfix conditionals at
    // the expression level, however they
    // would then fail to enclose properties
    if (this.allowPostfix***REMOVED*** {
      delete this.allowPostfix;
      state = 'expression';
  ***REMOVED***

    switch (state***REMOVED*** {
      case 'assignment':
      case 'expression':
      case 'function arguments':
        while (op =
             this.accept('if'***REMOVED***
          || this.accept('unless'***REMOVED***
          || this.accept('for'***REMOVED******REMOVED*** {
          switch (op.type***REMOVED*** {
            case 'if':
            case 'unless':
              stmt = new nodes.If(this.expression(***REMOVED***, stmt***REMOVED***;
              stmt.postfix = true;
              stmt.negate = 'unless' == op.type;
              this.accept(';'***REMOVED***;
              break;
            case 'for':
              var key
                , val = this.id(***REMOVED***.name;
              if (this.accept(','***REMOVED******REMOVED*** key = this.id(***REMOVED***.name;
              this.expect('in'***REMOVED***;
              var each = new nodes.Each(val, key, this.expression(***REMOVED******REMOVED***;
              block = new nodes.Block;
              block.push(stmt***REMOVED***;
              each.block = block;
              stmt = each;
        ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    return stmt;
***REMOVED***,

  /**
   *    ident
   *  | selector
   *  | literal
   *  | charset
   *  | import
   *  | require
   *  | media
   *  | scope
   *  | keyframes
   *  | page
   *  | for
   *  | if
   *  | unless
   *  | comment
   *  | expression
   *  | 'return' expression
   */

  stmt: function(***REMOVED*** {
    var type = this.peek(***REMOVED***.type;
    switch (type***REMOVED*** {
      case '-webkit-keyframes':
      case 'keyframes':
        return this.keyframes(***REMOVED***;
      case 'font-face':
        return this.fontface(***REMOVED***;
      case '-moz-document':
        return this.mozdocument(***REMOVED***;
      case 'comment':
      case 'selector':
      case 'literal':
      case 'charset':
      case 'import':
      case 'require':
      case 'extend':
      case 'media':
      case 'page':
      case 'ident':
      case 'scope':
      case 'unless':
      case 'function':
      case 'for':
      case 'if':
        return this[type](***REMOVED***;
      case 'return':
        return this.return(***REMOVED***;
      case '{':
        return this.property(***REMOVED***;
      default:
        // Contextual selectors
        if (this.stateAllowsSelector(***REMOVED******REMOVED*** {
          switch (type***REMOVED*** {
            case 'color':
            case '~':
            case '>':
            case '<':
            case ':':
            case '&':
            case '[':
            case '.':
            case '/':
              return this.selector(***REMOVED***;
            case '+':
              return 'function' == this.lookahead(2***REMOVED***.type
                ? this.functionCall(***REMOVED***
                : this.selector(***REMOVED***;
            case '*':
              return this.property(***REMOVED***;
            case '-':
              if ('{' == this.lookahead(2***REMOVED***.type***REMOVED***
                return this.property(***REMOVED***;
        ***REMOVED***
      ***REMOVED***

        // Expression fallback
        var expr = this.expression(***REMOVED***;
        if (expr.isEmpty***REMOVED*** this.error('unexpected {peek}'***REMOVED***;
        return expr;
  ***REMOVED***
***REMOVED***,

  /**
   * indent (!outdent***REMOVED***+ outdent
   */

  block: function(node, scope***REMOVED*** {
    var delim
      , stmt
      , block = this.parent = new nodes.Block(this.parent, node***REMOVED***;

    if (false === scope***REMOVED*** block.scope = false;

    // css-style
    if (this.accept('{'***REMOVED******REMOVED*** {
      this.css++;
      delim = '}';
      this.skipWhitespace(***REMOVED***;
  ***REMOVED*** else {
      delim = 'outdent';
      this.expect('indent'***REMOVED***;
  ***REMOVED***

    while (delim != this.peek(***REMOVED***.type***REMOVED*** {
      // css-style
      if (this.css***REMOVED*** {
        if (this.accept('newline'***REMOVED******REMOVED*** continue;
        stmt = this.statement(***REMOVED***;
        this.accept(';'***REMOVED***;
        this.skipWhitespace(***REMOVED***;
    ***REMOVED*** else {
        if (this.accept('newline'***REMOVED******REMOVED*** continue;
        stmt = this.statement(***REMOVED***;
        this.accept(';'***REMOVED***;
    ***REMOVED***
      if (!stmt***REMOVED*** this.error('unexpected token {peek} in block'***REMOVED***;
      block.push(stmt***REMOVED***;
  ***REMOVED***

    // css-style
    if (this.css***REMOVED*** {
      this.skipWhitespace(***REMOVED***;
      this.expect('}'***REMOVED***;
      this.skipSpaces(***REMOVED***;
      this.css--;
  ***REMOVED*** else {
      this.expect('outdent'***REMOVED***;
  ***REMOVED***

    this.parent = block.parent;
    return block;
***REMOVED***,

  /**
   * comment space*
   */

  comment: function(***REMOVED***{
    var node = this.next(***REMOVED***.val;
    this.skipSpaces(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * for val (',' key***REMOVED*** in expr
   */

  for: function(***REMOVED*** {
    this.expect('for'***REMOVED***;
    var key
      , val = this.id(***REMOVED***.name;
    if (this.accept(','***REMOVED******REMOVED*** key = this.id(***REMOVED***.name;
    this.expect('in'***REMOVED***;
    this.state.push('for'***REMOVED***;
    this.cond = true;
    var each = new nodes.Each(val, key, this.expression(***REMOVED******REMOVED***;
    this.cond = false;
    each.block = this.block(each, false***REMOVED***;
    this.state.pop(***REMOVED***;
    return each;
***REMOVED***,

  /**
   * return expression
   */

  return: function(***REMOVED*** {
    this.expect('return'***REMOVED***;
    var expr = this.expression(***REMOVED***;
    return expr.isEmpty
      ? new nodes.Return
      : new nodes.Return(expr***REMOVED***;
***REMOVED***,

  /**
   * unless expression block
   */

  unless: function(***REMOVED*** {
    this.expect('unless'***REMOVED***;
    this.state.push('conditional'***REMOVED***;
    this.cond = true;
    var node = new nodes.If(this.expression(***REMOVED***, true***REMOVED***;
    this.cond = false;
    node.block = this.block(node, false***REMOVED***;
    this.state.pop(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * if expression block (else block***REMOVED***?
   */

  if: function(***REMOVED*** {
    this.expect('if'***REMOVED***;
    this.state.push('conditional'***REMOVED***;
    this.cond = true;
    var node = new nodes.If(this.expression(***REMOVED******REMOVED***
      , cond
      , block;
    this.cond = false;
    node.block = this.block(node, false***REMOVED***;
    while (this.accept('else'***REMOVED******REMOVED*** {
      if (this.accept('if'***REMOVED******REMOVED*** {
        this.cond = true;
        cond = this.expression(***REMOVED***;
        this.cond = false;
        block = this.block(node, false***REMOVED***;
        node.elses.push(new nodes.If(cond, block***REMOVED******REMOVED***;
    ***REMOVED*** else {
        node.elses.push(this.block(node, false***REMOVED******REMOVED***;
        break;
    ***REMOVED***
  ***REMOVED***
    this.state.pop(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * @block
   *
   * @param {Expression} [node]
   */

  atblock: function(node***REMOVED***{
    if (!node***REMOVED*** this.expect('atblock'***REMOVED***;
    node = new nodes.Atblock;
    this.state.push('atblock'***REMOVED***;
    node.block = this.block(node, false***REMOVED***;
    this.state.pop(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * scope
   */

  scope: function(***REMOVED***{
    var val = this.expect('scope'***REMOVED***.val;
    this.selectorScope = val;
    return nodes.null;
***REMOVED***,

  /**
   * extend
   */

  extend: function(***REMOVED***{
    this.expect('extend'***REMOVED***;
    var selectors = []
      , arr;

    do {
      arr = this.selectorParts(***REMOVED***;
      if (arr.length***REMOVED*** selectors.push(new nodes.Selector(arr***REMOVED******REMOVED***;
  ***REMOVED*** while(this.accept(','***REMOVED******REMOVED***;

    return new nodes.Extend(selectors***REMOVED***;
***REMOVED***,

  /**
   * media queries
   */

  media: function(***REMOVED*** {
    this.expect('media'***REMOVED***;
    var media = new nodes.Media(this.queries(***REMOVED******REMOVED***;
    this.state.push('media'***REMOVED***;
    media.block = this.block(media***REMOVED***;
    this.state.pop(***REMOVED***;
    return media;
***REMOVED***,

  /**
   * query (',' query***REMOVED****
   */

  queries: function(***REMOVED*** {
    var queries = new nodes.QueryList;
    do {
      queries.push(this.query(***REMOVED******REMOVED***;
  ***REMOVED*** while(this.accept(','***REMOVED******REMOVED***;
    return queries;
***REMOVED***,

  /**
   *   (ident | 'not'***REMOVED***? ident ('and' queryExpr***REMOVED****
   * | queryExpr ('and' queryExpr***REMOVED****
   */

  query: function(***REMOVED*** {
    var pred
      , id
      , query;

    this.skipSpacesAndComments(***REMOVED***;
    if (pred = this.accept('ident'***REMOVED*** || this.accept('not'***REMOVED******REMOVED*** {
      pred = new nodes.Literal(pred.val.string || pred.val***REMOVED***;

      this.skipSpacesAndComments(***REMOVED***;
      if (id = this.accept('ident'***REMOVED******REMOVED*** {
        query = new nodes.Query(new nodes.QueryExpr([id.val]***REMOVED******REMOVED***;
        query.predicate = pred;
    ***REMOVED*** else {
        query = new nodes.Query(new nodes.QueryExpr([pred]***REMOVED******REMOVED***;
    ***REMOVED***
      this.skipSpacesAndComments(***REMOVED***;

      if (!this.accept('&&'***REMOVED******REMOVED*** return query;
  ***REMOVED***

    query = query || new nodes.Query;
    do {
      query.push(this.queryExpr(***REMOVED******REMOVED***;
  ***REMOVED*** while(this.accept('&&'***REMOVED******REMOVED***;

    return query;
***REMOVED***,

  /**
   * '(' ident ( ':'? expression ***REMOVED***? '***REMOVED***'
   */

  queryExpr: function(***REMOVED*** {
    this.skipSpacesAndComments(***REMOVED***;
    this.expect('('***REMOVED***;
    this.skipSpacesAndComments(***REMOVED***;
    var node = new nodes.QueryExpr(this.interpolate(***REMOVED******REMOVED***;
    this.skipSpacesAndComments(***REMOVED***;
    this.accept(':'***REMOVED***
    this.skipSpacesAndComments(***REMOVED***;
    node.expr = this.expression(***REMOVED***;
    this.skipSpacesAndComments(***REMOVED***;
    this.expect('***REMOVED***'***REMOVED***;
    this.skipSpacesAndComments(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * @-moz-document block
   */

  mozdocument: function(***REMOVED***{
    var val = this.expect('-moz-document'***REMOVED***.val
      , mozdocument = new nodes.MozDocument(val***REMOVED***;
    this.state.push('-moz-document'***REMOVED***;
    mozdocument.block = this.block(mozdocument, false***REMOVED***;
    this.state.pop(***REMOVED***;
    return mozdocument;
***REMOVED***,

  /**
   * fontface
   */

  fontface: function(***REMOVED*** {
    this.expect('font-face'***REMOVED***;
    var node = new nodes.FontFace;
    this.state.push('font-face'***REMOVED***;
    node.block = this.block(node***REMOVED***;
    this.state.pop(***REMOVED***;
    return node;
***REMOVED***,

  /**
   * import expression
   */

  import: function(***REMOVED*** {
    this.expect('import'***REMOVED***;
    this.allowPostfix = true;
    return new nodes.Import(this.expression(***REMOVED***, false***REMOVED***;
***REMOVED***,

  /**
   * require expression
   */

  require: function(***REMOVED*** {
    this.expect('require'***REMOVED***;
    this.allowPostfix = true;
    return new nodes.Import(this.expression(***REMOVED***, true***REMOVED***;
***REMOVED***,

  /**
   * charset string
   */

  charset: function(***REMOVED*** {
    this.expect('charset'***REMOVED***;
    var str = this.expect('string'***REMOVED***.val;
    this.allowPostfix = true;
    return new nodes.Charset(str***REMOVED***;
***REMOVED***,

  /**
   * page selector? block
   */

  page: function(***REMOVED*** {
    var selector;
    this.expect('page'***REMOVED***;
    if (this.accept(':'***REMOVED******REMOVED*** {
      var str = this.expect('ident'***REMOVED***.val.name;
      selector = new nodes.Literal(':' + str***REMOVED***;
  ***REMOVED***
    var page = new nodes.Page(selector***REMOVED***;
    this.skipSpaces(***REMOVED***;
    this.state.push('page'***REMOVED***;
    page.block = this.block(page***REMOVED***;
    this.state.pop(***REMOVED***;
    return page;
***REMOVED***,

  /**
   * keyframes name (
   *  (unit | from | to***REMOVED***
   *  (',' (unit | from | to***REMOVED*******REMOVED***
   *  block***REMOVED***+
   */

  keyframes: function(***REMOVED*** {
    var pos
      , tok = this.expect('keyframes'***REMOVED***
      , keyframes = new nodes.Keyframes(this.id(***REMOVED***, tok.val***REMOVED***
      , vals = [];

    // css-style
    if (this.accept('{'***REMOVED******REMOVED*** {
      this.css++;
      this.skipWhitespace(***REMOVED***;
  ***REMOVED*** else {
      this.expect('indent'***REMOVED***;
  ***REMOVED***

    this.skipNewlines(***REMOVED***;

    while (pos = this.accept('unit'***REMOVED*** || this.accept('ident'***REMOVED******REMOVED*** {
      // from | to
      if ('ident' == pos.type***REMOVED*** {
        this.accept('space'***REMOVED***;
        switch (pos.val.name***REMOVED*** {
          case 'from':
            pos = new nodes.Unit(0, '%'***REMOVED***;
            break;
          case 'to':
            pos = new nodes.Unit(100, '%'***REMOVED***;
            break;
          default:
            this.error('"' + pos.val.name + '" is invalid, use "from" or "to"'***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else {
        pos = pos.val;
    ***REMOVED***

      vals.push(pos***REMOVED***;

      // ','
      if (this.accept(','***REMOVED*** || this.accept('newline'***REMOVED******REMOVED*** continue;

      // block
      this.state.push('keyframe'***REMOVED***;
      var block = this.block(keyframes***REMOVED***;
      keyframes.push(vals, block***REMOVED***;
      vals = [];
      this.state.pop(***REMOVED***;
      if (this.css***REMOVED*** this.skipWhitespace(***REMOVED***;
      this.skipNewlines(***REMOVED***;
  ***REMOVED***

    // css-style
    if (this.css***REMOVED*** {
      this.skipWhitespace(***REMOVED***;
      this.expect('}'***REMOVED***;
      this.css--;
  ***REMOVED*** else {
      this.expect('outdent'***REMOVED***;
  ***REMOVED***

    return keyframes;
***REMOVED***,

  /**
   * literal
   */

  literal: function(***REMOVED*** {
    return this.expect('literal'***REMOVED***.val;
***REMOVED***,

  /**
   * ident space?
   */

  id: function(***REMOVED*** {
    var tok = this.expect('ident'***REMOVED***;
    this.accept('space'***REMOVED***;
    return tok.val;
***REMOVED***,

  /**
   *   ident
   * | assignment
   * | property
   * | selector
   */

  ident: function(***REMOVED*** {
    var i = 2
      , la = this.lookahead(i***REMOVED***.type;

    while ('space' == la***REMOVED*** la = this.lookahead(++i***REMOVED***.type;

    switch (la***REMOVED*** {
      // Assignment
      case '=':
      case '?=':
      case '-=':
      case '+=':
      case '*=':
      case '/=':
      case '%=':
        return this.assignment(***REMOVED***;
      // Member
      case '.':
        if ('space' == this.lookahead(i - 1***REMOVED***.type***REMOVED*** return this.selector(***REMOVED***;
        if (this._ident == this.peek(***REMOVED******REMOVED*** return this.id(***REMOVED***;
        while ('=' != this.lookahead(++i***REMOVED***.type
          && !~['[', ',', 'newline', 'indent', 'eos'].indexOf(this.lookahead(i***REMOVED***.type***REMOVED******REMOVED*** ;
        if ('=' == this.lookahead(i***REMOVED***.type***REMOVED*** {
          this._ident = this.peek(***REMOVED***;
          return this.expression(***REMOVED***;
      ***REMOVED***
      // Assignment []=
      case '[':
        if (this._ident == this.peek(***REMOVED******REMOVED*** return this.id(***REMOVED***;
        while (']' != this.lookahead(i++***REMOVED***.type
          && 'selector' != this.lookahead(i***REMOVED***.type
          && 'eos' != this.lookahead(i***REMOVED***.type***REMOVED*** ;
        if ('=' == this.lookahead(i***REMOVED***.type***REMOVED*** {
          this._ident = this.peek(***REMOVED***;
          return this.expression(***REMOVED***;
      ***REMOVED*** else if (this.looksLikeSelector(***REMOVED*** && this.stateAllowsSelector(***REMOVED******REMOVED*** {
          return this.selector(***REMOVED***;
      ***REMOVED***
      // Operation
      case '-':
      case '+':
      case '/':
      case '*':
      case '%':
      case '**':
      case 'and':
      case 'or':
      case '&&':
      case '||':
      case '>':
      case '<':
      case '>=':
      case '<=':
      case '!=':
      case '==':
      case '?':
      case 'in':
      case 'is a':
      case 'is defined':
        // Prevent cyclic .ident, return literal
        if (this._ident == this.peek(***REMOVED******REMOVED*** {
          return this.id(***REMOVED***;
      ***REMOVED*** else {
          this._ident = this.peek(***REMOVED***;
          switch (this.currentState(***REMOVED******REMOVED*** {
            // unary op or selector in property / for
            case 'for':
            case 'selector':
              return this.property(***REMOVED***;
            // Part of a selector
            case 'root':
            case 'media':
            case '-moz-document':
            case 'atblock':
            case 'font-face':
              return '[' == la
                ? this.subscript(***REMOVED***
                : this.selector(***REMOVED***;
            case 'function':
              return this.looksLikeSelector(***REMOVED***
                ? this.selector(***REMOVED***
                : this.expression(***REMOVED***;
            // Do not disrupt the ident when an operand
            default:
              return this.operand
                ? this.id(***REMOVED***
                : this.expression(***REMOVED***;
        ***REMOVED***
      ***REMOVED***
      // Selector or property
      default:
        switch (this.currentState(***REMOVED******REMOVED*** {
          case 'root':
            return this.selector(***REMOVED***;
          case 'for':
          case 'page':
          case 'media':
          case '-moz-document':
          case 'font-face':
          case 'selector':
          case 'function':
          case 'keyframe':
          case 'conditional':
          case 'atblock':
            return this.property(***REMOVED***;
          default:
            var id = this.id(***REMOVED***;
            if ('interpolation' == this.previousState(***REMOVED******REMOVED*** id.mixin = true;
            return id;
      ***REMOVED***
  ***REMOVED***
***REMOVED***,

  /**
   * '*'? (ident | '{' expression '}'***REMOVED***+
   */

  interpolate: function(***REMOVED*** {
    var node
      , segs = []
      , star;

    star = this.accept('*'***REMOVED***;
    if (star***REMOVED*** segs.push(new nodes.Literal('*'***REMOVED******REMOVED***;

    while (true***REMOVED*** {
      if (this.accept('{'***REMOVED******REMOVED*** {
        this.state.push('interpolation'***REMOVED***;
        segs.push(this.expression(***REMOVED******REMOVED***;
        this.expect('}'***REMOVED***;
        this.state.pop(***REMOVED***;
    ***REMOVED*** else if (node = this.accept('-'***REMOVED******REMOVED***{
        segs.push(new nodes.Literal('-'***REMOVED******REMOVED***;
    ***REMOVED*** else if (node = this.accept('ident'***REMOVED******REMOVED***{
        segs.push(node.val***REMOVED***;
    ***REMOVED*** else {
        break;
    ***REMOVED***
  ***REMOVED***
    if (!segs.length***REMOVED*** this.expect('ident'***REMOVED***;
    return segs;
***REMOVED***,

  /**
   *   property ':'? expression
   * | ident
   */

  property: function(***REMOVED*** {
    if (this.looksLikeSelector(***REMOVED******REMOVED*** return this.selector(***REMOVED***;

    // property
    var ident = this.interpolate(***REMOVED***
      , prop = new nodes.Property(ident***REMOVED***
      , ret = prop;

    // optional ':'
    this.accept('space'***REMOVED***;
    if (this.accept(':'***REMOVED******REMOVED*** this.accept('space'***REMOVED***;

    this.state.push('property'***REMOVED***;
    this.inProperty = true;
    prop.expr = this.list(***REMOVED***;
    if (prop.expr.isEmpty***REMOVED*** ret = ident[0];
    this.inProperty = false;
    this.allowPostfix = true;
    this.state.pop(***REMOVED***;

    // optional ';'
    this.accept(';'***REMOVED***;

    return ret;
***REMOVED***,

  /**
   *   selector ',' selector
   * | selector newline selector
   * | selector block
   */

  selector: function(***REMOVED*** {
    var arr
      , group = new nodes.Group
      , scope = this.selectorScope
      , isRoot = 'root' == this.currentState(***REMOVED***;

    do {
      // Clobber newline after ,
      this.accept('newline'***REMOVED***;

      arr = this.selectorParts(***REMOVED***;

      // Push the selector
      if (isRoot && scope***REMOVED*** arr.unshift(new nodes.Literal(scope + ' '***REMOVED******REMOVED***;
      if (arr.length***REMOVED*** group.push(new nodes.Selector(arr***REMOVED******REMOVED***;
  ***REMOVED*** while (this.accept(','***REMOVED*** || this.accept('newline'***REMOVED******REMOVED***;

    this.state.push('selector'***REMOVED***;
    group.block = this.block(group***REMOVED***;
    this.state.pop(***REMOVED***;

    return group;
***REMOVED***,

  selectorParts: function(***REMOVED***{
    var tok
      , arr = [];

    // Selector candidates,
    // stitched together to
    // form a selector.
    while (tok = this.selectorToken(***REMOVED******REMOVED*** {
      debug.selector('%s', tok***REMOVED***;
      // Selector component
      switch (tok.type***REMOVED*** {
        case '{':
          this.skipSpaces(***REMOVED***;
          var expr = this.expression(***REMOVED***;
          this.skipSpaces(***REMOVED***;
          this.expect('}'***REMOVED***;
          arr.push(expr***REMOVED***;
          break;
        case this.prefix && '.':
          var literal = new nodes.Literal(tok.val + this.prefix***REMOVED***;
          literal.prefixed = true;
          arr.push(literal***REMOVED***;
          break;
        case 'comment':
          arr.push(new nodes.Literal(tok.val.str***REMOVED******REMOVED***;
          break;
        case 'color':
        case 'unit':
          arr.push(new nodes.Literal(tok.val.raw***REMOVED******REMOVED***;
          break;
        case 'space':
          arr.push(new nodes.Literal(' '***REMOVED******REMOVED***;
          break;
        case 'function':
          arr.push(new nodes.Literal(tok.val.name + '('***REMOVED******REMOVED***;
          break;
        case 'ident':
          arr.push(new nodes.Literal(tok.val.name***REMOVED******REMOVED***;
          break;
        default:
          arr.push(new nodes.Literal(tok.val***REMOVED******REMOVED***;
          if (tok.space***REMOVED*** arr.push(new nodes.Literal(' '***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED***

    return arr;
***REMOVED***,

  /**
   * ident ('=' | '?='***REMOVED*** expression
   */

  assignment: function(***REMOVED*** {
    var op
      , node
      , name = this.id(***REMOVED***.name;

    if (op =
         this.accept('='***REMOVED***
      || this.accept('?='***REMOVED***
      || this.accept('+='***REMOVED***
      || this.accept('-='***REMOVED***
      || this.accept('*='***REMOVED***
      || this.accept('/='***REMOVED***
      || this.accept('%='***REMOVED******REMOVED*** {
      this.state.push('assignment'***REMOVED***;
      var expr = this.list(***REMOVED***;
      // @block support
      if (expr.isEmpty***REMOVED*** this.assignAtblock(expr***REMOVED***;
      node = new nodes.Ident(name, expr***REMOVED***;
      this.state.pop(***REMOVED***;

      switch (op.type***REMOVED*** {
        case '?=':
          var defined = new nodes.BinOp('is defined', node***REMOVED***
            , lookup = new nodes.Ident(name***REMOVED***;
          node = new nodes.Ternary(defined, lookup, node***REMOVED***;
          break;
        case '+=':
        case '-=':
        case '*=':
        case '/=':
        case '%=':
          node.val = new nodes.BinOp(op.type[0], new nodes.Ident(name***REMOVED***, expr***REMOVED***;
          break;
    ***REMOVED***
  ***REMOVED***

    return node;
***REMOVED***,

  /**
   *   definition
   * | call
   */

  function: function(***REMOVED*** {
    var parens = 1
      , i = 2
      , tok;

    // Lookahead and determine if we are dealing
    // with a function call or definition. Here
    // we pair parens to prevent false negatives
    out:
    while (tok = this.lookahead(i++***REMOVED******REMOVED*** {
      switch (tok.type***REMOVED*** {
        case 'function':
        case '(':
          ++parens;
          break;
        case '***REMOVED***':
          if (!--parens***REMOVED*** break out;
          break;
        case 'eos':
          this.error('failed to find closing paren "***REMOVED***"'***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    // Definition or call
    switch (this.currentState(***REMOVED******REMOVED*** {
      case 'expression':
        return this.functionCall(***REMOVED***;
      default:
        return this.looksLikeFunctionDefinition(i***REMOVED***
          ? this.functionDefinition(***REMOVED***
          : this.expression(***REMOVED***;
  ***REMOVED***
***REMOVED***,

  /**
   * url '(' (expression | urlchars***REMOVED***+ '***REMOVED***'
   */

  url: function(***REMOVED*** {
    this.expect('function'***REMOVED***;
    this.state.push('function arguments'***REMOVED***;
    var args = this.args(***REMOVED***;
    this.expect('***REMOVED***'***REMOVED***;
    this.state.pop(***REMOVED***;
    return new nodes.Call('url', args***REMOVED***;
***REMOVED***,

  /**
   * '+'? ident '(' expression '***REMOVED***'
   */

  functionCall: function(***REMOVED*** {
    var withBlock = this.accept('+'***REMOVED***;
    if ('url' == this.peek(***REMOVED***.val.name***REMOVED*** return this.url(***REMOVED***;
    var name = this.expect('function'***REMOVED***.val.name;
    this.state.push('function arguments'***REMOVED***;
    this.parens++;
    var args = this.args(***REMOVED***;
    this.expect('***REMOVED***'***REMOVED***;
    this.parens--;
    this.state.pop(***REMOVED***;
    var call = new nodes.Call(name, args***REMOVED***;
    if (withBlock***REMOVED*** {
      this.state.push('function'***REMOVED***;
      call.block = this.block(call***REMOVED***;
      this.state.pop(***REMOVED***;
  ***REMOVED***
    return call;
***REMOVED***,

  /**
   * ident '(' params '***REMOVED***' block
   */

  functionDefinition: function(***REMOVED*** {
    var name = this.expect('function'***REMOVED***.val.name;

    // params
    this.state.push('function params'***REMOVED***;
    this.skipWhitespace(***REMOVED***;
    var params = this.params(***REMOVED***;
    this.skipWhitespace(***REMOVED***;
    this.expect('***REMOVED***'***REMOVED***;
    this.state.pop(***REMOVED***;

    // Body
    this.state.push('function'***REMOVED***;
    var fn = new nodes.Function(name, params***REMOVED***;
    fn.block = this.block(fn***REMOVED***;
    this.state.pop(***REMOVED***;
    return new nodes.Ident(name, fn***REMOVED***;
***REMOVED***,

  /**
   *   ident
   * | ident '...'
   * | ident '=' expression
   * | ident ',' ident
   */

  params: function(***REMOVED*** {
    var tok
      , node
      , params = new nodes.Params;
    while (tok = this.accept('ident'***REMOVED******REMOVED*** {
      this.accept('space'***REMOVED***;
      params.push(node = tok.val***REMOVED***;
      if (this.accept('...'***REMOVED******REMOVED*** {
        node.rest = true;
    ***REMOVED*** else if (this.accept('='***REMOVED******REMOVED*** {
        node.val = this.expression(***REMOVED***;
    ***REMOVED***
      this.skipWhitespace(***REMOVED***;
      this.accept(','***REMOVED***;
      this.skipWhitespace(***REMOVED***;
  ***REMOVED***
    return params;
***REMOVED***,

  /**
   * (ident ':'***REMOVED***? expression (',' (ident ':'***REMOVED***? expression***REMOVED****
   */

  args: function(***REMOVED*** {
    var args = new nodes.Arguments
      , keyword;

    do {
      // keyword
      if ('ident' == this.peek(***REMOVED***.type && ':' == this.lookahead(2***REMOVED***.type***REMOVED*** {
        keyword = this.next(***REMOVED***.val.string;
        this.expect(':'***REMOVED***;
        args.map[keyword] = this.expression(***REMOVED***;
      // arg
    ***REMOVED*** else {
        args.push(this.expression(***REMOVED******REMOVED***;
    ***REMOVED***
  ***REMOVED*** while (this.accept(','***REMOVED******REMOVED***;

    return args;
***REMOVED***,

  /**
   * expression (',' expression***REMOVED****
   */

  list: function(***REMOVED*** {
    var node = this.expression(***REMOVED***;
    while (this.accept(','***REMOVED******REMOVED*** {
      if (node.isList***REMOVED*** {
        list.push(this.expression(***REMOVED******REMOVED***;
    ***REMOVED*** else {
        var list = new nodes.Expression(true***REMOVED***;
        list.push(node***REMOVED***;
        list.push(this.expression(***REMOVED******REMOVED***;
        node = list;
    ***REMOVED***
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * negation+
   */

  expression: function(***REMOVED*** {
    var node
      , expr = new nodes.Expression;
    this.state.push('expression'***REMOVED***;
    while (node = this.negation(***REMOVED******REMOVED*** {
      if (!node***REMOVED*** this.error('unexpected token {peek} in expression'***REMOVED***;
      expr.push(node***REMOVED***;
  ***REMOVED***
    this.state.pop(***REMOVED***;
    return expr;
***REMOVED***,

  /**
   *   'not' ternary
   * | ternary
   */

  negation: function(***REMOVED*** {
    if (this.accept('not'***REMOVED******REMOVED*** {
      return new nodes.UnaryOp('!', this.negation(***REMOVED******REMOVED***;
  ***REMOVED***
    return this.ternary(***REMOVED***;
***REMOVED***,

  /**
   * logical ('?' expression ':' expression***REMOVED***?
   */

  ternary: function(***REMOVED*** {
    var node = this.logical(***REMOVED***;
    if (this.accept('?'***REMOVED******REMOVED*** {
      var trueExpr = this.expression(***REMOVED***;
      this.expect(':'***REMOVED***;
      var falseExpr = this.expression(***REMOVED***;
      node = new nodes.Ternary(node, trueExpr, falseExpr***REMOVED***;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * typecheck (('&&' | '||'***REMOVED*** typecheck***REMOVED****
   */

  logical: function(***REMOVED*** {
    var op
      , node = this.typecheck(***REMOVED***;
    while (op = this.accept('&&'***REMOVED*** || this.accept('||'***REMOVED******REMOVED*** {
      node = new nodes.BinOp(op.type, node, this.typecheck(***REMOVED******REMOVED***;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * equality ('is a' equality***REMOVED****
   */

  typecheck: function(***REMOVED*** {
    var op
      , node = this.equality(***REMOVED***;
    while (op = this.accept('is a'***REMOVED******REMOVED*** {
      this.operand = true;
      if (!node***REMOVED*** this.error('illegal unary "' + op + '", missing left-hand operand'***REMOVED***;
      node = new nodes.BinOp(op.type, node, this.equality(***REMOVED******REMOVED***;
      this.operand = false;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * in (('==' | '!='***REMOVED*** in***REMOVED****
   */

  equality: function(***REMOVED*** {
    var op
      , node = this.in(***REMOVED***;
    while (op = this.accept('=='***REMOVED*** || this.accept('!='***REMOVED******REMOVED*** {
      this.operand = true;
      if (!node***REMOVED*** this.error('illegal unary "' + op + '", missing left-hand operand'***REMOVED***;
      node = new nodes.BinOp(op.type, node, this.in(***REMOVED******REMOVED***;
      this.operand = false;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * relational ('in' relational***REMOVED****
   */

  in: function(***REMOVED*** {
    var node = this.relational(***REMOVED***;
    while (this.accept('in'***REMOVED******REMOVED*** {
      this.operand = true;
      if (!node***REMOVED*** this.error('illegal unary "in", missing left-hand operand'***REMOVED***;
      node = new nodes.BinOp('in', node, this.relational(***REMOVED******REMOVED***;
      this.operand = false;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * range (('>=' | '<=' | '>' | '<'***REMOVED*** range***REMOVED****
   */

  relational: function(***REMOVED*** {
    var op
      , node = this.range(***REMOVED***;
    while (op =
         this.accept('>='***REMOVED***
      || this.accept('<='***REMOVED***
      || this.accept('<'***REMOVED***
      || this.accept('>'***REMOVED***
      ***REMOVED*** {
      this.operand = true;
      if (!node***REMOVED*** this.error('illegal unary "' + op + '", missing left-hand operand'***REMOVED***;
      node = new nodes.BinOp(op.type, node, this.range(***REMOVED******REMOVED***;
      this.operand = false;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * additive (('..' | '...'***REMOVED*** additive***REMOVED****
   */

  range: function(***REMOVED*** {
    var op
      , node = this.additive(***REMOVED***;
    if (op = this.accept('...'***REMOVED*** || this.accept('..'***REMOVED******REMOVED*** {
      this.operand = true;
      if (!node***REMOVED*** this.error('illegal unary "' + op + '", missing left-hand operand'***REMOVED***;
      node = new nodes.BinOp(op.val, node, this.additive(***REMOVED******REMOVED***;
      this.operand = false;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * multiplicative (('+' | '-'***REMOVED*** multiplicative***REMOVED****
   */

  additive: function(***REMOVED*** {
    var op
      , node = this.multiplicative(***REMOVED***;
    while (op = this.accept('+'***REMOVED*** || this.accept('-'***REMOVED******REMOVED*** {
      this.operand = true;
      node = new nodes.BinOp(op.type, node, this.multiplicative(***REMOVED******REMOVED***;
      this.operand = false;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   * defined (('**' | '*' | '/' | '%'***REMOVED*** defined***REMOVED****
   */

  multiplicative: function(***REMOVED*** {
    var op
      , node = this.defined(***REMOVED***;
    while (op =
         this.accept('**'***REMOVED***
      || this.accept('*'***REMOVED***
      || this.accept('/'***REMOVED***
      || this.accept('%'***REMOVED******REMOVED*** {
      this.operand = true;
      if ('/' == op && this.inProperty && !this.parens***REMOVED*** {
        this.stash.push(new Token('literal', new nodes.Literal('/'***REMOVED******REMOVED******REMOVED***;
        this.operand = false;
        return node;
    ***REMOVED*** else {
        if (!node***REMOVED*** this.error('illegal unary "' + op + '", missing left-hand operand'***REMOVED***;
        node = new nodes.BinOp(op.type, node, this.defined(***REMOVED******REMOVED***;
        this.operand = false;
    ***REMOVED***
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   *    unary 'is defined'
   *  | unary
   */

  defined: function(***REMOVED*** {
    var node = this.unary(***REMOVED***;
    if (this.accept('is defined'***REMOVED******REMOVED*** {
      if (!node***REMOVED*** this.error('illegal unary "is defined", missing left-hand operand'***REMOVED***;
      node = new nodes.BinOp('is defined', node***REMOVED***;
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   *   ('!' | '~' | '+' | '-'***REMOVED*** unary
   * | subscript
   */

  unary: function(***REMOVED*** {
    var op
      , node;
    if (op =
         this.accept('!'***REMOVED***
      || this.accept('~'***REMOVED***
      || this.accept('+'***REMOVED***
      || this.accept('-'***REMOVED******REMOVED*** {
      this.operand = true;
      node = new nodes.UnaryOp(op.type, this.unary(***REMOVED******REMOVED***;
      this.operand = false;
      return node;
  ***REMOVED***
    return this.subscript(***REMOVED***;
***REMOVED***,

  /**
   *   member ('[' expression ']' ('.' id***REMOVED***? '='?***REMOVED***+
   * | member
   */

  subscript: function(***REMOVED*** {
    var node = this.member(***REMOVED***
      , id;
    while (this.accept('['***REMOVED******REMOVED*** {
      node = new nodes.BinOp('[]', node, this.expression(***REMOVED******REMOVED***;
      this.expect(']'***REMOVED***;
      if (this.accept('.'***REMOVED******REMOVED*** {
        id = new nodes.Ident(this.expect('ident'***REMOVED***.val.string***REMOVED***;
        node = new nodes.Member(node, id***REMOVED***;
    ***REMOVED***
      // TODO: TernaryOp :***REMOVED***
      if (this.accept('='***REMOVED******REMOVED*** {
        node.op += '=';
        node.val = this.expression(***REMOVED***;
        // @block support
        if (node.val.isEmpty***REMOVED*** this.assignAtblock(node.val***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   *   primary ('.' id***REMOVED***+ '='?
   * | primary
   */
  
  member: function(***REMOVED*** {
    var node = this.primary(***REMOVED***;
    if (node***REMOVED*** {
      while (this.accept('.'***REMOVED******REMOVED*** {
        var id = new nodes.Ident(this.expect('ident'***REMOVED***.val.string***REMOVED***;
        node = new nodes.Member(node, id***REMOVED***;
    ***REMOVED***
      this.skipSpaces(***REMOVED***;
      if (this.accept('='***REMOVED******REMOVED*** {
        node.val = this.expression(***REMOVED***;
        // @block support
        if (node.val.isEmpty***REMOVED*** this.assignAtblock(node.val***REMOVED***;
    ***REMOVED***
  ***REMOVED***
    return node;
***REMOVED***,

  /**
   *   '{' '}'
   * | '{' pair (ws pair***REMOVED**** '}'
   */

  object: function(***REMOVED***{
    var id, val;
    var obj = new nodes.Object;
    this.expect('{'***REMOVED***;
    this.skipWhitespace(***REMOVED***;

    while (!this.accept('}'***REMOVED******REMOVED*** {
      id = this.accept('ident'***REMOVED*** || this.accept('string'***REMOVED***;
      if (!id***REMOVED*** this.error('expected "ident" or "string", got {peek}'***REMOVED***;
      id = id.val.hash;
      this.expect(':'***REMOVED***;
      val = this.expression(***REMOVED***;
      obj.set(id, val***REMOVED***;
      this.accept(','***REMOVED***;
      this.skipWhitespace(***REMOVED***;
  ***REMOVED***

    return obj;
***REMOVED***,

  /**
   *   unit
   * | null
   * | color
   * | string
   * | ident
   * | boolean
   * | literal
   * | object
   * | atblock
   * | '(' expression '***REMOVED***' '%'?
   */

  primary: function(***REMOVED*** {
    var op
      , node;

    // Parenthesis
    if (this.accept('('***REMOVED******REMOVED*** {
      ++this.parens;
      var expr = this.expression(***REMOVED***;
      this.expect('***REMOVED***'***REMOVED***;
      --this.parens;
      if (this.accept('%'***REMOVED******REMOVED*** expr.push(new nodes.Ident('%'***REMOVED******REMOVED***;
      return expr;
  ***REMOVED***

    // Primitive
    switch (this.peek(***REMOVED***.type***REMOVED*** {
      case 'null':
      case 'unit':
      case 'color':
      case 'string':
      case 'literal':
      case 'boolean':
        return this.next(***REMOVED***.val;
      case this.stateAllowsObject(***REMOVED*** && '{':
        return this.object(***REMOVED***;
      case 'atblock':
        return this.atblock(***REMOVED***;
      case 'ident':
        return this.ident(***REMOVED***;
      case 'function':
        return this.functionCall(***REMOVED***;
  ***REMOVED***
***REMOVED***
};
