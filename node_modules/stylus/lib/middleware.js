/*!
 * Stylus - middleware
 * Copyright(c***REMOVED*** 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var stylus = require('./stylus'***REMOVED***
  , fs = require('fs'***REMOVED***
  , url = require('url'***REMOVED***
  , basename = require('path'***REMOVED***.basename
  , dirname = require('path'***REMOVED***.dirname
  , mkdirp = require('mkdirp'***REMOVED***
  , join = require('path'***REMOVED***.join
  , sep = require('path'***REMOVED***.sep
  , debug = require('debug'***REMOVED***('stylus:middleware'***REMOVED***;

/**
 * Import map.
 */

var imports = {};

/**
 * Return Connect middleware with the given `options`.
 *
 * Options:
 *
 *    `force`     Always re-compile
 *    `src`       Source directory used to find .styl files,
 *                a string or function accepting `(path***REMOVED***` of request.
 *    `dest`      Destination directory used to output .css files,
 *                a string or function accepting `(path***REMOVED***` of request,
 *                when undefined defaults to `src`.
 *    `compile`   Custom compile function, accepting the arguments
 *                `(str, path***REMOVED***`.
 *    `compress`  Whether the output .css files should be compressed
 *    `firebug`   Emits debug infos in the generated CSS that can
 *                be used by the FireStylus Firebug plugin
 *    `linenos`   Emits comments in the generated CSS indicating 
 *                the corresponding Stylus line
 *
 * Examples:
 * 
 * Here we set up the custom compile function so that we may
 * set the `compress` option, or define additional functions.
 * 
 * By default the compile function simply sets the `filename`
 * and renders the CSS.
 * 
 *      function compile(str, path***REMOVED*** {
 *        return stylus(str***REMOVED***
 *          .set('filename', path***REMOVED***
 *          .set('compress', true***REMOVED***;
 *    ***REMOVED***
 * 
 * Pass the middleware to Connect, grabbing .styl files from this directory
 * and saving .css files to _./public_. Also supplying our custom `compile` function.
 * 
 * Following that we have a `static(***REMOVED***` layer setup to serve the .css
 * files generated by Stylus.
 * 
 *      var app = connect(***REMOVED***;
 * 
 *      app.middleware({
 *          src: __dirname
 *        , dest: __dirname + '/public'
 *        , compile: compile
 *    ***REMOVED******REMOVED***
 * 
 *      app.use(connect.static(__dirname + '/public'***REMOVED******REMOVED***;
 * 
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function(options***REMOVED***{
  options = options || {};

  // Accept src/dest dir
  if ('string' == typeof options***REMOVED*** {
    options = { src: options };
***REMOVED***

  // Force compilation
  var force = options.force;

  // Source dir required
  var src = options.src;
  if (!src***REMOVED*** throw new Error('stylus.middleware(***REMOVED*** requires "src" directory'***REMOVED***;

  // Default dest dir to source
  var dest = options.dest || src;

  // Default compile callback
  options.compile = options.compile || function(str, path***REMOVED***{
    return stylus(str***REMOVED***
      .set('filename', path***REMOVED***
      .set('compress', options.compress***REMOVED***
      .set('firebug', options.firebug***REMOVED***
      .set('linenos', options.linenos***REMOVED***;
***REMOVED***;

  // Middleware
  return function stylus(req, res, next***REMOVED***{
    if ('GET' != req.method && 'HEAD' != req.method***REMOVED*** return next(***REMOVED***;
    var path = url.parse(req.url***REMOVED***.pathname;
    if (/\.css$/.test(path***REMOVED******REMOVED*** {

      if (typeof dest == 'string' || typeof dest == 'function'***REMOVED*** {
        // check for dest-path overlap
        var overlap = compare((typeof dest == 'function' ? dest(path***REMOVED*** : dest***REMOVED***, path***REMOVED***;
        path = path.slice(overlap.length***REMOVED***;
    ***REMOVED***

      var cssPath, stylusPath;
      cssPath = (typeof dest == 'function'***REMOVED***
        ? dest(path***REMOVED***
        : join(dest, path***REMOVED***;
      stylusPath = (typeof src == 'function'***REMOVED***
        ? src(path***REMOVED***
        : join(src, path.replace('.css', '.styl'***REMOVED******REMOVED***;

      // Ignore ENOENT to fall through as 404
      function error(err***REMOVED*** {
        next('ENOENT' == err.code
          ? null
          : err***REMOVED***;
    ***REMOVED***

      // Force
      if (force***REMOVED*** return compile(***REMOVED***;

      // Compile to cssPath
      function compile(***REMOVED*** {
        debug('read %s', cssPath***REMOVED***;
        fs.readFile(stylusPath, 'utf8', function(err, str***REMOVED***{
          if (err***REMOVED*** return error(err***REMOVED***;
          var style = options.compile(str, stylusPath***REMOVED***;
          var paths = style.options._imports = [];
          delete imports[stylusPath];
          style.render(function(err, css***REMOVED***{
            if (err***REMOVED*** return next(err***REMOVED***;
            debug('render %s', stylusPath***REMOVED***;
            imports[stylusPath] = paths;
            mkdirp(dirname(cssPath***REMOVED***, 0700, function(err***REMOVED***{
              if (err***REMOVED*** return error(err***REMOVED***;
              fs.writeFile(cssPath, css, 'utf8', next***REMOVED***;
          ***REMOVED******REMOVED***;
        ***REMOVED******REMOVED***;
      ***REMOVED******REMOVED***;
    ***REMOVED***

      // Re-compile on server restart, disregarding
      // mtimes since we need to map imports
      if (!imports[stylusPath]***REMOVED*** return compile(***REMOVED***;

      // Compare mtimes
      fs.stat(stylusPath, function(err, stylusStats***REMOVED***{
        if (err***REMOVED*** return error(err***REMOVED***;
        fs.stat(cssPath, function(err, cssStats***REMOVED***{
          // CSS has not been compiled, compile it!
          if (err***REMOVED*** {
            if ('ENOENT' == err.code***REMOVED*** {
              debug('not found %s', cssPath***REMOVED***;
              compile(***REMOVED***;
          ***REMOVED*** else {
              next(err***REMOVED***;
          ***REMOVED***
        ***REMOVED*** else {
            // Source has changed, compile it
            if (stylusStats.mtime > cssStats.mtime***REMOVED*** {
              debug('modified %s', cssPath***REMOVED***;
              compile(***REMOVED***;
            // Already compiled, check imports
          ***REMOVED*** else {
              checkImports(stylusPath, function(changed***REMOVED***{
                if (debug && changed.length***REMOVED*** {
                  changed.forEach(function(path***REMOVED*** {
                    debug('modified import %s', path***REMOVED***;
                ***REMOVED******REMOVED***;
              ***REMOVED***
                changed.length ? compile(***REMOVED*** : next(***REMOVED***;
            ***REMOVED******REMOVED***;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED******REMOVED***;
    ***REMOVED******REMOVED***;
  ***REMOVED*** else {
      next(***REMOVED***;
  ***REMOVED***
***REMOVED***
};

/**
 * Check `path`'s imports to see if they have been altered.
 *
 * @param {String} path
 * @param {Function} fn
 * @api private
 */

function checkImports(path, fn***REMOVED*** {
  var nodes = imports[path];
  if (!nodes***REMOVED*** return fn(***REMOVED***;
  if (!nodes.length***REMOVED*** return fn(***REMOVED***;

  var pending = nodes.length
    , changed = [];

  nodes.forEach(function(imported***REMOVED***{
    fs.stat(imported.path, function(err, stat***REMOVED***{
      // error or newer mtime
      if (err || !imported.mtime || stat.mtime > imported.mtime***REMOVED*** {
        changed.push(imported.path***REMOVED***;
    ***REMOVED***
      --pending || fn(changed***REMOVED***;
  ***REMOVED******REMOVED***;
***REMOVED******REMOVED***;
}

/**
 * get the overlaping path from the end of path A, and the begining of path B.
 *
 * @param {String} pathA
 * @param {String} pathB
 * @return {String}
 * @api private
 */

function compare(pathA, pathB***REMOVED*** {
  pathA = pathA.split(sep***REMOVED***;
  pathB = pathB.split(sep***REMOVED***;
  var overlap = [];
  while (pathA[pathA.length - 1] == pathB[0]***REMOVED*** {
    overlap.push(pathA.pop(***REMOVED******REMOVED***;
    pathB.shift(***REMOVED***;
***REMOVED***
  return overlap.join(sep***REMOVED***;
}
